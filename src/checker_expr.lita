import "std/libc"
import "std/map"
import "std/string_buffer"
import "std/string_view"
import "std/string"
import "std/array"
import "std/assert"

import "types"
import "types_new"
import "symbols"
import "phase_result"
import "module"
import "ast"
import "ast_new"
import "lex"
import "lita"
import "checker"
import "common"
import "ast_print"
import "error_codes"
import "intern"
import "lsp/references"

public func (this: *TypeChecker) resolveConstExpr(expr: *Expr) : bool {
    if(!this.resolveExpr(expr)) {
        return false
    }

    if(!expr.operand.isConst) {
        this.result.addError(expr.startPos, "expected a constant expression")
        return false;
    }
    return true
}

public func (this: *TypeChecker) resolveExpr(expr: *Expr) : bool {
    if(!expr) return false

    defer {
        if(expr.operand.typeInfo == null) {
            return false
        }
    }

    switch(expr.kind) {
        case StmtKind.ARRAY_DESIGNATION_EXPR: {
            return this.resolveArrayDesignationExpr(expr as (*ArrayDesignationExpr))
        }
        case StmtKind.ARRAY_INIT_EXPR: {
            return this.resolveArrayInitExpr(expr as (*ArrayInitExpr))
        }
        case StmtKind.BINARY_EXPR: {
            return this.resolveBinaryExpr(expr as (*BinaryExpr))
        }
        case StmtKind.BOOLEAN_EXPR: {
            return this.resolveBooleanExpr(expr as (*BooleanExpr))
        }
        case StmtKind.CAST_EXPR: {
            return this.resolveCastExpr(expr as (*CastExpr))
        }
        case StmtKind.CHAR_EXPR: {
            return this.resolveCharExpr(expr as (*CharExpr))
        }
        case StmtKind.FUNC_CALL_EXPR: {
            return this.resolveFuncCallExpr(expr as (*FuncCallExpr))
        }
        case StmtKind.FUNC_IDENTIFIER_EXPR: {
            return this.resolveFuncIdentifierExpr(expr as (*IdentifierExpr))
        }
        case StmtKind.GET_EXPR:{
            return this.resolveGetExpr(expr as (*GetExpr))
        }
        case StmtKind.GROUP_EXPR: {
            return this.resolveGroupExpr(expr as (*GroupExpr))
        }
        case StmtKind.IDENTIFIER_EXPR: {
            return this.resolveIdentiferExpr(expr as (*IdentifierExpr))
        }
        case StmtKind.INIT_ARG_EXPR: {
            return this.resolveInitArgExpr(expr as (*InitArgExpr))
        }
        case StmtKind.INIT_EXPR: {
            return this.resolveInitExpr(expr as (*InitExpr))
        }
        case StmtKind.NULL_EXPR: {
            return this.resolveNullExpr(expr as (*NullExpr))
        }
        case StmtKind.NUMBER_EXPR: {
            return this.resolveNumberExpr(expr as (*NumberExpr))
        }
        case StmtKind.SET_EXPR: {
            return this.resolveSetExpr(expr as (*SetExpr))
        }
        case StmtKind.OFFSET_OF_EXPR: {
            return this.resolveOffsetOfExpr(expr as (*OffsetOfExpr))
        }
        case StmtKind.SIZE_OF_EXPR: {
            return this.resolveSizeOfExpr(expr as (*SizeOfExpr))
        }
        case StmtKind.STRING_EXPR: {
            return this.resolveStringExpr(expr as (*StringExpr))
        }
        case StmtKind.SUBSCRIPT_GET_EXPR: {
            return this.resolveSubscriptGetExpr(expr as (*SubscriptGetExpr))
        }
        case StmtKind.SUBSCRIPT_SET_EXPR: {
            return this.resolveSubscriptSetExpr(expr as (*SubscriptSetExpr))
        }
        case StmtKind.TERNARY_EXPR: {
            return this.resolveTernaryExpr(expr as (*TernaryExpr))
        }
        case StmtKind.TYPE_IDENTIFIER_EXPR: {
            return this.resolveTypeIdentifierExpr(expr as (*TypeIdentifierExpr))
        }
        case StmtKind.TYPE_OF_EXPR: {
            return this.resolveTypeOfExpr(expr as (*TypeOfExpr))
        }
        case StmtKind.UNARY_EXPR: {
            return this.resolveUnaryExpr(expr as (*UnaryExpr))
        }
        case StmtKind.POISON_EXPR: {
            return false
        }
        default: {
            PrintStmt(expr as (*Stmt))
            assert(false)
        }
    }
    return false
}


func (this: *TypeChecker) resolveFuncIdentifierExpr(expr: *IdentifierExpr) : bool {
    assert(expr != null)

    var type = this.resolveTypeSpec(expr.type, SearchType.FUNC)
    if(!type) {
        this.result.addError(expr.startPos, "unknown function '%.*s'", expr.type.name.length, expr.type.name.buffer)
        return false
    }
// TODO: must we check types for FUNC_PTR?
    var sym = type.sym
    if(type.kind == TypeKind.FUNC_PTR) {
        var funcSym = this.currentScope().lookup(expr.type.name)
        if(funcSym && funcSym.type && funcSym.type.kind == TypeKind.FUNC_PTR) {
            sym = funcSym
        }
    }

    if(!sym) {
        this.result.addError(expr.startPos, "unknown function '%.*s'", expr.type.name.length, expr.type.name.buffer)
        return false
    }

    //this.lita.references.addTypeReferenceBySymbol(expr.startPos, sym)

    expr.operand.typeInfo = sym.type
    expr.operand.isRightValue = true
    expr.sym = sym
    return true
}

func (this: *TypeChecker) isMethodSyntax(expr: *FuncCallExpr, suppliedArgs: *Array<CallArg>) : bool {
    assert(expr != null)
    if(expr.object.kind != StmtKind.GET_EXPR) {
        return false
    }

    var getExpr = expr.object as (*GetExpr)
    if(getExpr.field.operand.typeInfo.kind != TypeKind.FUNC) {
        return false
    }

    if(getExpr.flags & GetExprFlags.IS_METHOD_ARG) {
        return true
    }

    getExpr.flags |= GetExprFlags.IS_METHOD_ARG
    suppliedArgs.insertAt(0, CallArg { .argExpr = getExpr.object })
    return true
}

public func (this: *TypeChecker) coerceTypeWithUsing(expr: *Expr,
                                              sourceType: *TypeInfo,
                                              targetType: *TypeInfo) : *Expr {

    if(!IsAggregateLike(targetType)) {
        return expr
    }

    if(!IsAggregateLike(sourceType)) {
        return expr
    }


    var source = sourceType.getBaseType()
    var target = targetType.getBaseType()

    // if this is a generic template, see if their generic types match
    if(targetType.sym && targetType.sym.flags & SymbolFlags.IS_GENERIC_TEMPLATE) {
        if(source.genericTypeid == target.genericTypeid) {
            return expr
        }
    }

    if(source.typeid == target.typeid) {
        return expr
    }

    var path = FieldPath{}
    if(!source.getFieldPathByType(target, &path)) {
        return expr
    }

    var originalExpr = expr;
    const module = this.current

    for(var i = 0; i < path.numOfFields; i+=1) {
        var field = path.fields[i]
        assert(field.kind == StmtKind.VAR_FIELD_DECL)

        //var name = this.allocator.alloc((field.varField.name.str.length + 1) * sizeof(:char)) as (*char)
        //field.varField.name.str.copyTo(name, field.varField.name.str.length)
        var name = field.varField.name.str

        var nameTypeSpec = NewNameTypeSpecIntern(expr.startPos, name, &module.typeSpecAllocator)
        var idExpr = NewIdentifierExpr(expr.startPos, expr.endPos, nameTypeSpec, module.allocator) as (*IdentifierExpr)

        var parentExpr = expr.parent
        expr = NewGetExpr(expr.startPos, expr.endPos, expr, idExpr, module.allocator)
        if(parentExpr) {
            parentExpr.becomeParentOf(expr)
        }

    }

    if(!this.resolveExpr(expr)) {
        return originalExpr
    }

    return expr
}

func (this: *TypeChecker) coerceFuncArgs(expr: *FuncCallExpr,
                                         funcType: *TypeInfo,
                                         suppliedArgs: *Array<CallArg>) : bool {

    assert(IsFuncLike(funcType))

    if(funcType.kind == TypeKind.FUNC_PTR) {
        var funcPtr = funcType
        for(var i = 0; i < funcPtr.paramDecls.size() && i < suppliedArgs.size(); i += 1) {
            var argExpr = suppliedArgs.get(i).argExpr
            var paramInfo = funcPtr.paramDecls.get(i)

            if(!this.coerceFuncArg(expr, i, argExpr, paramInfo, suppliedArgs)) {
                return false
            }
        }
    }
    else {
        var funcInfo  = funcType
        for(var i = 0; i < funcInfo.funcDecl.params.size() && i < suppliedArgs.size(); i += 1) {
            var argExpr = suppliedArgs.get(i).argExpr
            var paramInfo = funcInfo.funcDecl.params.get(i).typeInfo

            if(!this.coerceFuncArg(expr, i, argExpr, paramInfo, suppliedArgs)) {
                return false
            }
        }
    }

    return true
}

func (this: *TypeChecker) coerceFuncArg(expr: *FuncCallExpr,
                                        index: i32,
                                        argExpr: *Expr,
                                        paramInfo: *TypeInfo,
                                        suppliedArgs: *Array<CallArg>) : bool {
    if(!this.resolveExpr(argExpr)) {
        return false
    }

    var argInfo = argExpr.operand.typeInfo

    if(argInfo.kind == TypeKind.ARRAY) {
        return true
    }

    if(!IsAggregateLike(argInfo)) {
        return true
    }

    if(!IsAggregateLike(paramInfo) || IsTraitLike(paramInfo)) {
        return true
    }

    argExpr = this.coerceTypeWithUsing(argExpr, argInfo, paramInfo)
    argInfo = argExpr.operand.typeInfo

    // promote the argument to a pointer
    if(IsPtrAggregate(paramInfo) && (!IsPtrAggregate(argInfo) && argInfo.kind != TypeKind.NULL)) {
        // can't take the address of a right value
        if(argExpr.operand.isRightValue) {
            return true
        }

        var groupExpr = NewGroupExpr(argExpr.startPos, argExpr.endPos, argExpr, this.allocator)
        argExpr = NewUnaryExpr(argExpr.startPos, argExpr.endPos, TokenType.BAND, groupExpr, this.allocator)
        if(!this.resolveExpr(argExpr)) {
            return false
        }
    }
    else if(IsAggregate(paramInfo) && IsPtrAggregate(argInfo)) {
        var groupExpr = NewGroupExpr(argExpr.startPos, argExpr.endPos, argExpr, this.allocator)
        argExpr = NewUnaryExpr(argExpr.startPos, argExpr.endPos, TokenType.STAR, groupExpr, this.allocator)
        if(!this.resolveExpr(argExpr)) {
            return false
        }
    }
    // promote the function to a function ptr
    else if (paramInfo.kind == TypeKind.FUNC_PTR && argInfo.kind == TypeKind.FUNC) {
        var groupExpr = NewGroupExpr(argExpr.startPos, argExpr.endPos, argExpr, this.allocator)
        argExpr = NewUnaryExpr(argExpr.startPos, argExpr.endPos, TokenType.BAND, groupExpr, this.allocator)
        if(!this.resolveExpr(argExpr)) {
            return false
        }
    }

    expr.node.becomeParentOf(argExpr)
    suppliedArgs.set(index, CallArg { .argExpr = argExpr })
    return true
}


func (this: *TypeChecker) checkNumberOfArgs(expr: *FuncCallExpr,
                                            funcName: InternedString,
                                            maxNumOfArgs: i32,
                                            hasVarargs: bool,
                                            numberOfSuppliedArgs: i32,
                                            numberOfDefaultArgs: i32) : bool {
    assert(expr != null)

    if(maxNumOfArgs == numberOfSuppliedArgs) {
        return true
    }

    var minNumOfArgs = maxNumOfArgs - numberOfDefaultArgs
    if(numberOfSuppliedArgs == minNumOfArgs) {
        return true
    }
    if(minNumOfArgs > numberOfSuppliedArgs) {
        this.result.addError(expr.startPos, "'%.*s' called with too few arguments", funcName.length, funcName.buffer)
        return false
    }

    if(hasVarargs) {
        return true
    }

    if(maxNumOfArgs < numberOfSuppliedArgs) {
        this.result.addError(expr.startPos, "'%.*s' called with too many arguments", funcName.length, funcName.buffer)
        return false
    }

    return true
}

func (this: *TypeChecker) inferredType(name: Identifier, paramType: *TypeInfo, expectedType: *TypeInfo) : *TypeInfo {
    assert(paramType != null)
    assert(expectedType != null)

    if(name.str.equals(paramType.name)) {
        return expectedType
    }

    if(paramType.kind != expectedType.kind) {
        return null
    }

    var index = 0;
    if(paramType.sym && (paramType.sym.flags & SymbolFlags.IS_FROM_GENERIC_TEMPLATE)) {
        var genericArgs = paramType.sym.genericArgs
        for(; index < genericArgs.size(); index += 1) {
            var arg = genericArgs.get(index)

            if(name.str.equals(arg.name)) {
                break;
            }
        }
    }

    switch(paramType.kind) {
        case TypeKind.ARRAY: {
            var arrayInfo = paramType
            var expectedArrayInfo = expectedType
            return this.inferredType(name, arrayInfo.arrayOf, expectedArrayInfo.arrayOf)
        }
        case TypeKind.CONST: {
            var constInfo = paramType
            var expectedConstInfo = expectedType
            return this.inferredType(name, constInfo.constOf, expectedConstInfo.constOf)
        }
        case TypeKind.PTR: {
            var ptrInfo = paramType
            var expectedPtrInfo = expectedType
            return this.inferredType(name, ptrInfo.ptrOf, expectedPtrInfo.ptrOf)
        }
        case TypeKind.TRAIT:
        case TypeKind.UNION:
        case TypeKind.STRUCT: {
            var aggInfo = paramType

            var size = aggInfo.aggDecl.genericParams.size()
            if(size == 0 || size <= index) {
                break;
            }

            var genericName = aggInfo.aggDecl.genericParams.get(index).name
            var expectedAggInfo = expectedType

            var aggBaseName: [MAX_SYMBOL_NAME]char;
            var expectedBaseName: [MAX_SYMBOL_NAME]char;

            aggInfo.getBaseName(aggBaseName);
            expectedAggInfo.getBaseName(expectedBaseName)

            if(strcmp(aggBaseName, expectedBaseName) == 0) {
                var sym = expectedAggInfo.sym; // expectedAggInfo.decl.genericParams?
                var pSize = sym.genericParams.size()
                if(pSize) {
                    for(var i = 0; i < pSize; i += 1) {
                        var param = sym.genericParams.get(i)
                        if(param.name.str.equals(genericName.str)) {
                            return sym.genericArgs.get(i)
                        }
                    }
                }
            }

            var fieldName = EMPTY_STR;
            for(var i = 0; i < aggInfo.aggDecl.fields.size(); i += 1) {
                var field = aggInfo.aggDecl.fields.get(i)
                switch(field.kind) {
                    case StmtKind.TRAIT_FIELD_DECL: {
                        var traitField = field.traitField
                        fieldName = traitField.name.str
                        break;
                    }
                    case StmtKind.VAR_FIELD_DECL: {
                        var varField = field.varField
                        fieldName = varField.name.str
                        break;
                    }
                    case StmtKind.ENUM_FIELD_DECL: {
                        var enumField = field.enumField
                        fieldName = enumField.name.str
                        break;
                    }
                    case StmtKind.UNION_FIELD_DECL:
                    case StmtKind.STRUCT_FIELD_DECL: {
                        var aggField = field.aggregateField
                        fieldName = aggField.name.str
                        break;
                    }
                    default: {
                        continue
                    }
                }

                //var argumentField = expectedAggInfo.getFieldWithUsing(fieldName)
                var argumentField = expectedAggInfo.getField(fieldName)
                if(argumentField.kind != StmtKind.POISON_EXPR) {
                    assert(field.typeInfo != null)

                    var fieldType = this.inferredType(genericName, field.typeInfo, argumentField.typeInfo)
                    if(fieldType) {
                        return fieldType
                    }
                }
            }
            break;
        }
        case TypeKind.FUNC_PTR: {
            var funcInfo = paramType
            if(funcInfo.genericParams.empty() || funcInfo.genericParams.size() <= index) {
                break;
            }
            var genericName = funcInfo.genericParams.get(index).name
            var argumentFuncInfo = expectedType

            var retType = this.inferredType(genericName, funcInfo.returnType, argumentFuncInfo.returnType)
            if(retType) {
                return retType
            }

            for(var i = 0; i < funcInfo.paramDecls.size(); i+=1) {
                if(i < argumentFuncInfo.paramDecls.size()) {
                    var pType = this.inferredType(genericName, funcInfo.paramDecls.get(i), argumentFuncInfo.paramDecls.get(i))
                    if(pType) {
                        return pType
                    }

                }
            }
            break;
        }
        default: {
            break;
        }
    }

    return null
}

func (this: *TypeChecker) checkInferrability(expr: *Expr, type: *TypeInfo) : bool {
    // Function ptr with generic arguments can't be inferred when used as a parameter to a generic function
    // for which we are trying to infer for, as there is nothing in the function ptr to hint for the
    // actual type.

    if(type.kind == TypeKind.FUNC && type.sym && type.sym.flags & SymbolFlags.IS_GENERIC_TEMPLATE) {
        this.errorMissingGenericArguments(expr, type.sym.name, &type.funcDecl.genericParams)
        return false
    }
    else if(type.kind == TypeKind.FUNC_PTR && !type.genericParams.empty()) {
        this.errorMissingGenericArguments(expr, type.name, &type.genericParams)
        return false
    }
    return true
}

func (this: *TypeChecker) inferFuncCallExpr(expr: *FuncCallExpr, funcType: *TypeInfo, suppliedArgs: *Array<CallArg>, isMethodCall: bool) : *TypeInfo {
    assert(IsFuncLike(funcType))

    for(var i = 0; i < expr.arguments.size(); i += 1) {
        var arg = expr.arguments.get(i)
        if(!this.resolveExpr(arg.argExpr)) {
            goto err;
        }

        if(!this.checkInferrability(arg.argExpr, arg.argExpr.operand.typeInfo)) {
            goto err;
        }
    }

    var objectExpr: *Expr = expr.object
    if(isMethodCall) {
        var getExpr: *GetExpr = expr.object as (*GetExpr);
        objectExpr = &getExpr.field.expr;
    }

    if(objectExpr.kind != StmtKind.FUNC_IDENTIFIER_EXPR) {
        return funcType
    }

    var funcExpr = objectExpr as (*IdentifierExpr);
    var nameSpec = funcExpr.type

    nameSpec.typeInfo = null // clear out the cached value, so it can be created with the generic types

    // TODO: Clean this up, too much duplicate code...
    var genericParams: Array<GenericParam>;
    if(funcType.kind == TypeKind.FUNC_PTR) {
        var funcPtr = funcType
        genericParams = funcPtr.genericParams;
        var size = genericParams.size()

        nameSpec.genericArgs.init(size, this.allocator)
        expr.genericArgs.init(size, this.allocator)

        var suppliedArgsSize = suppliedArgs.size()
        for(var i = 0; i < size; i+=1) {
            var genericParam = genericParams.get(i)

            for(var j = 0; j < funcPtr.paramDecls.size(); j+=1) {
                var paramType = funcPtr.paramDecls.get(j)

                if(j >= suppliedArgsSize) {
                    break
                }

                var argType = suppliedArgs.get(j).argExpr.operand.typeInfo
                assert(argType != null)
                assert(paramType != null)

                var inferredType = this.inferredType(genericParam.name, paramType, argType)
                if(inferredType) {
                    nameSpec.genericArgs.add(inferredType.asTypeSpec(this.current))
                    break
                }
            }
        }

    }
    else {
        var funcInfo = funcType
        genericParams = funcInfo.funcDecl.genericParams;

        var size = genericParams.size()

        nameSpec.genericArgs.init(size, this.allocator)
        expr.genericArgs.init(size, this.allocator)

        var suppliedArgsSize = suppliedArgs.size()
        for(var i = 0; i < size; i+=1) {
            var genericParam = genericParams.get(i)

            for(var j = 0; j < funcInfo.funcDecl.params.size(); j+=1) {
                var paramType = funcInfo.funcDecl.params.get(j).typeInfo

                if(j >= suppliedArgsSize) {
                    break
                }

                var argType = suppliedArgs.get(j).argExpr.operand.typeInfo
                assert(argType != null)
                assert(paramType != null)

                var inferredType = this.inferredType(genericParam.name, paramType, argType)
                if(inferredType) {
                    nameSpec.genericArgs.add(inferredType.asTypeSpec(this.current))
                    break
                }
            }
        }

    }

    if(!this.resolveExpr(expr.object)) {
        for(var i = expr.genericArgs.size(); i < genericParams.size(); i += 1) {
            var param = genericParams.get(i)
            this.errorInferGenericParameter(expr, &param)
        }
        goto err;
    }

    var type = expr.object.operand.typeInfo

    if(!IsFuncLike(type)) {
        goto err;
    }

    // if this is still a generic template, we haven't completely inferred all
    // generic parameters
    if(type.sym && type.sym.flags & SymbolFlags.IS_GENERIC_TEMPLATE) {
        var decl = type.sym.decl as (*GenericDecl)
        this.errorMissingGenericArguments(funcExpr, nameSpec.name, decl.genericParams)
        goto err;
    }

    return type

err:
    return &POISON_TYPE
}

func (this: *TypeChecker) checkFuncCallArgs(expr: *FuncCallExpr, funcType: *TypeInfo, suppliedArgs: *Array<CallArg>) : bool {
    assert(funcType != null)
    assert(IsFuncLike(funcType))

    var numberOfSuppliedArgs = suppliedArgs.size()
    var success = true
    var hasVarargs = false
    var i = 0;

    if(funcType.kind == TypeKind.FUNC_PTR) {
        var funcPtr = funcType
        hasVarargs = funcPtr.hasVarargs

        for(; i < funcPtr.paramDecls.size(); i+=1) {
            var p = funcPtr.paramDecls.get(i)
            if(i < numberOfSuppliedArgs) {
                var callArg = suppliedArgs.getPtr(i)
                var arg = callArg.argExpr

                // For now, we don't allow function pointers to contain
                // named arguments, only because we currently don't allow names in the
                // parameters in the TypeInfo
                if(callArg.argName.token.type == TokenType.IDENTIFIER) {
                    this.errorNamedArgumentsForFuncPtr(arg)
                    success = false
                }

                callArg.index = i

                success = this.checkTypeCompatibility(arg.startPos, p, arg.operand.typeInfo, .allowPtrArithmetic = false) && success
                arg.expectedType = p;

                // don't allow for trait casting on rvalues (i.e., prevents &4)
                if(IsTrait(p) && arg.operand.isRightValue) {
                    this.errorRvalueAssignmentToTrait(arg, arg.operand.typeInfo, p)
                    success = false
                }
            }
        }


    }
    else {
        var funcInfo = funcType
        var hasNamedArg = false
        hasVarargs = funcInfo.funcDecl.params.isVararg

        for(; i < funcInfo.funcDecl.params.size(); i+=1) {
            var p = funcInfo.funcDecl.params.get(i)
            if(i < numberOfSuppliedArgs) {
                var callArg = suppliedArgs.getPtr(i)
                var paramIndex = i

                if(callArg.argName.token.type == TokenType.IDENTIFIER) {
                    hasNamedArg = true
                    paramIndex = -1

                    for(var index = 0; index < funcInfo.funcDecl.params.size(); index += 1) {
                        var param = funcInfo.funcDecl.params.get(index)
                        if(param.name.str.equals(callArg.argName.str)) {
                            paramIndex = index
                            p = param
                            break
                        }
                    }

                    if(paramIndex < 0) {
                        this.errorInvalidNamedArgument(callArg.argName.token.pos, callArg.argName.str, funcInfo)
                        success = false
                    }
                }
                else if(hasNamedArg) {
                    // allow for in-order names to follow fixed arguments
                    if(!p.name.str.equals(callArg.argName.str)) {
                        this.errorFixedArgumentAfterNamed(callArg.argExpr)
                        success = false
                    }
                }

                var arg = callArg.argExpr
                callArg.index = paramIndex
                success = this.checkTypeCompatibility(arg.startPos, p.typeInfo, arg.operand.typeInfo, .allowPtrArithmetic = false) && success
                arg.expectedType = p.typeInfo;

                if(IsTrait(p.typeInfo) && arg.operand.isRightValue) {
                    this.errorRvalueAssignmentToTrait(arg, arg.operand.typeInfo, p.typeInfo)
                    success = false
                }
            }
        }

        // now populate the any default arguments
        for(var index = 0; index < funcInfo.funcDecl.params.size(); index+=1) {
            var param = funcInfo.funcDecl.params.get(index)
            if(param.defaultExpr) {
                var hasValue = false
                for(var j = 0; j < suppliedArgs.size(); j += 1) {
                    var callArg = suppliedArgs.getPtr(j)
                    if(callArg.index == index) {
                        hasValue = true
                        break
                    }
                }

                if(!hasValue) {
                    suppliedArgs.add(CallArg {
                        .argExpr = param.defaultExpr,
                        .index = index,
                        .isDefault = true,
                    })
                }
            }
        }
    }

    if(hasVarargs) {
        for(; i < numberOfSuppliedArgs; i+=1) {
            var arg = suppliedArgs.getPtr(i)
            arg.index = i

            if(!this.resolveExpr(arg.argExpr)) {
                return false
            }
        }
    }

    return success
}

func (this: *TypeChecker) resolveFuncCallExpr(expr: *FuncCallExpr) : bool {
    assert(expr != null)
    var errors = this.errors()

    if(!this.resolveExpr(expr.object)) {
        return false
    }

    var objectType = expr.object.operand.typeInfo
    if(!IsFuncLike(objectType)){
        this.errorNonFuncType(expr.object, objectType)
        return false
    }

    var isMethod = false
    var numberOfDefaultArgs = 0
    var suppliedArgs = ArrayInit<CallArg>(expr.arguments.size() + 1, this.allocator)
    suppliedArgs.addAll(expr.arguments)

    var hasVarargs = false
    var maxNumOfArgs = 0
    var returnType: *TypeInfo = null
    var genericParams: Array<GenericParam>;

    // TODO: there is a lot of duplicate code here, should we
    // represent FUNC and FUNC_PTR's in the same structure??
    if(objectType.kind == TypeKind.FUNC) {
        var funcInfo = objectType
        isMethod = (funcInfo.funcDecl.flags & FuncFlags.IS_METHOD)
        if(!funcInfo.funcDecl.params) {
            return false
        }

        maxNumOfArgs = funcInfo.funcDecl.params.size()
        hasVarargs = funcInfo.funcDecl.params.isVararg
        returnType = funcInfo.returnType
        genericParams = funcInfo.funcDecl.genericParams

        for(var i = 0; i < funcInfo.funcDecl.params.size(); i += 1) {
            var p = funcInfo.funcDecl.params.get(i)
            if(p.defaultExpr) {
                numberOfDefaultArgs += 1
            }
        }
    }
    else {
        var funcPtr = objectType
        maxNumOfArgs = funcPtr.paramDecls.size()
        hasVarargs = funcPtr.hasVarargs
        returnType = funcPtr.returnType
        genericParams = funcPtr.genericParams

        // ??? This looks like this might be a ticking time bomb with overriding the name each time ???
        // The thought here is that if this is a function pointer, which don't have
        // a name, get assigned the name on invocation -- this name becomes relavent for
        // error output
        if(expr.object.kind == StmtKind.FUNC_IDENTIFIER_EXPR) {
            var idExpr = expr.object as (*IdentifierExpr)
            funcPtr.name = idExpr.type.name
        }
        else if(expr.object.kind == StmtKind.GET_EXPR) {
            var getExpr = expr.object as (*GetExpr)
            funcPtr.name = getExpr.field.type.name
        }
    }

    var isMethodCall = isMethod && this.isMethodSyntax(expr, &suppliedArgs)
    var numberOfSuppliedArgs = suppliedArgs.size()

    if(!this.checkNumberOfArgs(expr, objectType.name, maxNumOfArgs, hasVarargs, numberOfSuppliedArgs, numberOfDefaultArgs)) {
        return false
    }

    if(!this.coerceFuncArgs(expr, objectType, suppliedArgs)) {
        return false
    }

    // apply generic type inferences if there are generics and no generic arguments
    if(!genericParams.empty()) {
        if(expr.genericArgs.empty()) {
            objectType = this.inferFuncCallExpr(expr, objectType, suppliedArgs, isMethodCall)

            // unable to infer types
            if(objectType == &POISON_TYPE || !objectType) {
                return false
            }

            assert(IsFuncLike(objectType))

            if(objectType.kind == TypeKind.FUNC) {
                var funcInfo = objectType
                returnType = funcInfo.returnType
            }
            else {
                var funcPtr = objectType
                returnType = funcPtr.returnType
            }
        }
        else {
            for(var i = 0; i < expr.genericArgs.size(); i += 1) {
                var arg = expr.genericArgs.get(i)
                this.resolveTypeSpec(arg)
            }
        }
    }

    if(!this.checkFuncCallArgs(expr, objectType, suppliedArgs)) {
        return false
    }

    assert(returnType != null)

    suppliedArgs.sort(CallArgSort)

    expr.arguments = *expr.node.becomeParentOfChildrenCallArgs(suppliedArgs)
    expr.operand.typeInfo = returnType
    expr.operand.isRightValue = true
    return errors == this.errors()
}

/*
func Print(text: *const char, suppliedArgs: *Array<CallArg>) {
    printf("%s:\n", text)
    for(var i = 0; i < suppliedArgs.size(); i += 1) {
        var arg = suppliedArgs.get(i)
        printf("   index: %d\n", arg.index)
    }
}*/

func (this: *TypeChecker) resolveBooleanExpr(expr: *BooleanExpr) : bool {
    assert(expr != null)
    expr.operand.typeInfo = &BOOL_TYPE
    expr.operand.isConst = true
    expr.operand.isRightValue = true
    expr.operand.val.intValue = expr.boolean
    return true
}

func (this: *TypeChecker) resolveCharExpr(expr: *CharExpr) : bool {
    assert(expr != null)
    expr.operand.typeInfo = &CHAR_TYPE
    expr.operand.isConst = true
    expr.operand.isRightValue = true
    expr.operand.val = expr.character.value
    return true
}

func (this: *TypeChecker) resolveNullExpr(expr: *NullExpr) : bool {
    assert(expr != null)
    expr.operand.typeInfo = &NULL_TYPE
    expr.operand.isConst = true
    expr.operand.isRightValue = true
    return true
}

func (this: *TypeChecker) resolveNumberExpr(expr: *NumberExpr) : bool {
    assert(expr != null)
    expr.operand.typeInfo = expr.number.typeInfo
    expr.operand.isConst = true
    expr.operand.isRightValue = true
    expr.operand.val = expr.number.value
    return true
}

func (this: *TypeChecker) resolveStringExpr(expr: *StringExpr) : bool {
    assert(expr != null)
    expr.operand.typeInfo = &STR_TYPE
    expr.operand.isConst = true
    expr.operand.isRightValue = true
    expr.operand.val = expr.string.value
    return true
}

func (this: *TypeChecker) resolveSubscriptSetExpr(expr: *SubscriptSetExpr) : bool {
    assert(expr != null)

    if(!this.resolveExpr(expr.object)) {
        return false
    }

    if(!this.resolveExpr(expr.index)) {
        return false
    }

    if(!this.resolveExpr(expr.value)) {
        return false
    }

    var baseObj: *TypeInfo = null

    var objectType = expr.object.operand.typeInfo
    switch(objectType.kind) {
        case TypeKind.STR: {
            this.errorSetIndexingConstType(expr.object, objectType)
            return false
        }
        case TypeKind.PTR: {
            var ptrInfo = objectType
            baseObj = ptrInfo.ptrOf
            break;
        }
        case TypeKind.ARRAY: {
            var arrayInfo = objectType
            baseObj = arrayInfo.arrayOf
            break;
        }
        default: {
            this.errorNonIndexableType(expr.object, objectType)
            return false
        }
    }

    if(baseObj.kind == TypeKind.CONST) {
        this.errorSetIndexingConstType(expr.object, objectType)
        return false
    }

    var indexType = expr.index.operand.typeInfo
    if(!IsInteger(indexType)) {
        this.errorIndexType(expr.index, indexType)
        return false
    }

    if(!this.checkTypeCompatibility(expr.value.startPos, baseObj, expr.value.operand.typeInfo)) {
        return false
    }

    // don't allow for trait casting on rvalues (i.e., prevents &4)
    if(IsTrait(baseObj) && expr.value.operand.isRightValue) {
        this.errorRvalueAssignmentToTrait(expr.value, expr.value.operand.typeInfo, baseObj)
        return false
    }

    expr.operand.typeInfo = expr.value.operand.typeInfo
    return true
}


func (this: *TypeChecker) resolveSubscriptGetExpr(expr: *SubscriptGetExpr) : bool {
    assert(expr != null)

    if(!this.resolveExpr(expr.object)) {
        return false
    }

    if(!this.resolveExpr(expr.index)) {
        return false
    }

    var baseObj: *TypeInfo = null

    var objectType = expr.object.operand.typeInfo
    switch(objectType.kind) {
        case TypeKind.STR: {
            baseObj = &CHAR_TYPE
            break;
        }
        case TypeKind.PTR: {
            var ptrInfo = objectType
            baseObj = ptrInfo.ptrOf
            if(baseObj.kind == TypeKind.CONST) {
                var constInfo = baseObj
                baseObj = constInfo.constOf
            }
            break;
        }
        case TypeKind.ARRAY: {
            var arrayInfo = objectType
            baseObj = arrayInfo.arrayOf
            if(baseObj.kind == TypeKind.CONST) {
                var constInfo = baseObj
                baseObj = constInfo.constOf
            }
            break;
        }
        default: {
            this.errorNonIndexableType(expr.object, objectType)
            return false
        }
    }

    var indexType = expr.index.operand.typeInfo
    if(!IsInteger(indexType)) {
        this.errorIndexType(expr.index, indexType)
        return false
    }

    expr.operand.typeInfo = baseObj
    return true
}

func (this: *TypeChecker) resolveInitArgExpr(expr: *InitArgExpr) : bool {
    assert(expr != null)
    expr.operand.typeInfo = &NULL_TYPE
    if(expr.value) {
        if(!this.resolveExpr(expr.value)) {
            return false
        }
        expr.operand = expr.value.operand
    }

    return true
}

func (this: *TypeChecker) addDefaultArguments(type: *TypeInfo, expr: *InitExpr) : bool {
    assert(expr != null)
    assert(type != null)
    assert(IsAggregate(type))

    var aggInfo = type

    var defaultArgs = Array<*InitArgExpr>{}
    defaultArgs.init(aggInfo.aggDecl.fields.size(), this.allocator)

    for(var position = 0; position < aggInfo.aggDecl.fields.size(); position += 1) {
        var field = aggInfo.aggDecl.fields.get(position)
        if(field.kind != StmtKind.VAR_FIELD_DECL) {
            continue
        }

        if(!field.varField.defaultExpr) {
            continue
        }

        var byName = false
        var byPos = false
        var hasNamedArgs = false
        for(var i = 0; i < expr.arguments.size(); i += 1) {
            var arg = expr.arguments.get(i)
            if(arg.fieldName.token.type == TokenType.IDENTIFIER) {
                hasNamedArgs = true

                if(arg.fieldName.str.equals(field.varField.name.str)) {
                    byName = true
                    break
                }
            }
            else if(arg.argPosition == position) {
                byPos = true
                break
            }
        }

        if(!byName && !(!hasNamedArgs && byPos)) {
            var arg = NewInitArgExpr(expr.startPos, expr.endPos, field.varField.name, position, field.varField.defaultExpr, this.allocator) as (*InitArgExpr)
            expr.node.becomeParentOf(arg)
            defaultArgs.add(arg)
        }
    }

    for(var i = 0; i < defaultArgs.size(); i += 1) {
        var arg = defaultArgs.get(i)
        expr.arguments.add(arg)
    }

    return true
}


func (this: *TypeChecker) addInitArgumentsReferences(type: *TypeInfo, expr: *InitExpr) {
    assert(expr != null)
    assert(type != null)

    if(IsAggregate(type)) {
        var aggInfo = type
        for(var i = 0; i < expr.arguments.size(); i += 1) {
            var arg = expr.arguments.get(i)

            if(arg.fieldName.token.type == TokenType.IDENTIFIER) {
                var fieldName = arg.fieldName.str
                var fieldResult = aggInfo.getFieldPosition(fieldName)
                if(fieldResult.aggInfo) {
                    this.lita.references.addFieldReference(arg.startPos,
                                                           fieldResult.aggInfo,
                                                           fieldResult.position)
                }
            }
        }
    }
}

func IsDecayable(arg: *InitArgExpr) : bool {
    if(!arg.value) {
        return false
    }

    if(arg.value.kind == StmtKind.ARRAY_INIT_EXPR ||
       arg.value.kind == StmtKind.STRING_EXPR) {
        return true
    }

    return false
}

func (this: *TypeChecker) checkInitArguments(type: *TypeInfo, expr: *InitExpr) : bool {
    assert(expr != null)
    assert(type != null)

    var errors = this.errors()
    if(IsAggregate(type)) {
        var aggInfo = type
        for(var i = 0; i < expr.arguments.size(); i += 1) {
            var arg = expr.arguments.get(i)
            var field: FieldStmt;

            if(arg.fieldName.token.type == TokenType.IDENTIFIER) {
                var fieldName = arg.fieldName.str

                field = aggInfo.getField(fieldName)
                if(field.kind == StmtKind.POISON_EXPR) {
                    this.errorNoField(arg, type, fieldName)
                    continue
                }
            }
            else {
                field = aggInfo.getFieldByPosition(arg.argPosition)
                if(field.kind == StmtKind.POISON_EXPR) {
                    this.errorNoFieldAt(arg, type, arg.argPosition)
                    continue
                }
            }

            this.checkAssignability(arg.startPos, field.typeInfo, arg.operand.typeInfo, IsDecayable(arg))
            arg.expectedType = field.typeInfo
            arg.value.expectedType = field.typeInfo

            // don't allow for trait casting on rvalues (i.e., prevents &4)
            if(IsTrait(field.typeInfo) && arg.operand.isRightValue) {
                this.errorRvalueAssignmentToTrait(arg, arg.operand.typeInfo, field.typeInfo)
            }
        }
    }
    else if(type.kind == TypeKind.ARRAY) {
        var arrayInfo = type
        for(var i = 0; i < expr.arguments.size(); i += 1) {
            var arg = expr.arguments.get(i)

            this.checkAssignability(arg.startPos, arrayInfo.arrayOf, arg.operand.typeInfo, IsDecayable(arg))
            arg.expectedType = arrayInfo.arrayOf
            arg.value.expectedType = arrayInfo.arrayOf

            // don't allow for trait casting on rvalues (i.e., prevents &4)
            if(IsTrait(arrayInfo.arrayOf) && arg.operand.isRightValue) {
                this.errorRvalueAssignmentToTrait(arg, arg.operand.typeInfo, arrayInfo.arrayOf)
            }
        }

    }

    return this.errors() == errors
}

func (this: *TypeChecker) inferInitExpr(expr: *InitExpr, aggInfo: *TypeInfo) : *TypeInfo {
    var size = aggInfo.aggDecl.genericParams.size()
    expr.genericArgs.init(size, this.allocator)
    var suppliedArgs = ArrayInit<*TypeInfo>(expr.arguments.size(), this.allocator)
    for(var i = 0; i < expr.arguments.size(); i += 1) {
        var arg = expr.arguments.get(i)
        var type = arg.operand.typeInfo
        if(!type) {
            this.errorInferGenericParameters(expr, aggInfo.aggDecl.genericParams)
            goto err
        }

        suppliedArgs.add(type)
    }

    if(!expr.type) {
        return aggInfo as (*TypeInfo)
    }

    expr.type.genericArgs.init(size, this.allocator)
    expr.type.typeInfo = null // clear out the cached value, so it can be created with the generic types

    for(var genericIndex = 0; genericIndex < size; genericIndex += 1) {
        var genericParam = aggInfo.aggDecl.genericParams.get(genericIndex)

        for(var fieldIndex = 0; fieldIndex < aggInfo.aggDecl.fields.size(); fieldIndex += 1) {
            var paramType = aggInfo.aggDecl.fields.get(fieldIndex).typeInfo
            if(!paramType) {
                this.errorInferGenericParameter(expr, genericParam)
                goto err
            }

            if(fieldIndex >= suppliedArgs.size()) {
                break
            }

            var inferredType = this.inferredType(genericParam.name, paramType, suppliedArgs.get(fieldIndex))
            if(inferredType) {
                expr.type.genericArgs.add(inferredType.asTypeSpec(this.current))
                break
            }
        }
    }

    var type = this.resolveTypeSpec(expr.type)
    if(!type) {
        goto err
    }

    if(type.sym && (type.sym.flags & SymbolFlags.IS_GENERIC_TEMPLATE)) {
        var decl = type.sym.decl as (*GenericDecl)
        this.errorMissingGenericArguments(expr, expr.type.name, decl.genericParams)
        goto err;
    }
    return type

err:
    return &POISON_TYPE
}

func (this: *TypeChecker) resolveInitExpr(expr: *InitExpr) : bool {
    assert(expr != null)

    var type = this.resolveTypeSpec(expr.type)
    if(!type) {
        return false
    }

    if(!IsAggregate(type) && type.kind != TypeKind.ARRAY) {
        this.result.addError(expr.startPos, "only struct, union or array can use initialization syntax")
        return false
    }

    if(IsAggregate(type)) {
        if(!this.addDefaultArguments(type, expr)) {
            return false
        }
    }

    for(var i = 0; i < expr.arguments.size(); i += 1) {
        var arg = expr.arguments.get(i)
        if(!this.resolveInitArgExpr(arg)) {
            return false
        }
    }

    // If this aggregate type has generics and there are no generic arguments supplied,
    // we attempt to infer the generic arguments
    if(IsAggregate(type)) {
        var aggInfo = type

        if(!aggInfo.aggDecl.genericParams.empty() && expr.genericArgs.empty()) {
            type = this.inferInitExpr(expr, aggInfo)
            if(type.kind == TypeKind.POISON) {
                return false
            }
        }
    }

    this.addInitArgumentsReferences(type, expr)

    expr.operand.typeInfo = type
    return this.checkInitArguments(type, expr)
}



func (this: *TypeChecker) resolveSetExpr(expr: *SetExpr) : bool {
    assert(expr != null)

    if(!this.resolveExpr(expr.object)) {
        return false
    }

    if(!this.resolveExpr(expr.value)) {
        return false
    }

    // should we resolve field?
    if(!expr.field) {
        return false
    }

    var objectTypeInfo = expr.object.operand.typeInfo
    if(objectTypeInfo.kind == TypeKind.ENUM) {
        this.errorEnumFieldSet(expr.object, objectTypeInfo, expr.field.type.name)
        return false
    }

    if(!IsFieldAccessible(objectTypeInfo)) {
        this.errorNoFieldAccess(expr.object, objectTypeInfo, expr.field.type.name)
        return false
    }

    var info = objectTypeInfo.getBaseType()
    assert(info != null)
    assert(info.kind == TypeKind.STRUCT || info.kind == TypeKind.UNION)

    var aggInfo = info
    var field = aggInfo.getField(expr.field.type.name)
    if(field.kind == StmtKind.POISON_EXPR) {
        field = aggInfo.getFieldWithUsing(expr.field.type.name)
        if(field.kind == StmtKind.POISON_EXPR) {
            this.errorNoField(expr.field, objectTypeInfo, expr.field.type.name)
            return false
        }
        expr.flags |= GetExprFlags.IS_USING
    }

    var fieldResult = aggInfo.getFieldPosition(expr.field.type.name)
    if(fieldResult.aggInfo) {
        this.lita.references.addFieldReference(expr.field.type.pos,
                                                fieldResult.aggInfo,
                                                fieldResult.position)
    }

    expr.field.operand.typeInfo = field.typeInfo
    expr.operand.typeInfo = field.typeInfo

    // don't allow for trait casting on rvalues (i.e., prevents &4)
    if(IsTrait(field.typeInfo) && expr.value.operand.isRightValue) {
        this.errorRvalueAssignmentToTrait(expr.value, expr.value.operand.typeInfo, field.typeInfo)
        return false
    }

    return this.checkTypeCompatibility(expr.startPos, field.typeInfo, expr.value.operand.typeInfo)
}

func (this: *TypeChecker) resolveTernaryExpr(expr: *TernaryExpr) : bool {
    assert(expr != null)

    if(!this.resolveExpr(expr.cond)) {
        return false
    }

    var condType = expr.cond.operand.typeInfo
    if(!IsBooleanable(condType)) {
        this.result.addError(expr.cond.startPos, "must be a boolean expression")
        return false
    }

    if(!this.resolveExpr(expr.then)) {
        return false;
    }

    if(!this.resolveExpr(expr.other)) {
        return false;
    }


    expr.operand.typeInfo = expr.then.operand.typeInfo
    expr.operand.isRightValue = true

    return this.checkTypeCompatibility(expr.startPos, expr.then.operand.typeInfo, expr.other.operand.typeInfo)
}

func (this: *TypeChecker) resolveTypeIdentifierExpr(expr: *TypeIdentifierExpr) : bool {
    assert(expr != null)

    var type = this.resolveTypeSpec(expr.type)
    if(!type) {
        return false
    }

    // We allow for taking the base type (e.g., '*const Type' is reduced to just 'Type')
    if(expr.isBased) {
        type = type.getBaseType()
    }

    expr.sym = type.sym
    expr.operand.typeInfo = type
    expr.operand.isRightValue = true
    expr.operand.isConst = true
    return true
}

func (this: *TypeChecker) resolveTypeOfExpr(expr: *TypeOfExpr) : bool {
    assert(expr != null)
    if(expr.typeOfExpr) {
        if(!this.resolveExpr(expr.typeOfExpr)) {
            return false
        }
        var type = expr.typeOfExpr.operand.typeInfo
        expr.operand.val.intValue = type.typeid
    }
    else {
        var type = this.resolveTypeSpec(expr.type)
        if(!type) {
            return false
        }
        expr.operand.val.intValue = type.typeid
    }

    expr.operand.typeInfo = &U64_TYPE
    expr.operand.isRightValue = true
    expr.operand.isConst = true
    return true
}

func (this: *TypeChecker) resolveOffsetOfExpr(expr: *OffsetOfExpr) : bool {
    assert(expr != null)
    var type = this.resolveTypeSpec(expr.type)
    if(!type) {
        return false
    }
    if(!IsAggregate(type)) {
        this.errorNonAggregateType(expr, type)
        return false
    }
    if(expr.field.token.type != TokenType.IDENTIFIER) {
        return false
    }

    var fieldName = expr.field.str

    var aggInfo = type
    var fieldStmt = aggInfo.getField(fieldName)
    if(fieldStmt.kind == StmtKind.POISON_EXPR) {
        this.errorNoField(expr, type, fieldName)
        return false
    }

    expr.operand.typeInfo = &USIZE_TYPE
    expr.operand.isRightValue = true
    expr.operand.isConst = true
    return true
}

func (this: *TypeChecker) resolveSizeOfExpr(expr: *SizeOfExpr) : bool {
    assert(expr != null)
    if(!this.resolveExpr(expr.sizeOfExpr)) {
        return false
    }

    expr.operand.typeInfo = &USIZE_TYPE
    expr.operand.isRightValue = true
    expr.operand.isConst = true
    return true
}

func (this: *TypeChecker) checkMethodExpr(expr: *GetExpr, type: *TypeInfo) : bool {
    assert(expr != null)

    // we don't allow func ptrs to have methods on them
    // otherwise, any other type can have methods on them
    if(!type || type.kind == TypeKind.FUNC_PTR) {
        return false
    }

    // If this was already processed as a method, we'll need to determine
    // if this is a generic symbol and must be re-resolved - this happens
    // during type inference for methods -- @see resolveFuncCallExpr and inferFuncCallExpr
    if(expr.flags & GetExprFlags.IS_METHOD_CALL) {
        var funcSym = this.getType(expr.field.type, SearchType.FUNC)
        if(!funcSym) {
            // TODO: mark an error?
            return false
        }

        if(funcSym.flags & SymbolFlags.IS_GENERIC_TEMPLATE) {
            var typeInfo = this.resolveTypeSpec(expr.field.type, SearchType.FUNC)
            if(!typeInfo) {
                // TODO: mark an error?
                return false;
            }

            expr.field.operand.typeInfo = typeInfo
            expr.operand.typeInfo = typeInfo
        }

        return true;
    }

    var methodResult = type.getMethod(this.lita.strings, this.current, expr.field.type.name)

    // check to see if this is a method call from a generic type,
    // in which case, we want to check the callsite module in addition to the template
    // declaration module
    if(!methodResult.symbol && this.genericContext.callsite) {
        methodResult = type.getMethod(this.lita.strings, this.genericContext.callsite, expr.field.type.name)
    }

    var funcSym = methodResult.symbol
    if(funcSym) {
        var typeInfo = funcSym.type;

        // if this is the first time we are processing this AST node
        // and it's a method, we'll need to calculate the actual Function
        // name and not just the method name
        if(!(expr.flags & GetExprFlags.IS_METHOD_CALL)) {
            expr.flags |= GetExprFlags.IS_METHOD_CALL

            expr.field.type.name = methodResult.name
        }

        if(funcSym.flags & SymbolFlags.IS_GENERIC_TEMPLATE) {
            typeInfo = this.resolveTypeSpec(expr.field.type, SearchType.FUNC)
            if(!typeInfo) {
                // TODO: mark an error?
                return false
            }
        }

        this.lita.references.addTypeReferenceByTypeInfo(expr.field.startPos, typeInfo)

        expr.field.operand.typeInfo = typeInfo
        expr.operand.typeInfo = typeInfo
        return true
    }

    if(IsAggregate(type)) {
        var aggInfo = type
        for(var i = 0; i < aggInfo.aggDecl.fields.size(); i += 1) {
            var field = aggInfo.aggDecl.fields.get(i)
            if(field.kind == StmtKind.VAR_FIELD_DECL) {
                var varField = field.varField
                if(varField.attributes.isUsing) {
                    var baseType = field.typeInfo.getBaseType()

                    // avoid inifinite recursion
                    if(baseType.strictEquals(aggInfo)) {
                        continue
                    }

                    if(this.checkMethodExpr(expr, baseType)) {
                        return true
                    }

                }
            }
        }
    }

    return false
}

func (this: *TypeChecker) resolveGetExpr(expr: *GetExpr) : bool {
    assert(expr != null)

    if(!this.resolveExpr(expr.object)) {
        return false
    }

    // should we resolve field?
    if(!expr.field /*|| !this.resolveExpr(expr.field)*/) {
        return false
    }

    var objectTypeInfo = expr.object.operand.typeInfo
    if(!IsFieldAccessible(objectTypeInfo)) {

        // for primitive types, only check and see if there is
        // a method defined for field access
        var info = objectTypeInfo.getBaseType()
        if(!this.checkMethodExpr(expr, info)) {
            this.errorNoFieldAccess(expr.object, objectTypeInfo, expr.field.type.name)
            return false
        }
        return true
    }

    if(objectTypeInfo.kind == TypeKind.ENUM) {
        var enumInfo = objectTypeInfo
        var field = enumInfo.getEnumField(expr.field.type.name)
        if(!field) {
            this.errorNoField(expr.field, objectTypeInfo, expr.field.type.name)
            return false
        }

        this.lita.references.addFieldReference(expr.field.type.pos, enumInfo, enumInfo.getEnumFieldIndex(expr.field.type.name))

        expr.flags |= GetExprFlags.IS_ENUM
        expr.operand.typeInfo = &I32_TYPE
        expr.operand.isConst = true
        expr.operand.isRightValue = true
        return true
    }
    else {
        var info = objectTypeInfo.getBaseType()
        assert(info != null)
        assert(IsAggregate(info))

        var aggInfo = info

        // is this a vanilla field access?
        var field = aggInfo.getField(expr.field.type.name)
        if(field.kind != StmtKind.POISON_EXPR) {
            this.lita.references.addFieldReference(expr.field.type.pos, aggInfo, aggInfo.getFieldIndex(expr.field.type.name))

            expr.field.operand.typeInfo = field.typeInfo
            expr.operand.typeInfo = field.typeInfo

            // if this is a trait method reference (i.e., not a function call), we must convert this to
            // a trait function pointer
            if(aggInfo.kind == TypeKind.TRAIT && expr.field.kind != StmtKind.FUNC_IDENTIFIER_EXPR) {
                var funcPtr = AsTraitFuncPtr(field.typeInfo, expr.field.type.name, this.typeCache) as (*TypeInfo)
                expr.field.operand.typeInfo = funcPtr
                expr.operand.typeInfo = funcPtr
            }
            return true
        }

        // is this a using field access?
        field = aggInfo.getFieldWithUsing(expr.field.type.name)
        if(field.kind != StmtKind.POISON_EXPR) {
            var fieldResult = aggInfo.getFieldPosition(expr.field.type.name)
            if(fieldResult.aggInfo) {
                this.lita.references.addFieldReference(expr.field.type.pos,
                                                       fieldResult.aggInfo,
                                                       fieldResult.position)
            }

            expr.flags |= GetExprFlags.IS_USING
            expr.field.operand.typeInfo = field.typeInfo
            expr.operand.typeInfo = field.typeInfo

            // if this is a trait method reference (i.e., not a function call), we must convert this to
            // a trait function pointer
            if(fieldResult.aggInfo.kind == TypeKind.TRAIT && expr.field.kind != StmtKind.FUNC_IDENTIFIER_EXPR) {
                var funcPtr = AsTraitFuncPtr(field.typeInfo, expr.field.type.name, this.typeCache) as (*TypeInfo)
                expr.field.operand.typeInfo = funcPtr
                expr.operand.typeInfo = funcPtr
            }

            return true
        }

        if(this.checkMethodExpr(expr, aggInfo)) {
            return true
        }
    }

    this.errorNoField(expr.field, objectTypeInfo, expr.field.type.name)
    return false
}

func (this: *TypeChecker) resolveGroupExpr(expr: *GroupExpr) : bool {
    assert(expr != null)

    if(!this.resolveExpr(expr.groupedExpr)) {
        return false
    }

    expr.operand = expr.groupedExpr.operand
    return true
}

func (this: *TypeChecker) resolveUnaryExpr(expr: *UnaryExpr) : bool {
    assert(expr != null)

    if(!this.resolveExpr(expr.unaryExpr)) {
        return false
    }

    var type = expr.unaryExpr.operand.typeInfo
    assert(type != null)

    switch(expr.operator) {
        case TokenType.STAR: {
            switch(type.kind) {
                case TypeKind.PTR: {
                    var info = type
                    if(info.ptrOf.kind == TypeKind.CONST) {
                        var constInfo = info.ptrOf
                        expr.operand.typeInfo = constInfo.constOf
                    }
                    else {
                        expr.operand.typeInfo = info.ptrOf
                    }
                    break
                }
                case TypeKind.STR: {
                    expr.operand.typeInfo = &CHAR_TYPE
                    break
                }
                case TypeKind.ARRAY: {
                    var info = type
                    if(info.arrayOf.kind == TypeKind.CONST) {
                        var constInfo = info.arrayOf
                        expr.operand.typeInfo = constInfo.constOf
                    }
                    else {
                        expr.operand.typeInfo = info.arrayOf
                    }
                    break
                }
                case TypeKind.CONST: {
                    var constInfo = type
                    if(IsPtrLike(constInfo.constOf)) {
                        expr.operand.typeInfo = constInfo.constOf
                    }
                    break
                }
                default: {
                    var sb = StringBufferInit(256, this.allocator)
                    sb.appendStrn("'", 1)
                    type.toString(sb)
                    sb.appendStr("' is not a pointer type")

                    this.result.addErrorStr(expr.unaryExpr.startPos, sb)
                    return false
                }

            }
            break;
        }
        case TokenType.BAND: {
            if(type.kind == TypeKind.FUNC) {
                expr.operand.typeInfo = type.asPtr(this.typeCache)
                expr.operand.isRightValue = true
            }
            else if(expr.unaryExpr.operand.isRightValue) {
                this.result.addError(expr.unaryExpr.startPos, "lvalue required as unary '&' operand")
                return false
            }
            else {
                expr.operand.typeInfo = this.typeCache.newPtrTypeInfo(type)
            }
            break;
        }
        case TokenType.NOT: {
            if(!this.checkTruthyness(expr.unaryExpr, type)) {
                return false
            }
            expr.operand.typeInfo = &BOOL_TYPE
            break;
        }
        default: {
            expr.operand = expr.unaryExpr.operand
            break;
        }
    }

    return true
}

func (this: *TypeChecker) resolveCastExpr(expr: *CastExpr) : bool {
    assert(expr != null)

    var typeInfo = this.resolveTypeSpec(expr.castTo)
    if(!typeInfo) {
        return false
    }

    if(!this.resolveExpr(expr.exprToCast)) {
        return false
    }

    expr.operand.typeInfo = typeInfo

    if(!this.checkCastability(expr.startPos, expr.exprToCast.operand.typeInfo, typeInfo)) {
        return false
    }

    return true
}


func (this: *TypeChecker) resolveArrayDesignationExpr(expr: *ArrayDesignationExpr) : bool {
    assert(expr != null)

    if(!this.resolveExpr(expr.index)) {
        return false
    }

    if(!this.resolveExpr(expr.value)) {
        return false
    }

    if(!expr.index.isConstNumberExpr()) {
        this.result.addError(expr.index.startPos, "array designation must be indexed by a number")
        return false
    }

    if(expr.index.kind == StmtKind.IDENTIFIER_EXPR) {
        var idExpr = expr.index as (*IdentifierExpr)
        if(idExpr.sym != null && !(idExpr.sym.flags & SymbolFlags.IS_CONSTANT)) {
            this.result.addError(expr.index.startPos, "'%.*s' must be a constant", idExpr.sym.name.length, idExpr.sym.name.buffer)
            return false
        }
    }

    if(!this.checkTypeCompatibility(expr.startPos, &USIZE_TYPE, expr.index.operand.typeInfo)) {
        return false
    }

    expr.operand = expr.value.operand
    return true
}

func (this: *TypeChecker) resolveArrayInitExpr(expr: *ArrayInitExpr) : bool {
    assert(expr != null)

    var typeInfo = this.resolveTypeSpec(expr.type)
    if(!typeInfo || typeInfo.kind == TypeKind.POISON) {
        return false
    }

    expr.operand.typeInfo = typeInfo
    expr.operand.isRightValue = true

    assert(typeInfo.kind == TypeKind.ARRAY)

    var arrayInfo = typeInfo
    var arrayOf = arrayInfo.arrayOf

    if(!expr.values.empty()) {
        if(!arrayInfo.numOfElements && arrayInfo.length < 1) {
            arrayInfo.length = expr.values.size()
            arrayInfo.isLengthDefined = true
        }

        var success = true
        for(var i = 0; i < expr.values.size(); i += 1) {
            var value = expr.values.get(i)
            value.expectedType = arrayOf

            if(!this.resolveExpr(value)) {
                success = false
                continue
            }

            if(value.operand.typeInfo) {
                success = this.checkTypeCompatibility(value.startPos, arrayOf, value.operand.typeInfo) && success

                // don't allow for trait casting on rvalues (i.e., prevents &4)
                if(IsTrait(arrayOf) && value.operand.isRightValue) {
                    this.errorRvalueAssignmentToTrait(value, value.operand.typeInfo, arrayOf)
                    success = false
                }
            }
        }
        return success
    }

    return true
}

func (this: *TypeChecker) resolveBinaryExpr(expr: *BinaryExpr) : bool {
    assert(expr != null)

    var errors = this.errors()

    if(!this.resolveExpr(expr.left)) {
        goto err;
    }

    if(!this.resolveExpr(expr.right)) {
        goto err;
    }

    var leftType = expr.left.operand.typeInfo
    var rightType = expr.right.operand.typeInfo

    var targetType = (leftType.typeid > rightType.typeid) ? leftType : rightType

    switch(expr.operator) {
        case TokenType.EQUALS: {
            expr.right = this.coerceTypeWithUsing(expr.right, rightType, leftType)
            rightType = expr.right.operand.typeInfo

            this.checkConstant(expr.left)
            this.checkAssignability(expr.right.startPos, leftType, rightType)
            this.checkRightValue(expr.left)
            break;
        }
        case TokenType.BAND_EQ:
        case TokenType.BNOT_EQ:
        case TokenType.BOR_EQ:
        case TokenType.XOR_EQ:
        case TokenType.LSHIFT_EQ:
        case TokenType.RSHIFT_EQ:
            this.checkConstant(expr.left)
            this.checkAssignability(expr.right.startPos, leftType, rightType)
            this.checkRightValue(expr.left)
            // fallthru
        case TokenType.BAND:
        case TokenType.BNOT:
        case TokenType.BOR:
        case TokenType.XOR:
        case TokenType.LSHIFT:
        case TokenType.RSHIFT: {
            if(!IsInteger(leftType)) {
                this.errorOperand(expr.left, leftType, "left")
            }

            if(!IsInteger(rightType)) {
                this.errorOperand(expr.right, rightType, "right")
            }
            break;
        }
        case TokenType.AND:
        case TokenType.OR: {
            this.checkTruthyness(expr.left, leftType)
            this.checkTruthyness(expr.right, rightType)
            targetType = &BOOL_TYPE
            break;
        }
        case TokenType.EQUALS_EQUALS:
        case TokenType.NOT_EQUALS: {
            this.checkTruthyness(expr.left, leftType)
            this.checkTruthyness(expr.right, rightType)
            targetType = &BOOL_TYPE
            break;
        }
        case TokenType.GREATER_EQUALS:
        case TokenType.GREATER_THAN:
        case TokenType.LESS_EQUALS:
        case TokenType.LESS_THAN: {
            if(!IsNumberLike(leftType)) {
                this.errorOperand(expr.left, leftType, "left")
            }

            if(!IsNumberLike(rightType)) {
                this.errorOperand(expr.right, rightType, "right")
            }
            targetType = &BOOL_TYPE;
            break;
        }
        case TokenType.MINUS_EQ:
        case TokenType.PLUS_EQ:
        case TokenType.MOD_EQ:
        case TokenType.MUL_EQ:
        case TokenType.DIV_EQ:
            this.checkConstant(expr.left)
            this.checkAssignability(expr.right.startPos, leftType, rightType)
            // fallthru
        case TokenType.MINUS:
        case TokenType.PLUS:
        case TokenType.MOD:
        case TokenType.STAR:
        case TokenType.SLASH: {
            if(!IsNumberLike(leftType)) {
                this.errorOperand(expr.left, leftType, "left")
            }

            if(!IsNumberLike(rightType)) {
                this.errorOperand(expr.right, rightType, "right")
            }
            break;
        }
        default: {
            assert(false)
        }
    }

    expr.operand.typeInfo = targetType
    expr.operand.isConst = expr.left.operand.isConst &&
                           expr.right.operand.isConst
    expr.operand.isRightValue = true

    return this.errors() == errors

err:
    return false
}

func (this: *TypeChecker) errorRvalueAssignmentToTrait(expr: *Expr, type: *TypeInfo, typeTrait: *TypeInfo) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.appendStr("invalid trait assignment from rvalue of type '")
    type.toString(sb)
    sb.appendStr("' to trait type '")
    typeTrait.toString(sb)
    sb.appendStrn("'", 1)

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorNonIndexableType(expr: *Expr, type: *TypeInfo) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.appendStr("invalid index into '")
    type.toString(sb)
    sb.appendStrn("'", 1)

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorSetIndexingConstType(expr: *Expr, type: *TypeInfo) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.appendStr("invalid read-only assignment to '")
    type.toString(sb)
    sb.appendStrn("'", 1)

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorIndexType(expr: *Expr, type: *TypeInfo) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.appendStrn("'", 1)
    type.toString(sb)
    sb.appendStrn("'", 1)
    sb.appendStr(" invalid index value")

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorNonAggregateType(expr: *Expr, type: *TypeInfo) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.appendStrn("'", 1)
    type.toString(sb)
    sb.appendStrn("'", 1)
    sb.appendStr(" must be an aggregate type")

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorNonFuncType(expr: *Expr, type: *TypeInfo) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.appendStrn("'", 1)
    type.toString(sb)
    sb.appendStrn("'", 1)
    sb.appendStr(" must be function type")

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorOperand(expr: *Expr, type: *TypeInfo, side: *const char) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.append("illegal, %s operand has type '", side)
    type.toString(sb)
    sb.appendStrn("'", 1)

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorEnumFieldSet(expr: *Expr, type: *TypeInfo, field: InternedString) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.appendStr("can't reassign enum '")
    type.toString(sb)
    sb.append("' field '%.*s'", field.length, field.buffer)

    this.result.addErrorStr(expr.startPos, sb)
}

public func (this: *TypeChecker) errorNoField(expr: *Expr, type: *TypeInfo, field: InternedString) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.appendStrn("'", 1)
    type.toString(sb)
    sb.appendStrn("'", 1)
    sb.append(" does not have field '%.*s'", field.length, field.buffer)

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorNoFieldAt(expr: *Expr, type: *TypeInfo, position: i32) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.appendStrn("'", 1)
    type.toString(sb)
    sb.appendStrn("'", 1)
    sb.append(" does not have a field at index '%d'", position)

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorNoFieldAccess(expr: *Expr, type: *TypeInfo, field: InternedString) {
    assert(expr != null)
    assert(type != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.appendStrn("'", 1)
    type.toString(sb)
    sb.appendStrn("'", 1)
    sb.append(" can't be accessed with field '%.*s'", field.length, field.buffer)

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorInferGenericParameter(expr: *Expr, param: *GenericParam) {
    assert(expr != null)
    assert(param != null)
    this.result.addError(expr.startPos, "unable to infer generic parameter '%.*s'", param.name.str.length, param.name.str.buffer)
}

func (this: *TypeChecker) errorInferGenericParameters(expr: *Expr, params: *Array<GenericParam>) {
    assert(expr != null)
    assert(params != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.appendStr("unable to infer generic parameters [")
    for(var i = 0; i < params.size(); i += 1) {
        if(i > 0) {
            sb.appendStrn(", ", 2)
        }
        var p = params.get(i)
        sb.append("'%.*s'", p.name.str.length, p.name.str.buffer)
    }
    sb.appendStrn("]", 1)
    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorMissingGenericArguments(expr: *Expr, typeName: InternedString, genericParams: *Array<GenericParam>) {
    assert(expr != null)
    assert(genericParams != null)

    var sb = StringBufferInit(256, this.allocator)
    sb.append("'%.*s' is missing generic arguments [", typeName.length, typeName.buffer)
    for(var i = 0; i < genericParams.size(); i += 1) {
        var param = genericParams.get(i)
        if(i > 0) {
            sb.appendStrn(", ", 1)
        }
        sb.append("'%.*s'", param.name.str.length, param.name.str.buffer)
    }
    sb.appendStrn("]", 1)

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorFixedArgumentAfterNamed(arg: *Expr) {
    assert(arg != null)

    var sb = StringBufferInit(128, this.allocator)
    sb.appendStr("Named argument specifications must appear after all fixed arguments have been specified")

    this.result.addErrorStr(arg.startPos, sb)
}


func (this: *TypeChecker) errorNamedArgumentsForFuncPtr(expr: *Expr) {
    assert(expr != null)

    var sb = StringBufferInit(128, this.allocator)
    sb.appendStr("Named arguments are not allowed on function pointers")

    this.result.addErrorStr(expr.startPos, sb)
}

func (this: *TypeChecker) errorInvalidNamedArgument(pos: SrcPos, name: *InternedString, funcInfo: *TypeInfo) {
    var sb = StringBufferInit(256, this.allocator)
    sb.append("Invalid named parameter: '%.*s'; no parameter with that name found in 'func %.*s(",
        name.length, name.buffer, funcInfo.name.length, funcInfo.name.buffer)

    for(var i = 0; i < funcInfo.funcDecl.params.size(); i+=1) {
        var param = funcInfo.funcDecl.params.get(i)
        if(i > 0) {
            sb.append(", ")
        }
        sb.append("%.*s: ", param.name.str.length, param.name.str.buffer)
        if(param.typeInfo) {
            param.typeInfo.toString(sb)
        }
    }

    sb.append(")'")

    this.result.addErrorStr(pos, sb)
}

func (this: *TypeChecker) checkConstant(expr: *Expr) : bool {
    assert(expr != null)

    var sym: *Symbol = null
    if(expr.kind == StmtKind.IDENTIFIER_EXPR) {
        var idExpr = expr as (*IdentifierExpr)
        sym = idExpr.sym

        if(sym && (sym.flags & SymbolFlags.IS_TYPE)) {
            this.result.addError(expr.startPos, "can't reassign type '%.*s'", sym.name.length, sym.name.buffer)
            return false
        }
    }

    if(!sym) {
        if(!expr.operand.typeInfo) {
            this.result.addError(expr.startPos, "no type information")
            return false;
        }

        // this isn't a type with a symbol, example: (*data); pointer types
        // don't have a symbol
        sym = expr.operand.typeInfo.sym
        if(!sym) {
            return true;
        }
    }

    if(sym.flags & SymbolFlags.IS_CONSTANT) {
        this.result.addError(expr.startPos, "can't reassign constant variable '%.*s'", sym.name.length, sym.name.buffer)
        return false
    }

    return true
}

func (this: *TypeChecker) checkTruthyness(expr: *Expr, type: *TypeInfo) : bool {
    assert(expr != null)
    assert(type != null)

    if(!IsBooleanable(type)) {
        var sb = StringBufferInit(256, this.allocator)
        sb.appendStrn("'", 1)
        type.toString(sb)
        sb.appendStr("' can't be coerced to boolean")

        this.result.addErrorStr(expr.startPos, sb)
        return false
    }
    return true
}

func (this: *TypeChecker) checkRightValue(expr: *Expr) : bool {
    assert(expr != null)
    if(expr.operand.isRightValue) {
        this.result.addError(expr.startPos, "rvalue can't be assigned to")
        return false
    }
    return true
}

func (this: *TypeChecker) resolveIdentiferExpr(expr: *IdentifierExpr) : bool {
    assert(expr != null)

    var sym = this.currentScope().lookup(expr.type.name)
    if(!sym) {
        sym = this.currentScope().lookupFunc(expr.type.name)
        if(!sym) {
            this.result.addError(expr.startPos, "unknown variable '%.*s'", expr.type.name.length, expr.type.name.buffer)
            return false
        }
    }

    // Account for Type Expressions such as sizeof(Array<i32>) which should
    // really be sizeof(:Array<i32>)  ...Do we still want to support the former
    // syntax?
    var typeInfo: *TypeInfo = sym.type
    if(sym.flags & SymbolFlags.IS_GENERIC_TEMPLATE && !expr.type.genericArgs.empty()) {
        typeInfo = this.resolveTypeSpec(expr.type)
        if(!typeInfo || typeInfo == &POISON_TYPE) {
            this.result.addError(expr.startPos, "unknown type '%s'", expr.type.name)
            return false
        }
        sym = typeInfo.sym
    }

    expr.sym = sym
    expr.operand.typeInfo = typeInfo

    if(!expr.operand.typeInfo) {
        this.result.addError(expr.startPos, "unknown type or variable '%.*s'", expr.type.name.length, expr.type.name.buffer)
        return false
    }

    this.lita.references.addSymbolReference(sym, expr.startPos)

    // if we are able to determine the constant of this symbol,
    // make sure this expression contains the constant
    if(sym.flags & SymbolFlags.IS_CONSTANT) {
        expr.operand.isConst = true
        expr.operand.val = sym.val
    }

    return true;
}