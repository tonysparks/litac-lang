import "std/libc"
import "std/mem"
import "std/mem/linear_allocator"
import "std/io"
import "std/cmdline"
import "std/system"
import "std/array"
import "std/map"
import "std/string"
import "std/string_view"
import "std/string_buffer"
import "std/profile"
import "std/http"

import "lex"
import "lita"
import "types"
import "ast"
import "ast_new"
import "ast_print"
import "parser"
import "phase_result"
import "error_codes"
import "module"
import "checker"
import "cgen"
import "lsp"
import "intern"
import "build"

import "pkg_mgr"

import "config"

func main(len: i32, args: **char) : i32 {
    var startTime = SystemTimeMSec()

    var options = new<LitaOptions>()
    memset(options, 0, sizeof(:LitaOptions))
    defer defaultAllocator.free(options)

    var status = ParseArgs(len, args, options)
    if(status != ParseStatus.OK) {
        return ParseStatus.TERMINATE == status ? 0 : -1;
    }

    if(options.pkgOptions.pkgCmd != PkgCommand.PKG_NONE) {
        return HandlePkgCommand(options)
    }

    var lita = Lita{}
    lita.init(options)
    defer lita.free()

    if(options.languageServer) {
        var server = LspServer{}
        server.init(&lita)
        defer server.free()

        server.start()

        return 0;
    }

    var root = lita.parse()
    if(!root) {
        goto report
    }

    if(!lita.typeCheck(root)) {
        goto report
    }

    if(options.checkerOnly) {
        goto report;
    }

    if(!lita.transpile(root)) {
        goto report;
    }

    var runProgram = options.run

report:
    var totalTime = SystemTimeMSec() - startTime

    var sb = StringBufferInit(1024)
    defer sb.free()

    if(!lita.result.errors.empty()) {
        for(var i = 0; i < lita.result.errors.size(); i += 1) {
            PrintError(sb, lita.result.errors.get(i))

            printf("%s\n", sb.cStr())
            sb.clear()
        }
        printf("Total errors: %d\n", lita.result.errors.size())
    }

    if(options.showProfileInfo) {
        var allocator: *LinearAllocator = lita.allocator as (*LinearAllocator)

        printf("\n\n")
        printf("%-30s %-17s %-6s %-14s %-5s\n", "Segment", "Time", "%", "Mem", "#")
        printf("====================================================================================\n")
        for(var i = 0; i < MetricType.MAX_METRIC_TYPES; i+=1) {
            var metric = &lita.metrics[i]
            printf("%-30s %-15.6f   %3.0f%% %-14zu %-5u\n",
                MetricTypeAsStr(i),
                metric.executionTime,
                (metric.executionTime / totalTime) * 100f,
                metric.bytesAllocated,
                metric.allocationCount)
        }
        printf("\n")
        printf("Total time:         %f\n", totalTime)
        printf("Total memory:       %zu\n", allocator.totalBytesAllocated)
        printf("Total allocations:  %u\n", allocator.totalAllocations)
        printf("Total source lines: %u\n", lita.totalSourceLines)
        printf("\n")
    }


    if(runProgram) {
        /*
        var m = lita.getModule("src/main.lita")
        lita.incrementalBuild(m)
        lita.incrementalBuild(m)

        if(!lita.result.errors.empty()) {
            for(var i = 0; i < lita.result.errors.size(); i += 1) {
                PrintError(sb, lita.result.errors.get(i))

                printf("%s\n", sb.cStr())
                sb.clear()
            }
            printf("Total errors: %d\n", lita.result.errors.size())
        }*/
        return lita.run()
    }

    return 0
}

enum ParseStatus {
    OK,
    ERROR,
    TERMINATE,
}

func ParseArgs(n: i32, args: **char, options: *LitaOptions) : ParseStatus {
    var parser = CmdParserInit()
    defer parser.free()

    parser.header = "<usage> litac [options] [source file to compile]\nOPTIONS:";
    parser.addOption("languageServer", '\0', "Start the LitaC language server", 0, null);
    parser.addOption("lib",            '\0', "The LitaC library path", OptionFlag.HAS_ARGUMENT, null);
    parser.addOption("cPrefx",         '\0', "The symbol prefix to use on the generated C code output", OptionFlag.HAS_ARGUMENT, null);
    parser.addOption("cFormat",        '\0', "Formats the C output", 0, null);
    parser.addOption("run",            '\0', "Runs the program after a successful compile", 0, null);
    parser.addOption("checkerOnly",    '\0', "Only runs the type checker, does not compile", 0, null);
    parser.addOption("cOnly",          '\0', "Only creates the C output file, does not cimple the generated C code", 0, null);
    parser.addOption("profile",        '\0', "Reports profile metrics of the compiler", 0, null);
    parser.addOption("disableLine",    '\0', "Disables #line dorective in C output", 0, null);
    parser.addOption("debug",          '\0', "Enables debug mode", 0, null);
    parser.addOption("verbose",        '\0', "Enables verbose output", 0, null);
    parser.addOption("instrument",     '\0', "Enables profile instrumentation of @profile annotated functions", 0, null);
    parser.addOption("srcDir",         '\0', "Specifies the source code directory, defaults to the parent folder of the supplied source file", OptionFlag.HAS_ARGUMENT, null);
    parser.addOption("doc",            '\0', "Generates document output", 0, null);
    parser.addOption("docDir",         '\0', "Directory where the generated documents are written to, defaults to './output'", OptionFlag.HAS_ARGUMENT, null);
    parser.addOption("docAll",         '\0', "Includes non-public types in the documentation generation", 0, null);
    parser.addOption("output",         'o', "The name of the compiled binary", OptionFlag.HAS_ARGUMENT, null);
    parser.addOption("outputDir",      '\0', "The directory in which the C ouput files are stored", OptionFlag.HAS_ARGUMENT, null);
    parser.addOption("version",        'v', "Displays the LitaC version", 0, null);
    parser.addOption("help",           'h', "Displays this help", 0, null);
    parser.addOption("types",          't', "Includes TypeInfo for reflection\n<arg> can be:\nall       Means all types will have reflection values\ntagged    Means only basic types and types annotated with @typeinfo will have reflection values", OptionFlag.HAS_ARGUMENT, null);
    parser.addOption("test",           '\0', "Runs functions annotated with @test\n<arg> is a regex of which tests should be run", OptionFlag.HAS_ARGUMENT, null);
    parser.addOption("testFile",       '\0', "Runs functions annotated with @test in the suppplied source file only", 0, null);
    parser.addOption("pkg-install",    '\0', "Scans for a pkg.json file and downloads and installs LitaC packages defined in the `dependencies` section.\nIf successful, creates a build.json which is used for building this LitaC project.", 0, null);
    parser.addOption("force",          '\0', "Forces a full clean install of all packages.  Must be ran with `pkg-install` option, otherwise will be ignored.", 0, null);
    parser.addOption("pkg-run",        '\0', "Runs a script defined in the `commands` section in this projects `pkg.json`.  The argument passed of this option is used to run the `commands.{option}` command", OptionFlag.HAS_ARGUMENT, null);
    parser.addOption("proxy",          '\0', "Defines a proxy server to use when making network calls.  Ex. -proxy https://proxy.com:443", OptionFlag.HAS_ARGUMENT, null);
    parser.addOption("buildCmd",       'b',  "The underlying C compiler build and compile command.  Variables will be substituted if found:\n%output%\tThe executable name\n%input%\tThe file(s) generated.\n%options%\tThe generated @compiler_option's if -strict option is enabled. \nOtherwise, the LitaC compiler will append any @compiler_option flags to this command.", OptionFlag.HAS_ARGUMENT, null);
    parser.addOption("strict",         '\0', "The LitaC compiler will not modify the `buildCmd` option (for applying @compiler_option), instead it will store the generated @compiler_options in the %options% substitution variable.", 0, null);
    parser.addOption("tcc",            '\0', "Use tcc to compile.  This ignores buildCmd/strictBuildCmd", 0, null);
    parser.addOption("maxMemory",      '\0', "The max amount of memory allowed for allocation. NOTE: This is a temporary option", OptionFlag.HAS_ARGUMENT, null);


    if(parser.parse(n, args) != CmdParserStatus.OK) {
        goto err_print;
    }


    if(parser.hasOption("version")) {
        printf("Version: %s\n", LITA_VERSION)
        goto terminate;
    }

    if(parser.hasOption("help")) {
        {
            var sb = StringBufferInit()
            defer sb.free()

            parser.printHelp(sb)
            printf("%s\n", sb.cStr())
        }
        goto terminate;
    }

    options.pkgOptions.pkgCmd = PkgCommand.PKG_NONE
    if(parser.hasOption("pkg-install")) {
        options.pkgOptions.pkgCmd = PkgCommand.PKG_INSTALL
        options.pkgOptions.forceClean = parser.hasOption("force")
    }

    if(parser.hasOption("pkg-run")) {
        options.pkgOptions.pkgCmd = PkgCommand.PKG_RUN
        options.pkgOptions.pkgRunCmdArg = parser.getOption("pkg-run").value
    }

    options.languageServer = parser.hasOption("languageServer")
    if(!options.languageServer && options.pkgOptions.pkgCmd == PkgCommand.PKG_NONE) {
        if(parser.args.size() < 2) {
            printf("Missing input file\n")
            goto err;
        }

        GetAbsolutePath(CurrentWorkingPath(), parser.args.get(1), options.inputFile)
    }

    var lib:*const char = GetEnv("LITAC_HOME")
    if(!lib) lib = LITAC_HOME_DEFAULT;

    GetAbsolutePath("", lib, options.litaPath)

    options.checkerOnly = parser.hasOption("checkerOnly")
    options.cOutputOnly = parser.hasOption("cOnly")
    options.showProfileInfo = parser.hasOption("profile")
    options.run = parser.hasOption("run")
    options.isDebug = parser.hasOption("debug")
    options.cFormat = parser.hasOption("cFormat")
    options.instrument = parser.hasOption("instrument")
    options.disableLineSync = parser.hasOption("disableLine")
    options.isVerbose = parser.hasOption("verbose")
    options.isTcc = parser.hasOption("tcc")
    options.isStrict = parser.hasOption("strict")

    if(parser.hasOption("maxMemory")) {
        var memoryStr = parser.getOption("maxMemory").value
        var view = StringViewInit(memoryStr)

        options.maxMemory = strtol(memoryStr, null, 10)
        if(view.indexOf("GB") > -1 || view.indexOf("GiB") > -1 ||
           view.indexOf("gb") > -1 || view.indexOf("gib") > -1) {
            options.maxMemory *= GiB
        }
        else if(view.indexOf("MB") > -1 || view.indexOf("MiB") > -1 ||
           view.indexOf("mb") > -1 || view.indexOf("mib") > -1) {
            options.maxMemory *= MiB
        }
        else if(view.indexOf("KB") > -1 || view.indexOf("KiB") > -1 ||
           view.indexOf("kb") > -1 || view.indexOf("kib") > -1) {
            options.maxMemory *= KiB
        }
    }
    else {
        options.maxMemory = 300 * MiB
    }

    options.typeOption = TypeInfoOption.NONE
    if(parser.hasOption("types")) {
        var opt = parser.getOption("types").value
        if(strcmp(opt, "all") == 0) {
            options.typeOption = TypeInfoOption.ALL
        }
        else if(strcmp(opt, "tagged") == 0) {
            options.typeOption = TypeInfoOption.TAGGED
        }
    }

    if(parser.hasOption("test")) {
        options.testsRegex = parser.getOption("test").value
        options.testsOnly = true
    }

    if(parser.hasOption("testFile")) {
        options.testFileOnly = true
        options.testsOnly = true
    }

    if(parser.hasOption("proxy")) {
        options.proxy = parser.getOption("proxy").value
    }

    if(parser.hasOption("buildCmd")) {
        options.compileCmd = parser.getOption("buildCmd").value
    }
    else {
        options.compileCmd = BUILD_CMD_DEFAULT;
    }

    var cPrefix = parser.hasOption("cPrefix") ? parser.getOption("cPrefix").value : "litaC_"
    StringCopy(.src = cPrefix, .dest = options.cPrefix, .size = MAX_PREFIX_SIZE)

    var outputFile = parser.hasOption("output") ? parser.getOption("output").value : OUTPUT_NAME_DEFAULT
    StringCopy(.src = outputFile, .dest = options.outputFile, .size = MAX_PATH)

    var outputPath = parser.hasOption("outputDir") ? parser.getOption("outputDir").value : OUTPUT_DIR_DEFAULT
    StringCopy(.src = outputPath, .dest = options.outputPath, .size = MAX_PATH)

    var len = strlen(options.outputPath)
    if(len > 0) {
        if(options.outputPath[len-1] != '/') {
            strcat(options.outputPath, "/")
        }

        var output = [MAX_PATH]char{0}
        GetAbsolutePath(CurrentWorkingPath(), options.outputPath, output)
        StringCopy(.src = output, .dest = options.outputPath, .size = MAX_PATH)
    }

    if(parser.hasOption("srcDir")) {
        StringCopy(.src = parser.getOption("srcDir").value, .dest = options.srcPath, .size = MAX_PATH)
    }

    if(strnlen(options.srcPath, MAX_PATH) == 0) {
        var path = StringViewInit(options.inputFile, MAX_PATH)
        var index = path.lastIndexOfAt("/src/", .len = 5)
        if(index > -1) {
            StringCopy(.src = options.inputFile, .dest = options.srcPath, .size = index + 5)
        }
        else {
            FileParent(options.inputFile, options.srcPath)
        }
    }

    // if there is no source path
    if(strnlen(options.srcPath, MAX_PATH) > 0) {
        FileParent(options.srcPath, options.projectPath)
    }
    else {
        StringCopy(.src = CurrentWorkingPath(), .dest = options.projectPath, .size = MAX_PATH)
    }

    if(strlen(options.projectPath) == 0) {
        StringCopy(.src = ".", .dest = options.projectPath, .size = 2)
    }

    return ParseStatus.OK

terminate:
    return ParseStatus.TERMINATE

err_print:
    {
        var sb = StringBufferInit()
        defer sb.free()

        parser.printHelp(sb)
        printf("%s", sb.cStr())
    }
err:
    return ParseStatus.ERROR
}


func HandlePkgCommand(options: *LitaOptions) : i32 {
    var size: usize = options.maxMemory > 0
        ? options.maxMemory
        : 1024 * 1024 * 1024;

    var linearAllocator = LinearAllocator{}
    linearAllocator.init(defaultAllocator.alloc(size), size)
    defer defaultAllocator.free(linearAllocator.mem)

    var pm = PackageManager{};
    pm.init(PackageSyncOptions{
        .projectPath = options.projectPath,
        .fullSync = options.pkgOptions.forceClean,
        .httpOptions = HttpOptions {
            .proxy = options.proxy,
        }
    }, linearAllocator.allocator)
    defer pm.free()

    switch(options.pkgOptions.pkgCmd) {
        case PkgCommand.PKG_INSTALL: {
            return RunPkgInstall(options, &pm)
        }
        case PkgCommand.PKG_RUN: {
            return RunPkgCommand(options, &pm)
        }
        default:
            return 0;
    }

    return 0;
}

func RunPkgInstall(options: *LitaOptions, pm: *PackageManager) : i32 {
    var status = pm.install()
    if(status != PkgStatus.OK) {
        printf("Error installing packages:\nErrorCode: %s - %s\n",
            PkgStatusAsStr(status), pm.errors.cStr())
        return 1;
    }

    var buildFile = BuildFile{}
    defer buildFile.free()

    status = pm.createBuildFile(&buildFile)
    if(status != PkgStatus.OK) {
        printf("Error creating build.json:\nErrorCode: %s - %s\n",
            PkgStatusAsStr(status), pm.errors.cStr())
        return 1;
    }

    var temp: [MAX_PATH]char;
    var build = StringInit(temp, MAX_PATH, 0)
    build.format("%s/.build.json", options.projectPath)

    var file = File{}
    file.open(build.cStr(), FileOpenOp.WRITE)

    printf("Writing '%s'.\n", build.cStr())
    if(!buildFile.writeTo(&file)) {
        printf("Error writing out build.json\n")
        return 1;
    }

    printf("Success.\n")
    return 0;
}

func RunPkgCommand(options: *LitaOptions, pm: *PackageManager) : i32 {
    var status = pm.runCommand(options.pkgOptions.pkgRunCmdArg)
    if(status != PkgStatus.OK) {
        printf("Error running pkg command:\nErrorCode: %s - %s\n",
            PkgStatusAsStr(status), pm.errors.cStr())
        return 1;
    }
    return 0;
}
