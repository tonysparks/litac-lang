import "std/libc"
import "std/mem"
import "std/mem/bucket_allocator"
import "std/mem/linear_allocator"
import "std/io"
import "std/cmdline"
import "std/system"
import "std/array"
import "std/map"
import "std/hash"
import "std/string/buffer"
import "std/string"
import "std/string/builder"
import "std/profile"
import "std/http"
import "std/assert"

import "lex"
import "lita"
import "types"
import "ast"
import "ast_new"
import "ast_print"
import "parser"
import "phase_result"
import "error_codes"
import "module"
import "checker"
import "cgen"
import "lsp"
import "intern"
import "build"
import "config"
import "pkg_mgr"


func main(len: i32, args: **char) : i32 {
    var options = new<LitaOptions>()
    memset(options, 0, sizeof(:LitaOptions))
    defer defaultAllocator.free(options)

    var status = ParseArgs(len, args, options)
    if(status != ParseStatus.OK) {
        return ParseStatus.TERMINATE == status ? 0 : -1;
    }

    if(options.pkgOptions.pkgCmd != PkgCommand.PKG_NONE) {
        return HandlePkgCommand(options)
    }

    return RunLitac(options)
}

public func RunLitac(options: *LitaOptions) : i32 {
    var startTime = SystemTimeMSec()

    var lita = Lita{}
    lita.init(options)
    defer lita.free()

    if(options.languageServer) {
        var server = LspServer{}
        server.init(&lita)
        defer server.free()

        server.start()

        return 0;
    }

    var hasError = false

    var root = lita.parse()
    if(!root) {
        hasError = true
        goto report
    }

    if(!lita.typeCheck(root)) {
        hasError = true
        goto report
    }

    if(options.checkerOnly) {
        goto report;
    }

    if(!lita.transpile(root)) {
        hasError = true
        goto report;
    }

    var runProgram = options.run

report:
    var totalTime = SystemTimeMSec() - startTime

    var sb = StringBuilderInit(1024)
    defer sb.free()

    hasError = hasError || !lita.result.errors.empty()
    if(hasError) {
        for(var i = 0; i < lita.result.errors.size(); i += 1) {
            PrintError(lita.options.isColoredOutput, sb, lita.result.errors.get(i))

            printf("%s\n", sb.cStr())
            sb.clear()
        }
        printf("Total errors: %d\n", lita.result.errors.size())
    }

    if(options.showProfileInfo) {
        var allocator: *BucketAllocator = lita.allocator as (*BucketAllocator)

        printf("\n\n")
        printf("%-30s %-17s %-6s %-14s %-5s\n", "Segment", "Time", "%", "Mem", "#")
        printf("====================================================================================\n")
        for(var i = 0; i < MetricType.MAX_METRIC_TYPES; i+=1) {
            var metric = &lita.metrics[i]
            printf("%-30s %-15.6f   %3.0f%% %-14zu %-5u\n",
                MetricTypeAsStr(i),
                metric.executionTime,
                (metric.executionTime / totalTime) * 100f,
                metric.bytesAllocated,
                metric.allocationCount)
        }
        printf("\n")
        printf("Total time:         %f\n", totalTime)
        printf("Total memory:       %zu\n", allocator.totalBytesAllocated)
        printf("Total allocations:  %u\n", allocator.totalAllocations)
        printf("Total source lines: %u\n", lita.totalSourceLines)
        printf("\n")
    }


    if(runProgram) {
        return lita.run()
    }

    return hasError ? 1 : 0
}

public enum ParseStatus {
    OK,
    ERROR,
    TERMINATE,
}

public func ParseArgs(n: i32, args: **char, options: *LitaOptions) : ParseStatus {
    var parser = CmdParserInit()
    defer parser.free()

    parser.header = "<usage> litac [options] [source file to compile]\nOPTIONS:";

    parser.addCommand("build", "Builds the LitaC package")
        .addOption("run",            '\0', "Runs the program after a successful compile", 0, null)
        .addOption("lib",            '\0', "The LitaC library path", OptionFlag.HAS_ARGUMENT, null)
        .addOption("profile",        '\0', "Reports profile metrics of the compiler", 0, null)
        .addOption("disableLine",    '\0', "Disables #line dorective in C output", 0, null)
        .addOption("instrument",     '\0', "Enables profile instrumentation of @profile annotated functions", 0, null)
        .addOption("srcDir",         '\0', "Specifies the source code directory, defaults to the parent folder of the supplied source file", OptionFlag.HAS_ARGUMENT, null)
        .addOption("output",         'o', "The name of the compiled binary", OptionFlag.HAS_ARGUMENT, null)
        .addOption("outputDir",      '\0', "The directory in which the C ouput files are stored", OptionFlag.HAS_ARGUMENT, null)
        .addOption("types",          't', "Includes TypeInfo for reflection\n<arg> can be:\nall       Means all types will have reflection values\ntagged    Means only basic types and types annotated with @typeinfo will have reflection values", OptionFlag.HAS_ARGUMENT, null)
        .addOption("debug",          '\0', "Enables debug mode", 0, null)
        .addOption("release",        '\0', "Marks builds in release mode", 0, null)
        .addOption("buildCmd",       'b',  "The underlying C compiler build and compile command.  Variables will be substituted if found:\n%output%\tThe executable name\n%input%\tThe file(s) generated.\n%options%\tThe generated @compiler_option's if -strict option is enabled. \nOtherwise, the LitaC compiler will append any @compiler_option flags to this command.", OptionFlag.HAS_ARGUMENT, null)
        .addOption("strict",         '\0', "The LitaC compiler will not modify the `buildCmd` option (for applying @compiler_option), instead it will store the generated @compiler_options in the %options% substitution variable.", 0, null)
        .addOption("tcc",            '\0', "Use tcc to compile.  This ignores buildCmd/strictBuildCmd", 0, null)
        .addOption("checkerOnly",    '\0', "Only runs the type checker, does not compile", 0, null)
        .addOption("cOnly",          '\0', "Only creates the C output file, does not cimple the generated C code", 0, null)
        .addOption("cFormat",        '\0', "Formats the C output", 0, null)
        .addOption("cPrefx",         '\0', "The symbol prefix to use on the generated C code output", OptionFlag.HAS_ARGUMENT, null)


    parser.addCommand("lsp", "Start the LitaC language server")

    parser.addCommand("doc", "Generates document output")
        .addOption("docDir",         '\0', "Directory where the generated documents are written to, defaults to './output'", OptionFlag.HAS_ARGUMENT, null)
        .addOption("all",            '\0', "Includes non-public types in the documentation generation", 0, null)

    parser.addCommand("test", "Recursively scan for *_test.lita files and run each. Optionally pass a directory to scan (default: current directory).")
        .addOption("file",           '\0', "Runs functions annotated with @test in the supplied source file only", OptionFlag.HAS_ARGUMENT, null)
        .addOption("package",        '\0', "Runs functions annotated with @test in the supplied source package only", OptionFlag.HAS_ARGUMENT, null)
        .addOption("regex",          '\0', "Runs functions annotated with @test matching the supplied regex expression.  Can use used with -file -package or default for filtering", OptionFlag.HAS_ARGUMENT, null)
        .addOption("testDir",        '\0', "Specifies the source code test directory", OptionFlag.HAS_ARGUMENT, null)
        // build flags
        .addOption("lib",            '\0', "The LitaC library path", OptionFlag.HAS_ARGUMENT, null)
        .addOption("profile",        '\0', "Reports profile metrics of the compiler", 0, null)
        .addOption("disableLine",    '\0', "Disables #line dorective in C output", 0, null)
        .addOption("instrument",     '\0', "Enables profile instrumentation of @profile annotated functions", 0, null)
        .addOption("srcDir",         '\0', "Specifies the source code directory, defaults to the parent folder of the supplied source file", OptionFlag.HAS_ARGUMENT, null)
        .addOption("output",         'o', "The name of the compiled binary", OptionFlag.HAS_ARGUMENT, null)
        .addOption("outputDir",      '\0', "The directory in which the C ouput files are stored", OptionFlag.HAS_ARGUMENT, null)
        .addOption("types",          't', "Includes TypeInfo for reflection\n<arg> can be:\nall       Means all types will have reflection values\ntagged    Means only basic types and types annotated with @typeinfo will have reflection values", OptionFlag.HAS_ARGUMENT, null)
        .addOption("debug",          '\0', "Enables debug mode", 0, null)
        .addOption("release",        '\0', "Marks builds in release mode", 0, null)
        .addOption("buildCmd",       'b',  "The underlying C compiler build and compile command.  Variables will be substituted if found:\n%output%\tThe executable name\n%input%\tThe file(s) generated.\n%options%\tThe generated @compiler_option's if -strict option is enabled. \nOtherwise, the LitaC compiler will append any @compiler_option flags to this command.", OptionFlag.HAS_ARGUMENT, null)
        .addOption("strict",         '\0', "The LitaC compiler will not modify the `buildCmd` option (for applying @compiler_option), instead it will store the generated @compiler_options in the %options% substitution variable.", 0, null)
        .addOption("tcc",            '\0', "Use tcc to compile.  This ignores buildCmd/strictBuildCmd", 0, null)

    parser.addCommand("install", "Scans for a pkg.json file and downloads and installs LitaC packages defined in the `dependencies` section.\nIf successful, creates a build.json which is used for building this LitaC project.")
        .addOption("force",          '\0', "Forces a full clean install of all packages.", 0, null)

    parser.addCommand("command", "Runs a script defined in the `commands` section in this projects `pkg.json`.  The argument passed of this option is used to run the `commands.{option}` command", true)

    parser.addCommand("init", "Initializes a new LitaC package project, the input argument is the name of the package", true)

    // Global options
    parser.addOption("version",      'v', "Displays the LitaC version", 0, null)
    parser.addOption("help",         'h', "Displays this help", 0, null)
    parser.addOption("verbose",      '\0', "Enables verbose output", 0, null)
    parser.addOption("colors",       '\0', "Disables console colors for output", 0, null)
    parser.addOption("proxy",        '\0', "Defines a proxy server to use when making network calls.  Ex. -proxy https://proxy.com:443", OptionFlag.HAS_ARGUMENT, null)
    parser.addOption("maxMemory",    '\0', "The max amount of memory allowed for allocation. NOTE: This is a temporary option", OptionFlag.HAS_ARGUMENT, null)
    parser.addOption("--",           '\0', "Signals any arguments after are to be passed to the compile program when -run is set", 0, null)

    if(parser.parse(n, args) != CmdParserStatus.OK) {
        goto err_print;
    }

    if(parser.hasOption("version")) {
        printf("Version: %s\n", LITA_VERSION)
        goto terminate;
    }

    options.isColoredOutput = !parser.hasOption("colors")
    options.isVerbose = parser.hasOption("verbose")

    if(parser.hasOption("help")) {
        {
            var sb = StringBuilderInit()
            defer sb.free()

            parser.printHelp(sb)
            printf("%s\n", sb.cStr())
        }
        goto terminate;
    }

    if(parser.hasOption("maxMemory")) {
        var memoryStr = parser.getOption("maxMemory").value
        var view = StringInit(memoryStr)

        options.maxMemory = strtol(memoryStr, null, 10)
        if(view.indexOf($"GB") > -1 || view.indexOf($"GiB") > -1 ||
           view.indexOf($"gb") > -1 || view.indexOf($"gib") > -1) {
            options.maxMemory *= GiB
        }
        else if(view.indexOf($"MB") > -1 || view.indexOf($"MiB") > -1 ||
           view.indexOf($"mb") > -1 || view.indexOf($"mib") > -1) {
            options.maxMemory *= MiB
        }
        else if(view.indexOf($"KB") > -1 || view.indexOf($"KiB") > -1 ||
           view.indexOf($"kb") > -1 || view.indexOf($"kib") > -1) {
            options.maxMemory *= KiB
        }
    }
    else {
        options.maxMemory = 300 * MiB
    }

    if(parser.hasOption("proxy")) {
        options.proxy = parser.getOption("proxy").value
    }

    var lib:*const char = GetEnv("LITAC_HOME")
    if(!lib) lib = LITAC_HOME_DEFAULT;

    GetAbsolutePath("", lib, options.litaPath)

    options.pkgOptions.pkgCmd = PkgCommand.PKG_NONE
    if(!parser.hasCmd()) {
        if(parser.args.size() < 2) {
            goto err_print;
        }
        printf("Missing or invalid command argument\n")
        goto err;
    }

    var cmd = parser.getCmd()

    if(cmd.name.equals("build") || cmd.name.equals("test")) {
        options.pkgOptions.pkgCmd = PkgCommand.PKG_BUILD
        options.pkgOptions.isRelease = cmd.hasOption("release")

        options.checkerOnly = cmd.hasOption("checkerOnly")
        options.cOutputOnly = cmd.hasOption("cOnly")
        options.showProfileInfo = cmd.hasOption("profile")
        options.run = cmd.hasOption("run")
        options.isDebug = cmd.hasOption("debug")
        options.cFormat = cmd.hasOption("cFormat")
        options.instrument = cmd.hasOption("instrument")
        options.disableLineSync = cmd.hasOption("disableLine")
        options.isVerbose = cmd.hasOption("verbose")
        options.isTcc = cmd.hasOption("tcc")
        options.isStrict = cmd.hasOption("strict")

        options.typeOption = TypeInfoOption.NONE
        if(cmd.hasOption("types")) {
            var opt = cmd.getOption("types").value
            if(opt.equals("all")) {
                options.typeOption = TypeInfoOption.ALL
            }
            else if(opt.equals("tagged")) {
                options.typeOption = TypeInfoOption.TAGGED
            }
        }

        if(cmd.hasOption("buildCmd")) {
            options.compileCmd = cmd.getOption("buildCmd").value
        }
        else {
            options.compileCmd = BUILD_CMD_DEFAULT;
        }

        var cPrefix = cmd.hasOption("cPrefix") ? cmd.getOption("cPrefix").value : "litaC_"
        StringCopy(.src = cPrefix, .dest = options.cPrefix, .size = MAX_PREFIX_SIZE)

        var outputFile = cmd.hasOption("output") ? cmd.getOption("output").value : OUTPUT_NAME_DEFAULT
        StringCopy(.src = outputFile, .dest = options.outputFile, .size = MAX_PATH)

        var outputPath = cmd.hasOption("outputDir") ? cmd.getOption("outputDir").value : OUTPUT_DIR_DEFAULT
        StringCopy(.src = outputPath, .dest = options.outputPath, .size = MAX_PATH)

        var len = options.outputPath.length()
        if(len > 0) {
            if(options.outputPath[len-1] != '/') {
                strcat(options.outputPath, "/")
            }

            var output = [MAX_PATH]char{0}
            GetAbsolutePath(CurrentWorkingPath(), options.outputPath, output)
            StringCopy(.src = output, .dest = options.outputPath, .size = MAX_PATH)
        }

        // we optionally can provide an input file for build/test commands
        if(parser.args.size() > 1) {
            var inputFile = parser.args.get(1)

            // make sure we are not passing in program arguments
            if(!inputFile.equals("--")) {
                GetAbsolutePath(CurrentWorkingPath(), parser.args.get(1), options.inputFile)
                if(!FileExists(options.inputFile)) {
                    printf("Could not find '%s'\n", options.inputFile)
                    goto err;
                }
            }
        }

        if(cmd.hasOption("srcDir")) {
            StringCopy(.src = cmd.getOption("srcDir").value, .dest = options.srcPath, .size = MAX_PATH)
        }

        if(options.srcPath.empty()) {
            var path = StringInit(options.inputFile, MAX_PATH)
            var paths = []String {
                $"/src/",
                $"/stdlib/",
                $"/test/",
            }

            var index = -1
            for(var i = 0; i < sizeof(paths) / sizeof(paths[0]); i+=1) {
                index = path.lastIndexOfAt(paths[i])
                if(index > -1) {
                    StringCopy(
                        .src = options.inputFile,
                        .dest = options.srcPath,
                        .size = index + paths[i].length
                    )
                    break
                }
            }

            if(index < 0) {
                FileParent(options.inputFile, options.srcPath)
            }
        }

        // if there is no source path
        if(!options.srcPath.empty()) {
            FileParent(options.srcPath, options.projectPath)
        }

        if(options.projectPath.empty()) {
            StringCopy(.src = CurrentWorkingPath(), .dest = options.projectPath, .size = MAX_PATH)
            //StringCopy(.src = ".", .dest = options.projectPath, .size = 2)
        }

        if(cmd.hasOption("lib")) {
            StringCopy(.src = cmd.getOption("lib").value, .dest = options.libPath, .size = MAX_PATH)
        }

        // Handle test specific configurations
        if(cmd.name.equals("test")) {
            options.testsOnly = true

            if(cmd.hasOption("regex")) {
                options.testsRegex = cmd.getOption("regex").value
            }

            if(cmd.hasOption("file")) {
                options.testFileOnly = true
                StringCopy(
                    .src = cmd.getOption("file").value,
                    .dest = options.inputFile,
                    .size = MAX_PATH
                )
            }

            if(cmd.hasOption("package")) {
                options.testPackage = cmd.getOption("package").value
            }

            // flag to go to the test sub command
            if(!options.testFileOnly) {
                options.pkgOptions.pkgCmd = PkgCommand.PKG_TEST
            } else {
                options.run = true
            }

            if(cmd.hasOption("testDir")) {
                StringCopy(
                    .src = cmd.getOption("testDir").value,
                    .dest = options.testPath,
                    .size = MAX_PATH
                )
            }
            else {
                StringCopy(.src = "./test", .dest = options.testPath, .size = MAX_PATH)
            }
        }

        // sanitize paths
        TrimPath(options.projectPath)
        TrimPath(options.srcPath)
        TrimPath(options.libPath)
        TrimPath(options.litaPath)
        TrimPath(options.testPath)
    }
    else if(cmd.name.equals("install")) {
        options.pkgOptions.pkgCmd = PkgCommand.PKG_INSTALL
        options.pkgOptions.forceClean = cmd.hasOption("force")
    }
    else if(cmd.name.equals("command")) {
        options.pkgOptions.pkgCmd = PkgCommand.PKG_RUN
        options.pkgOptions.pkgRunCmdArg = cmd.getOption("pkg-run").value
    }
    else if(cmd.name.equals("init")) {
        options.pkgOptions.pkgCmd = PkgCommand.PKG_INIT
        if(!cmd.hasArgValue()) {
            printf("Missing project name argument.\n")
            goto err;
        }

        StringCopy(.src = CurrentWorkingPath(), .dest = options.projectPath, .size = MAX_PATH)
        options.pkgOptions.pkgName = cmd.getArgValue()
    }
    else if(cmd.name.equals("doc")) {
        // TODO
        //options.pkgOptions.pkgCmd = PkgCommand.PKG_TEST
        //options.testsOnly = true
    }
    else if(cmd.name.equals("lsp")) {
        // TODO
        options.languageServer = true
    }
    else {
        // We forgot to implement something!
        assert(false)
    }

    // determine if we need to collect arguments
    if(options.run || options.pkgOptions.pkgCmd == PkgCommand.PKG_RUN) {
        for(var i = 0; i < n; i+=1) {
            var arg = args[i]
            if("--".equals(arg)) {
                i += 1
                options.args = (args + i)
                options.nargs = n - i
                break;
            }
        }
    }

    return ParseStatus.OK

terminate:
    return ParseStatus.TERMINATE

err_print:
    {
        var sb = StringBuilderInit()
        defer sb.free()

        parser.printErrors(sb)
        sb.append("\n\n")
        parser.printHelp(sb)
        printf("%s", sb.cStr())
    }
err:
    return ParseStatus.ERROR
}

func TrimPath(path: [MAX_PATH]char) {
    var len = path.length()
    if(len < 1) {
        return;
    }

    if(path[len - 1] == '/' || path[len - 1] == '\\') {
        path[len - 1] = '\0'
    }
}

func HandlePkgCommand(options: *LitaOptions) : i32 {
    var size: usize = options.maxMemory > 0
        ? options.maxMemory
        : 1024 * 1024 * 1024;

    var linearAllocator = LinearAllocator{}
    linearAllocator.init(defaultAllocator.alloc(size), size)
    defer defaultAllocator.free(linearAllocator.mem)

    var pm = PackageManager{};
    pm.init(PackageOptions{
        .projectPath = options.projectPath,
        .litaOptions = options,

    }, linearAllocator.allocator)
    defer pm.free()

    switch(options.pkgOptions.pkgCmd) {
        case PkgCommand.PKG_INSTALL: {
            return RunPkgInstall(options, &pm)
        }
        case PkgCommand.PKG_RUN: {
            return RunPkgCommand(options, &pm)
        }
        case PkgCommand.PKG_INIT: {
            return RunPkgInit(options, &pm)
        }
        case PkgCommand.PKG_BUILD: {
            return RunPkgBuild(options, &pm)
        }
        case PkgCommand.PKG_TEST: {
            return RunPkgTest(options, &pm)
        }
        default:
            return 0;
    }

    return 0;
}

func RunPkgInstall(options: *LitaOptions, pm: *PackageManager) : i32 {
    var status = pm.installCommand(PackageInstallOptions {
        .fullSync = options.pkgOptions.forceClean,
        .httpOptions = HttpOptions {
            .proxy = options.proxy,
        }
    })
    if(status != PkgStatus.OK) {
        printf("Error installing packages:\nErrorCode: %s - %s\n",
            PkgStatusAsStr(status), pm.errors.cStr())
        return 1;
    }

    var buildFile = BuildFile{}
    defer buildFile.free()

    status = pm.createBuildFile(&buildFile)
    if(status != PkgStatus.OK) {
        printf("Error creating build.json:\nErrorCode: %s - %s\n",
            PkgStatusAsStr(status), pm.errors.cStr())
        return 1;
    }

    var temp: [MAX_PATH]char;
    var build = StringBufferInit(temp, MAX_PATH, 0)
    build.format("%s/.build.json", options.projectPath)

    var file = File{}
    file.open(build.cStr(), FileOpenOp.WRITE)
    defer file.close()

    printf("Writing '%s'.\n", build.cStr())
    if(!buildFile.writeTo(&file)) {
        printf("Error writing out build.json\n")
        return 1;
    }

    printf("Success.\n")
    return 0;
}

func RunPkgCommand(options: *LitaOptions, pm: *PackageManager) : i32 {
    var status = pm.runCommand(options.pkgOptions.pkgRunCmdArg)
    if(status != PkgStatus.OK) {
        printf("Error running pkg command: '%s'\nErrorCode: %s %s\n",
            options.pkgOptions.pkgRunCmdArg,
            PkgStatusAsStr(status),
            pm.errors.cStr()
        )
        return 1;
    }
    return 0;
}


func RunPkgInit(options: *LitaOptions, pm: *PackageManager) : i32 {
    var status = pm.initCommand(PackageInitOptions {
        .name = options.pkgOptions.pkgName
    })
    if(status != PkgStatus.OK) {
        printf("Error running pkg init:\nErrorCode: %s - %s\n",
            PkgStatusAsStr(status), pm.errors.cStr()
        )
        return 1;
    }
    return 0;
}

func RunPkgBuild(options: *LitaOptions, pm: *PackageManager) : i32 {
    var status = pm.buildCommand(
        PackageBuildOptions {
            .isRelease = options.pkgOptions.isRelease
        }
    )
    if(status != PkgStatus.OK) {
        printf("Error running pkg build:\nErrorCode: %s - %s\n",
            PkgStatusAsStr(status), pm.errors.cStr()
        )
        return 1;
    }
    return 0;
}

func RunPkgTest(options: *LitaOptions, pm: *PackageManager) : i32 {
    var buildResult = RunPkgBuild(options, pm)
    if(buildResult != 0) {
        return buildResult
    }
    return pm.testCommand(options)
}
