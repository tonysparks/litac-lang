import "std/array"
import "std/mem"
import "std/map"
import "std/libc"
import "std/hash"
import "std/string"
import "std/string/builder"
import "std/string/buffer"
import "std/assert"

import "intern"
import "symbols"
import "types"

import "lita"
import "ast"
import "ast_copy"
import "ast_new"
import "parser"
import "checker"
import "lex"
import "module"
import "common"
import "coroutine"

public struct FuncLowerContext {
    allocator: *const Allocator
    strings: *Strings
    module: *Module

    funcDecl: *FuncDecl
    tempIndex: u32


    current: *BlockScope

    //stack: Map<String, InternedString>
    stack: Array<InternedString>
    scopeIndex: u32
    // numOfScopes: u32

    patches: Array<Patch>
}

struct Patch {
    stmt: *Stmt
    block: *BlockStmt
    index: u32
    name: InternedString
}


struct BlockScope {
    parent: *BlockScope
    block: *BlockStmt
    insertIndex: i32
    numberOfInserts: i32
    noTemp: bool

    locals: Array<InternedString>
}

func (this: *FuncLowerContext) setVar(name: InternedString) : InternedString {
    if (this.current.locals.capacity == 0) {
        this.current.locals = ArrayInit<InternedString>(16, this.allocator)
    }

    var buffer: [MAX_SYMBOL_NAME]char;
    var sb = StringBufferInit(buffer, MAX_SYMBOL_NAME, 0)
    sb.format("%.*s__%d", name.length, name.buffer, this.scopeIndex)

    var internedName = this.strings.internCopy(sb.cStr(), sb.length)
    this.current.locals.add(internedName)
    this.stack.add(internedName)
}

func (this: *FuncLowerContext) getVar(name: InternedString) : InternedString {
    assert(this.current != null)

    var scope = this.current
    while(scope != null) {
        for(var i = 0; i < scope.locals.size(); i+=1) {
            var localName = scope.locals.get(i)
            if (localName.view.startsWith(name.view)) {
                return localName
            }
        }

        scope = scope.parent
    }

    return InternedString{}
}

func (this: *FuncLowerContext) push(scope: *BlockScope) {
    var current = this.current
    this.current = scope
    scope.parent = current
    this.scopeIndex += 1
}
func (this: *FuncLowerContext) pop() {
    if(!this.current) return;

    var parent = this.current.parent
    this.current = parent
    // this.scopeIndex -= 1
}
func (this: *FuncLowerContext) currentBlock(): *BlockStmt {
    if(!this.current) return null;
    return this.current.block
}

func NewTempName(context: *FuncLowerContext) : StringBuilder {
    var name = StringBuilderInit(MAX_SYMBOL_NAME, context.allocator)
    name.append("__%d", context.tempIndex += 1)
    return name
}

func NewTempAssignment(context: *FuncLowerContext, expr: *Expr) : *VarDecl {
    var name = NewTempName(context)

    var tempNode = NewVarDecl(
        expr.getStartPos(),
        expr.getEndPos(),
        NewIdentifier(
            name.cStr(),
            expr.getStartPos(),
            context.strings
        ),
        null,
        expr,
        context.allocator
    )
    var temp = &tempNode.varDecl
    temp.flags |= VarDeclFlags.IS_TEMPORARY

    InsertTempStmt(context, temp, .atEnd = true)

    return temp as (*VarDecl)
}

func NewTempEmptyAssignment(
    context: *FuncLowerContext,
    expr: *Expr,
    isTernary: bool = false
) : *VarDecl {
    var name = NewTempName(context)

    var tempNode = NewVarDecl(
        expr.getStartPos(),
        expr.getEndPos(),
        NewIdentifier(
            name.cStr(),
            expr.getStartPos(),
            context.strings
        ),
        !isTernary ? expr.operand.typeInfo.asTypeSpec(
            context.module, true
        ) : null,
        null,
        context.allocator
    )

    var temp = &tempNode.varDecl
    temp.flags |= VarDeclFlags.IS_TEMPORARY

    InsertTempStmt(context, temp, .atEnd = true)
    return temp as (*VarDecl)
}

func InsertTempStmt(
    context: *FuncLowerContext,
    stmt: *Stmt,
    atEnd: bool
) {

    // TODO: This does right to left ordering of parameters
    // we probably want left to right even though this
    // isn't standard in C
    var scope = context.current
    var index = scope.insertIndex// + scope.numberOfInserts
    if(atEnd) {
        index += scope.numberOfInserts
    }
    // printf("Inserting at %d\n", index)
    scope.block.stmts.insertAt(index, stmt)
    scope.block.asNode().becomeParentOf(stmt)
    scope.numberOfInserts += 1
}

func PushBlock(
    context: *FuncLowerContext,
    scope: *BlockScope,
    stmt1: *Stmt,
    stmt2: *Stmt = null
) : *BlockStmt {
    var stmts = ArrayInit<*Stmt>(2, context.allocator)
    stmts.add(stmt1)
    if(stmt2) {
        stmts.add(stmt2)
    }

    var blockNode = NewBlockStmt(
        stmt1.getStartPos(), stmt1.getEndPos(),
        stmts,
        context.allocator
    )

    scope.block = &blockNode.blockStmt
    scope.insertIndex = 0
    scope.numberOfInserts = 0

    context.push(scope)
    return scope.block
}

/**
    Convert function call expressions into lowered expressions:

    var x = object.value(call1(), call2()) ?
    object.value1(call3(), call4()) :
    object.value2(call6(), call6())

    var x = undefined
    var _1 = call1()
    var _2 = call2()
    var _r3 = object.value(_1, _2)
    if (_r3) {
        var _3 = call3()
        var _4 = call4()
        x = object.value(_3, _4)
    } else {
        var _5 = call5()
        var _6 = call6()
        x = object.value(_5, _6)
    }
*/
func ResolveCoroutine(this: *TypeChecker, decls: Array<*Decl>) {
    this.bypassing = true
    for(var i = 0; i < decls.size(); i += 1) {
        var decl = decls.get(i)

        var sym = this.createDeclSymbol(decl)
        if(sym == null) {
            continue
        }

        this.resolveSymbol(sym)
        this.finishResolveSymbol(sym)

        printf("Resolved sym: %.*s\n", sym.name.length, sym.name.buffer)
    }
    this.bypassing = false
}

public func LowerFuncBody(checker: *TypeChecker, funcDecl: *FuncDecl) : bool {
    if(!funcDecl.body) {
        return true;
    }

// TODO:
// 1) CreateCoroutine Decls for Wrapper and CoroutineStack here,
// 2) modify the funcDecl params to pass in the coStack
// 3) finally resolve the patches


    var context = FuncLowerContext {
        .allocator = checker.allocator,
        .strings = &checker.strings,
        .module = checker.current,
        .funcDecl = funcDecl,
        .tempIndex = 0_u32,
        .current = null,
        .scopeIndex = 0_u32,
        .stack = ArrayInit<InternedString>(64, checker.allocator),
        .patches = ArrayInit<Patch>(64, checker.allocator),
    }

    //var bodyStmt: *BodyStmt = null
    if(funcDecl.body.getKind() != StmtKind.FUNC_BODY_STMT) {
        var body = funcDecl.body
        var stmts = ArrayInit<*Stmt>(1, checker.allocator)
        stmts.add(body)

        var bodyNode = NewFuncBodyStmt(
            body.getStartPos(),
            body.getEndPos(),
            stmts,
            checker.allocator
        )

        funcDecl.body = &bodyNode.asStmt
    }

    funcDecl.body = FunctionLowering(&context, funcDecl.body)

    if(!checker.resolveStmt(funcDecl.body)) {
        return false
    }

    assert(funcDecl.sym != null)
    var decls = CreateCoroutine(
        checker,
        funcDecl.sym
    )

    ResolveCoroutine(checker, decls)

    var tempName = $"__cont"

    var funcNode = funcDecl.asNode()
    var continuationParamNode = NewIdentifierExpr(
        funcNode.startPos, funcNode.endPos,
        NewNameTypeSpecIntern(
            funcNode.startPos,
            context.strings.internString(tempName),
            &checker.current.typeSpecAllocator
        ),
        context.allocator
    )

    var continuationName = context.strings.internString(tempName)

    for(var i = 0; i < context.patches.size(); i+=1) {
        var patch = context.patches.getPtr(i)
        var node = patch.stmt.asNode()

        // TODO: Get vs Set??
        node.kind = StmtKind.GET_EXPR
        node.getExpr.object = node.becomeParentOf(
            &NewIdentifierExpr(
                node.startPos, node.endPos,
                NewNameTypeSpecIntern(
                    node.startPos,
                    continuationName,
                    &checker.current.typeSpecAllocator
                ),
                context.allocator
            ).asExpr
        )
        node.getExpr.field = node.becomeParentOf(
            &NewIdentifierExpr(
                node.startPos, node.endPos,
                NewNameTypeSpecIntern(
                    node.startPos,
                    patch.name,
                    &checker.current.typeSpecAllocator
                ),
                context.allocator
            ).identifierExpr
        )
    }

    for(var i = 0; i < context.stack.size(); i+=1) {
        var e = context.stack.get(i)
        printf(
            "%.*s\n", e.length, e.buffer
        )
    }
}

func FunctionLowering(context: *FuncLowerContext, ast: *Stmt) : *Stmt {
    if(!ast) {
        return null;
    }

    switch(ast.getKind()) {
        case StmtKind.TRAIT_DECL:
        case StmtKind.UNION_DECL:
        case StmtKind.STRUCT_DECL:
        case StmtKind.FUNC_DECL:
        case StmtKind.IMPORT_DECL:
        case StmtKind.TYPEDEF_DECL:
        case StmtKind.ENUM_DECL:
        case StmtKind.PARAM_DECL:
        case StmtKind.NATIVE_DECL:
        case StmtKind.POISON_DECL: {
            break;
        }
        case StmtKind.CONST_DECL:
        case StmtKind.VAR_DECL: {
            var decl = ast as (*VarDecl)
            if(decl.expr) {
                decl.expr = FunctionLowering(context, decl.expr) as (*Expr)
            }
            if(!(decl.flags & VarDeclFlags.IS_TEMPORARY)) {
                context.patches.add(
                    Patch {
                        .stmt = decl as (*Stmt),
                        .block = context.current.block,
                        .index = context.current.insertIndex,
                        .name = context.setVar(decl.name.str),
                    }
                )
            }
            break;
        }

        case StmtKind.FUNC_BODY_STMT:
        case StmtKind.BLOCK_STMT: {
            var body = ast as (*BlockStmt)

            var scope = BlockScope {
                .block = body,
                .insertIndex = 0,
                .numberOfInserts = 0,
            }

            context.push(&scope)
            defer context.pop()

            for(var i = 0; i < body.stmts.size(); i+=1) {
                var stmt = body.stmts.get(i)
                scope.insertIndex = i
                scope.noTemp = !RequiresFuncTempResult(stmt)

                stmt = FunctionLowering(context, stmt)
                i = i + scope.numberOfInserts
                body.stmts.set(i, stmt)

                scope.numberOfInserts = 0
            }
            break;
        }
        case StmtKind.BREAK_STMT: {
            break;
        }
        case StmtKind.COMP_STMT: {
            var comp = ast as (*CompStmt)
            if(comp.evaluatedStmt) {
                comp.evaluatedStmt = FunctionLowering(context, comp.evaluatedStmt)
            }
            if(comp.end) {
                comp.end = FunctionLowering(context, comp.end) as (*CompStmt)
            }
            for(var i = 0; i < comp.body.size(); i+=1) {
                var s = comp.body.get(i)
                s = FunctionLowering(context, s)
                comp.body.set(i, s)
            }
            break;
        }
        case StmtKind.CONTINUE_STMT: {
            break;
        }
        case StmtKind.DEFER_STMT: {
            var deferStmt = ast as (*DeferStmt)
            deferStmt.deferedStmt = FunctionLowering(context, deferStmt.deferedStmt)
            break;
        }
        case StmtKind.DO_WHILE_STMT: {
            var whileStmt = ast as (*DoWhileStmt)
            /*
                convert to:

                do {
                    body
                    if(cond)
                        continue
                    else
                        break
                } while(true);
            */

            var cond = whileStmt.cond

            var ifStmt = &NewIfStmt(
                cond.getStartPos(), cond.getEndPos(),
                cond,
                &NewContinueStmt(
                    cond.getStartPos(), cond.getEndPos(),
                    context.allocator
                ).asStmt,
                &NewBreakStmt(
                    cond.getStartPos(), cond.getEndPos(),
                    context.allocator
                ).asStmt,
                context.allocator
            ).asStmt

            var scope = BlockScope{}
            var block = PushBlock(context, &scope, whileStmt.body, ifStmt)
            defer context.pop()

            whileStmt.cond = &NewBooleanExpr(
                cond.getStartPos(), cond.getEndPos(),
                true,
                context.allocator
            ).asExpr

            whileStmt.body = FunctionLowering(context, block)
            whileStmt.cond = FunctionLowering(context, whileStmt.cond) as (*Expr)
            break;
        }
        case StmtKind.EMPTY_STMT: {
            break;
        }
        case StmtKind.FOR_STMT: {
            var forStmt = ast as (*ForStmt)
            /*
                lowered to:

                {
                    init
                    while(cond) {
                        body
                        post
                    }
                }
            */
            var stmts = ArrayInit<*Stmt>(2, context.allocator)
            if(forStmt.body) {
                stmts.add(forStmt.body)
            }
            if(forStmt.post) {
                stmts.add(forStmt.post)
            }

            var whileBodyNode = NewBlockStmt(
                forStmt.getStartPos(), forStmt.getEndPos(),
                stmts,
                context.allocator
            )
            var whileBody = &whileBodyNode.asStmt

            var cond = forStmt.cond ? forStmt.cond : &NewBooleanExpr(
                forStmt.getStartPos(), forStmt.getEndPos(),
                true,
                context.allocator
            ).asExpr

            var whileStmt = &NewWhileStmt(
                forStmt.getStartPos(), forStmt.getEndPos(),
                cond,
                whileBody,
                context.allocator
            ).asStmt

            var initStmt = forStmt.init ? forStmt.init : &NewEmptyStmt(
                forStmt.getStartPos(), forStmt.getEndPos(),
                context.allocator
            ).asStmt

            var scope = BlockScope{}
            var block = PushBlock(context, &scope, initStmt, whileStmt)
            defer context.pop()

            return FunctionLowering(context, block)
        }
        case StmtKind.GOTO_STMT: {
            break;
        }
        case StmtKind.IF_STMT: {
            var ifStmt = ast as (*IfStmt)

            /*
                Lower to:

                {
                if(cond)
                    {body}
                else
                    {other}
                }

                which if else's get modified to:

                {
                    if(cond)
                        {body}
                    else
                        {
                            if(cond)
                                {body}
                            else
                                {other}
                        }
                }
            */
            var scope = BlockScope{}
            var block = PushBlock(context, &scope, ifStmt)
            defer context.pop()

            ifStmt.cond = FunctionLowering(context, ifStmt.cond) as (*Expr)
            {
                var scope = BlockScope{}
                var thenBlock = PushBlock(context, &scope, ifStmt.then)
                defer context.pop()

                ifStmt.then = FunctionLowering(context, thenBlock)
            }

            if(ifStmt.elseStmt) {
                var scope = BlockScope{}
                var elseBlock = PushBlock(context, &scope, ifStmt.elseStmt)
                defer context.pop()

                ifStmt.elseStmt = FunctionLowering(context, elseBlock)
            }

            return block as (*Stmt)
        }
        case StmtKind.LABEL_STMT: {
            break;
        }
        case StmtKind.MODULE_STMT: {
            break;
        }
        case StmtKind.NOTE_STMT: {
            break;
        }
        case StmtKind.PARAMETERS_STMT: {
            var params = ast as (*ParametersStmt)
            for(var i = 0; i < params.size(); i += 1) {
                var param = params.get(i)

                param = FunctionLowering(context, param) as (*ParameterDecl)
                params.set(i, param)
            }
            break;
        }
        case StmtKind.RETURN_STMT: {
            var stmt = ast as (*ReturnStmt)
            if(stmt.expr) {
                stmt.expr = FunctionLowering(context, stmt.expr) as (*Expr)
            }
            break;
        }
        case StmtKind.SWITCH_CASE_STMT: {
            var caseStmt = ast as (*SwitchCaseStmt)
            caseStmt.cond = FunctionLowering(context, caseStmt.cond) as (*Expr)
            caseStmt.body = FunctionLowering(context, caseStmt.body)
            break;
        }
        case StmtKind.SWITCH_STMT:{
            var switchStmt = ast as (*SwitchStmt)
            /*
                lowered to

                {
                    switch(cond) {
                        case c1: stmt
                    }
                }
            */
            var scope = BlockScope{}
            var block = PushBlock(context, &scope, switchStmt)
            defer context.pop()

            switchStmt.cond = FunctionLowering(context, switchStmt.cond) as (*Expr)
            for(var i = 0; i < switchStmt.cases.size(); i+=1) {
                var caseStmt = switchStmt.cases.get(i)
                caseStmt = FunctionLowering(context, caseStmt) as (*SwitchCaseStmt)
                switchStmt.cases.set(i, caseStmt)
            }
            if(switchStmt.defaultStmt) {
                switchStmt.defaultStmt = FunctionLowering(context, switchStmt.defaultStmt)
            }

            return block as (*Stmt)
        }
        case StmtKind.ENUM_FIELD_DECL:
        case StmtKind.ENUM_FIELD_ENTRY_DECL:
        case StmtKind.STRUCT_FIELD_DECL:
        case StmtKind.UNION_FIELD_DECL:
        case StmtKind.TRAIT_FIELD_DECL:
        case StmtKind.VAR_FIELD_DECL: {
            // TODO: Is this needed??
            break;
        }
        case StmtKind.WHILE_STMT: {
            var whileStmt = ast as (*WhileStmt)

            /*
                Convert to:
                while(true) {
                    if(cond)
                        body
                    else
                        break;
                }
            */

            var cond = whileStmt.cond

            whileStmt.cond = &NewBooleanExpr(
                cond.getStartPos(), cond.getEndPos(),
                true,
                context.allocator
            ).asExpr

            whileStmt.body = &NewIfStmt(
                cond.getStartPos(), cond.getEndPos(),
                cond,
                whileStmt.body,
                &NewBreakStmt(
                    cond.getStartPos(), cond.getEndPos(),
                    context.allocator
                ).asStmt,
                context.allocator
            ).asStmt

            whileStmt.cond = FunctionLowering(context, whileStmt.cond) as (*Expr)
            whileStmt.body = FunctionLowering(context, whileStmt.body)
            break;
        }


        /*--------------------------------------
            Expressions
        ----------------------------------------*/
        case StmtKind.ARRAY_DESIGNATION_EXPR: {
            var expr = ast as (*ArrayDesignationExpr)
            expr.index = FunctionLowering(context, expr.index) as (*Expr)
            expr.value = FunctionLowering(context, expr.value) as (*Expr)
            break;
        }
        case StmtKind.ARRAY_INIT_EXPR: {
            var expr = ast as (*ArrayInitExpr)
            for(var i = 0; i < expr.values.size(); i += 1) {
                var arg = expr.values.get(i)
                arg = FunctionLowering(context, arg) as (*Expr)
                expr.values.set(i, arg)
            }
            break;
        }
        case StmtKind.BINARY_EXPR: {
            var expr = ast as (*BinaryExpr)
            /*
                left && right

                lowered to:

                var result = false
                var t1 = left
                if (t1) {
                    var t2 = right
                    if (t2) {
                        result = true
                    }
                }
            */
            if(expr.operator == TokenType.AND) {
                var result = NewTempAssignment(
                    context,
                    &NewBooleanExpr(
                        expr.getStartPos(), expr.getEndPos(),
                        false,
                        context.allocator
                    ).asExpr
                )

                var nameTypeSpec = NewNameTypeSpecIntern(
                    expr.getStartPos(),
                    result.name.str,
                    &context.module.typeSpecAllocator
                )

                var resultExpr = &NewIdentifierExpr(
                    expr.getStartPos(), expr.getEndPos(),
                    nameTypeSpec,
                    context.allocator
                ).asExpr

                var ifRight = &NewIfStmt(
                    expr.getStartPos(), expr.getEndPos(),
                    expr.right,
                    &NewBinaryExpr(
                        expr.getStartPos(), expr.getEndPos(),
                        resultExpr,
                        TokenType.EQUALS,
                        &NewBooleanExpr(
                            expr.getStartPos(), expr.getEndPos(),
                            true,
                            context.allocator
                        ).asExpr,
                        context.allocator
                    ).asStmt,
                    null,
                    context.allocator
                ).asStmt

                ifRight = FunctionLowering(context, ifRight)

                var ifLeft = &NewIfStmt(
                    expr.getStartPos(), expr.getEndPos(),
                    expr.left,
                    ifRight,
                    null,
                    context.allocator
                ).asStmt

                ifLeft = FunctionLowering(context, ifLeft)
                InsertTempStmt(context, ifLeft, .atEnd = true)

                return resultExpr as (*Stmt)
            }
            /*
                left || right

                lowered to:

                var result = false
                var t1 = left
                if (t1) {
                    result = true
                } else {
                    var t2 = right
                    if (t2) {
                        result = true
                    }
                }
            */
            else if(expr.operator == TokenType.OR) {
                var result = NewTempAssignment(
                    context,
                    &NewBooleanExpr(
                        expr.getStartPos(), expr.getEndPos(),
                        false,
                        context.allocator
                    ).asExpr
                )

                var nameTypeSpec = NewNameTypeSpecIntern(
                    expr.getStartPos(),
                    result.name.str,
                    &context.module.typeSpecAllocator
                )

                var resultExpr = &NewIdentifierExpr(
                    expr.getStartPos(), expr.getEndPos(),
                    nameTypeSpec,
                    context.allocator
                ).asExpr

                var ifRight = &NewIfStmt(
                    expr.getStartPos(), expr.getEndPos(),
                    expr.right,
                    &NewBinaryExpr(
                        expr.getStartPos(), expr.getEndPos(),
                        resultExpr,
                        TokenType.EQUALS,
                        &NewBooleanExpr(
                            expr.getStartPos(), expr.getEndPos(),
                            true,
                            context.allocator
                        ).asExpr,
                        context.allocator
                    ).asStmt,
                    null,
                    context.allocator
                ).asStmt

                ifRight = FunctionLowering(context, ifRight)

                var ifLeft = &NewIfStmt(
                    expr.getStartPos(), expr.getEndPos(),
                    expr.left,
                    &NewBinaryExpr(
                        expr.getStartPos(), expr.getEndPos(),
                        resultExpr,
                        TokenType.EQUALS,
                        &NewBooleanExpr(
                            expr.getStartPos(), expr.getEndPos(),
                            true,
                            context.allocator
                        ).asExpr,
                        context.allocator
                    ).asStmt,
                    ifRight,
                    context.allocator
                ).asStmt

                ifLeft = FunctionLowering(context, ifLeft)
                InsertTempStmt(context, ifLeft, .atEnd = true)

                return resultExpr as (*Stmt)
            } else {
                expr.left = FunctionLowering(context, expr.left) as (*Expr)
                expr.right = FunctionLowering(context, expr.right) as (*Expr)
            }
            break;
        }
        case StmtKind.BOOLEAN_EXPR: {
            break;
        }
        case StmtKind.CAST_EXPR: {
            var expr = ast as (*CastExpr)
            expr.exprToCast = FunctionLowering(context, expr.exprToCast) as (*Expr)
            break;
        }
        case StmtKind.CHAR_EXPR: {
            break;
        }
        case StmtKind.FUNC_CALL_EXPR: {
            var expr = ast as (*FuncCallExpr)
            /*
                Lowered to

                var t1 = call()
                t1

                ordering:

                expr.object
                a1
                a2
                ...

                var t1 = temp
                t1
            */
            expr.object = FunctionLowering(context, expr.object) as (*Expr)

            for(var i = 0; i < expr.arguments.size(); i += 1) {
                var arg = expr.arguments.getPtr(i)
                arg.argExpr = FunctionLowering(context, arg.argExpr) as (*Expr)
            }

            if (context.current.noTemp) {
                return expr as (*Stmt)
            }

            var temp = NewTempAssignment(context, expr)

            var nameTypeSpec = NewNameTypeSpecIntern(
                expr.getStartPos(),
                temp.name.str,
                &context.module.typeSpecAllocator
            )

            return &NewIdentifierExpr(
                expr.getStartPos(),
                expr.getEndPos(),
                nameTypeSpec,
                context.allocator
            ).asStmt
        }
        case StmtKind.GET_EXPR: {
            var expr = ast as (*GetExpr)
            expr.object = FunctionLowering(context, expr.object) as (*Expr)
            expr.field = FunctionLowering(context, expr.field) as (*IdentifierExpr)
            break;
        }
        case StmtKind.GROUP_EXPR: {
            var expr = ast as (*GroupExpr)
            expr.groupedExpr = FunctionLowering(context, expr.groupedExpr) as (*Expr)
            break;
        }
        case StmtKind.FUNC_IDENTIFIER_EXPR:
        case StmtKind.IDENTIFIER_EXPR: {
            var expr = ast as (*IdentifierExpr)
            if (expr.type.kind == TypeSpecKind.NAME) {
                var name = context.getVar(expr.type.name)
                if (name.length != 0) {
                    // printf("~%.*s vs %.*s\n",
                    //     expr.type.name.length, expr.type.name.buffer,
                    //     name.length, name.buffer
                    // )
                    context.patches.add(
                        Patch {
                            .stmt = expr as (*Stmt),
                            .block = context.current.block,
                            .index = context.current.insertIndex,
                        }
                    )
                }
            }
            break;
        }
        case StmtKind.INIT_EXPR: {
            var expr = ast as (*InitExpr)

            for(var i = 0; i < expr.arguments.size(); i += 1) {
                var arg = expr.arguments.get(i)
                arg = FunctionLowering(context, arg) as (*InitArgExpr)
                expr.arguments.set(i, arg)
            }
            break;
        }
        case StmtKind.INIT_ARG_EXPR: {
            var expr = ast as (*InitArgExpr)
            expr.value = FunctionLowering(context, expr.value) as (*Expr)
            break;
        }
        case StmtKind.NULL_EXPR: {
            break;
        }
        case StmtKind.NUMBER_EXPR: {
            break;
        }
        case StmtKind.OFFSET_OF_EXPR: {
            var expr = ast as (*OffsetOfExpr)
            break;
        }
        case StmtKind.SET_EXPR: {
            var expr = ast as (*SetExpr)
            expr.object = FunctionLowering(context, expr.object) as (*Expr)
            expr.field = FunctionLowering(context, expr.field) as (*IdentifierExpr)
            expr.value = FunctionLowering(context, expr.value) as (*Expr)
            break;
        }
        case StmtKind.SIZE_OF_EXPR: {
            var expr = ast as (*SizeOfExpr)
            expr.sizeOfExpr = FunctionLowering(context, expr.sizeOfExpr) as (*Expr)
            break;
        }
        case StmtKind.NATIVE_STRING_EXPR: {
            break;
        }
        case StmtKind.STRING_EXPR: {
            break;
        }
        case StmtKind.SUBSCRIPT_GET_EXPR: {
            var expr = ast as (*SubscriptGetExpr)
            expr.object = FunctionLowering(context, expr.object) as (*Expr)
            expr.index = FunctionLowering(context, expr.index) as (*Expr)
            break;
        }
        case StmtKind.SUBSCRIPT_SET_EXPR: {
            var expr = ast as (*SubscriptSetExpr)
            expr.object = FunctionLowering(context, expr.object) as (*Expr)
            expr.index = FunctionLowering(context, expr.index) as (*Expr)
            expr.value = FunctionLowering(context, expr.value) as (*Expr)
            break;
        }
        case StmtKind.TERNARY_EXPR: {
            var expr = ast as (*TernaryExpr)
            /*
                var x = cond ? then : other

                lowered to

                var result
                if (cond) {
                    result = then
                } else {
                    result = other
                }
                result
            */
            var resultTemp = NewTempEmptyAssignment(context, expr.then, true)
            resultTemp.flags |= VarDeclFlags.IS_TERNARY

            var nameTypeSpec = NewNameTypeSpecIntern(
                expr.getStartPos(),
                resultTemp.name.str,
                &context.module.typeSpecAllocator
            )

            var resultExpr = &NewIdentifierExpr(
                expr.getStartPos(), expr.getEndPos(),
                nameTypeSpec,
                context.allocator
            ).asExpr

            var thenExprNode = NewBinaryExpr(
                expr.getStartPos(), expr.getEndPos(),
                resultExpr,
                TokenType.EQUALS,
                expr.then,
                context.allocator
            )

            // mark this as a ternary lowering declaration
            var binExpr = &thenExprNode.binaryExpr
            binExpr.ternaryDecl = resultTemp

            var ifStmt = &NewIfStmt(
                expr.getStartPos(), expr.getEndPos(),
                expr.cond,
                thenExprNode.asStmt,
                &NewBinaryExpr(
                    expr.getStartPos(), expr.getEndPos(),
                    resultExpr,
                    TokenType.EQUALS,
                    expr.other,
                    context.allocator
                ).asStmt,
                context.allocator
            ).asStmt

            ifStmt = FunctionLowering(context, ifStmt)
            InsertTempStmt(context, ifStmt, .atEnd = true)

            return resultExpr as (*Stmt)
        }
        case StmtKind.TYPE_IDENTIFIER_EXPR: {
            var expr = ast as (*TypeIdentifierExpr)
            break;
        }
        case StmtKind.NAME_OF_EXPR:
        case StmtKind.TYPE_OF_EXPR: {
            var expr = ast as (*TypeOfExpr)
            expr.typeOfExpr = FunctionLowering(context, expr.typeOfExpr) as (*Expr)
            break;
        }
        case StmtKind.UNARY_EXPR: {
            var expr = ast as (*UnaryExpr)
            expr.unaryExpr = FunctionLowering(context, expr.unaryExpr) as (*Expr)
            break;
        }
        case StmtKind.POISON_EXPR: {
            break;
        }
        default: {
            printf("Statement Kind: %s\n", StmtKindAsStr(ast.getKind()))
            assert(false)
        }
    }
    return ast
}


func RequiresFuncTempResult(ast: *Stmt) : bool {
    if(!ast) {
        return false;
    }

    switch(ast.getKind()) {
        case StmtKind.TRAIT_DECL:
        case StmtKind.UNION_DECL:
        case StmtKind.STRUCT_DECL:
        case StmtKind.FUNC_DECL:
        case StmtKind.IMPORT_DECL:
        case StmtKind.TYPEDEF_DECL:
        case StmtKind.ENUM_DECL:
        case StmtKind.PARAM_DECL:
        case StmtKind.NATIVE_DECL:
        case StmtKind.POISON_DECL: {
            break;
        }
        case StmtKind.CONST_DECL:
        case StmtKind.VAR_DECL: {
            return true;
        }

        case StmtKind.FUNC_BODY_STMT:
        case StmtKind.BLOCK_STMT:
        case StmtKind.BREAK_STMT:
        case StmtKind.COMP_STMT:
        case StmtKind.CONTINUE_STMT:
        case StmtKind.DEFER_STMT: {
            break;
        }
        case StmtKind.DO_WHILE_STMT: {
            return true;
        }
        case StmtKind.EMPTY_STMT: {
            break;
        }
        case StmtKind.FOR_STMT: {
            return true;
        }
        case StmtKind.GOTO_STMT: {
            break;
        }
        case StmtKind.IF_STMT: {
            return true;
        }
        case StmtKind.LABEL_STMT: {
            break;
        }
        case StmtKind.MODULE_STMT: {
            break;
        }
        case StmtKind.NOTE_STMT: {
            break;
        }
        case StmtKind.PARAMETERS_STMT: {
            break;
        }
        case StmtKind.RETURN_STMT: {
            return true;
        }
        case StmtKind.SWITCH_CASE_STMT: {
            break;
        }
        case StmtKind.SWITCH_STMT:{
            return true;
        }
        case StmtKind.ENUM_FIELD_DECL:
        case StmtKind.ENUM_FIELD_ENTRY_DECL:
        case StmtKind.STRUCT_FIELD_DECL:
        case StmtKind.UNION_FIELD_DECL:
        case StmtKind.TRAIT_FIELD_DECL:
        case StmtKind.VAR_FIELD_DECL: {
            break;
        }
        case StmtKind.WHILE_STMT: {
            return true;
        }


        /*--------------------------------------
            Expressions
        ----------------------------------------*/
        case StmtKind.ARRAY_DESIGNATION_EXPR: {
            return true;
        }
        case StmtKind.ARRAY_INIT_EXPR: {
            return true;
        }
        case StmtKind.BINARY_EXPR: {
            return true;
        }
        case StmtKind.BOOLEAN_EXPR: {
            break;
        }
        case StmtKind.CAST_EXPR: {
            return true;
        }
        case StmtKind.CHAR_EXPR: {
            break;
        }
        case StmtKind.FUNC_CALL_EXPR: {
            break;
        }
        case StmtKind.FUNC_IDENTIFIER_EXPR: {
            break;
        }
        case StmtKind.GET_EXPR: {
            break;
        }
        case StmtKind.GROUP_EXPR: {
            break;
        }
        case StmtKind.IDENTIFIER_EXPR: {
            break;
        }
        case StmtKind.INIT_EXPR: {
            return true;
        }
        case StmtKind.INIT_ARG_EXPR: {
            break;
        }
        case StmtKind.NULL_EXPR: {
            break;
        }
        case StmtKind.NUMBER_EXPR: {
            break;
        }
        case StmtKind.OFFSET_OF_EXPR: {
            return true;
        }
        case StmtKind.SET_EXPR: {
            return true;
        }
        case StmtKind.SIZE_OF_EXPR: {
            return true;
        }
        case StmtKind.NATIVE_STRING_EXPR: {
            break;
        }
        case StmtKind.STRING_EXPR: {
            break;
        }
        case StmtKind.SUBSCRIPT_GET_EXPR: {
            break;
        }
        case StmtKind.SUBSCRIPT_SET_EXPR: {
            return true;
        }
        case StmtKind.TERNARY_EXPR: {
            return true;
        }
        case StmtKind.TYPE_IDENTIFIER_EXPR: {
            break;
        }
        case StmtKind.NAME_OF_EXPR:
        case StmtKind.TYPE_OF_EXPR: {
            return true;
        }
        case StmtKind.UNARY_EXPR: {
            return true;
        }
        case StmtKind.POISON_EXPR: {
            break;
        }
        default: {
            printf("Statement Kind: %s\n", StmtKindAsStr(ast.getKind()))
            assert(false)
        }
    }
    return false
}