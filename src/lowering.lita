import "std/array"
import "std/mem"
import "std/map"
import "std/libc"
import "std/hash"
import "std/string"
import "std/string/builder"
import "std/string/buffer"
import "std/assert"

import "intern"
import "symbols"
import "types"

import "lita"
import "ast"
import "ast_copy"
import "ast_new"
import "ast_print"
import "parser"
import "checker"
import "lex"
import "module"
import "common"
import "coroutine"

public struct FuncLowerContext {
    allocator: *const Allocator
    checker: *TypeChecker
    strings: *Strings
    module: *Module

    funcDecl: *FuncDecl
    tempIndex: u32
    labelIndex: u32

    current: *BlockScope

    //stack: Map<String, InternedString>
    stack: Array<InternedString>
    scopeIndex: u32
    // numOfScopes: u32

    patches: Array<Patch>
}

public struct Patch {
    stmt: *Stmt
    aux: *Stmt
    block: *BlockStmt
    index: u32
    name: InternedString
}


struct BlockScope {
    parent: *BlockScope
    block: *BlockStmt
    insertIndex: i32
    numberOfInserts: i32
    noTemp: bool

    locals: Array<InternedString>
}

func (this: *FuncLowerContext) setVar(name: InternedString, makeCanonical: bool = true) : InternedString {
    if (!this.current) {
        return InternedString{}
    }

    if (this.current.locals.capacity == 0) {
        this.current.locals = ArrayInit<InternedString>(16, this.allocator)
    }

    var buffer: [MAX_SYMBOL_NAME]char;
    var sb = StringBufferInit(buffer, MAX_SYMBOL_NAME, 0)
    if(makeCanonical) {
        sb.format("__%.*s__%d", name.length, name.buffer, this.scopeIndex)
    } else {
        sb.format("__%.*s", name.length, name.buffer)
    }

    var internedName = this.strings.internCopy(sb.cStr(), sb.length)
    this.current.locals.add(internedName)
    this.stack.add(internedName)
    printf("Added var: %.*s\n", internedName.length, internedName.buffer)

    return internedName
}

func (this: *FuncLowerContext) getVar(name: InternedString) : InternedString {
    assert(this.current != null)

    var buffer:[MAX_SYMBOL_NAME]char
    var nameTemplate = StringBufferInit(buffer, MAX_SYMBOL_NAME, 0)
    nameTemplate.format("__%.*s__", name.length, name.buffer)
    var formattedName = nameTemplate.toString()

    var scope = this.current
    while(scope != null) {
        for(var i = 0; i < scope.locals.size(); i+=1) {
            var localName = scope.locals.get(i)

            if (localName.view.startsWith(formattedName)) {
                return localName
            }
        }

        scope = scope.parent
    }

    return InternedString{}
}

func (this: *FuncLowerContext) push(scope: *BlockScope) {
    var current = this.current
    this.current = scope
    scope.parent = current
    this.scopeIndex += 1
}
func (this: *FuncLowerContext) pop() {
    if(!this.current) return;

    var parent = this.current.parent
    this.current = parent
    // this.scopeIndex -= 1
}
func (this: *FuncLowerContext) currentBlock(): *BlockStmt {
    if(!this.current) return null;
    return this.current.block
}

func NewTempName(context: *FuncLowerContext) : StringBuilder {
    var name = StringBuilderInit(MAX_SYMBOL_NAME, context.allocator)
    name.append("__%d", context.tempIndex += 1)
    return name
}

func NewTempAssignment(context: *FuncLowerContext, expr: *Expr, varName: *const char = null) : *VarDecl {
    if(varName == null) {
        var name = NewTempName(context)
        varName = name.cStr()
    }

    var tempNode = NewVarDecl(
        expr.getStartPos(),
        expr.getEndPos(),
        NewIdentifier(
            varName,
            expr.getStartPos(),
            context.strings
        ),
        null,
        expr,
        context.allocator
    )
    var temp = &tempNode.varDecl
    temp.flags |= VarDeclFlags.IS_TEMPORARY

    InsertTempStmt(context, temp, .atEnd = true)

    return temp as (*VarDecl)
}

func NewTempEmptyAssignment(
    context: *FuncLowerContext,
    expr: *Expr,
    isTernary: bool = false
) : *VarDecl {
    var name = NewTempName(context)

    var tempNode = NewVarDecl(
        expr.getStartPos(),
        expr.getEndPos(),
        NewIdentifier(
            name.cStr(),
            expr.getStartPos(),
            context.strings
        ),
        !isTernary ? expr.operand.typeInfo.asTypeSpec(
            context.module, true
        ) : null,
        null,
        context.allocator
    )

    var temp = &tempNode.varDecl
    temp.flags |= VarDeclFlags.IS_TEMPORARY

    InsertTempStmt(context, temp, .atEnd = true)
    return temp as (*VarDecl)
}

func InsertLabel(
    context: *FuncLowerContext,
    parent: *Stmt
) : bool {
    var name = StringBuilderInit(MAX_SYMBOL_NAME, context.allocator)
    name.append("__LABEL_%d", context.labelIndex += 1)

    var labelNode = NewLabelStmt(
        parent.getStartPos(), parent.getEndPos(),
        NewIdentifier(
            name.cStr(),
            parent.getStartPos(),
            context.strings
        ),
        context.allocator
    )

    var labelStmt = &labelNode.asStmt
    if(!context.checker.resolveStmt(labelStmt)) {
        return false
    }

    InsertTempStmt(context, labelStmt, .atEnd = false)
    return true
}

func InsertTempStmt(
    context: *FuncLowerContext,
    stmt: *Stmt,
    atEnd: bool
) {

    // TODO: This does right to left ordering of parameters
    // we probably want left to right even though this
    // isn't standard in C
    var scope = context.current
    var index = scope.insertIndex// + scope.numberOfInserts
    if(atEnd) {
        index += scope.numberOfInserts
    }
    // printf("Inserting at %d\n", index)
    // scope.block.stmts.insertAt(index, stmt)
    // scope.block.asNode().becomeParentOf(stmt)
    scope.numberOfInserts += 1
    InsertStmt(
        context,
        stmt,
        scope.block,
        index
    )
}

func InsertStmt(
    context: *FuncLowerContext,
    stmt: *Stmt,
    block: *BlockStmt,
    index: u32
) {
    block.stmts.insertAt(index as (i32), stmt)
    block.asNode().becomeParentOf(stmt)
}

func PushBlock(
    context: *FuncLowerContext,
    scope: *BlockScope,
    stmt1: *Stmt,
    stmt2: *Stmt = null
) : *BlockStmt {
    var stmts = ArrayInit<*Stmt>(2, context.allocator)
    stmts.add(stmt1)
    if(stmt2) {
        stmts.add(stmt2)
    }

    var blockNode = NewBlockStmt(
        stmt1.getStartPos(), stmt1.getEndPos(),
        stmts,
        context.allocator
    )

    scope.block = &blockNode.blockStmt
    scope.insertIndex = 0
    scope.numberOfInserts = 0

    context.push(scope)
    return scope.block
}

/**
    Convert function call expressions into lowered expressions:

    var x = object.value(call1(), call2()) ?
    object.value1(call3(), call4()) :
    object.value2(call6(), call6())

    var x = undefined
    var _1 = call1()
    var _2 = call2()
    var _r3 = object.value(_1, _2)
    if (_r3) {
        var _3 = call3()
        var _4 = call4()
        x = object.value(_3, _4)
    } else {
        var _5 = call5()
        var _6 = call6()
        x = object.value(_5, _6)
    }
*/
func ResolveCoroutine(this: *TypeChecker, decls: Array<*Decl>) : bool {
    this.bypassing = true
    for(var i = 0; i < decls.size(); i += 1) {
        var decl = decls.get(i)

        var sym = this.createDeclSymbol(decl)
        if(sym == null) {
            return false
        }

        this.resolveSymbol(sym)
        this.finishResolveSymbol(sym)

        //printf("Resolved sym: %.*s\n", sym.name.length, sym.name.buffer)
    }
    this.bypassing = false

    return true
}

public func LowerFuncBody(checker: *TypeChecker, funcDecl: *FuncDecl) : bool {
    if(!funcDecl.body) {
        return true;
    }

// TODO:
// 1) CreateCoroutine Decls for Wrapper and CoroutineStack here,
// 2) modify the funcDecl params to pass in the coStack
// 3) finally resolve the patches
//
// Clean up
// * Move to this coroutine module
// * clean up resolveFuncDecl


    var context = FuncLowerContext {
        .allocator = checker.allocator,
        .checker = checker,
        .strings = &checker.strings,
        .module = checker.current,
        .funcDecl = funcDecl,
        .tempIndex = 0_u32,
        .current = null,
        .scopeIndex = 0_u32,
        .labelIndex = 1_u32,
        .stack = ArrayInit<InternedString>(64, checker.allocator),
        .patches = ArrayInit<Patch>(64, checker.allocator),
    }

    //var bodyStmt: *BodyStmt = null
    if(funcDecl.body.getKind() != StmtKind.FUNC_BODY_STMT) {
        var body = funcDecl.body
        var stmts = ArrayInit<*Stmt>(1, checker.allocator)
        stmts.add(body)

        var bodyNode = NewFuncBodyStmt(
            body.getStartPos(),
            body.getEndPos(),
            stmts,
            checker.allocator
        )

        funcDecl.body = &bodyNode.asStmt
    }

    funcDecl.body = FunctionLowering(&context, funcDecl.body)

    if(!checker.resolveStmt(funcDecl.body)) {
        return false
    }

    // Parameter handling
    // 1) inject in new Continuation parameter
    // 2) include Patches for each parameter
    var params = funcDecl.params
    {
        assert(params != null)
        var coIndex = 0

        // if this is a method, the first argument must be 'this' type
        if(funcDecl.flags & FuncFlags.IS_METHOD) {
            coIndex += 1
        }

        var paramsNode = params.asNode()
        var contParamType = NewTypeSpec(
            TypeSpecKind.PTR,
            paramsNode.startPos,
            &checker.current.typeSpecAllocator
        )
        var paramValue = $"std::coroutine::Continuation"
        contParamType.base = NewNameTypeSpecIntern(
            paramsNode.startPos,
            context.strings.internString(paramValue),
            &checker.current.typeSpecAllocator
        )

        var coParamNode = NewParameterDecl(
            paramsNode.startPos, paramsNode.endPos,
            NewIdentifier(
                "__cont",
                paramsNode.startPos,
                context.strings
            ),
            contParamType,
            null,
            false,
            context.allocator
        )

        var coParam = &coParamNode.paramDecl
        if(!checker.resolveStmt(coParam)) {
            return false
        }

        var coParamSym = coParam.sym
        assert(coParamSym != null)
        coParamSym.flags |= SymbolFlags.IS_GENERATED

        params.insertAt(coIndex, coParam)
    }

    assert(funcDecl.sym != null)
    var decls = CreateCoroutine(
        checker,
        funcDecl.sym,
        &context
    )

    if(!ResolveCoroutine(checker, decls)) {
        return false
    }


    // Inject in state machine jumps
    {
        assert(funcDecl.body.getKind() == StmtKind.FUNC_BODY_STMT)
        var bodyStmt = funcDecl.body as (*BlockStmt)

        var sb = StringBuilderInit(1024, context.allocator)
        sb.append(
            """
            {
                var __stack = __cont.stack as (*%.*s__CoroutineStack)
                switch(__cont.state) {
            """, // TODO: Get GetCoroutineName
                funcDecl.name.str.length, funcDecl.name.str.buffer
        )
        for(var i = 0; i < context.labelIndex; i+=1) {
            sb.append(
                """
                    case %d: goto __LABEL_%d; break;
                """, i, i
            )
        }
        sb.append(
            """
                    default: assert(false)
                }
                __LABEL_0:
            }
            """
        )

        var parser = ParserInit(
            "generated",
            sb.cStr(),
            sb.length,
            checker.current,
            checker.lita
        )

        parser.funcLevel += 1
        var stmt = parser.statement()

        if(stmt.getKind() != StmtKind.BLOCK_STMT) {
            return false
        }

        stmt.setKind(StmtKind.FUNC_BODY_STMT)
        if(!checker.resolveStmt(stmt)) {
            return false
        }

        var newBlockStmt = stmt as (*BlockStmt)
        bodyStmt.stmts.insertAllAt(0, newBlockStmt.stmts)
    }

    // Convert locals to __stack.localVarName
    {
        var tempName = $"__stack"
        var continuationName = context.strings.internString(tempName)

        for(var i = 0; i < context.patches.size(); i+=1) {
            var patch = context.patches.getPtr(i)
            var node = patch.stmt.asNode()

            switch(node.kind) {
                case StmtKind.VAR_DECL:
                case StmtKind.CONST_DECL: {
                    var varDecl = &node.varDecl

                    node.kind = StmtKind.SET_EXPR
                    node.setExpr.object = node.becomeParentOf(
                        &NewIdentifierExpr(
                            node.startPos, node.endPos,
                            NewNameTypeSpecIntern(
                                node.startPos,
                                continuationName,
                                &checker.current.typeSpecAllocator
                            ),
                            context.allocator
                        ).asExpr
                    )
                    node.setExpr.field = node.becomeParentOf(
                        &NewIdentifierExpr(
                            node.startPos, node.endPos,
                            NewNameTypeSpecIntern(
                                node.startPos,
                                patch.name,
                                &checker.current.typeSpecAllocator
                            ),
                            context.allocator
                        ).identifierExpr
                    )
                    node.setExpr.value = varDecl.expr
                    node.setExpr.operator = TokenType.EQUALS
                    break
                }
                case StmtKind.RETURN_STMT: {
                    var returnStmt = &node.returnStmt
                    assert(returnStmt.expr != null)

                    var idName = $"std::coroutine::ContinuationResult"
                    var ok = $"OK"
                    var originalExpr = returnStmt.expr.asNode()
                    returnStmt.expr = &NewGetExpr(
                        originalExpr.startPos, originalExpr.endPos,
                        &NewIdentifierExpr(
                            originalExpr.startPos, originalExpr.endPos,
                            NewNameTypeSpecIntern(
                                originalExpr.startPos,
                                context.strings.internString(idName),
                                &checker.current.typeSpecAllocator
                            ),
                            context.allocator
                        ).asExpr,
                        &NewIdentifierExpr(
                            originalExpr.startPos, originalExpr.endPos,
                            NewNameTypeSpecIntern(
                                originalExpr.startPos,
                                context.strings.internString(ok),
                                &checker.current.typeSpecAllocator
                            ),
                            context.allocator
                        ).identifierExpr,
                        context.allocator
                    ).asExpr
                    break
                }
                case StmtKind.FUNC_CALL_EXPR: {
                    var funcCallExpr = &node.funcCallExpr

                    var idName = $"std::coroutine::Continuation"
                    var contParam = &NewInitExpr(
                        node.startPos, node.endPos,
                        NewNameTypeSpecIntern(
                            node.startPos,
                            context.strings.internString(idName),
                            &checker.current.typeSpecAllocator
                        ),
                        Array<*InitArgExpr>{},
                        context.allocator
                    ).asStmt

                    InsertStmt(context, contParam, patch.block, patch.index)
                    break
                }
                default: {
                    node.kind = StmtKind.GET_EXPR
                    node.getExpr.object = node.becomeParentOf(
                        &NewIdentifierExpr(
                            node.startPos, node.endPos,
                            NewNameTypeSpecIntern(
                                node.startPos,
                                continuationName,
                                &checker.current.typeSpecAllocator
                            ),
                            context.allocator
                        ).asExpr
                    )
                    node.getExpr.field = node.becomeParentOf(
                        &NewIdentifierExpr(
                            node.startPos, node.endPos,
                            NewNameTypeSpecIntern(
                                node.startPos,
                                patch.name,
                                &checker.current.typeSpecAllocator
                            ),
                            context.allocator
                        ).identifierExpr
                    )
                    break;
                }
            }
//PrintStmt(patch.stmt) printf("\n")
            if(!checker.resolveStmt(patch.stmt)) {
                // printf("Here!!!\n")
                // PrintStmt(funcDecl)
                return false
            }
        }
    }

    // Convert return to ContinuationResult
    {
        if(funcDecl.returnType != null) {
            var resultName = $"std::coroutine::ContinuationResult"
            funcDecl.returnType = NewNameTypeSpecIntern(
                funcDecl.getStartPos(),
                context.strings.internString(resultName),
                &checker.current.typeSpecAllocator
            )

            if(!checker.resolveTypeSpec(funcDecl.returnType)) {
                printf("Here!!\n")
                return false
            }
        }
    }

    PrintStmt(funcDecl)
    checker.current.currentScope.print("Function Scope")

    // for(var i = 0; i < context.stack.size(); i+=1) {
    //     var e = context.stack.get(i)
    //     printf(
    //         "%.*s\n", e.length, e.buffer
    //     )
    // }
}

func FunctionLowering(context: *FuncLowerContext, ast: *Stmt) : *Stmt {
    if(!ast) {
        return null;
    }

    switch(ast.getKind()) {
        case StmtKind.TRAIT_DECL:
        case StmtKind.UNION_DECL:
        case StmtKind.STRUCT_DECL:
        case StmtKind.FUNC_DECL:
        case StmtKind.IMPORT_DECL:
        case StmtKind.TYPEDEF_DECL:
        case StmtKind.ENUM_DECL:
        case StmtKind.PARAM_DECL:
        case StmtKind.NATIVE_DECL:
        case StmtKind.POISON_DECL: {
            break;
        }
        case StmtKind.CONST_DECL:
        case StmtKind.VAR_DECL: {
            var decl = ast as (*VarDecl)
            if(decl.expr) {
                decl.expr = FunctionLowering(context, decl.expr) as (*Expr)
            }
            if(!(decl.flags & VarDeclFlags.IS_TEMPORARY)) {
                context.patches.add(
                    Patch {
                        .stmt = decl as (*Stmt),
                        .block = context.current.block,
                        .index = context.current.insertIndex,
                        .name = context.setVar(decl.name.str),
                    }
                )
            }
            break;
        }

        case StmtKind.FUNC_BODY_STMT:
        case StmtKind.BLOCK_STMT: {
            var body = ast as (*BlockStmt)

            var scope = BlockScope {
                .block = body,
                .insertIndex = 0,
                .numberOfInserts = 0,
            }

            context.push(&scope)
            defer context.pop()

            if(ast.getKind() == StmtKind.FUNC_BODY_STMT) {
                var params = context.funcDecl.params
                for(var i = 0; i < params.size(); i+=1) {
                    var param = params.get(i)
                    context.setVar(param.name.str)
                }
            }

            for(var i = 0; i < body.stmts.size(); i+=1) {
                var stmt = body.stmts.get(i)
                scope.insertIndex = i
                scope.noTemp = !RequiresFuncTempResult(stmt)

                stmt = FunctionLowering(context, stmt)
                i = i + scope.numberOfInserts
                body.stmts.set(i, stmt)

                scope.numberOfInserts = 0
            }
            break;
        }
        case StmtKind.BREAK_STMT: {
            break;
        }
        case StmtKind.COMP_STMT: {
            var comp = ast as (*CompStmt)
            if(comp.evaluatedStmt) {
                comp.evaluatedStmt = FunctionLowering(context, comp.evaluatedStmt)
            }
            if(comp.end) {
                comp.end = FunctionLowering(context, comp.end) as (*CompStmt)
            }
            for(var i = 0; i < comp.body.size(); i+=1) {
                var s = comp.body.get(i)
                s = FunctionLowering(context, s)
                comp.body.set(i, s)
            }
            break;
        }
        case StmtKind.CONTINUE_STMT: {
            break;
        }
        case StmtKind.DEFER_STMT: {
            var deferStmt = ast as (*DeferStmt)
            deferStmt.deferedStmt = FunctionLowering(context, deferStmt.deferedStmt)
            break;
        }
        case StmtKind.DO_WHILE_STMT: {
            var whileStmt = ast as (*DoWhileStmt)
            /*
                convert to:

                do {
                    body
                    if(cond)
                        continue
                    else
                        break
                } while(true);
            */

            var cond = whileStmt.cond

            var ifStmt = &NewIfStmt(
                cond.getStartPos(), cond.getEndPos(),
                cond,
                &NewContinueStmt(
                    cond.getStartPos(), cond.getEndPos(),
                    context.allocator
                ).asStmt,
                &NewBreakStmt(
                    cond.getStartPos(), cond.getEndPos(),
                    context.allocator
                ).asStmt,
                context.allocator
            ).asStmt

            var scope = BlockScope{}
            var block = PushBlock(context, &scope, whileStmt.body, ifStmt)
            defer context.pop()

            whileStmt.cond = &NewBooleanExpr(
                cond.getStartPos(), cond.getEndPos(),
                true,
                context.allocator
            ).asExpr

            whileStmt.body = FunctionLowering(context, block)
            whileStmt.cond = FunctionLowering(context, whileStmt.cond) as (*Expr)
            break;
        }
        case StmtKind.EMPTY_STMT: {
            break;
        }
        case StmtKind.FOR_STMT: {
            var forStmt = ast as (*ForStmt)
            /*
                lowered to:

                {
                    init
                    while(cond) {
                        body
                        post
                    }
                }
            */
            var stmts = ArrayInit<*Stmt>(2, context.allocator)
            if(forStmt.body) {
                stmts.add(forStmt.body)
            }
            if(forStmt.post) {
                stmts.add(forStmt.post)
            }

            var whileBodyNode = NewBlockStmt(
                forStmt.getStartPos(), forStmt.getEndPos(),
                stmts,
                context.allocator
            )
            var whileBody = &whileBodyNode.asStmt

            var cond = forStmt.cond ? forStmt.cond : &NewBooleanExpr(
                forStmt.getStartPos(), forStmt.getEndPos(),
                true,
                context.allocator
            ).asExpr

            var whileStmt = &NewWhileStmt(
                forStmt.getStartPos(), forStmt.getEndPos(),
                cond,
                whileBody,
                context.allocator
            ).asStmt

            var initStmt = forStmt.init ? forStmt.init : &NewEmptyStmt(
                forStmt.getStartPos(), forStmt.getEndPos(),
                context.allocator
            ).asStmt

            var scope = BlockScope{}
            var block = PushBlock(context, &scope, initStmt, whileStmt)
            defer context.pop()

            return FunctionLowering(context, block)
        }
        case StmtKind.GOTO_STMT: {
            break;
        }
        case StmtKind.IF_STMT: {
            var ifStmt = ast as (*IfStmt)

            /*
                Lower to:

                {
                if(cond)
                    {body}
                else
                    {other}
                }

                which if else's get modified to:

                {
                    if(cond)
                        {body}
                    else
                        {
                            if(cond)
                                {body}
                            else
                                {other}
                        }
                }
            */
            var scope = BlockScope{}
            var block = PushBlock(context, &scope, ifStmt)
            defer context.pop()

            ifStmt.cond = FunctionLowering(context, ifStmt.cond) as (*Expr)
            {
                var scope = BlockScope{}
                var thenBlock = PushBlock(context, &scope, ifStmt.then)
                defer context.pop()

                ifStmt.then = FunctionLowering(context, thenBlock)
            }

            if(ifStmt.elseStmt) {
                var scope = BlockScope{}
                var elseBlock = PushBlock(context, &scope, ifStmt.elseStmt)
                defer context.pop()

                ifStmt.elseStmt = FunctionLowering(context, elseBlock)
            }

            return block as (*Stmt)
        }
        case StmtKind.LABEL_STMT: {
            break;
        }
        case StmtKind.MODULE_STMT: {
            break;
        }
        case StmtKind.NOTE_STMT: {
            break;
        }
        case StmtKind.PARAMETERS_STMT: {
            var params = ast as (*ParametersStmt)
            for(var i = 0; i < params.size(); i += 1) {
                var param = params.get(i)

                param = FunctionLowering(context, param) as (*ParameterDecl)
                params.set(i, param)
            }
            break;
        }
        case StmtKind.RETURN_STMT: {
            var stmt = ast as (*ReturnStmt)
            if(stmt.expr) {
                var expr = FunctionLowering(context, stmt.expr) as (*Expr)
                var varDecl = NewTempAssignment(context, expr, "result__0")
                context.patches.add(
                    Patch {
                        .stmt = varDecl as (*Stmt),
                        .block = context.current.block,
                        .index = context.current.insertIndex,
                        .name = context.setVar(varDecl.name.str, false),
                    }
                )

                // TODO return ContinuationResult
                stmt.expr = expr
                context.patches.add(
                    Patch {
                        .stmt = stmt as (*Stmt),
                        .block = context.current.block,
                        .index = context.current.insertIndex,
                    }
                )
            }
            break;
        }
        case StmtKind.SWITCH_CASE_STMT: {
            var caseStmt = ast as (*SwitchCaseStmt)
            caseStmt.cond = FunctionLowering(context, caseStmt.cond) as (*Expr)
            caseStmt.body = FunctionLowering(context, caseStmt.body)
            break;
        }
        case StmtKind.SWITCH_STMT:{
            var switchStmt = ast as (*SwitchStmt)
            /*
                lowered to

                {
                    switch(cond) {
                        case c1: stmt
                    }
                }
            */
            var scope = BlockScope{}
            var block = PushBlock(context, &scope, switchStmt)
            defer context.pop()

            switchStmt.cond = FunctionLowering(context, switchStmt.cond) as (*Expr)
            for(var i = 0; i < switchStmt.cases.size(); i+=1) {
                var caseStmt = switchStmt.cases.get(i)
                caseStmt = FunctionLowering(context, caseStmt) as (*SwitchCaseStmt)
                switchStmt.cases.set(i, caseStmt)
            }
            if(switchStmt.defaultStmt) {
                switchStmt.defaultStmt = FunctionLowering(context, switchStmt.defaultStmt)
            }

            return block as (*Stmt)
        }
        case StmtKind.ENUM_FIELD_DECL:
        case StmtKind.ENUM_FIELD_ENTRY_DECL:
        case StmtKind.STRUCT_FIELD_DECL:
        case StmtKind.UNION_FIELD_DECL:
        case StmtKind.TRAIT_FIELD_DECL:
        case StmtKind.VAR_FIELD_DECL: {
            // TODO: Is this needed??
            break;
        }
        case StmtKind.WHILE_STMT: {
            var whileStmt = ast as (*WhileStmt)

            /*
                Convert to:
                while(true) {
                    if(cond)
                        body
                    else
                        break;
                }
            */

            var cond = whileStmt.cond

            whileStmt.cond = &NewBooleanExpr(
                cond.getStartPos(), cond.getEndPos(),
                true,
                context.allocator
            ).asExpr

            whileStmt.body = &NewIfStmt(
                cond.getStartPos(), cond.getEndPos(),
                cond,
                whileStmt.body,
                &NewBreakStmt(
                    cond.getStartPos(), cond.getEndPos(),
                    context.allocator
                ).asStmt,
                context.allocator
            ).asStmt

            whileStmt.cond = FunctionLowering(context, whileStmt.cond) as (*Expr)
            whileStmt.body = FunctionLowering(context, whileStmt.body)
            break;
        }


        /*--------------------------------------
            Expressions
        ----------------------------------------*/
        case StmtKind.ARRAY_DESIGNATION_EXPR: {
            var expr = ast as (*ArrayDesignationExpr)
            expr.index = FunctionLowering(context, expr.index) as (*Expr)
            expr.value = FunctionLowering(context, expr.value) as (*Expr)
            break;
        }
        case StmtKind.ARRAY_INIT_EXPR: {
            var expr = ast as (*ArrayInitExpr)
            for(var i = 0; i < expr.values.size(); i += 1) {
                var arg = expr.values.get(i)
                arg = FunctionLowering(context, arg) as (*Expr)
                expr.values.set(i, arg)
            }
            break;
        }
        case StmtKind.BINARY_EXPR: {
            var expr = ast as (*BinaryExpr)
            /*
                left && right

                lowered to:

                var result = false
                var t1 = left
                if (t1) {
                    var t2 = right
                    if (t2) {
                        result = true
                    }
                }
            */
            if(expr.operator == TokenType.AND) {
                var result = NewTempAssignment(
                    context,
                    &NewBooleanExpr(
                        expr.getStartPos(), expr.getEndPos(),
                        false,
                        context.allocator
                    ).asExpr
                )

                var nameTypeSpec = NewNameTypeSpecIntern(
                    expr.getStartPos(),
                    result.name.str,
                    &context.module.typeSpecAllocator
                )

                var resultExpr = &NewIdentifierExpr(
                    expr.getStartPos(), expr.getEndPos(),
                    nameTypeSpec,
                    context.allocator
                ).asExpr

                var ifRight = &NewIfStmt(
                    expr.getStartPos(), expr.getEndPos(),
                    expr.right,
                    &NewBinaryExpr(
                        expr.getStartPos(), expr.getEndPos(),
                        resultExpr,
                        TokenType.EQUALS,
                        &NewBooleanExpr(
                            expr.getStartPos(), expr.getEndPos(),
                            true,
                            context.allocator
                        ).asExpr,
                        context.allocator
                    ).asStmt,
                    null,
                    context.allocator
                ).asStmt

                ifRight = FunctionLowering(context, ifRight)

                var ifLeft = &NewIfStmt(
                    expr.getStartPos(), expr.getEndPos(),
                    expr.left,
                    ifRight,
                    null,
                    context.allocator
                ).asStmt

                ifLeft = FunctionLowering(context, ifLeft)
                InsertTempStmt(context, ifLeft, .atEnd = true)

                return resultExpr as (*Stmt)
            }
            /*
                left || right

                lowered to:

                var result = false
                var t1 = left
                if (t1) {
                    result = true
                } else {
                    var t2 = right
                    if (t2) {
                        result = true
                    }
                }
            */
            else if(expr.operator == TokenType.OR) {
                var result = NewTempAssignment(
                    context,
                    &NewBooleanExpr(
                        expr.getStartPos(), expr.getEndPos(),
                        false,
                        context.allocator
                    ).asExpr
                )

                var nameTypeSpec = NewNameTypeSpecIntern(
                    expr.getStartPos(),
                    result.name.str,
                    &context.module.typeSpecAllocator
                )

                var resultExpr = &NewIdentifierExpr(
                    expr.getStartPos(), expr.getEndPos(),
                    nameTypeSpec,
                    context.allocator
                ).asExpr

                var ifRight = &NewIfStmt(
                    expr.getStartPos(), expr.getEndPos(),
                    expr.right,
                    &NewBinaryExpr(
                        expr.getStartPos(), expr.getEndPos(),
                        resultExpr,
                        TokenType.EQUALS,
                        &NewBooleanExpr(
                            expr.getStartPos(), expr.getEndPos(),
                            true,
                            context.allocator
                        ).asExpr,
                        context.allocator
                    ).asStmt,
                    null,
                    context.allocator
                ).asStmt

                ifRight = FunctionLowering(context, ifRight)

                var ifLeft = &NewIfStmt(
                    expr.getStartPos(), expr.getEndPos(),
                    expr.left,
                    &NewBinaryExpr(
                        expr.getStartPos(), expr.getEndPos(),
                        resultExpr,
                        TokenType.EQUALS,
                        &NewBooleanExpr(
                            expr.getStartPos(), expr.getEndPos(),
                            true,
                            context.allocator
                        ).asExpr,
                        context.allocator
                    ).asStmt,
                    ifRight,
                    context.allocator
                ).asStmt

                ifLeft = FunctionLowering(context, ifLeft)
                InsertTempStmt(context, ifLeft, .atEnd = true)

                return resultExpr as (*Stmt)
            } else {
                expr.left = FunctionLowering(context, expr.left) as (*Expr)
                expr.right = FunctionLowering(context, expr.right) as (*Expr)
            }
            break;
        }
        case StmtKind.BOOLEAN_EXPR: {
            break;
        }
        case StmtKind.CAST_EXPR: {
            var expr = ast as (*CastExpr)
            expr.exprToCast = FunctionLowering(context, expr.exprToCast) as (*Expr)
            break;
        }
        case StmtKind.CHAR_EXPR: {
            break;
        }
        case StmtKind.FUNC_CALL_EXPR: {
            var expr = ast as (*FuncCallExpr)
            /*
                Lowered to

                var t1 = call()
                t1

                ordering:

                expr.object
                a1
                a2
                ...

                var t1 = temp
                t1

                Coroutine:


                var t0 = Continuation {
                    .stack = X__CoroutineStack{
                        .param1__1 = a1,
                        .param2__1 = a2,
                    }
                }
                var t1 = callWrapper(&t0)
                LABEL__X:
                t1
            */
            expr.object = FunctionLowering(context, expr.object) as (*Expr)

            for(var i = 0; i < expr.arguments.size(); i += 1) {
                var arg = expr.arguments.getPtr(i)
                arg.argExpr = FunctionLowering(context, arg.argExpr) as (*Expr)
            }

            // this isn't a suspend function
            // we can skip all of this additional continuation stuff
            // if (context.current.noTemp) {
            //     return expr as (*Stmt)
            // }



            var temp = NewTempAssignment(context, expr)
            InsertLabel(context, temp)

            var nameTypeSpec = NewNameTypeSpecIntern(
                expr.getStartPos(),
                temp.name.str,
                &context.module.typeSpecAllocator
            )

            context.patches.add(
                Patch {
                    .stmt = expr as (*Stmt),
                    .block = context.current.block,
                    .index = context.current.insertIndex,
                    .aux = temp as (*Stmt)
                }
            )

            return &NewIdentifierExpr(
                expr.getStartPos(),
                expr.getEndPos(),
                nameTypeSpec,
                context.allocator
            ).asStmt
        }
        case StmtKind.GET_EXPR: {
            var expr = ast as (*GetExpr)
            expr.object = FunctionLowering(context, expr.object) as (*Expr)
            expr.field = FunctionLowering(context, expr.field) as (*IdentifierExpr)
            break;
        }
        case StmtKind.GROUP_EXPR: {
            var expr = ast as (*GroupExpr)
            expr.groupedExpr = FunctionLowering(context, expr.groupedExpr) as (*Expr)
            break;
        }
        case StmtKind.FUNC_IDENTIFIER_EXPR:
        case StmtKind.IDENTIFIER_EXPR: {
            var expr = ast as (*IdentifierExpr)
            if (expr.type.kind == TypeSpecKind.NAME) {
                var name = context.getVar(expr.type.name)
                if (name.length != 0) {
                    // printf("~%.*s vs %.*s\n",
                    //     expr.type.name.length, expr.type.name.buffer,
                    //     name.length, name.buffer
                    // )
                    context.patches.add(
                        Patch {
                            .stmt = expr as (*Stmt),
                            .block = context.current.block,
                            .index = context.current.insertIndex,
                            .name = name
                        }
                    )
                }
            }
            break;
        }
        case StmtKind.INIT_EXPR: {
            var expr = ast as (*InitExpr)

            for(var i = 0; i < expr.arguments.size(); i += 1) {
                var arg = expr.arguments.get(i)
                arg = FunctionLowering(context, arg) as (*InitArgExpr)
                expr.arguments.set(i, arg)
            }
            break;
        }
        case StmtKind.INIT_ARG_EXPR: {
            var expr = ast as (*InitArgExpr)
            expr.value = FunctionLowering(context, expr.value) as (*Expr)
            break;
        }
        case StmtKind.NULL_EXPR: {
            break;
        }
        case StmtKind.NUMBER_EXPR: {
            break;
        }
        case StmtKind.OFFSET_OF_EXPR: {
            var expr = ast as (*OffsetOfExpr)
            break;
        }
        case StmtKind.SET_EXPR: {
            var expr = ast as (*SetExpr)
            expr.object = FunctionLowering(context, expr.object) as (*Expr)
            expr.field = FunctionLowering(context, expr.field) as (*IdentifierExpr)
            expr.value = FunctionLowering(context, expr.value) as (*Expr)
            break;
        }
        case StmtKind.SIZE_OF_EXPR: {
            var expr = ast as (*SizeOfExpr)
            expr.sizeOfExpr = FunctionLowering(context, expr.sizeOfExpr) as (*Expr)
            break;
        }
        case StmtKind.NATIVE_STRING_EXPR: {
            break;
        }
        case StmtKind.STRING_EXPR: {
            break;
        }
        case StmtKind.SUBSCRIPT_GET_EXPR: {
            var expr = ast as (*SubscriptGetExpr)
            expr.object = FunctionLowering(context, expr.object) as (*Expr)
            expr.index = FunctionLowering(context, expr.index) as (*Expr)
            break;
        }
        case StmtKind.SUBSCRIPT_SET_EXPR: {
            var expr = ast as (*SubscriptSetExpr)
            expr.object = FunctionLowering(context, expr.object) as (*Expr)
            expr.index = FunctionLowering(context, expr.index) as (*Expr)
            expr.value = FunctionLowering(context, expr.value) as (*Expr)
            break;
        }
        case StmtKind.TERNARY_EXPR: {
            var expr = ast as (*TernaryExpr)
            /*
                var x = cond ? then : other

                lowered to

                var result
                if (cond) {
                    result = then
                } else {
                    result = other
                }
                result
            */
            var resultTemp = NewTempEmptyAssignment(context, expr.then, true)
            resultTemp.flags |= VarDeclFlags.IS_TERNARY

            var nameTypeSpec = NewNameTypeSpecIntern(
                expr.getStartPos(),
                resultTemp.name.str,
                &context.module.typeSpecAllocator
            )

            var resultExpr = &NewIdentifierExpr(
                expr.getStartPos(), expr.getEndPos(),
                nameTypeSpec,
                context.allocator
            ).asExpr

            var thenExprNode = NewBinaryExpr(
                expr.getStartPos(), expr.getEndPos(),
                resultExpr,
                TokenType.EQUALS,
                expr.then,
                context.allocator
            )

            // mark this as a ternary lowering declaration
            var binExpr = &thenExprNode.binaryExpr
            binExpr.ternaryDecl = resultTemp

            var ifStmt = &NewIfStmt(
                expr.getStartPos(), expr.getEndPos(),
                expr.cond,
                thenExprNode.asStmt,
                &NewBinaryExpr(
                    expr.getStartPos(), expr.getEndPos(),
                    resultExpr,
                    TokenType.EQUALS,
                    expr.other,
                    context.allocator
                ).asStmt,
                context.allocator
            ).asStmt

            ifStmt = FunctionLowering(context, ifStmt)
            InsertTempStmt(context, ifStmt, .atEnd = true)

            return resultExpr as (*Stmt)
        }
        case StmtKind.TYPE_IDENTIFIER_EXPR: {
            var expr = ast as (*TypeIdentifierExpr)
            break;
        }
        case StmtKind.NAME_OF_EXPR:
        case StmtKind.TYPE_OF_EXPR: {
            var expr = ast as (*TypeOfExpr)
            expr.typeOfExpr = FunctionLowering(context, expr.typeOfExpr) as (*Expr)
            break;
        }
        case StmtKind.UNARY_EXPR: {
            var expr = ast as (*UnaryExpr)
            expr.unaryExpr = FunctionLowering(context, expr.unaryExpr) as (*Expr)
            break;
        }
        case StmtKind.POISON_EXPR: {
            break;
        }
        default: {
            printf("Statement Kind: %s\n", StmtKindAsStr(ast.getKind()))
            assert(false)
        }
    }
    return ast
}


func RequiresFuncTempResult(ast: *Stmt) : bool {
    if(!ast) {
        return false;
    }

    switch(ast.getKind()) {
        case StmtKind.TRAIT_DECL:
        case StmtKind.UNION_DECL:
        case StmtKind.STRUCT_DECL:
        case StmtKind.FUNC_DECL:
        case StmtKind.IMPORT_DECL:
        case StmtKind.TYPEDEF_DECL:
        case StmtKind.ENUM_DECL:
        case StmtKind.PARAM_DECL:
        case StmtKind.NATIVE_DECL:
        case StmtKind.POISON_DECL: {
            break;
        }
        case StmtKind.CONST_DECL:
        case StmtKind.VAR_DECL: {
            return true;
        }

        case StmtKind.FUNC_BODY_STMT:
        case StmtKind.BLOCK_STMT:
        case StmtKind.BREAK_STMT:
        case StmtKind.COMP_STMT:
        case StmtKind.CONTINUE_STMT:
        case StmtKind.DEFER_STMT: {
            break;
        }
        case StmtKind.DO_WHILE_STMT: {
            return true;
        }
        case StmtKind.EMPTY_STMT: {
            break;
        }
        case StmtKind.FOR_STMT: {
            return true;
        }
        case StmtKind.GOTO_STMT: {
            break;
        }
        case StmtKind.IF_STMT: {
            return true;
        }
        case StmtKind.LABEL_STMT: {
            break;
        }
        case StmtKind.MODULE_STMT: {
            break;
        }
        case StmtKind.NOTE_STMT: {
            break;
        }
        case StmtKind.PARAMETERS_STMT: {
            break;
        }
        case StmtKind.RETURN_STMT: {
            return true;
        }
        case StmtKind.SWITCH_CASE_STMT: {
            break;
        }
        case StmtKind.SWITCH_STMT:{
            return true;
        }
        case StmtKind.ENUM_FIELD_DECL:
        case StmtKind.ENUM_FIELD_ENTRY_DECL:
        case StmtKind.STRUCT_FIELD_DECL:
        case StmtKind.UNION_FIELD_DECL:
        case StmtKind.TRAIT_FIELD_DECL:
        case StmtKind.VAR_FIELD_DECL: {
            break;
        }
        case StmtKind.WHILE_STMT: {
            return true;
        }


        /*--------------------------------------
            Expressions
        ----------------------------------------*/
        case StmtKind.ARRAY_DESIGNATION_EXPR: {
            return true;
        }
        case StmtKind.ARRAY_INIT_EXPR: {
            return true;
        }
        case StmtKind.BINARY_EXPR: {
            return true;
        }
        case StmtKind.BOOLEAN_EXPR: {
            break;
        }
        case StmtKind.CAST_EXPR: {
            return true;
        }
        case StmtKind.CHAR_EXPR: {
            break;
        }
        case StmtKind.FUNC_CALL_EXPR: {
            break;
        }
        case StmtKind.FUNC_IDENTIFIER_EXPR: {
            break;
        }
        case StmtKind.GET_EXPR: {
            break;
        }
        case StmtKind.GROUP_EXPR: {
            break;
        }
        case StmtKind.IDENTIFIER_EXPR: {
            break;
        }
        case StmtKind.INIT_EXPR: {
            return true;
        }
        case StmtKind.INIT_ARG_EXPR: {
            break;
        }
        case StmtKind.NULL_EXPR: {
            break;
        }
        case StmtKind.NUMBER_EXPR: {
            break;
        }
        case StmtKind.OFFSET_OF_EXPR: {
            return true;
        }
        case StmtKind.SET_EXPR: {
            return true;
        }
        case StmtKind.SIZE_OF_EXPR: {
            return true;
        }
        case StmtKind.NATIVE_STRING_EXPR: {
            break;
        }
        case StmtKind.STRING_EXPR: {
            break;
        }
        case StmtKind.SUBSCRIPT_GET_EXPR: {
            break;
        }
        case StmtKind.SUBSCRIPT_SET_EXPR: {
            return true;
        }
        case StmtKind.TERNARY_EXPR: {
            return true;
        }
        case StmtKind.TYPE_IDENTIFIER_EXPR: {
            break;
        }
        case StmtKind.NAME_OF_EXPR:
        case StmtKind.TYPE_OF_EXPR: {
            return true;
        }
        case StmtKind.UNARY_EXPR: {
            return true;
        }
        case StmtKind.POISON_EXPR: {
            break;
        }
        default: {
            printf("Statement Kind: %s\n", StmtKindAsStr(ast.getKind()))
            assert(false)
        }
    }
    return false
}