import "std/array"
import "std/mem"
import "std/map"
import "std/libc"
import "std/hash"
import "std/string"
import "std/string/builder"
import "std/string/buffer"
import "std/assert"

import "intern"
import "symbols"
import "types"

import "lita"
import "ast"
import "ast_copy"
import "ast_new"
import "ast_print"
import "parser"
import "checker"
import "lex"
import "module"
import "common"
import "coroutine"

public struct FuncLowerContext {
    allocator: *const Allocator
    checker: *TypeChecker
    strings: *Strings
    module: *Module

    funcDecl: *FuncDecl
    tempIndex: u32
    labelIndex: u32

    current: *BlockScope

    //stack: Map<String, InternedString>
    // stack: Array<InternedString>
    scopeIndex: u32
    // numOfScopes: u32

    patches: Array<Patch>
}

public struct CoroutinePatch {
    coSym: *Symbol
    patches: Array<Patch>
}

public struct Patch {
    stmt: *Stmt       // the statement that is triggering the patch
    aux: *Stmt        // [optional] auxilary statement to give context
    ret: *Stmt        // [optional] the returned statement
    label: *Stmt      // [optional] the label

    block: *BlockStmt
    index: u32
    name: InternedString
}


struct BlockScope {
    parent: *BlockScope
    block: *BlockStmt
    insertIndex: i32
    numberOfInserts: i32
    noTemp: bool

    locals: Array<InternedString>
}

func (this: *FuncLowerContext) setVar(name: InternedString, makeCanonical: bool = true) : InternedString {
    if (!this.current) {
        return InternedString{}
    }

    if (this.current.locals.capacity == 0) {
        this.current.locals = ArrayInit<InternedString>(16, this.allocator)
    }

    var buffer: [MAX_SYMBOL_NAME]char;
    var sb = StringBufferInit(buffer, MAX_SYMBOL_NAME, 0)
    if(makeCanonical) {
        sb.format("__%.*s__%d", name.length, name.buffer, this.scopeIndex)
    } else {
        sb.format("__%.*s", name.length, name.buffer)
    }

    var internedName = this.strings.internCopy(sb.cStr(), sb.length)
    this.current.locals.add(internedName)
    //this.stack.add(internedName)
    //printf("Added var: %.*s\n", internedName.length, internedName.buffer)

    return internedName
}

func (this: *FuncLowerContext) getVar(name: InternedString) : InternedString {
    assert(this.current != null)

    var buffer:[MAX_SYMBOL_NAME]char
    var nameTemplate = StringBufferInit(buffer, MAX_SYMBOL_NAME, 0)
    nameTemplate.format("__%.*s__", name.length, name.buffer)
    var formattedName = nameTemplate.toString()

    var scope = this.current
    while(scope != null) {
        for(var i = 0; i < scope.locals.size(); i+=1) {
            var localName = scope.locals.get(i)

            if (localName.view.startsWith(formattedName)) {
                return localName
            }
        }

        scope = scope.parent
    }

    return InternedString{}
}

func (this: *FuncLowerContext) push(scope: *BlockScope) {
    var current = this.current
    this.current = scope
    scope.parent = current
    this.scopeIndex += 1
}
func (this: *FuncLowerContext) pop() {
    if(!this.current) return;

    var parent = this.current.parent
    this.current = parent
    // this.scopeIndex -= 1
}
func (this: *FuncLowerContext) currentBlock(): *BlockStmt {
    if(!this.current) return null;
    return this.current.block
}

func NewIdentFromTemp(context: *FuncLowerContext, temp: *VarDecl): *Node {
    var nameTypeSpec = NewNameTypeSpecIntern(
        temp.getStartPos(),
        temp.name.str,
        &context.module.typeSpecAllocator
    )

    return NewIdentifierExpr(
        temp.getStartPos(),
        temp.getEndPos(),
        nameTypeSpec,
        context.allocator
    )
}

func NewTempName(context: *FuncLowerContext) : StringBuilder {
    var name = StringBuilderInit(MAX_SYMBOL_NAME, context.allocator)
    name.append("__%d", context.tempIndex += 1)
    return name
}

func NewTempAssignment(
    context: *FuncLowerContext,
    expr: *Expr,
    varName: *const char = null,
    insert: bool = true
) : *VarDecl {
    if(varName == null) {
        var name = NewTempName(context)
        varName = name.cStr()
    }

    var tempNode = NewVarDecl(
        expr.getStartPos(),
        expr.getEndPos(),
        NewIdentifier(
            varName,
            expr.getStartPos(),
            context.strings
        ),
        null,
        expr,
        context.allocator
    )
    var temp = &tempNode.varDecl
    temp.flags |= VarDeclFlags.IS_TEMPORARY

    if(insert) {
        InsertTempStmt(context, temp, .atEnd = true)
    }

    return temp as (*VarDecl)
}

func NewTempEmptyAssignment(
    context: *FuncLowerContext,
    expr: *Expr,
    isTernary: bool = false
) : *VarDecl {
    var name = NewTempName(context)

    var tempNode = NewVarDecl(
        expr.getStartPos(),
        expr.getEndPos(),
        NewIdentifier(
            name.cStr(),
            expr.getStartPos(),
            context.strings
        ),
        !isTernary ? expr.operand.typeInfo.asTypeSpec(
            context.module, true
        ) : null,
        null,
        context.allocator
    )

    var temp = &tempNode.varDecl
    temp.flags |= VarDeclFlags.IS_TEMPORARY

    InsertTempStmt(context, temp, .atEnd = true)
    return temp as (*VarDecl)
}

func InsertLabel(
    context: *FuncLowerContext,
    parent: *Stmt
) : *Stmt {
    var name = StringBuilderInit(MAX_SYMBOL_NAME, context.allocator)
    name.append("__LABEL_%d", context.labelIndex += 1)

    var labelNode = NewLabelStmt(
        parent.getStartPos(), parent.getEndPos(),
        NewIdentifier(
            name.cStr(),
            parent.getStartPos(),
            context.strings
        ),
        context.allocator
    )

    var labelStmt = &labelNode.asStmt
    if(!context.checker.resolveStmt(labelStmt)) {
        return labelStmt
    }

    InsertTempStmt(context, labelStmt, .atEnd = false)
    return labelStmt
}

func InsertTempStmt(
    context: *FuncLowerContext,
    stmt: *Stmt,
    atEnd: bool
) {

    // TODO: This does right to left ordering of parameters
    // we probably want left to right even though this
    // isn't standard in C
    var scope = context.current
    var index = scope.insertIndex// + scope.numberOfInserts
    if(atEnd) {
        index += scope.numberOfInserts
    }
    // printf("Inserting at %d\n", index)
    // scope.block.stmts.insertAt(index, stmt)
    // scope.block.asNode().becomeParentOf(stmt)
    scope.numberOfInserts += 1
    InsertStmt(
        context,
        stmt,
        scope.block,
        index
    )
}

func InsertStmt(
    context: *FuncLowerContext,
    stmt: *Stmt,
    block: *BlockStmt,
    index: u32
) {
    block.stmts.insertAt(index as (i32), stmt)
    block.asNode().becomeParentOf(stmt)
}

func PushBlock(
    context: *FuncLowerContext,
    scope: *BlockScope,
    stmt1: *Stmt,
    stmt2: *Stmt = null
) : *BlockStmt {
    var stmts = ArrayInit<*Stmt>(2, context.allocator)
    stmts.add(stmt1)
    if(stmt2) {
        stmts.add(stmt2)
    }

    var blockNode = NewBlockStmt(
        stmt1.getStartPos(), stmt1.getEndPos(),
        stmts,
        context.allocator
    )

    scope.block = &blockNode.blockStmt
    scope.insertIndex = 0
    scope.numberOfInserts = 0

    context.push(scope)
    return scope.block
}

/**
    Convert function call expressions into lowered expressions:

    var x = object.value(call1(), call2()) ?
    object.value1(call3(), call4()) :
    object.value2(call6(), call6())

    var x = undefined
    var _1 = call1()
    var _2 = call2()
    var _r3 = object.value(_1, _2)
    if (_r3) {
        var _3 = call3()
        var _4 = call4()
        x = object.value(_3, _4)
    } else {
        var _5 = call5()
        var _6 = call6()
        x = object.value(_5, _6)
    }
*/
func ResolveCoroutine(this: *TypeChecker, decls: Array<*Decl>) : bool {
    var count = this.errors()
    this.bypassing = true
    for(var i = 0; i < decls.size(); i += 1) {
        var decl = decls.get(i)

        var sym = this.createDeclSymbol(decl)
        if(sym == null) {
            //printf("Failed to resolve: %.*s\n", decl.name.str.length, decl.name.str.buffer)
            return false
        }

        this.resolveSymbol(sym)
        this.finishResolveSymbol(sym)

        // printf("Resolved sym: %.*s\n", sym.name.length, sym.name.buffer)
    }
    this.bypassing = false

    return count == this.errors()
}

public func LowerFuncBody(checker: *TypeChecker, funcDecl: *FuncDecl) : bool {
    if(!funcDecl.body) {
        return true;
    }

// TODO:
// 1) CreateCoroutine Decls for Wrapper and CoroutineStack here,
// 2) modify the funcDecl params to pass in the coStack
// 3) finally resolve the patches
//
// Clean up
// * Move to this coroutine module
// * clean up resolveFuncDecl


    var context = FuncLowerContext {
        .allocator = checker.allocator,
        .checker = checker,
        .strings = &checker.strings,
        .module = checker.current,
        .funcDecl = funcDecl,
        .tempIndex = 0_u32,
        .current = null,
        .scopeIndex = 0_u32,
        .labelIndex = 0_u32,
        .patches = ArrayInit<Patch>(64, checker.allocator),
    }

    if(funcDecl.body.getKind() != StmtKind.FUNC_BODY_STMT) {
        var body = funcDecl.body
        var stmts = ArrayInit<*Stmt>(1, checker.allocator)
        stmts.add(body)

        var bodyNode = NewFuncBodyStmt(
            body.getStartPos(),
            body.getEndPos(),
            stmts,
            checker.allocator
        )

        funcDecl.body = &bodyNode.asStmt
    }

    funcDecl.body = FunctionLowering(&context, funcDecl.body)

    if(!checker.resolveStmt(funcDecl.body)) {
        printf("*************************************Failed to lower!\n")
        return false
    }

    // Parameter handling
    // 1) inject in new Continuation parameter
    // 2) include Patches for each parameter
    var params = funcDecl.params

/*
    {
        assert(params != null)
        var coIndex = 0

        // if this is a method, the first argument must be 'this' type
        if(funcDecl.flags & FuncFlags.IS_METHOD) {
            coIndex += 1
        }

        var paramsNode = params.asNode()
        var contParamType = NewTypeSpec(
            TypeSpecKind.PTR,
            paramsNode.startPos,
            &checker.current.typeSpecAllocator
        )
        var paramValue = $"std::coroutine::Continuation"
        contParamType.base = NewNameTypeSpecIntern(
            paramsNode.startPos,
            context.strings.internString(paramValue),
            &checker.current.typeSpecAllocator
        )

        var coParamNode = NewParameterDecl(
            paramsNode.startPos, paramsNode.endPos,
            NewIdentifier(
                "__cont",
                paramsNode.startPos,
                context.strings
            ),
            contParamType,
            null,
            false,
            context.allocator
        )

        var coParam = &coParamNode.paramDecl
        if(!checker.resolveStmt(coParam)) {
            return false
        }

        var coParamSym = coParam.sym
        assert(coParamSym != null)
        coParamSym.flags |= SymbolFlags.IS_GENERATED

        params.insertAt(coIndex, coParam)
    }
*/
    assert(funcDecl.sym != null)
    var decls = CreateCoroutine(
        checker,
        funcDecl.sym,
        &context
    )

    if(!ResolveCoroutine(checker, decls)) {
        printf("*************************BADxer\n")
        return false
    }

    return PatchCoroutine(
        &context,
        funcDecl
    )
}

func PatchCoroutine(
    context: *FuncLowerContext,
    funcDecl: *FuncDecl
): bool {
    var allocator = context.allocator
    var checker = context.checker

    var code = StringBuilderInit(1024, allocator)

    // Inject in state machine jumps
    {
        assert(funcDecl.body.getKind() == StmtKind.FUNC_BODY_STMT)
        var bodyStmt = funcDecl.body as (*BlockStmt)

        code.append(
            """
            {
                var __stack = __cont.stack as (*%.*s__CoroutineStack)
                if(__stack == null) {
                    __stack = new<%.*s__CoroutineStack>(__cont.context.allocator)
                    __cont.stack = __stack
            """,
            funcDecl.name.str.length, funcDecl.name.str.buffer,
            funcDecl.name.str.length, funcDecl.name.str.buffer
        )
        for(var i = 1; i < funcDecl.params.size(); i+=1) {
            var param = funcDecl.params.get(i)
            code.append(
                "__stack.__%.*s__1 = %.*s;\n",
                param.name.str.length, param.name.str.buffer,
                param.name.str.length, param.name.str.buffer
            )
        }
        code.append(
            """
                }
                switch(__cont.state) {
            """
        )
        for(var i = 0; i <= context.labelIndex; i+=1) {
            code.append(
                """
                    case %d: goto __LABEL_%d; break;
                """, i, i
            )
        }
        code.append(
            """
                    default: assert(false)
                }
                __LABEL_0:
            }
            """
        )
        var snapshot = code.toString()
        var parser = ParserInit(
            "generated",
            snapshot.buffer,
            snapshot.length,
            checker.current,
            checker.lita
        )

        parser.funcLevel += 1
        var stmt = parser.statement()

        if(stmt.getKind() != StmtKind.BLOCK_STMT) {
            return false
        }

        stmt.setKind(StmtKind.FUNC_BODY_STMT)

        if(!checker.resolveStmt(stmt)) {
            printf("*************************BADf\n")
            return false
        }

        var newBlockStmt = stmt as (*BlockStmt)
        bodyStmt.stmts.insertAllAt(0, newBlockStmt.stmts)
    }

    // Convert locals to __stack.localVarName
    {
        var tempName = $"__stack"
        var continuationName = context.strings.internString(tempName)

        for(var i = 0; i < context.patches.size(); i+=1) {
            var patch = context.patches.getPtr(i)
            var node = patch.stmt.asNode()

            switch(node.kind) {
                case StmtKind.VAR_DECL:
                case StmtKind.CONST_DECL: {
                    var varDecl = &node.varDecl

                    node.kind = StmtKind.SET_EXPR
                    node.setExpr.object = node.becomeParentOf(
                        &NewIdentifierExpr(
                            node.startPos, node.endPos,
                            NewNameTypeSpecIntern(
                                node.startPos,
                                continuationName,
                                &checker.current.typeSpecAllocator
                            ),
                            allocator
                        ).asExpr
                    )
                    node.setExpr.field = node.becomeParentOf(
                        &NewIdentifierExpr(
                            node.startPos, node.endPos,
                            NewNameTypeSpecIntern(
                                node.startPos,
                                patch.name,
                                &checker.current.typeSpecAllocator
                            ),
                            allocator
                        ).identifierExpr
                    )
                    node.setExpr.value = varDecl.expr
                    node.setExpr.operator = TokenType.EQUALS
                    break
                }
                case StmtKind.RETURN_STMT: {
                    var returnStmt = &node.returnStmt
                    assert(returnStmt.expr != null)

                    var idName = $"std::coroutine::ContinuationResult"
                    var ok = $"OK"
                    var originalExpr = returnStmt.expr.asNode()
                    returnStmt.expr = &NewGetExpr(
                        originalExpr.startPos, originalExpr.endPos,
                        &NewIdentifierExpr(
                            originalExpr.startPos, originalExpr.endPos,
                            NewNameTypeSpecIntern(
                                originalExpr.startPos,
                                context.strings.internString(idName),
                                &checker.current.typeSpecAllocator
                            ),
                            allocator
                        ).asExpr,
                        &NewIdentifierExpr(
                            originalExpr.startPos, originalExpr.endPos,
                            NewNameTypeSpecIntern(
                                originalExpr.startPos,
                                context.strings.internString(ok),
                                &checker.current.typeSpecAllocator
                            ),
                            allocator
                        ).identifierExpr,
                        allocator
                    ).asExpr
                    break
                }
                case StmtKind.FUNC_CALL_EXPR: {
                    var funcCallExpr = &node.funcCallExpr

                    var typeInfo = funcCallExpr.object.operand.typeInfo
                    assert(typeInfo)

                    var sym = typeInfo.sym
                    assert(sym)

                    var tempDeclIndex = -1

                    assert(patch.aux)
                    var auxNode = patch.aux.asNode()
                    for(var i = patch.index as (i32); i < patch.block.stmts.size(); i+=1) {
                        var tmp = patch.block.stmts.get(i).asNode()
                        if(tmp == auxNode) {
                            tempDeclIndex = i
                            break;
                        }
                    }
                    assert(tempDeclIndex > -1)

                    var contParamName: String//*const char = null
                    var stackParamName: String

                    /**
                        Current issues:
                        1) passed in continuation needs to be
                           lowered to a temp variable, so it
                           can be referenced later
                        2) called continuation return value needs
                           to be checked for ContinuationResult
                        3) the stack continuation result needs to
                           be looked at for the actual function value
                           result if ContinuationResult.OK
                    */
                    if(!(sym.flags & SymbolFlags.IS_COROUTINE)) {
                        funcCallExpr.arguments.removeAt(0)
                    } else {
                        // TODO - this needs to be allocated on the heap
/*
                        var idName = $"std::coroutine::Continuation"
                        var contParam = &NewInitExpr(
                            node.startPos, node.endPos,
                            NewNameTypeSpecIntern(
                                node.startPos,
                                context.strings.internString(idName),
                                &checker.current.typeSpecAllocator
                            ),
                            // TODO
                            Array<*InitArgExpr>{

                            },
                            context.allocator
                        ).asExpr
*/
                        contParamName = NewTempName(context).toString()
                        // First build the Stack
                        // TODO:
                        /*
                        {
                            var initArgs = ArrayInit<*InitArgExpr>(
                                funcCallExpr.arguments.size(),
                                allocator
                            )

                            for(var i = 0; i < funcCallExpr.arguments.size(); i+=1) {
                                var callArg = funcCallExpr.arguments.get(i)
                                var initArg = NewInitArgExpr(
                                    callArg.argExpr.getStartPos(),
                                    callArg.argExpr.getEndPos(),
                                    Identifier{},
                                    i,
                                    callArg.argExpr,
                                    allocator
                                )
                                initArgs.add(&initArg.initArgExpr)
                            }

                            var mark = code.length
                            code.append(
                                "%.*s__CoroutineStack",
                                typeInfo.name.length, typeInfo.name.buffer
                            )

                            var stackName = code.toString().substring(mark)
                            var stackParam = &NewInitExpr(
                                node.startPos, node.endPos,
                                NewNameTypeSpecIntern(
                                    node.startPos,
                                    context.strings.internString(stackName),
                                    &checker.current.typeSpecAllocator
                                ),
                                initArgs,
                                allocator
                            ).asExpr

                            // TODO make local variable
                            var temp = NewTempAssignment(context, stackParam, .insert = false)
                            if(!checker.resolveStmt(temp)) {
                                PrintStmt(stackParam.operand.typeInfo.sym.decl)
                                PrintStmt(temp)
                                checker.current.print("At failure")
                                printf("*************************BADx1\n")
                                return false
                            }

                            stackParamName = temp.name.str.view

                            InsertStmt(context, temp, patch.block, tempDeclIndex += 1)
                        }*/

                        // Create the Continuation
                        {
                            var mark = code.length
                            code.append(
                                """
                                NewContinuation(
                                    __cont.context.allocator,
                                    std::coroutine::Continuation {
                                        .context = __cont.context,
                                        .parent = __cont,
                                        .stack = null,
                                        .state = 0_u32,
                                        .callback = %.*s__Coroutine
                                    }
                                )
                                """,
                                funcDecl.name.str.length, funcDecl.name.str.buffer
                            )
                            var snapshot = code.toString().substring(mark)
                            var parser = ParserInit(
                                "generated",
                                snapshot.buffer,
                                snapshot.length,
                                checker.current,
                                checker.lita
                            )

                            parser.funcLevel += 1
                            var stmt = parser.statement()

                            // TODO make local variable
                            var temp = NewTempAssignment(context, stmt as (*Expr), .insert = false)
                            if(!checker.resolveStmt(temp)) {
                                printf("*************************BADx2\n")
                                return false
                            }

                            contParamName = temp.name.str.view

                            InsertStmt(context, temp, patch.block, tempDeclIndex += 1)

                            // finally add it to the first arg call
                            var idExpr = &NewIdentFromTemp(context, temp).asExpr
                            if(!checker.resolveStmt(idExpr)) {
                                printf("*************************BADy\n")
                                return false
                            }

                            funcCallExpr.arguments.set(0, CallArg {.argExpr = idExpr})
                        }
                    }

                    // if void return, patch up the temp assignment
                    var retType = typeInfo.returnType
                    if(retType != null && patch.ret) {
                        if(retType.kind == TypeKind.VOID) {
                            var returnNode = patch.ret.asNode();
                            var exprNode = patch.stmt.asNode();
                            var tempNode = patch.aux.asNode();

                            tempNode.kind = StmtKind.EMPTY_STMT;

                            *returnNode = *exprNode
                        } else {
                            assert(patch.aux.getKind() == StmtKind.VAR_DECL)

                            var tempVar = &patch.aux.asNode().varDecl
                            assert(tempVar.expr)

                            var coTempResult = NewTempAssignment(context, tempVar.expr, .insert = false)
                            if(!checker.resolveStmt(coTempResult)) {
                                printf("*************************BADz\n")
                                return false
                            }
                            InsertStmt(context, coTempResult, patch.block, tempDeclIndex += 1)

                            tempVar.expr = null
                            tempVar.typeSpec = retType.asTypeSpec(
                                context.module, true
                            )

                            assert(patch.label && patch.label.getKind() == StmtKind.LABEL_STMT)
                            var labelNode = patch.label.asNode()
                            labelNode.kind = StmtKind.EMPTY_STMT // we're moving the label

                            var label = &labelNode.labelStmt

                            // the temp var will continue to be the "defined"
                            // function call result, while the replaceVar will now be
                            // the continuation result
                            var mark = code.length

                            code.append(
                                """
                                if(%.*s == std::coroutine::ContinuationResult.SUSPENDED) {
                                    __cont.state += 1
                                    return std::coroutine::ContinuationResult.SUSPENDED
                                } else {
                                %.*s:
                                    __cont.state += 1
                                    %.*s = (%.*s.stack as (*%.*s__CoroutineStack)).__result__0
                                    FreeContinuation(%.*s)
                                }
                                """,
                                coTempResult.name.str.length, coTempResult.name.str.buffer,
                                label.label.str.length, label.label.str.buffer,
                                tempVar.name.str.length, tempVar.name.str.buffer,
                                contParamName.length, contParamName.buffer,
                                //sym.qualifiedName.length, sym.qualifiedName.buffer
                                typeInfo.name.length, typeInfo.name.buffer,
                                contParamName.length, contParamName.buffer
                            )

                            var snapshot = code.toString().substring(mark)
                            var parser = ParserInit(
                                "generated",
                                snapshot.buffer,
                                snapshot.length,
                                checker.current,
                                checker.lita
                            )

                            // TODO: Issue
                            // We need to basically forward declare all
                            // CoroutineStack variables because when we resolve these,
                            // we don't have the types yet in scope

                            parser.funcLevel += 1
                            var stmt = parser.statement()
                            if(!checker.resolveStmt(stmt)) {
                                printf("*************************BADw\n")
                                //checker.current.print("Bad Scope")
                                return false
                            }
                            InsertStmt(context, stmt, patch.block, tempDeclIndex += 1)
                        }
                    }

                    break
                }
                default: {
                    node.kind = StmtKind.GET_EXPR
                    node.getExpr.object = node.becomeParentOf(
                        &NewIdentifierExpr(
                            node.startPos, node.endPos,
                            NewNameTypeSpecIntern(
                                node.startPos,
                                continuationName,
                                &checker.current.typeSpecAllocator
                            ),
                            allocator
                        ).asExpr
                    )
                    node.getExpr.field = node.becomeParentOf(
                        &NewIdentifierExpr(
                            node.startPos, node.endPos,
                            NewNameTypeSpecIntern(
                                node.startPos,
                                patch.name,
                                &checker.current.typeSpecAllocator
                            ),
                            allocator
                        ).identifierExpr
                    )
                    break;
                }
            }

            if(!checker.resolveStmt(patch.stmt)) {
                printf("*************************BADv\n")
                //PrintStmt(funcDecl)
                return false
            }
        }
    }

    // Convert return to ContinuationResult
    {
        if(funcDecl.returnType != null) {
            var resultName = $"std::coroutine::ContinuationResult"
            funcDecl.returnType = NewNameTypeSpecIntern(
                funcDecl.getStartPos(),
                context.strings.internString(resultName),
                &checker.current.typeSpecAllocator
            )

            if(!checker.resolveTypeSpec(funcDecl.returnType)) {
                printf("*************************BAD2\n")
                return false
            }
        }
    }

    PrintStmt(funcDecl)
    checker.current.currentScope.print("Function Scope")

    // for(var i = 0; i < context.stack.size(); i+=1) {
    //     var e = context.stack.get(i)
    //     printf(
    //         "%.*s\n", e.length, e.buffer
    //     )
    // }
}

func FunctionLowering(context: *FuncLowerContext, ast: *Stmt) : *Stmt {
    if(!ast) {
        return null;
    }

    switch(ast.getKind()) {
        case StmtKind.TRAIT_DECL:
        case StmtKind.UNION_DECL:
        case StmtKind.STRUCT_DECL:
        case StmtKind.FUNC_DECL:
        case StmtKind.IMPORT_DECL:
        case StmtKind.TYPEDEF_DECL:
        case StmtKind.ENUM_DECL:
        case StmtKind.PARAM_DECL:
        case StmtKind.NATIVE_DECL:
        case StmtKind.POISON_DECL: {
            break;
        }
        case StmtKind.CONST_DECL:
        case StmtKind.VAR_DECL: {
            var decl = ast as (*VarDecl)
            if(decl.expr) {
                decl.expr = FunctionLowering(context, decl.expr) as (*Expr)
            }
            if(!(decl.flags & VarDeclFlags.IS_TEMPORARY)) {
                context.patches.add(
                    Patch {
                        .stmt = decl as (*Stmt),
                        .block = context.current.block,
                        .index = context.current.insertIndex,
                        .name = context.setVar(decl.name.str),
                    }
                )
            }
            break;
        }

        case StmtKind.FUNC_BODY_STMT:
        case StmtKind.BLOCK_STMT: {
            var body = ast as (*BlockStmt)

            var scope = BlockScope {
                .block = body,
                .insertIndex = 0,
                .numberOfInserts = 0,
            }

            context.push(&scope)
            defer context.pop()

            if(ast.getKind() == StmtKind.FUNC_BODY_STMT) {
                var params = context.funcDecl.params
                for(var i = 0; i < params.size(); i+=1) {
                    var param = params.get(i)
                    context.setVar(param.name.str)
                }
            }

            for(var i = 0; i < body.stmts.size(); i+=1) {
                var stmt = body.stmts.get(i)
                scope.insertIndex = i
                scope.noTemp = !RequiresFuncTempResult(stmt)

                stmt = FunctionLowering(context, stmt)
                i = i + scope.numberOfInserts
                body.stmts.set(i, stmt)

                scope.numberOfInserts = 0
            }
            break;
        }
        case StmtKind.BREAK_STMT: {
            break;
        }
        case StmtKind.COMP_STMT: {
            var comp = ast as (*CompStmt)
            if(comp.evaluatedStmt) {
                comp.evaluatedStmt = FunctionLowering(context, comp.evaluatedStmt)
            }
            if(comp.end) {
                comp.end = FunctionLowering(context, comp.end) as (*CompStmt)
            }
            for(var i = 0; i < comp.body.size(); i+=1) {
                var s = comp.body.get(i)
                s = FunctionLowering(context, s)
                comp.body.set(i, s)
            }
            break;
        }
        case StmtKind.CONTINUE_STMT: {
            break;
        }
        case StmtKind.DEFER_STMT: {
            var deferStmt = ast as (*DeferStmt)
            deferStmt.deferedStmt = FunctionLowering(context, deferStmt.deferedStmt)
            break;
        }
        case StmtKind.DO_WHILE_STMT: {
            var whileStmt = ast as (*DoWhileStmt)
            /*
                convert to:

                do {
                    body
                    if(cond)
                        continue
                    else
                        break
                } while(true);
            */

            var cond = whileStmt.cond

            var ifStmt = &NewIfStmt(
                cond.getStartPos(), cond.getEndPos(),
                cond,
                &NewContinueStmt(
                    cond.getStartPos(), cond.getEndPos(),
                    context.allocator
                ).asStmt,
                &NewBreakStmt(
                    cond.getStartPos(), cond.getEndPos(),
                    context.allocator
                ).asStmt,
                context.allocator
            ).asStmt

            var scope = BlockScope{}
            var block = PushBlock(context, &scope, whileStmt.body, ifStmt)
            defer context.pop()

            whileStmt.cond = &NewBooleanExpr(
                cond.getStartPos(), cond.getEndPos(),
                true,
                context.allocator
            ).asExpr

            whileStmt.body = FunctionLowering(context, block)
            whileStmt.cond = FunctionLowering(context, whileStmt.cond) as (*Expr)
            break;
        }
        case StmtKind.EMPTY_STMT: {
            break;
        }
        case StmtKind.FOR_STMT: {
            var forStmt = ast as (*ForStmt)
            /*
                lowered to:

                {
                    init
                    while(cond) {
                        body
                        post
                    }
                }
            */
            var stmts = ArrayInit<*Stmt>(2, context.allocator)
            if(forStmt.body) {
                stmts.add(forStmt.body)
            }
            if(forStmt.post) {
                stmts.add(forStmt.post)
            }

            var whileBodyNode = NewBlockStmt(
                forStmt.getStartPos(), forStmt.getEndPos(),
                stmts,
                context.allocator
            )
            var whileBody = &whileBodyNode.asStmt

            var cond = forStmt.cond ? forStmt.cond : &NewBooleanExpr(
                forStmt.getStartPos(), forStmt.getEndPos(),
                true,
                context.allocator
            ).asExpr

            var whileStmt = &NewWhileStmt(
                forStmt.getStartPos(), forStmt.getEndPos(),
                cond,
                whileBody,
                context.allocator
            ).asStmt

            var initStmt = forStmt.init ? forStmt.init : &NewEmptyStmt(
                forStmt.getStartPos(), forStmt.getEndPos(),
                context.allocator
            ).asStmt

            var scope = BlockScope{}
            var block = PushBlock(context, &scope, initStmt, whileStmt)
            defer context.pop()

            return FunctionLowering(context, block)
        }
        case StmtKind.GOTO_STMT: {
            break;
        }
        case StmtKind.IF_STMT: {
            var ifStmt = ast as (*IfStmt)

            /*
                Lower to:

                {
                if(cond)
                    {body}
                else
                    {other}
                }

                which if else's get modified to:

                {
                    if(cond)
                        {body}
                    else
                        {
                            if(cond)
                                {body}
                            else
                                {other}
                        }
                }
            */
            var scope = BlockScope{}
            var block = PushBlock(context, &scope, ifStmt)
            defer context.pop()

            ifStmt.cond = FunctionLowering(context, ifStmt.cond) as (*Expr)
            {
                var scope = BlockScope{}
                var thenBlock = PushBlock(context, &scope, ifStmt.then)
                defer context.pop()

                ifStmt.then = FunctionLowering(context, thenBlock)
            }

            if(ifStmt.elseStmt) {
                var scope = BlockScope{}
                var elseBlock = PushBlock(context, &scope, ifStmt.elseStmt)
                defer context.pop()

                ifStmt.elseStmt = FunctionLowering(context, elseBlock)
            }

            return block as (*Stmt)
        }
        case StmtKind.LABEL_STMT: {
            break;
        }
        case StmtKind.MODULE_STMT: {
            break;
        }
        case StmtKind.NOTE_STMT: {
            break;
        }
        case StmtKind.PARAMETERS_STMT: {
            var params = ast as (*ParametersStmt)
            for(var i = 0; i < params.size(); i += 1) {
                var param = params.get(i)

                param = FunctionLowering(context, param) as (*ParameterDecl)
                params.set(i, param)
            }
            break;
        }
        case StmtKind.RETURN_STMT: {
            var stmt = ast as (*ReturnStmt)
            if(stmt.expr) {
                var expr = FunctionLowering(context, stmt.expr) as (*Expr)
                var varDecl = NewTempAssignment(context, expr, "result__0")
                context.patches.add(
                    Patch {
                        .stmt = varDecl as (*Stmt),
                        .block = context.current.block,
                        .index = context.current.insertIndex,
                        .name = context.setVar(varDecl.name.str, false),
                    }
                )

                // TODO return ContinuationResult
                stmt.expr = expr
                context.patches.add(
                    Patch {
                        .stmt = stmt as (*Stmt),
                        .block = context.current.block,
                        .index = context.current.insertIndex,
                    }
                )
            }
            break;
        }
        case StmtKind.SWITCH_CASE_STMT: {
            var caseStmt = ast as (*SwitchCaseStmt)
            caseStmt.cond = FunctionLowering(context, caseStmt.cond) as (*Expr)
            caseStmt.body = FunctionLowering(context, caseStmt.body)
            break;
        }
        case StmtKind.SWITCH_STMT:{
            var switchStmt = ast as (*SwitchStmt)
            /*
                lowered to

                {
                    switch(cond) {
                        case c1: stmt
                    }
                }
            */
            var scope = BlockScope{}
            var block = PushBlock(context, &scope, switchStmt)
            defer context.pop()

            switchStmt.cond = FunctionLowering(context, switchStmt.cond) as (*Expr)
            for(var i = 0; i < switchStmt.cases.size(); i+=1) {
                var caseStmt = switchStmt.cases.get(i)
                caseStmt = FunctionLowering(context, caseStmt) as (*SwitchCaseStmt)
                switchStmt.cases.set(i, caseStmt)
            }
            if(switchStmt.defaultStmt) {
                switchStmt.defaultStmt = FunctionLowering(context, switchStmt.defaultStmt)
            }

            return block as (*Stmt)
        }
        case StmtKind.ENUM_FIELD_DECL:
        case StmtKind.ENUM_FIELD_ENTRY_DECL:
        case StmtKind.STRUCT_FIELD_DECL:
        case StmtKind.UNION_FIELD_DECL:
        case StmtKind.TRAIT_FIELD_DECL:
        case StmtKind.VAR_FIELD_DECL: {
            // TODO: Is this needed??
            break;
        }
        case StmtKind.WHILE_STMT: {
            var whileStmt = ast as (*WhileStmt)

            /*
                Convert to:
                while(true) {
                    if(cond)
                        body
                    else
                        break;
                }
            */

            var cond = whileStmt.cond

            whileStmt.cond = &NewBooleanExpr(
                cond.getStartPos(), cond.getEndPos(),
                true,
                context.allocator
            ).asExpr

            whileStmt.body = &NewIfStmt(
                cond.getStartPos(), cond.getEndPos(),
                cond,
                whileStmt.body,
                &NewBreakStmt(
                    cond.getStartPos(), cond.getEndPos(),
                    context.allocator
                ).asStmt,
                context.allocator
            ).asStmt

            whileStmt.cond = FunctionLowering(context, whileStmt.cond) as (*Expr)
            whileStmt.body = FunctionLowering(context, whileStmt.body)
            break;
        }


        /*--------------------------------------
            Expressions
        ----------------------------------------*/
        case StmtKind.ARRAY_DESIGNATION_EXPR: {
            var expr = ast as (*ArrayDesignationExpr)
            expr.index = FunctionLowering(context, expr.index) as (*Expr)
            expr.value = FunctionLowering(context, expr.value) as (*Expr)
            break;
        }
        case StmtKind.ARRAY_INIT_EXPR: {
            var expr = ast as (*ArrayInitExpr)
            for(var i = 0; i < expr.values.size(); i += 1) {
                var arg = expr.values.get(i)
                arg = FunctionLowering(context, arg) as (*Expr)
                expr.values.set(i, arg)
            }
            break;
        }
        case StmtKind.BINARY_EXPR: {
            var expr = ast as (*BinaryExpr)
            /*
                left && right

                lowered to:

                var result = false
                var t1 = left
                if (t1) {
                    var t2 = right
                    if (t2) {
                        result = true
                    }
                }
            */
            if(expr.operator == TokenType.AND) {
                var result = NewTempAssignment(
                    context,
                    &NewBooleanExpr(
                        expr.getStartPos(), expr.getEndPos(),
                        false,
                        context.allocator
                    ).asExpr
                )

                var nameTypeSpec = NewNameTypeSpecIntern(
                    expr.getStartPos(),
                    result.name.str,
                    &context.module.typeSpecAllocator
                )

                var resultExpr = &NewIdentifierExpr(
                    expr.getStartPos(), expr.getEndPos(),
                    nameTypeSpec,
                    context.allocator
                ).asExpr

                var ifRight = &NewIfStmt(
                    expr.getStartPos(), expr.getEndPos(),
                    expr.right,
                    &NewBinaryExpr(
                        expr.getStartPos(), expr.getEndPos(),
                        resultExpr,
                        TokenType.EQUALS,
                        &NewBooleanExpr(
                            expr.getStartPos(), expr.getEndPos(),
                            true,
                            context.allocator
                        ).asExpr,
                        context.allocator
                    ).asStmt,
                    null,
                    context.allocator
                ).asStmt

                ifRight = FunctionLowering(context, ifRight)

                var ifLeft = &NewIfStmt(
                    expr.getStartPos(), expr.getEndPos(),
                    expr.left,
                    ifRight,
                    null,
                    context.allocator
                ).asStmt

                ifLeft = FunctionLowering(context, ifLeft)
                InsertTempStmt(context, ifLeft, .atEnd = true)

                return resultExpr as (*Stmt)
            }
            /*
                left || right

                lowered to:

                var result = false
                var t1 = left
                if (t1) {
                    result = true
                } else {
                    var t2 = right
                    if (t2) {
                        result = true
                    }
                }
            */
            else if(expr.operator == TokenType.OR) {
                var result = NewTempAssignment(
                    context,
                    &NewBooleanExpr(
                        expr.getStartPos(), expr.getEndPos(),
                        false,
                        context.allocator
                    ).asExpr
                )

                var nameTypeSpec = NewNameTypeSpecIntern(
                    expr.getStartPos(),
                    result.name.str,
                    &context.module.typeSpecAllocator
                )

                var resultExpr = &NewIdentifierExpr(
                    expr.getStartPos(), expr.getEndPos(),
                    nameTypeSpec,
                    context.allocator
                ).asExpr

                var ifRight = &NewIfStmt(
                    expr.getStartPos(), expr.getEndPos(),
                    expr.right,
                    &NewBinaryExpr(
                        expr.getStartPos(), expr.getEndPos(),
                        resultExpr,
                        TokenType.EQUALS,
                        &NewBooleanExpr(
                            expr.getStartPos(), expr.getEndPos(),
                            true,
                            context.allocator
                        ).asExpr,
                        context.allocator
                    ).asStmt,
                    null,
                    context.allocator
                ).asStmt

                ifRight = FunctionLowering(context, ifRight)

                var ifLeft = &NewIfStmt(
                    expr.getStartPos(), expr.getEndPos(),
                    expr.left,
                    &NewBinaryExpr(
                        expr.getStartPos(), expr.getEndPos(),
                        resultExpr,
                        TokenType.EQUALS,
                        &NewBooleanExpr(
                            expr.getStartPos(), expr.getEndPos(),
                            true,
                            context.allocator
                        ).asExpr,
                        context.allocator
                    ).asStmt,
                    ifRight,
                    context.allocator
                ).asStmt

                ifLeft = FunctionLowering(context, ifLeft)
                InsertTempStmt(context, ifLeft, .atEnd = true)

                return resultExpr as (*Stmt)
            } else {
                expr.left = FunctionLowering(context, expr.left) as (*Expr)
                expr.right = FunctionLowering(context, expr.right) as (*Expr)
            }
            break;
        }
        case StmtKind.BOOLEAN_EXPR: {
            break;
        }
        case StmtKind.CAST_EXPR: {
            var expr = ast as (*CastExpr)
            expr.exprToCast = FunctionLowering(context, expr.exprToCast) as (*Expr)
            break;
        }
        case StmtKind.CHAR_EXPR: {
            break;
        }
        case StmtKind.FUNC_CALL_EXPR: {
            var expr = ast as (*FuncCallExpr)
            /*
                Lowered to

                var t1 = call()
                t1

                ordering:

                expr.object
                a1
                a2
                ...

                var t1 = temp
                t1

                Coroutine:


                var t0 = Continuation {
                    .stack = X__CoroutineStack{
                        .param1__1 = a1,
                        .param2__1 = a2,
                    }
                }
                var t1 = callWrapper(&t0)
                LABEL__X:
                t1
            */
            expr.object = FunctionLowering(context, expr.object) as (*Expr)

            var nullExpr = &NewNullExpr(
                expr.getStartPos(),
                expr.getEndPos(),
                context.allocator
            ).asExpr

            // create a temporary argument for the passed in continuation
            // if this isn't a continuation, we will patch this argument out
            expr.arguments.insertAt(0, CallArg {.argExpr = nullExpr})

            for(var i = 0; i < expr.arguments.size(); i += 1) {
                var arg = expr.arguments.getPtr(i)
                arg.argExpr = FunctionLowering(context, arg.argExpr) as (*Expr)
            }

            var temp = NewTempAssignment(context, expr)
            var label = InsertLabel(context, temp)

            var idExpr = &NewIdentFromTemp(context, temp).asStmt
            // var nameTypeSpec = NewNameTypeSpecIntern(
            //     expr.getStartPos(),
            //     temp.name.str,
            //     &context.module.typeSpecAllocator
            // )

            // var idExpr = &NewIdentifierExpr(
            //     expr.getStartPos(),
            //     expr.getEndPos(),
            //     nameTypeSpec,
            //     context.allocator
            // ).asStmt

            context.patches.add(
                Patch {
                    .stmt = expr as (*Stmt),
                    .block = context.current.block,
                    .index = context.current.insertIndex + context.current.numberOfInserts + 1,
                    .aux = temp as (*Stmt),
                    .label = label,
                    .ret = idExpr
                }
            )

            return idExpr
        }
        case StmtKind.GET_EXPR: {
            var expr = ast as (*GetExpr)
            expr.object = FunctionLowering(context, expr.object) as (*Expr)
            expr.field = FunctionLowering(context, expr.field) as (*IdentifierExpr)
            break;
        }
        case StmtKind.GROUP_EXPR: {
            var expr = ast as (*GroupExpr)
            expr.groupedExpr = FunctionLowering(context, expr.groupedExpr) as (*Expr)
            break;
        }
        case StmtKind.FUNC_IDENTIFIER_EXPR:
        case StmtKind.IDENTIFIER_EXPR: {
            var expr = ast as (*IdentifierExpr)
            if (expr.type.kind == TypeSpecKind.NAME) {
                var name = context.getVar(expr.type.name)
                if (name.length != 0) {
                    // printf("~%.*s vs %.*s\n",
                    //     expr.type.name.length, expr.type.name.buffer,
                    //     name.length, name.buffer
                    // )
                    context.patches.add(
                        Patch {
                            .stmt = expr as (*Stmt),
                            .block = context.current.block,
                            .index = context.current.insertIndex,
                            .name = name
                        }
                    )
                }
            }
            break;
        }
        case StmtKind.INIT_EXPR: {
            var expr = ast as (*InitExpr)

            for(var i = 0; i < expr.arguments.size(); i += 1) {
                var arg = expr.arguments.get(i)
                arg = FunctionLowering(context, arg) as (*InitArgExpr)
                expr.arguments.set(i, arg)
            }
            break;
        }
        case StmtKind.INIT_ARG_EXPR: {
            var expr = ast as (*InitArgExpr)
            expr.value = FunctionLowering(context, expr.value) as (*Expr)
            break;
        }
        case StmtKind.NULL_EXPR: {
            break;
        }
        case StmtKind.NUMBER_EXPR: {
            break;
        }
        case StmtKind.OFFSET_OF_EXPR: {
            var expr = ast as (*OffsetOfExpr)
            break;
        }
        case StmtKind.SET_EXPR: {
            var expr = ast as (*SetExpr)
            expr.object = FunctionLowering(context, expr.object) as (*Expr)
            expr.field = FunctionLowering(context, expr.field) as (*IdentifierExpr)
            expr.value = FunctionLowering(context, expr.value) as (*Expr)
            break;
        }
        case StmtKind.SIZE_OF_EXPR: {
            var expr = ast as (*SizeOfExpr)
            expr.sizeOfExpr = FunctionLowering(context, expr.sizeOfExpr) as (*Expr)
            break;
        }
        case StmtKind.NATIVE_STRING_EXPR: {
            break;
        }
        case StmtKind.STRING_EXPR: {
            break;
        }
        case StmtKind.SUBSCRIPT_GET_EXPR: {
            var expr = ast as (*SubscriptGetExpr)
            expr.object = FunctionLowering(context, expr.object) as (*Expr)
            expr.index = FunctionLowering(context, expr.index) as (*Expr)
            break;
        }
        case StmtKind.SUBSCRIPT_SET_EXPR: {
            var expr = ast as (*SubscriptSetExpr)
            expr.object = FunctionLowering(context, expr.object) as (*Expr)
            expr.index = FunctionLowering(context, expr.index) as (*Expr)
            expr.value = FunctionLowering(context, expr.value) as (*Expr)
            break;
        }
        case StmtKind.TERNARY_EXPR: {
            var expr = ast as (*TernaryExpr)
            /*
                var x = cond ? then : other

                lowered to

                var result
                if (cond) {
                    result = then
                } else {
                    result = other
                }
                result
            */
            var resultTemp = NewTempEmptyAssignment(context, expr.then, true)
            resultTemp.flags |= VarDeclFlags.IS_TERNARY

            var nameTypeSpec = NewNameTypeSpecIntern(
                expr.getStartPos(),
                resultTemp.name.str,
                &context.module.typeSpecAllocator
            )

            var resultExpr = &NewIdentifierExpr(
                expr.getStartPos(), expr.getEndPos(),
                nameTypeSpec,
                context.allocator
            ).asExpr

            var thenExprNode = NewBinaryExpr(
                expr.getStartPos(), expr.getEndPos(),
                resultExpr,
                TokenType.EQUALS,
                expr.then,
                context.allocator
            )

            // mark this as a ternary lowering declaration
            var binExpr = &thenExprNode.binaryExpr
            binExpr.ternaryDecl = resultTemp

            var ifStmt = &NewIfStmt(
                expr.getStartPos(), expr.getEndPos(),
                expr.cond,
                thenExprNode.asStmt,
                &NewBinaryExpr(
                    expr.getStartPos(), expr.getEndPos(),
                    resultExpr,
                    TokenType.EQUALS,
                    expr.other,
                    context.allocator
                ).asStmt,
                context.allocator
            ).asStmt

            ifStmt = FunctionLowering(context, ifStmt)
            InsertTempStmt(context, ifStmt, .atEnd = true)

            return resultExpr as (*Stmt)
        }
        case StmtKind.TYPE_IDENTIFIER_EXPR: {
            var expr = ast as (*TypeIdentifierExpr)
            break;
        }
        case StmtKind.NAME_OF_EXPR:
        case StmtKind.TYPE_OF_EXPR: {
            var expr = ast as (*TypeOfExpr)
            expr.typeOfExpr = FunctionLowering(context, expr.typeOfExpr) as (*Expr)
            break;
        }
        case StmtKind.UNARY_EXPR: {
            var expr = ast as (*UnaryExpr)
            expr.unaryExpr = FunctionLowering(context, expr.unaryExpr) as (*Expr)
            break;
        }
        case StmtKind.POISON_EXPR: {
            break;
        }
        default: {
            printf("Statement Kind: %s\n", StmtKindAsStr(ast.getKind()))
            assert(false)
        }
    }
    return ast
}


func RequiresFuncTempResult(ast: *Stmt) : bool {
    if(!ast) {
        return false;
    }

    switch(ast.getKind()) {
        case StmtKind.TRAIT_DECL:
        case StmtKind.UNION_DECL:
        case StmtKind.STRUCT_DECL:
        case StmtKind.FUNC_DECL:
        case StmtKind.IMPORT_DECL:
        case StmtKind.TYPEDEF_DECL:
        case StmtKind.ENUM_DECL:
        case StmtKind.PARAM_DECL:
        case StmtKind.NATIVE_DECL:
        case StmtKind.POISON_DECL: {
            break;
        }
        case StmtKind.CONST_DECL:
        case StmtKind.VAR_DECL: {
            return true;
        }

        case StmtKind.FUNC_BODY_STMT:
        case StmtKind.BLOCK_STMT:
        case StmtKind.BREAK_STMT:
        case StmtKind.COMP_STMT:
        case StmtKind.CONTINUE_STMT:
        case StmtKind.DEFER_STMT: {
            break;
        }
        case StmtKind.DO_WHILE_STMT: {
            return true;
        }
        case StmtKind.EMPTY_STMT: {
            break;
        }
        case StmtKind.FOR_STMT: {
            return true;
        }
        case StmtKind.GOTO_STMT: {
            break;
        }
        case StmtKind.IF_STMT: {
            return true;
        }
        case StmtKind.LABEL_STMT: {
            break;
        }
        case StmtKind.MODULE_STMT: {
            break;
        }
        case StmtKind.NOTE_STMT: {
            break;
        }
        case StmtKind.PARAMETERS_STMT: {
            break;
        }
        case StmtKind.RETURN_STMT: {
            return true;
        }
        case StmtKind.SWITCH_CASE_STMT: {
            break;
        }
        case StmtKind.SWITCH_STMT:{
            return true;
        }
        case StmtKind.ENUM_FIELD_DECL:
        case StmtKind.ENUM_FIELD_ENTRY_DECL:
        case StmtKind.STRUCT_FIELD_DECL:
        case StmtKind.UNION_FIELD_DECL:
        case StmtKind.TRAIT_FIELD_DECL:
        case StmtKind.VAR_FIELD_DECL: {
            break;
        }
        case StmtKind.WHILE_STMT: {
            return true;
        }


        /*--------------------------------------
            Expressions
        ----------------------------------------*/
        case StmtKind.ARRAY_DESIGNATION_EXPR: {
            return true;
        }
        case StmtKind.ARRAY_INIT_EXPR: {
            return true;
        }
        case StmtKind.BINARY_EXPR: {
            return true;
        }
        case StmtKind.BOOLEAN_EXPR: {
            break;
        }
        case StmtKind.CAST_EXPR: {
            return true;
        }
        case StmtKind.CHAR_EXPR: {
            break;
        }
        case StmtKind.FUNC_CALL_EXPR: {
            break;
        }
        case StmtKind.FUNC_IDENTIFIER_EXPR: {
            break;
        }
        case StmtKind.GET_EXPR: {
            break;
        }
        case StmtKind.GROUP_EXPR: {
            break;
        }
        case StmtKind.IDENTIFIER_EXPR: {
            break;
        }
        case StmtKind.INIT_EXPR: {
            return true;
        }
        case StmtKind.INIT_ARG_EXPR: {
            break;
        }
        case StmtKind.NULL_EXPR: {
            break;
        }
        case StmtKind.NUMBER_EXPR: {
            break;
        }
        case StmtKind.OFFSET_OF_EXPR: {
            return true;
        }
        case StmtKind.SET_EXPR: {
            return true;
        }
        case StmtKind.SIZE_OF_EXPR: {
            return true;
        }
        case StmtKind.NATIVE_STRING_EXPR: {
            break;
        }
        case StmtKind.STRING_EXPR: {
            break;
        }
        case StmtKind.SUBSCRIPT_GET_EXPR: {
            break;
        }
        case StmtKind.SUBSCRIPT_SET_EXPR: {
            return true;
        }
        case StmtKind.TERNARY_EXPR: {
            return true;
        }
        case StmtKind.TYPE_IDENTIFIER_EXPR: {
            break;
        }
        case StmtKind.NAME_OF_EXPR:
        case StmtKind.TYPE_OF_EXPR: {
            return true;
        }
        case StmtKind.UNARY_EXPR: {
            return true;
        }
        case StmtKind.POISON_EXPR: {
            break;
        }
        default: {
            printf("Statement Kind: %s\n", StmtKindAsStr(ast.getKind()))
            assert(false)
        }
    }
    return false
}