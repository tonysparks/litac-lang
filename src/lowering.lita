import "std/array"
import "std/mem"
import "std/map"
import "std/libc"
import "std/hash"
import "std/string"
import "std/string/builder"
import "std/string/buffer"
import "std/assert"

import "intern"
import "symbols"
import "types"

import "lita"
import "ast"
import "ast_copy"
import "ast_new"
import "parser"
import "checker"
import "lex"
import "module"
import "common"

public struct FuncLowerContext {
    allocator: *const Allocator
    strings: *Strings
    module: *Module

    funcDecl: *FuncDecl
    tempIndex: u32

    current: *BlockScope
}

func (this: *FuncLowerContext) push(scope: *BlockScope) {
    var current = this.current
    this.current = scope
    scope.parent = current
}
func (this: *FuncLowerContext) pop() {
    if(!this.current) return;

    var parent = this.current.parent
    this.current = parent
}
func (this: *FuncLowerContext) currentBlock(): *BlockStmt {
    if(!this.current) return null;
    return this.current.block
}

struct BlockScope {
    parent: *BlockScope
    block: *BlockStmt
    insertIndex: i32
    numberOfInserts: i32
    noTemp: bool
}

func NewTempName(context: *FuncLowerContext) : StringBuilder {
    var name = StringBuilderInit(MAX_SYMBOL_NAME, context.allocator)
    name.append("__%d", context.tempIndex += 1)
    return name
}

func NewTempAssignment(context: *FuncLowerContext, expr: *Expr) : *VarDecl {
    var name = NewTempName(context)

    var temp = NewVarDecl(
        expr.startPos,
        expr.endPos,
        NewIdentifier(
            name.cStr(),
            expr.startPos,
            context.strings
        ),
        null,
        expr,
        context.allocator
    )
/*
    // TODO: This does right to left ordering of parameters
    // we probably want left to right even though this
    // isn't standard in C
    var scope = context.current
    var index = scope.insertIndex// + scope.numberOfInserts
    // printf("Inserting at %d\n", index)
    scope.block.stmts.insertAt(index, temp as (*Stmt))
    scope.block.becomeParentOf(temp)
    scope.numberOfInserts += 1
*/
    InsertTempStmt(context, temp as (*Stmt), .atEnd = true)

    return temp as (*VarDecl)
}

func NewTempEmptyAssignment(context: *FuncLowerContext, expr: *Expr) : *VarDecl {
    var name = NewTempName(context)

    var temp = NewVarDecl(
        expr.startPos,
        expr.endPos,
        NewIdentifier(
            name.cStr(),
            expr.startPos,
            context.strings
        ),
        expr.operand.typeInfo.asTypeSpec(
            context.module, true
        ),
        null,
        context.allocator
    )

    InsertTempStmt(context, temp as (*Stmt), .atEnd = true)
    return temp as (*VarDecl)
}

func InsertTempStmt(
    context: *FuncLowerContext,
    stmt: *Stmt,
    atEnd: bool
) {

    // TODO: This does right to left ordering of parameters
    // we probably want left to right even though this
    // isn't standard in C
    var scope = context.current
    var index = scope.insertIndex// + scope.numberOfInserts
    if(atEnd) {
        index += scope.numberOfInserts
    }
    // printf("Inserting at %d\n", index)
    scope.block.stmts.insertAt(index, stmt)
    scope.block.becomeParentOf(stmt)
    scope.numberOfInserts += 1
}

func PushBlock(
    context: *FuncLowerContext,
    scope: *BlockScope,
    stmt1: *Stmt,
    stmt2: *Stmt = null
) : *BlockStmt {
    var stmts = ArrayInit<*Stmt>(2, context.allocator)
    stmts.add(stmt1)
    if(stmt2) {
        stmts.add(stmt2)
    }

    var block = NewBlockStmt(
        stmt1.startPos, stmt1.endPos,
        stmts,
        context.allocator
    ) as (*BlockStmt)

    scope.block = block
    scope.insertIndex = 0
    scope.numberOfInserts = 0

    context.push(scope)
    return block
}

/**
    Convert function call expressions into lowered expressions:

    var x = object.value(call1(), call2()) ?
    object.value1(call3(), call4()) :
    object.value2(call6(), call6())

    var x = undefined
    var _1 = call1()
    var _2 = call2()
    var _r3 = object.value(_1, _2)
    if (_r3) {
        var _3 = call3()
        var _4 = call4()
        x = object.value(_3, _4)
    } else {
        var _5 = call5()
        var _6 = call6()
        x = object.value(_5, _6)
    }
*/
public func LowerFuncBody(checker: *TypeChecker, funcDecl: *FuncDecl) {
    if(!funcDecl.body) {
        return;
    }

    var context = FuncLowerContext {
        .allocator = checker.allocator,
        .strings = &checker.strings,
        .module = checker.current,
        .funcDecl = funcDecl,
        .tempIndex = 0_u32,
        .current = null,
    }

    if(funcDecl.body.kind != StmtKind.FUNC_BODY_STMT) {
        var body = funcDecl.body
        var stmts = ArrayInit<*Stmt>(1, checker.allocator)
        stmts.add(body)

        funcDecl.body = NewFuncBodyStmt(
            body.startPos, body.endPos,
            stmts,
            checker.allocator
        )
    }

    funcDecl.body = FunctionLowering(&context, funcDecl.body) as (*Stmt)
}

func FunctionLowering(context: *FuncLowerContext, ast: *Node) : *Node {
    if(!ast) {
        return null;
    }

    switch(ast.kind) {
        case StmtKind.TRAIT_DECL:
        case StmtKind.UNION_DECL:
        case StmtKind.STRUCT_DECL:
        case StmtKind.FUNC_DECL:
        case StmtKind.IMPORT_DECL:
        case StmtKind.TYPEDEF_DECL:
        case StmtKind.ENUM_DECL:
        case StmtKind.PARAM_DECL:
        case StmtKind.NATIVE_DECL:
        case StmtKind.POISON_DECL: {
            break;
        }
        case StmtKind.CONST_DECL:
        case StmtKind.VAR_DECL: {
            var decl = ast as (*VarDecl)
            if(decl.expr) {
                decl.expr = FunctionLowering(context, decl.expr) as (*Expr)
            }
            break;
        }

        case StmtKind.FUNC_BODY_STMT:
        case StmtKind.BLOCK_STMT: {
            var body = ast as (*BlockStmt)

            var scope = BlockScope {
                .block = body,
                .insertIndex = 0,
                .numberOfInserts = 0,
            }

            context.push(&scope)
            defer context.pop()

            for(var i = 0; i < body.stmts.size(); i+=1) {
                var stmt = body.stmts.get(i)
                scope.insertIndex = i
                scope.noTemp = !RequiresFuncTempResult(stmt)

                stmt = FunctionLowering(context, stmt) as (*Stmt)
                i = i + scope.numberOfInserts
                body.stmts.set(i, stmt)

                scope.numberOfInserts = 0
            }
            break;
        }
        case StmtKind.BREAK_STMT: {
            break;
        }
        case StmtKind.COMP_STMT: {
            var comp = ast as (*CompStmt)
            if(comp.evaluatedStmt) {
                comp.evaluatedStmt = FunctionLowering(context, comp.evaluatedStmt) as (*Stmt)
            }
            if(comp.end) {
                comp.end = FunctionLowering(context, comp.end) as (*CompStmt)
            }
            for(var i = 0; i < comp.body.size(); i+=1) {
                var s = comp.body.get(i)
                s = FunctionLowering(context, s) as (*Stmt)
                comp.body.set(i, s)
            }
            break;
        }
        case StmtKind.CONTINUE_STMT: {
            break;
        }
        case StmtKind.DEFER_STMT: {
            var deferStmt = ast as (*DeferStmt)
            deferStmt.deferedStmt = FunctionLowering(context, deferStmt.deferedStmt) as (*Stmt)
            break;
        }
        case StmtKind.DO_WHILE_STMT: {
            var whileStmt = ast as (*DoWhileStmt)
            /*
                convert to:

                do {
                    body
                    if(cond)
                        continue
                    else
                        break
                } while(true);
            */

            var cond = whileStmt.cond

            var ifStmt = NewIfStmt(
                cond.startPos, cond.endPos,
                cond,
                NewContinueStmt(
                    cond.startPos, cond.endPos,
                    context.allocator
                ),
                NewBreakStmt(
                    cond.startPos, cond.endPos,
                    context.allocator
                ),
                context.allocator
            )

            var scope = BlockScope{}
            var block = PushBlock(context, &scope, whileStmt.body, ifStmt)
            defer context.pop()

            whileStmt.cond = NewBooleanExpr(
                cond.startPos, cond.endPos,
                true,
                context.allocator
            )

            whileStmt.body = FunctionLowering(context, block) as (*Stmt)
            whileStmt.cond = FunctionLowering(context, whileStmt.cond) as (*Expr)
            break;
        }
        case StmtKind.EMPTY_STMT: {
            break;
        }
        case StmtKind.FOR_STMT: {
            var forStmt = ast as (*ForStmt)
            /*
                lowered to:

                {
                    init
                    while(cond) {
                        body
                        post
                    }
                }
            */
            var stmts = ArrayInit<*Stmt>(2, context.allocator)
            if(forStmt.body) {
                stmts.add(forStmt.body)
            }
            if(forStmt.post) {
                stmts.add(forStmt.post)
            }

            var whileBody = NewBlockStmt(
                forStmt.startPos, forStmt.endPos,
                stmts,
                context.allocator
            )

            var whileStmt = NewWhileStmt(
                forStmt.startPos, forStmt.endPos,
                forStmt.cond,
                whileBody,
                context.allocator
            )

            var initStmt = forStmt.init ? forStmt.init : NewEmptyStmt(
                forStmt.startPos, forStmt.endPos,
                context.allocator
            )

            var scope = BlockScope{}
            var block = PushBlock(context, &scope, initStmt, whileStmt)
            defer context.pop()

            return FunctionLowering(context, block) as (*Node)
        }
        case StmtKind.GOTO_STMT: {
            break;
        }
        case StmtKind.IF_STMT: {
            var ifStmt = ast as (*IfStmt)

            /*
                Lower to:

                {
                if(cond)
                    {body}
                else
                    {other}
                }

                which if else's get modified to:

                {
                    if(cond)
                        {body}
                    else
                        {
                            if(cond)
                                {body}
                            else
                                {other}
                        }
                }
            */
            var scope = BlockScope{}
            var block = PushBlock(context, &scope, ifStmt)
            defer context.pop()

            ifStmt.cond = FunctionLowering(context, ifStmt.cond) as (*Expr)
            {
                var scope = BlockScope{}
                var thenBlock = PushBlock(context, &scope, ifStmt.then)
                defer context.pop()

                ifStmt.then = FunctionLowering(context, thenBlock) as (*Stmt)
            }

            if(ifStmt.elseStmt) {
                var scope = BlockScope{}
                var elseBlock = PushBlock(context, &scope, ifStmt.elseStmt)
                defer context.pop()

                ifStmt.elseStmt = FunctionLowering(context, elseBlock) as (*Stmt)
            }

            return block as (*Node)
        }
        case StmtKind.LABEL_STMT: {
            break;
        }
        case StmtKind.MODULE_STMT: {
            break;
        }
        case StmtKind.NOTE_STMT: {
            break;
        }
        case StmtKind.PARAMETERS_STMT: {
            var params = ast as (*ParametersStmt)
            for(var i = 0; i < params.size(); i += 1) {
                var param = params.get(i)

                param = FunctionLowering(context, param) as (*ParameterDecl)
                params.set(i, param)
            }
            break;
        }
        case StmtKind.RETURN_STMT: {
            var stmt = ast as (*ReturnStmt)
            if(stmt.expr) {
                stmt.expr = FunctionLowering(context, stmt.expr) as (*Expr)
            }
            break;
        }
        case StmtKind.SWITCH_CASE_STMT: {
            var caseStmt = ast as (*SwitchCaseStmt)
            caseStmt.cond = FunctionLowering(context, caseStmt.cond) as (*Expr)
            caseStmt.body = FunctionLowering(context, caseStmt.body) as (*Stmt)
            break;
        }
        case StmtKind.SWITCH_STMT:{
            var switchStmt = ast as (*SwitchStmt)
            /*
                lowered to

                {
                    switch(cond) {
                        case c1: stmt
                    }
                }
            */
            var scope = BlockScope{}
            var block = PushBlock(context, &scope, switchStmt)
            defer context.pop()

            switchStmt.cond = FunctionLowering(context, switchStmt.cond) as (*Expr)
            for(var i = 0; i < switchStmt.cases.size(); i+=1) {
                var caseStmt = switchStmt.cases.get(i)
                caseStmt = FunctionLowering(context, caseStmt) as (*SwitchCaseStmt)
                switchStmt.cases.set(i, caseStmt)
            }
            if(switchStmt.defaultStmt) {
                switchStmt.defaultStmt = FunctionLowering(context, switchStmt.defaultStmt) as (*Stmt)
            }

            return block as (*Node)
        }
        case StmtKind.ENUM_FIELD_DECL:
        case StmtKind.ENUM_FIELD_ENTRY_DECL:
        case StmtKind.STRUCT_FIELD_DECL:
        case StmtKind.UNION_FIELD_DECL:
        case StmtKind.TRAIT_FIELD_DECL:
        case StmtKind.VAR_FIELD_DECL: {
            // TODO: Is this needed??
            break;
        }
        case StmtKind.WHILE_STMT: {
            var whileStmt = ast as (*WhileStmt)

            /*
                Convert to:
                while(true) {
                    if(cond)
                        body
                    else
                        break;
                }
            */

            var cond = whileStmt.cond

            whileStmt.cond = NewBooleanExpr(
                cond.startPos, cond.endPos,
                true,
                context.allocator
            )

            whileStmt.body = NewIfStmt(
                cond.startPos, cond.endPos,
                cond,
                whileStmt.body,
                NewBreakStmt(
                    cond.startPos, cond.endPos,
                    context.allocator
                ),
                context.allocator
            )

            whileStmt.cond = FunctionLowering(context, whileStmt.cond) as (*Expr)
            whileStmt.body = FunctionLowering(context, whileStmt.body) as (*Stmt)
            break;
        }


        /*--------------------------------------
            Expressions
        ----------------------------------------*/
        case StmtKind.ARRAY_DESIGNATION_EXPR: {
            var expr = ast as (*ArrayDesignationExpr)
            FunctionLowering(context, expr.index)
            FunctionLowering(context, expr.value)
            break;
        }
        case StmtKind.ARRAY_INIT_EXPR: {
            var expr = ast as (*ArrayInitExpr)
            for(var i = 0; i < expr.values.size(); i += 1) {
                FunctionLowering(context, expr.values.get(i))
            }
            break;
        }
        case StmtKind.BINARY_EXPR: {
            var expr = ast as (*BinaryExpr)
            /*
                left && right

                lowered to:

                var result = false
                var t1 = left
                if (t1) {
                    var t2 = right
                    if (t2) {
                        result = true
                    }
                }
            */
            if(expr.operator == TokenType.AND) {
                var result = NewTempAssignment(
                    context,
                    NewBooleanExpr(
                        expr.startPos, expr.endPos,
                        false,
                        context.allocator
                    )
                )

                var nameTypeSpec = NewNameTypeSpecIntern(
                    expr.startPos,
                    result.name.str,
                    &context.module.typeSpecAllocator
                )

                var resultExpr = NewIdentifierExpr(
                    expr.startPos, expr.endPos,
                    nameTypeSpec,
                    context.allocator
                )

                var ifRight = NewIfStmt(
                    expr.startPos, expr.endPos,
                    expr.right,
                    NewBinaryExpr(
                        expr.startPos, expr.endPos,
                        resultExpr,
                        TokenType.EQUALS,
                        NewBooleanExpr(
                            expr.startPos, expr.endPos,
                            true,
                            context.allocator
                        ),
                        context.allocator
                    ),
                    null,
                    context.allocator
                )

                ifRight = FunctionLowering(context, ifRight) as (*Stmt)

                var ifLeft = NewIfStmt(
                    expr.startPos, expr.endPos,
                    expr.left,
                    ifRight,
                    null,
                    context.allocator
                )

                ifLeft = FunctionLowering(context, ifLeft) as (*Stmt)
                InsertTempStmt(context, ifLeft, .atEnd = true)

                return resultExpr as (*Node)
            }
            /*
                left || right

                lowered to:

                var result = false
                var t1 = left
                if (t1) {
                    result = true
                } else {
                    var t2 = right
                    if (t2) {
                        result = true
                    }
                }
            */
            else if(expr.operator == TokenType.OR) {
                var result = NewTempAssignment(
                    context,
                    NewBooleanExpr(
                        expr.startPos, expr.endPos,
                        false,
                        context.allocator
                    )
                )

                var nameTypeSpec = NewNameTypeSpecIntern(
                    expr.startPos,
                    result.name.str,
                    &context.module.typeSpecAllocator
                )

                var resultExpr = NewIdentifierExpr(
                    expr.startPos, expr.endPos,
                    nameTypeSpec,
                    context.allocator
                )

                var ifRight = NewIfStmt(
                    expr.startPos, expr.endPos,
                    expr.right,
                    NewBinaryExpr(
                        expr.startPos, expr.endPos,
                        resultExpr,
                        TokenType.EQUALS,
                        NewBooleanExpr(
                            expr.startPos, expr.endPos,
                            true,
                            context.allocator
                        ),
                        context.allocator
                    ),
                    null,
                    context.allocator
                )

                ifRight = FunctionLowering(context, ifRight) as (*Stmt)

                var ifLeft = NewIfStmt(
                    expr.startPos, expr.endPos,
                    expr.left,
                    NewBinaryExpr(
                        expr.startPos, expr.endPos,
                        resultExpr,
                        TokenType.EQUALS,
                        NewBooleanExpr(
                            expr.startPos, expr.endPos,
                            true,
                            context.allocator
                        ),
                        context.allocator
                    ),
                    ifRight,
                    context.allocator
                )

                ifLeft = FunctionLowering(context, ifLeft) as (*Stmt)
                InsertTempStmt(context, ifLeft, .atEnd = true)

                return resultExpr as (*Node)
            } else {
                expr.left = FunctionLowering(context, expr.left) as (*Expr)
                expr.right = FunctionLowering(context, expr.right) as (*Expr)
            }
            break;
        }
        case StmtKind.BOOLEAN_EXPR: {
            break;
        }
        case StmtKind.CAST_EXPR: {
            var expr = ast as (*CastExpr)
            expr.exprToCast = FunctionLowering(context, expr.exprToCast) as (*Expr)
            break;
        }
        case StmtKind.CHAR_EXPR: {
            break;
        }
        case StmtKind.FUNC_CALL_EXPR: {
            var expr = ast as (*FuncCallExpr)
            /*
                Lowered to

                var t1 = call()
                t1

                ordering:

                expr.object
                a1
                a2
                ...

                var t1 = temp
                t1
            */
            expr.object = FunctionLowering(context, expr.object) as (*Expr)

            for(var i = 0; i < expr.arguments.size(); i += 1) {
                var arg = expr.arguments.getPtr(i)
                arg.argExpr = FunctionLowering(context, arg.argExpr) as (*Expr)
            }

            if (context.current.noTemp) {
                return expr as (*Node)
            }

            var temp = NewTempAssignment(context, expr)

            var nameTypeSpec = NewNameTypeSpecIntern(
                expr.startPos,
                temp.name.str,
                &context.module.typeSpecAllocator
            )

            return NewIdentifierExpr(
                expr.startPos,
                expr.endPos,
                nameTypeSpec,
                context.allocator
            ) as (*Node)
        }
        case StmtKind.FUNC_IDENTIFIER_EXPR: {
            var expr = ast as (*IdentifierExpr)
            break;
        }
        case StmtKind.GET_EXPR: {
            var expr = ast as (*GetExpr)
            FunctionLowering(context, expr.object)
            FunctionLowering(context, expr.field as (*Node))
            break;
        }
        case StmtKind.GROUP_EXPR: {
            var expr = ast as (*GroupExpr)
            expr.groupedExpr = FunctionLowering(context, expr.groupedExpr) as (*Expr)
            break;
        }
        case StmtKind.IDENTIFIER_EXPR: {
            var expr = ast as (*IdentifierExpr)
            break;
        }
        case StmtKind.INIT_EXPR: {
            var expr = ast as (*InitExpr)

            for(var i = 0; i < expr.arguments.size(); i += 1) {
                var arg = expr.arguments.get(i)
                arg = FunctionLowering(context, arg) as (*InitArgExpr)
                expr.arguments.set(i, arg)
            }
            break;
        }
        case StmtKind.INIT_ARG_EXPR: {
            var expr = ast as (*InitArgExpr)
            expr.value = FunctionLowering(context, expr.value) as (*Expr)
            break;
        }
        case StmtKind.NULL_EXPR: {
            break;
        }
        case StmtKind.NUMBER_EXPR: {
            break;
        }
        case StmtKind.OFFSET_OF_EXPR: {
            var expr = ast as (*OffsetOfExpr)
            break;
        }
        case StmtKind.SET_EXPR: {
            var expr = ast as (*SetExpr)
            FunctionLowering(context, expr.object)
            FunctionLowering(context, expr.field as (*Node))
            FunctionLowering(context, expr.value)
            break;
        }
        case StmtKind.SIZE_OF_EXPR: {
            var expr = ast as (*SizeOfExpr)
            FunctionLowering(context, expr.sizeOfExpr)
            break;
        }
        case StmtKind.NATIVE_STRING_EXPR: {
            break;
        }
        case StmtKind.STRING_EXPR: {
            break;
        }
        case StmtKind.SUBSCRIPT_GET_EXPR: {
            var expr = ast as (*SubscriptGetExpr)
            FunctionLowering(context, expr.object)
            FunctionLowering(context, expr.index)
            break;
        }
        case StmtKind.SUBSCRIPT_SET_EXPR: {
            var expr = ast as (*SubscriptSetExpr)
            FunctionLowering(context, expr.object)
            FunctionLowering(context, expr.index)
            FunctionLowering(context, expr.value)
            break;
        }
        case StmtKind.TERNARY_EXPR: {
            var expr = ast as (*TernaryExpr)
            /*
                var x = cond ? then : other

                lowered to

                var result
                if (cond) {
                    result = then
                } else {
                    result = other
                }
                result
            */
            var resultTemp = NewTempEmptyAssignment(context, expr.then)

            var nameTypeSpec = NewNameTypeSpecIntern(
                expr.startPos,
                resultTemp.name.str,
                &context.module.typeSpecAllocator
            )

            var resultExpr = NewIdentifierExpr(
                expr.startPos, expr.endPos,
                nameTypeSpec,
                context.allocator
            )

            var ifStmt = NewIfStmt(
                expr.startPos, expr.endPos,
                expr.cond,
                NewBinaryExpr(
                    expr.startPos, expr.endPos,
                    resultExpr,
                    TokenType.EQUALS,
                    expr.then,
                    context.allocator
                ),
                NewBinaryExpr(
                    expr.startPos, expr.endPos,
                    resultExpr,
                    TokenType.EQUALS,
                    expr.other,
                    context.allocator
                ),
                context.allocator
            )

            ifStmt = FunctionLowering(context, ifStmt) as (*Stmt)
            InsertTempStmt(context, ifStmt, .atEnd = true)

            return resultExpr as (*Node)
        }
        case StmtKind.TYPE_IDENTIFIER_EXPR: {
            var expr = ast as (*TypeIdentifierExpr)
            break;
        }
        case StmtKind.NAME_OF_EXPR:
        case StmtKind.TYPE_OF_EXPR: {
            var expr = ast as (*TypeOfExpr)
            expr.typeOfExpr = FunctionLowering(context, expr.typeOfExpr) as (*Expr)
            break;
        }
        case StmtKind.UNARY_EXPR: {
            var expr = ast as (*UnaryExpr)
            expr.unaryExpr = FunctionLowering(context, expr.unaryExpr) as (*Expr)
            break;
        }
        case StmtKind.POISON_EXPR: {
            break;
        }
        default: {
            printf("Statement Kind: %s\n", StmtKindAsStr(ast.kind))
            assert(false)
        }
    }
    return ast
}


func RequiresFuncTempResult(ast: *Node) : bool {
    if(!ast) {
        return false;
    }

    switch(ast.kind) {
        case StmtKind.TRAIT_DECL:
        case StmtKind.UNION_DECL:
        case StmtKind.STRUCT_DECL:
        case StmtKind.FUNC_DECL:
        case StmtKind.IMPORT_DECL:
        case StmtKind.TYPEDEF_DECL:
        case StmtKind.ENUM_DECL:
        case StmtKind.PARAM_DECL:
        case StmtKind.NATIVE_DECL:
        case StmtKind.POISON_DECL: {
            break;
        }
        case StmtKind.CONST_DECL:
        case StmtKind.VAR_DECL: {
            return true;
        }

        case StmtKind.FUNC_BODY_STMT:
        case StmtKind.BLOCK_STMT:
        case StmtKind.BREAK_STMT:
        case StmtKind.COMP_STMT:
        case StmtKind.CONTINUE_STMT:
        case StmtKind.DEFER_STMT: {
            break;
        }
        case StmtKind.DO_WHILE_STMT: {
            return true;
        }
        case StmtKind.EMPTY_STMT: {
            break;
        }
        case StmtKind.FOR_STMT: {
            return true;
        }
        case StmtKind.GOTO_STMT: {
            break;
        }
        case StmtKind.IF_STMT: {
            return true;
        }
        case StmtKind.LABEL_STMT: {
            break;
        }
        case StmtKind.MODULE_STMT: {
            break;
        }
        case StmtKind.NOTE_STMT: {
            break;
        }
        case StmtKind.PARAMETERS_STMT: {
            break;
        }
        case StmtKind.RETURN_STMT: {
            return true;
        }
        case StmtKind.SWITCH_CASE_STMT: {
            break;
        }
        case StmtKind.SWITCH_STMT:{
            return true;
        }
        case StmtKind.ENUM_FIELD_DECL:
        case StmtKind.ENUM_FIELD_ENTRY_DECL:
        case StmtKind.STRUCT_FIELD_DECL:
        case StmtKind.UNION_FIELD_DECL:
        case StmtKind.TRAIT_FIELD_DECL:
        case StmtKind.VAR_FIELD_DECL: {
            break;
        }
        case StmtKind.WHILE_STMT: {
            return true;
        }


        /*--------------------------------------
            Expressions
        ----------------------------------------*/
        case StmtKind.ARRAY_DESIGNATION_EXPR: {
            return true;
        }
        case StmtKind.ARRAY_INIT_EXPR: {
            return true;
        }
        case StmtKind.BINARY_EXPR: {
            return true;
        }
        case StmtKind.BOOLEAN_EXPR: {
            break;
        }
        case StmtKind.CAST_EXPR: {
            return true;
        }
        case StmtKind.CHAR_EXPR: {
            break;
        }
        case StmtKind.FUNC_CALL_EXPR: {
            break;
        }
        case StmtKind.FUNC_IDENTIFIER_EXPR: {
            break;
        }
        case StmtKind.GET_EXPR: {
            break;
        }
        case StmtKind.GROUP_EXPR: {
            break;
        }
        case StmtKind.IDENTIFIER_EXPR: {
            break;
        }
        case StmtKind.INIT_EXPR: {
            return true;
        }
        case StmtKind.INIT_ARG_EXPR: {
            break;
        }
        case StmtKind.NULL_EXPR: {
            break;
        }
        case StmtKind.NUMBER_EXPR: {
            break;
        }
        case StmtKind.OFFSET_OF_EXPR: {
            return true;
        }
        case StmtKind.SET_EXPR: {
            return true;
        }
        case StmtKind.SIZE_OF_EXPR: {
            return true;
        }
        case StmtKind.NATIVE_STRING_EXPR: {
            break;
        }
        case StmtKind.STRING_EXPR: {
            break;
        }
        case StmtKind.SUBSCRIPT_GET_EXPR: {
            break;
        }
        case StmtKind.SUBSCRIPT_SET_EXPR: {
            return true;
        }
        case StmtKind.TERNARY_EXPR: {
            return true;
        }
        case StmtKind.TYPE_IDENTIFIER_EXPR: {
            break;
        }
        case StmtKind.NAME_OF_EXPR:
        case StmtKind.TYPE_OF_EXPR: {
            return true;
        }
        case StmtKind.UNARY_EXPR: {
            return true;
        }
        case StmtKind.POISON_EXPR: {
            break;
        }
        default: {
            printf("Statement Kind: %s\n", StmtKindAsStr(ast.kind))
            assert(false)
        }
    }
    return false
}