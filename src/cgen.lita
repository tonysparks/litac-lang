import "std/io"
import "std/string_buffer"
import "std/string_view"
import "std/string"
import "std/libc"
import "std/array"
import "std/map"
import "std/assert"
import "std/system"
import "std/mem"
import "std/unicode/utf8"

import "ast"
import "types"
import "module"
import "symbols"
import "lita"
import "phase_result"
import "lex"
import "common"
import "dependency_graph"
import "cgen_decl"
import "intern"

public struct CGen {
    lita: using *Lita
    buf: StringBuffer
    line: StringBuffer
    format: bool
    indent: i32
    aggregateLevel: i32

    currentLine: i32
    currentFile: *const char

    bufferFlush: bool
    funcIndex: i32
    tmpVar: i32
    deferStack: i32

    inTextBlock: bool

    currentFunc: *TypeInfo
    currentScope: *CGenScope

    output: *File
}

struct CGenScope {
    parent: *CGenScope
    defers: Array<*Stmt>
    constDefs: Array<*const char>
    isLoop: bool
    isSwitch: bool
}

public const MAX_COMPILATION_UNITS = 256
struct CompilationUnit {
    module: *Module
    filename: [MAX_PATH]char
    file: *FILE
}

const escapeStrings = [256]*const char {
    ['\b'] = "\\b",
    ['\f'] = "\\f",
    ['\n'] = "\\n",
    ['\r'] = "\\r",
    ['\t'] = "\\t",
    ['\\'] = "\\\\",
    ['\''] = "\\'",
    //['"'] = "\\\"",
    ['\0'] = "\\0",
}

const escapeChars = [256]*const char {
    ['b'] = "\\\\b",
    ['f'] = "\\\\f",
    ['n'] = "\\\\n",
    ['r'] = "\\\\r",
    ['t'] = "\\\\t",
    ['\\'] = "\\\\",
    ['\''] = "\\'",
    ['"'] = "\\\\\"",
    ['\0'] = "\\0",
}


public func (this: *CGen) init(lita: *Lita, output: *File) {
    this.lita = lita
    this.buf.init(1024 * 2, lita.allocator)
    this.line.init(1024 * 2, lita.allocator)
    this.aggregateLevel = 0
    this.currentLine = 0
    this.currentFile = null
    this.currentFunc = null
    this.currentScope = null
    this.bufferFlush = false

    this.deferStack = 0

    this.format = lita.options.cFormat
    this.output = output
}

public func (this: using *CGen) emitProgram(module: *Module) {
    assert(module != null)
    assert(module.ast != null)

    this.bufferFlush = true

    buf.appendStr("#ifndef _LITAC_HEADER_H\n")
    buf.appendStr("#define _LITAC_HEADER_H\n")

    this.emitForward()
    this.emitPrimitiveConstDecls()
    this.emitModuleNotes()
    this.emitForwardDecls()
    this.emitTraitForwardDecls()

    buf.appendStr("\n#endif /* _LITAC_HEADER_H */\n")

    buf.appendStr("\n\n")
    buf.appendStr("// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n")
    buf.appendStr("// translated code begins\n")
    buf.appendStr("// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n")
    buf.appendStr("\n\n")

    this.bufferFlush = false

    var graph = DependencyGraph{}
    graph.init(this.lita)
    var declarations = graph.sort()

    var isTesting = this.lita.options.testsOnly

    for(var i = 0; i < declarations.size(); i += 1) {
        var sym = declarations.get(i)
        assert(sym.decl)

        if(sym.flags & SymbolFlags.IS_GENERIC_TEMPLATE) {
            continue
        }

        if(sym.flags & SymbolFlags.IS_EMITTED) {
            continue
        }

        if(sym.flags & SymbolFlags.IS_FOREIGN) {
            continue
        }

        if(sym == this.lita.programSymbols.mainEntry) {
            continue
        }

        if(!isTesting && sym.flags & SymbolFlags.IS_TEST) {
            continue
        }

        this.emitStmt(sym.decl)
        this.emitln()

        this.flush()
    }

    this.emitTraitDecls()

    this.emitln()

    if(this.lita.programSymbols.mainEntry) {
        this.emitMain(this.lita.programSymbols.mainEntry)
    }

    this.flush()
}

func (this: using *CGen) emitMain(sym: *Symbol) {
    var decl = sym.decl as (*FuncDecl)
    this.emitFuncDeclSignature(decl, "main");
    this.currentFunc = sym.type
    defer this.currentFunc = null

    this.emitStrn(" {", 2)
    this.funcIndex = this.buf.length
    this.emitStmt(decl.body)
    this.emitStrn("}", 1)

}

func (this: using *CGen) emitForward() {
    this.buf.append(
"""
// Generated on %s
#include <stdint.h>
#include <stddef.h>
typedef int8_t    %s%s;
typedef int16_t   %s%s;
typedef int32_t   %s%s;
typedef int64_t   %s%s;
typedef uint8_t   %s%s;
typedef uint16_t  %s%s;
typedef uint32_t  %s%s;
typedef uint64_t  %s%s;
typedef float     %s%s;
typedef double    %s%s;
//typedef int8_t    %s%s;
typedef size_t    %s%s;

#if _MSC_VER
#define LITAC_THREADLOCAL __declspec(thread)
#define LITAC_INLINE static inline __forceinline
#define LITAC_NOINLINE __declspec(noinline)
#define LITAC_PACKED __pragma(pack(push, 1))
#define LITAC_PACKED_POP __pragma(pack(pop))
#define LITAC_EXPORT __declspec(dllexport)
#endif

#if __GNUC__
#define LITAC_THREADLOCAL __thread
#define LITAC_INLINE static inline __attribute__((always_inline))
#define LITAC_NOINLINE __attribute__((noinline))
#define LITAC_PACKED _Pragma("pack(push)")
#define LITAC_PACKED_POP _Pragma("pack(pop)")
#define LITAC_EXPORT __attribute__((visibility("default")))
#endif

#if __TINYC__
#define LITAC_THREADLOCAL
#define LITAC_INLINE
#define LITAC_NOINLINE
#define LITAC_PACKED __attribute__((packed))
#define LITAC_PACKED_POP
#define LITAC_EXPORT __attribute__((dllexport))
#endif

""",
    CurrentDateTime(),
    this.options.cPrefix, "i8",
    this.options.cPrefix, "i16",
    this.options.cPrefix, "i32",
    this.options.cPrefix, "i64",
    this.options.cPrefix, "u8",
    this.options.cPrefix, "u16",
    this.options.cPrefix, "u32",
    this.options.cPrefix, "u64",
    this.options.cPrefix, "f32",
    this.options.cPrefix, "f64",
    this.options.cPrefix, "bool",
    this.options.cPrefix, "usize"
    );

    if(strlen(this.options.cPrefix) > 0) {
        buf.append("typedef int8_t %s%s;\n", this.options.cPrefix, "bool")
        buf.append("#define %s%s (1)\n", this.options.cPrefix, "true")
        buf.append("#define %s%s (0)\n", this.options.cPrefix, "false")
        buf.append("#define %s%s void\n", this.options.cPrefix, "void")
        buf.append("typedef char   %s%s;\n", this.options.cPrefix, "char")
    }
    else {
        buf.appendStr("""
// Boolean type
#if defined(__STDC__) && __STDC_VERSION__ >= 199901L
    #include <stdbool.h>
#elif !defined(__cplusplus) && !defined(bool)
    typedef enum { false, true } bool;
#endif
        """)
    }
}

func (this: using *CGen) emitPrimitiveConstDecls() {
    var program = &this.lita.programSymbols
    for(var i = 0; i < program.values.size(); i += 1) {
        var sym = program.values.get(i)

        if(!(sym.flags & SymbolFlags.IS_CONSTANT)) {
            continue
        }

        if(sym.flags & SymbolFlags.IS_FOREIGN) {
            continue
        }

        if(!IsPrimitive(sym.type)) {
            continue
        }

        this.emitVarDecl(sym.decl as (*VarDecl))
        this.emitln()
    }
}

func (this: using *CGen) emitModuleNotes() {

    for(var it = this.lita.modules.iter(); it.hasNext();) {
        var m = it.next()
        var module = m.value

        for(var i = 0; i < module.ast.notes.size(); i += 1) {
            var note = module.ast.notes.get(i)

            this.emitPreludeNote(note)
            this.emitStrn("\n", 1)
        }
    }
}

func (this: using *CGen) findSymbolByTypeid(id: Typeid) : *Symbol {
    if(id < TypeKind.MAX_TYPE_KINDS) {
        return GetBuiltinSymbol(id)
    }

    var symbols = this.lita.programSymbols.symbolTypes
    for(var i = 0; i < symbols.size(); i += 1) {
        var sym = symbols.get(i)
        if(sym.type && sym.type.typeid == id) {
            return sym
        }
    }

    return null
}


func (this: using *CGen) emitTraitForwardDecls() {
    var interfaceImpls = this.lita.programSymbols.interfaceImpls

    this.emit("\n\n// Generated code for interfaces\n")

    for(var it = interfaceImpls.iter(); it.hasNext();) {
        var entry = it.next()
        var traitSym = this.findSymbolByTypeid(entry.key)
        assert(traitSym)
        assert(traitSym.decl && traitSym.decl.kind == StmtKind.TRAIT_DECL)

        var traitDecl = traitSym.decl as (*AggregateDecl)
        var traitName = this.cTypeName(traitSym.type)

        this.emit("// Generated code %s\n", traitName)

        // Generate Casting functions
        {
            for(var i = 0; i < entry.value.size(); i += 1) {
                var implSym = this.findSymbolByTypeid(entry.value.get(i))
                assert(implSym)

                var implName = this.cTypeName(implSym.type)
                this.emit("%s %s__to__%s(%s* x);\n",
                    traitName,
                    implName,
                    traitName,
                    implName)
            }
        }
        this.emitStrn("\n", 1)
    }
}


func (this: using *CGen) emitTraitDecls() {
    var root = this.lita.programSymbols.root
    assert(root != null)

    var interfaceImpls = this.lita.programSymbols.interfaceImpls
    for(var it = interfaceImpls.iter(); it.hasNext();) {
        var entry = it.next()
        var traitSym = this.findSymbolByTypeid(entry.key)
        assert(traitSym)
        assert(traitSym.decl && traitSym.decl.kind == StmtKind.TRAIT_DECL)

        var traitDecl = traitSym.decl as (*AggregateDecl)
        var traitName = this.cTypeName(traitSym.type)
        var module = root

        // we put all generated trait tables in the root module, so therefore we have to manually
        // name mangle the vtable name
        var vtableName = [MAX_SYMBOL_NAME]char;
        var vtableNameStr = StringInit(vtableName, MAX_SYMBOL_NAME, 0)
        var escapedName = this.escapeNameStr(traitSym.name)
        vtableNameStr.format("%s%.*s__%.*s",
            this.options.cPrefix,
            module.id.name.length,
            module.id.name.buffer,
            escapedName.length,
            escapedName.buffer)

        // Generate Casting functions;
        // we generate the casting functions in C code and not in lita
        // code because the Trait itself doesn't have a 'vtable' or 'this'
        // fields, these are added in cgen
        {
            for(var i = 0; i < entry.value.size(); i += 1) {
                var implSym = this.findSymbolByTypeid(entry.value.get(i))
                assert(implSym)

                var implName = this.cTypeName(implSym.type)
                this.emit("%s %s__to__%s(%s* x) {", traitName, implName, traitName, implName)
                this.emit("return (%s) {", traitName)
                this.emit(".__vtable = %s__vtables[%d],\n", vtableNameStr.cStr(), i)
                this.emit(".__this = x")
                this.emitStrn("}", 1)
                this.emitStrn(";\n", 2)
                this.emitStrn("}\n", 2)
            }
        }
    }
}

public func (this: using *CGen) emitTraitCast(expr: *Expr) : bool {
    if(!expr) {
        return false;
    }

    if(IsTraitLike(expr.expectedType)) {
        if(expr.operand.typeInfo != null && !IsTraitLike(expr.operand.typeInfo)) {
            var traitName = this.cTypeName(expr.expectedType.getBaseType())
            var implName = this.cTypeName(expr.operand.typeInfo.getBaseType())

            if(IsPtr(expr.expectedType)) {
                this.emitStrn("&", 1)
            }
            this.emit("%s__to__%s(", implName, traitName)
            if(!IsPtr(expr.operand.typeInfo)) {
                this.emitStrn("&", 1)
            }
            this.emitStrn("(", 1)
            this.emitStmt(expr)
            this.emitStrn("))", 2)
            return true
        }

    }

    return false;
}

func (this: using *CGen) emitForwardDecls() {
    var program = &this.lita.programSymbols
    for(var i = 0; i < program.symbolTypes.size(); i += 1) {
        var sym = program.symbolTypes.get(i)
        this.emitTypeForwardDecl(sym)
    }

    for(var i = 0; i < program.symbolFuncs.size(); i += 1) {
        var sym = program.symbolFuncs.get(i)
        this.emitTypeForwardDecl(sym)
    }
}

func (this: using *CGen) emitTypeForwardDecl(sym: *Symbol) {
    var decl = sym.decl

    if(sym.flags & SymbolFlags.IS_FOREIGN || sym.flags & SymbolFlags.IS_GENERIC_TEMPLATE) {
        return;
    }


    if(!this.lita.options.testsOnly && sym.flags & SymbolFlags.IS_TEST) {
        return;
    }

    var name = this.cName(decl.sym)
    switch(decl.kind) {
        case StmtKind.VAR_DECL:
        case StmtKind.CONST_DECL:
            break;
        case StmtKind.FUNC_DECL: {
            this.emitFuncDeclSignature(decl as (*FuncDecl), name)
            buf.appendStrn(";\n", 2)
            break;
        }
        case StmtKind.UNION_DECL:
        case StmtKind.STRUCT_DECL:
        case StmtKind.TRAIT_DECL: {
            var aggDecl = decl as (*AggregateDecl)
            //if(!(aggDecl.flags & AggregateFlags.IS_EMBEDDED))
            {
                this.buf.append("typedef %s %s %s;\n", aggDecl.kind == StmtKind.UNION_DECL ? "union" : "struct", name, name)
            }
            break;
        }
        case StmtKind.ENUM_DECL: {
            this.emitEnumDecl(decl as (*EnumDecl))
            break;
        }
        case StmtKind.TYPEDEF_DECL: {
            // we don't emit any other typedefs because we just use the
            // raw types
            break;
        }
        default: {
            assert(false)
        }
    }
}

func (this: using *CGen) allocTemp(type: *TypeInfo, buffer: [MAX_SYMBOL_NAME]char) : *const char {
    var name = StringInit(buffer, MAX_SYMBOL_NAME, 0)
    name.format("__tmp%d", this.tmpVar)
    this.tmpVar += 1

    var decl = this.cTypeDecl(type, name.cStr(), false)
    this.buf.insert(this.funcIndex, "    %s;\n", decl)

    return name.cStr()
}

public func (this: using *CGen) escapeNameStr(name: InternedString) : StringView {
    var sb = StringBufferInit(256, this.allocator)
    EscapeName(name.buffer, name.length, sb)
    return StringView {
        .buffer = sb.buffer,
        .length = sb.length
    }
}

func (this: using *CGen) escapeNameChars(name: *const char) : StringView {
    var sb = StringBufferInit(256, this.allocator)
    EscapeName(name, strlen(name), sb)
    return StringView {
        .buffer = sb.buffer,
        .length = sb.length
    }
}

func (this: using *CGen) escapeName(type: *TypeInfo) : StringView {
    if(IsAggregate(type)) {
        return this.escapeNameStr(type.name)
    }

    if(IsFuncLike(type)) {
        if(type.kind == TypeKind.FUNC) {
            var funcInfo = type
            if(funcInfo.funcDecl.flags & FuncFlags.IS_METHOD) {
                var methodName:[MAX_SYMBOL_NAME]char;
                if(!funcInfo.funcDecl.getName(methodName)) {
                    assert(false)
                }

                return this.escapeNameChars(methodName)
            }
        }
        // function pointer
        return StringView {
            .buffer = "_",
            .length = 1
        }
    }

    return type.name.view
}

func (this: using *CGen) baseTypeName(name: StringView) : StringView {
    // strip module name
    var index = name.indexOf("::")
    if(index >= 0) {
        name = name.substring(index + 2)
    }

    // strip generics
    index = name.indexOf("<")
    if(index >= 0) {
        name = name.substring(0, index)
    }

    return name
}

func (this: using *CGen) pushScope(scope: *CGenScope) {
    scope.parent = this.currentScope
    this.currentScope = scope
}

func (this: using *CGen) popScope() : *CGenScope {
    var scope = this.currentScope
    if(!scope) {
        return null
    }

    this.currentScope = scope.parent
    this.leaveScope(scope)
    return scope
}

func (this: using *CGen) popLoopScope(checkSwitch: bool = false) {
    var scope = this.currentScope
    while(scope) {
        if(checkSwitch && scope.isSwitch) {
            break;
        }

        this.leaveScope(scope)
        if(!scope || scope.isLoop) {
            break;
        }

        scope = scope.parent
    }
}

func (this: using *CGen) leaveScope(scope: *CGenScope, includeConst: bool = true) {
    if(!scope) {
        return;
    }

    this.deferStack += 1
    for(var i = scope.defers.size() - 1; i >= 0; i-=1) {
        var deferStmt = scope.defers.get(i)
        this.emitStmt(deferStmt)
        this.emitStrn(";\n", 2)
    }
    this.deferStack -= 1

    if(includeConst) {
        for(var i = 0; i < scope.constDefs.size(); i+=1) {
            var name = scope.constDefs.get(i)
            this.emit("#undef %s\n", name)
        }
    }
}

func (this: using *CGen) hasPendingDefers() : bool {
    var scope = this.currentScope
    while(scope) {
        if(!scope.defers.empty()) {
            return true
        }

        scope = scope.parent
    }

    return false
}

func (this: using *CGen) emitDefers() {
    if(this.deferStack > 0) {
        return;
    }
    var scope = this.currentScope
    while(scope) {
        this.leaveScope(scope, .includeConst = false)
        scope = scope.parent
    }
}

public func (this: using *CGen) emitLineInfo(stmt: *Stmt) {
    if(this.inTextBlock || !stmt || this.options.disableLineSync) {
        return;
    }

    var pos = stmt.startPos

    if(this.currentLine != pos.lineNumber ||
       this.currentFile != pos.filename) {

        this.currentFile = pos.filename
        this.currentLine = pos.lineNumber

        if(this.currentFile) {
            this.emit("\n#line %d \"", this.currentLine)

            var len = strlen(this.currentFile)
            for(var i = 0; i < len; i += 1) {
                var c:char = this.currentFile[i]
                var escaped = escapeStrings[c as (u32)]
                if(escaped) {
                    this.emitStr(escaped)
                    continue
                }
                else {
                    buf.appendChar(c)
                }
            }
            this.emitStrn("\"\n", 2)
        }
        else {
            this.emit("\n#line %d \n", this.currentLine)
        }
    }
}

/**
    Outputs a type in C for the supplied symbol
*/
public func (this: using *CGen) cType(type: *TypeInfo,
                                      isCast: bool = false,
                                      decay: bool = false) : *const char {
    var sb = StringBufferInit(256, this.allocator)
    switch(type.kind) {
        case TypeKind.PTR: {
            var ptrInfo = type
            var ptrOf = ptrInfo.ptrOf
            if(ptrOf.kind == TypeKind.ARRAY && !decay) {
                var arrayInfo = ptrOf
                if(arrayInfo.isLengthDefined) {
                    var baseInfo = arrayInfo.getBaseType()
                    var cType = this.cType(baseInfo, isCast, false)
                    sb.append("%s (*)[%zu]", cType, arrayInfo.length)
                    return sb.cStrConst()
                }
            }
            var cType = this.cType(ptrInfo.ptrOf, isCast, decay)
            sb.appendStr(cType)
            sb.appendStrn("*", 1)
            return sb.cStrConst()

        }
        case TypeKind.CONST: {
            var constInfo = type
            if(IsPtrLike(constInfo.constOf)) {
                var cType = this.cType(constInfo.constOf, isCast, decay)
                sb.appendStr(cType)
                sb.appendStrn(" const", 6)
                return sb.cStrConst()
            }
            var cType = this.cType(constInfo.constOf, isCast, decay)
            sb.appendStrn("const ", 6)
            sb.appendStr(cType)
            return sb.cStrConst()
        }
        case TypeKind.ARRAY: {
            var arrayInfo = type
            if(decay) {
                var ptrInfo = TypeInfo {
                    .kind = TypeKind.PTR,
                    .ptrOf = arrayInfo.arrayOf
                }
                // array's only decay once
                return this.cType(ptrInfo, isCast, false)
            }

            var baseInfo = arrayInfo.getBaseType()
            var baseName = this.cType(baseInfo)

            var buf = StringBufferInit(256, this.allocator)
            var line = StringBufferInit(256, this.allocator)
            do {
                if(arrayInfo.length < 0) {
                    if(arrayInfo.numOfElements) {
                        buf.appendStrn("[", 1)
                        var cgen = CGen {
                            .lita = this.lita,
                            .buf = buf,
                            .line = line,
                        }
                        cgen.emitStmt(arrayInfo.numOfElements)
                        buf.appendStrn("]", 1)
                    }
                    else if(!arrayInfo.isLengthDefined) {
                        buf.appendStrn("[]", 2)
                    }
                    else {
                        buf.appendStrn("[0]", 3)
                    }
                }
                else {
                    buf.append("[%zu]", arrayInfo.length)
                }

                if(arrayInfo.arrayOf && arrayInfo.arrayOf.kind == TypeKind.ARRAY) {
                    arrayInfo = arrayInfo.arrayOf
                }
                else {
                    arrayInfo = null
                }
            }
            while(arrayInfo);

            sb.appendStr(baseName)
            sb.appendStr(buf.cStrConst())
            return sb.cStrConst()
        }
        case TypeKind.FUNC_PTR: {
            var funcInfo = type
            var params = StringBufferInit(512, this.allocator)
            if(funcInfo.isTrait) {
                params.appendStrn("void*", 5)
            }
            for(var i = 0; i < funcInfo.paramDecls.size(); i += 1) {
                if(i > 0 || funcInfo.isTrait) {
                    params.appendStrn(",", 1)
                }

                var param = funcInfo.paramDecls.get(i)
                params.appendStr(this.cType(param, isCast, true))
            }

            sb.append("%s (*%s)(%s)", this.cType(funcInfo.returnType, isCast, decay),
                isCast ? "" : this.cTypeName(funcInfo), params.cStrConst())
            return sb.cStrConst()
        }
        default: {
            return this.cTypeName(type)
        }
    }
}

/**
    Outputs a type declaration in C for the supplied symbol
*/
public func (this: using *CGen) cTypeDecl(type: *TypeInfo,
                                   name: *const char,
                                   decay: bool = false) : *const char {

    var sb = StringBufferInit(256, this.allocator)
    switch(type.kind) {
        case TypeKind.PTR: {
            var ptrInfo = type
            var ptrOf = ptrInfo.ptrOf
            if(ptrOf.kind == TypeKind.ARRAY && !decay) {
                var arrayInfo = ptrOf
                if(arrayInfo.isLengthDefined) {
                    var baseInfo = arrayInfo.getBaseType()
                    var cType = this.cType(baseInfo)
                    sb.append("%s (*%s)[%zu]", cType, name, arrayInfo.length)
                    return sb.cStrConst()
                }
            }
            var cType = this.cType(type, false, decay)
            sb.appendStr(cType)
            sb.appendStrn(" ", 1)
            sb.appendStr(name)
            return sb.cStrConst()
        }
        case TypeKind.CONST: {
            var constInfo = type
            if(IsPtrLike(constInfo.constOf)) {
                var cType = this.cType(constInfo.constOf, false, decay)
                sb.appendStr(cType)
                sb.appendStrn(" const ", 7)
                sb.appendStr(name)
                return sb.cStrConst()
            }
            var cType = this.cTypeDecl(constInfo.constOf, name, decay)
            sb.appendStrn("const ", 6)
            sb.appendStr(cType)
            return sb.cStrConst()
        }
        case TypeKind.ARRAY: {
            var arrayInfo = type
            if(decay) {
                var ptrInfo = TypeInfo {
                    .kind = TypeKind.PTR,
                    .ptrOf = arrayInfo.arrayOf
                }
                // arrays only decay once
                return this.cTypeDecl(ptrInfo, name, false)
            }

            var baseInfo = arrayInfo.getBaseType()
            var baseName = this.cType(baseInfo)

            var buf = StringBufferInit(256, this.allocator)
            var line = StringBufferInit(256, this.allocator)
            do {
                if(arrayInfo.length == 0) {
                    if(arrayInfo.numOfElements) {
                        this.flush()

                        buf.appendStrn("[", 1)
                        var cgen = CGen {
                            .lita = this.lita,
                            .buf = buf,
                            .line = line
                        }
                        cgen.emitStmt(arrayInfo.numOfElements)
                        buf = cgen.buf // the buffer has expanded
                        buf.appendStrn("]", 1)
                    }
                    else if(!arrayInfo.isLengthDefined) {
                        buf.appendStrn("[]", 2)
                    }
                    else {
                        buf.appendStrn("[0]", 3)
                    }
                }
                else {
                    buf.append("[%zu]", arrayInfo.length)
                }

                if(arrayInfo.arrayOf && arrayInfo.arrayOf.kind == TypeKind.ARRAY) {
                    arrayInfo = arrayInfo.arrayOf
                }
                else {
                    arrayInfo = null
                }
            }
            while(arrayInfo);

            if(baseInfo.kind == TypeKind.FUNC_PTR) {
                buf.insert(0, "%s", name)
                return this.cTypeDecl(baseInfo, buf.cStrConst(), decay)
            }
            sb.appendStr(baseName)
            sb.appendStrn(" ", 1)
            sb.appendStr(name)
            sb.appendStr(buf.cStr())
            return sb.cStrConst()
        }
        case TypeKind.STR: {
            sb.appendStr("const char* ")
            sb.appendStr(name)
            return sb.cStrConst()
        }
        case TypeKind.FUNC_PTR: {
            var funcInfo = type
            var params = StringBufferInit(512, this.allocator)
            if(funcInfo.isTrait) {
                params.appendStrn("void*", 5)
            }
            for(var i = 0; i < funcInfo.paramDecls.size(); i += 1) {
                if(i > 0 || funcInfo.isTrait) {
                    params.appendStrn(",", 1)
                }

                var param = funcInfo.paramDecls.get(i)
                params.appendStr(this.cType(param, false, true))
            }

            sb.append("%s (*%s)(%s)", this.cType(funcInfo.returnType, false, decay), name, params.cStrConst())
            return sb.cStrConst()
        }
        default: {
            var cType = this.cType(type, false, decay)
            sb.appendStr(cType)
            sb.appendStrn(" ", 1)
            sb.appendStr(name)
            return sb.cStrConst()
        }
    }
}

func (this: using *CGen) foreignName(decl: *Decl, defaultName: StringView) : StringView {
    if(!decl) {
        return defaultName
    }

    var note = decl.getNote("foreign")
    if(!note) {
        return defaultName
    }

    if(note.arguments.empty()) {
        return defaultName
    }

    var arg = note.arguments.get(0)
    if(!arg.argExpr) {
        return defaultName
    }

    return arg.argExpr.operand.val.str;
}

/**
    Outputs the C name for the symbol
*/
public func (this: using *CGen) cName(sym: *Symbol) : *const char {
    var sb = StringBufferInit(256, this.allocator)

    var declName = sym.name.view
    if(IsFuncLike(sym.type)) {
        declName = this.escapeNameStr(sym.name)
    }
    else if (sym.flags & SymbolFlags.IS_TYPE) {
        declName = this.escapeName(sym.type)
    }

    if(sym.flags & SymbolFlags.IS_LOCAL) {
        return this.prefix(declName, sb)
    }

    if(sym.flags & SymbolFlags.IS_FOREIGN) {
        if(sym.flags & SymbolFlags.IS_BUILTIN) {
            return this.prefix(sym.name.view, sb)
        }

        var name = this.foreignName(sym.decl, this.baseTypeName(sym.decl.name.str.view))
        sb.appendStrn(name.buffer, name.length)
        return sb.cStrConst()
    }

    sb.appendStr(this.options.cPrefix)
    sb.appendStrn(sym.declared.id.name.buffer, sym.declared.id.name.length)
    sb.appendStrn("__", 2)
    sb.appendStrn(declName.buffer, declName.length)
    return sb.cStrConst()
}

/**
    Outputs the C name for the symbol
*/
public func (this: using *CGen) cTypeName(type: *TypeInfo) : *const char {
    assert(type != null)

    if(!type.sym) {
        var typeName = this.escapeName(type)
        var sb = StringBufferInit(256, this.allocator)
        return this.prefix(typeName, sb)
    }

    return this.cName(type.sym)
}

public func (this: using *CGen) prefix(name: StringView, sb: *StringBuffer) : *const char {
    sb.appendStr(this.options.cPrefix)
    sb.appendStrn(name.buffer, name.length)
    return sb.cStrConst()
}

func (this: using *CGen) emitTypeSpec(spec: *TypeSpec) {
    assert(spec != null)

    switch(spec.kind) {
        case TypeSpecKind.NONE: {
            return;
        }
        case TypeSpecKind.ARRAY: {
            var array = spec
            buf.appendStrn("[", 1);
            if(array.numElements) {
                this.emitStmt(array.numElements)
            }
            buf.appendStrn("]", 1);
            this.emitTypeSpec(array.base)
            return;
        }
        case TypeSpecKind.PTR: {
            var ptr = spec
            buf.appendStrn("*", 1);
            this.emitTypeSpec(ptr.base)
            return;
        }
        case TypeSpecKind.CONST: {
            var c = spec
            buf.appendStrn("const ", 6);
            this.emitTypeSpec(c.base)
            return;
        }
        case TypeSpecKind.NAME: {
            var name = spec
            buf.appendStrn(name.name.buffer, name.name.length)
            if(!name.genericArgs.empty()) {
                buf.appendStrn("<", 1)
                for(var i = 0; i < name.genericArgs.size(); i += 1) {
                    if(i > 0) buf.appendStrn(",", 1)
                    this.emitTypeSpec(name.genericArgs.get(i))
                }
                buf.appendStrn(">", 1)
            }
            return;
        }
        case TypeSpecKind.FUNC_PTR: {
            var fn = spec
            buf.appendStrn("func", 4)
            if(!fn.genericParams.empty()) {
                buf.appendStrn("<", 1)
                for(var i = 0; i < fn.genericParams.size(); i += 1) {
                    if(i > 0) buf.appendStrn(",", 1)
                    this.emitName(fn.genericParams.get(i).name)
                }
                buf.appendStrn(">", 1)
            }
            buf.appendStrn("(", 1)
            for(var i = 0; i < fn.args.size(); i += 1) {
                if(i > 0) buf.append(",")
                this.emitTypeSpec(fn.args.get(i))
            }
            buf.appendStrn(") : ", 4)
            this.emitTypeSpec(fn.ret)
            return;
        }
        default: {
            Panic("Invalid TypeSpecKind: '%d'\n", spec.kind)
        }
    }
}

public func (this: using *CGen) flush() {
    if(this.output) {
        this.output.writeBytes(buf.buffer, buf.length)
        buf.length = 0
    }
}

public func (this: using *CGen) emitNameStr(name: StringView) {
    buf.appendStrn(name.buffer, name.length)
}

public func (this: using *CGen) emitName(id: Identifier) {
    var tok = id.token
    if(tok.type != TokenType.ERROR) {
        buf.appendStrn(tok.value.str.buffer, tok.value.str.length)
    }
}

public func (this: using *CGen) emitln() {
    buf.appendChar('\n')
    for(var i = 0; i < indent; i += 1) {
        buf.appendStrn("    ", 4);
    }
}

public func (this: using *CGen) emit(strFormat: *const char, ...) {
    if(this.format) {
        line.clear()

        var args: va_list;
        va_start(args, strFormat);
        line.appendArgs(strFormat, args)
        va_end(args)

        for(var i = 0; i < line.length; i+=1) {
            var c = line.buffer[i]
            if(c == '\n') {
                this.emitln()
            }
            else if(c == '{') {
                buf.appendChar(c)
                indent+=1
                this.emitln()
            }
            else if(c == '}') {
                indent-=1
                this.emitln()
                buf.appendChar(c)
            }
            else {
                buf.appendChar(c)
            }
        }
    }
    else {
        var args: va_list;
        va_start(args, strFormat);
        buf.appendArgs(strFormat, args)
        va_end(args)
    }

    if(this.bufferFlush) {
        if(buf.length > (buf.capacity/2)) {
            this.flush()
        }
    }
}

public func (this: using *CGen) emitStr(str: *const char) {
    var len = strlen(str)
    this.emitStrn(str, len)
}

public func (this: using *CGen) emitStrn(str: *const char, len: i32) {
    if(this.format) {
        for(var i = 0; i < len; i+=1) {
            var c = str[i]
            if(c == '\n') {
                this.emitln()
            }
            else if(c == '{') {
                buf.appendChar(c)
                indent+=1
                this.emitln()
            }
            else if(c == '}') {
                indent-=1
                this.emitln()
                buf.appendChar(c)
            }
            else {
                buf.appendChar(c)
            }
        }
    }
    else {
        buf.appendStrn(str, len)
    }

    if(this.bufferFlush) {
        if(buf.length > (buf.capacity/2)) {
            this.flush()
        }
    }
}


public func (this: using *CGen) emitNotes(attributes: *Attributes, isPrelude: bool = true) {
    if(attributes.notes.empty()) {
        return;
    }

    if(isPrelude) {
        for(var i = 0; i < attributes.notes.size(); i += 1) {
            this.emitPreludeNote(attributes.notes.get(i))
            this.emitStrn("\n", 1)
        }
    }
    else {
        for(var i = 0; i < attributes.notes.size(); i += 1) {
            this.emitPostludeNote(attributes.notes.get(i))
            this.emitStrn("\n", 1)
        }
    }

}

func (this: using *CGen) emitPreludeNote(note: *NoteStmt) {
    if(note.type.name.equals(&INCLUDE)) {
        for(var i = 0; i < note.arguments.size(); i += 1) {
            var attr = note.arguments.get(i)
            if(!attr.argExpr) {
                continue
            }

            var value = attr.argExpr.operand.val.str

            if(value.length > 0 && value.buffer[0] == '<') {
                this.emit("#include %.*s\n", value.length, value.buffer)
            }
            else {
                this.emit("#include \"%.*s\"\n", value.length, value.buffer)
            }
        }
    }
    else if(note.type.name.equals(&RAW)) {
        for(var i = 0; i < note.arguments.size(); i += 1) {
            var attr = note.arguments.get(i)
            if(!attr.argExpr) {
                continue
            }

            var value = attr.argExpr.operand.val.str
            buf.appendStrn(value.buffer, value.length)
        }
    }
    else if(note.type.name.equals(&COMPILER_OPTION)) {
        var ccOption = CCompilerOption{
            .os = OS.Lita_OSType_OTHER,
            .arch = Arch.Lita_ArchType_UNKNOWN,
            .options = StringView{},
        }

        var temp:[MAX_PATH]char;
        // this constant is strlen("{relativePath}")
        const len = 14

        for(var i = 0; i < note.arguments.size(); i += 1) {
            var attr = note.arguments.get(i)
            if(!attr.argExpr) {
                continue
            }

            var value = attr.argExpr.operand.val.str

            // determine if the compiler_option has a template
            // substitution within it.  We have this to allow for
            // include/library path's to be relative to where they
            // are used -- either locally or referenced from the .pkgs
            // directory.
            {
                var index = value.indexOf("{relativePath}", len)
                if(index > -1 && note.startPos.filename != null) {
                    var buffer = StringBufferInit(MAX_PATH, this.lita.allocator)
                    buffer.append("%.*s", value.length, value.buffer)

                    buffer.replace(index, index + len, FileParent(note.startPos.filename, temp))
                    value = buffer.asStringView()
                }
            }

            if(attr.argName.token.type == TokenType.IDENTIFIER) {
                if(attr.argName.str.equalsStr("os")) {
                    ccOption.os = OSFromStr(value.buffer, value.length)
                }
                else if(attr.argName.str.equalsStr("arch")) {
                    ccOption.arch = ArchFromStr(value.buffer, value.length)
                }
                else if(attr.argName.str.equalsStr("options")) {
                    ccOption.options = value
                }
            }
            else {
                if(i == 0) {
                    ccOption.os = OSFromStr(value.buffer, value.length)
                }
                else if(i == 1) {
                    ccOption.options = value
                }
                else if(i == 2) {
                    ccOption.arch = ArchFromStr(value.buffer, value.length)
                }
            }
        }

        this.lita.compilerOptions.add(ccOption)
    }
    else if(note.type.name.equals(&INLINE)) {
        this.emitStr("LITAC_INLINE ")
    }
    else if(note.type.name.equals(&NOINLINE)) {
        this.emitStr("LITAC_NOINLINE ")
    }
    else if(note.type.name.equals(&STATIC)) {
        this.emitStr("static ")
    }
    else if(note.type.name.equals(&ATOMIC)) {
        this.emitStr("_Atomic ")
    }
    else if(note.type.name.equals(&REGISTER)) {
        this.emitStr("register ")
    }
    else if(note.type.name.equals(&THREADLOCAL)) {
        this.emitStr("LITAC_THREADLOCAL ")
    }
    else if(note.type.name.equals(&EXPORT)) {
        this.emitStr("LITAC_EXPORT ")
        // TODO
    }
    else if(note.type.name.equals(&PACKED)) {
        this.emitStr("LITAC_PACKED ")
    }
    else if(note.type.name.equals(&CC)) {
        if(!note.arguments.empty()) {
            var attr = note.arguments.get(0)
            if(attr.argExpr) {
                var value = attr.argExpr.operand.val.str
                this.emitStrn(value.buffer, value.length)
                this.emitStrn(" ", 1)
            }
        }
    }
    else if(note.type.name.equals(&CFILE)) {
        const BUFFER_SIZE = 1024*10;
        var filename = [MAX_PATH]char {0};
        var filenameStr = StringInit(filename, MAX_PATH, 0)
        var filedata = [BUFFER_SIZE]char{0};

        for(var i = 0; i < note.arguments.size(); i += 1) {
            var arg = note.arguments.get(i)
            if(!arg.argExpr) {
                continue
            }

            var value = arg.argExpr.operand.val.str

            FilePath(note.startPos.filename, filename)

            filenameStr.adjust()
            filenameStr.append("/%.*s", value.length, value.buffer)

            if(!FileExists(filenameStr.cStr())) {
                // TODO:
                //      check relative to source directory
                //      check working directory
                //      check lib directory
                //printf("FilePath: '%s'\n", filename)
                this.result.addError(note.startPos, "unable to locate file: '%.*s'", value.length, value.buffer)
                continue;
            }

            var file = fopen(filename, "r");
            defer if(file) fclose(file)

            if(!file) {
                this.result.addError(note.startPos, "unable to open file: '%s'", filename)
                continue;
            }

            this.flush()
            this.emitStrn("\n", 1)
            this.emit("#line %d \"%s\"\n", 0, filename)
            var bytesRead = 0_i64;
            do {
                bytesRead = fread(filedata, 1, BUFFER_SIZE, file)
                if(this.output) {
                    this.output.writeBytes(filedata, bytesRead)
                }
            }
            while(bytesRead > 0);
            this.emitStrn("\n", 1)
        }
    }
    else if(note.type.name.equals(&CINCLUDE)) {
        const BUFFER_SIZE = 1024*10;
        var filename = [MAX_PATH]char {0};
        var filenameStr = StringInit(filename, MAX_PATH, 0)
        var filedata = [BUFFER_SIZE]char{0};

        for(var i = 0; i < note.arguments.size(); i += 1) {
            var arg = note.arguments.get(i)
            if(!arg.argExpr) {
                continue
            }

            var value = arg.argExpr.operand.val.str

            FilePath(note.startPos.filename, filename)

            filenameStr.adjust()
            filenameStr.append("/%.*s", value.length, value.buffer)

            if(!FileExists(filenameStr.cStr())) {
                // TODO:
                //      check relative to source directory
                //      check working directory
                //      check lib directory
                //printf("FilePath: '%s'\n", filename)
                this.result.addError(note.startPos, "unable to locate file: '%.*s'", value.length, value.buffer)
                continue;
            }
            this.emit("#line %d \"%s\"\n", 0, filename)
            this.emit("#include \"%s\"\n", filename)
        }
    }
}

func (this: using *CGen) emitPostludeNote(note: *NoteStmt) {
    if(note.type.name.equals(&PACKED)) {
        this.emitStr(" LITAC_PACKED_POP ")
    }
}

func (this: using *CGen) emitFieldName(field: FieldStmt) {
    assert(field.kind != StmtKind.POISON_EXPR)
    var alias = field.varField.decl.getNote("alias")
    if(alias && alias.arguments.size()) {
        var name = alias.arguments.get(0)
        if(name.argExpr) {
            this.emitNameStr(name.argExpr.operand.val.str)
            return;
        }
    }
    this.emitName(field.varField.name)
}

func (this: using *CGen) emitSymbol(sym: *Symbol) {
    if(!sym) {
        return;
    }

    if(!(sym.flags & SymbolFlags.IS_USING)) {
        this.emitStr(this.cName(sym))
        return;
    }

    var paramInfo = sym.usingParent
    assert(paramInfo != null)

    var aggType = paramInfo.type.getBaseType()
    this.emitStr(this.cName(paramInfo))

    var path = FieldPath{}
    var isFound = aggType.getFieldPath(sym.name, &path)
    assert(isFound)

    var nextType = paramInfo.type
    for(var i = 0; i < path.numOfFields; i+=1) {
        var field = path.fields[i]
        if(nextType.kind == TypeKind.PTR) {
            buf.appendStrn("->", 2)
        }
        else {
            buf.appendStrn(".", 1)
        }
        this.emitStrn(field.varField.name.str.buffer, field.varField.name.str.length)
        nextType = field.typeInfo
    }
}

func (this: using *CGen) emitTraitFuncCall(expr: *FuncCallExpr) {
    switch(expr.object.kind) {
        case StmtKind.FUNC_IDENTIFIER_EXPR: {
            var idExpr = expr.object as (*IdentifierExpr)
            this.emit("/* something here */")
            break
        }
        case StmtKind.GET_EXPR: {
            var getExpr = expr.object as (*GetExpr)
            var type = getExpr.object.operand.typeInfo

            // for identifiers, we don't have to worry about side-effects
            if(getExpr.object.kind == StmtKind.IDENTIFIER_EXPR) {
                this.emitStmt(getExpr.object)
                if(IsPtr(type)) {
                    this.emitStrn("->", 2)
                }
                else {
                    this.emitStrn(".", 1)
                }
                this.emitStr("__vtable->")

                assert(IsAggregateLike(type))

                var aggInfo = AsAggregate(type)
                var field = aggInfo.getField(getExpr.field.type.name)
                this.emitFieldName(field)

                this.emitStrn("(", 1)
                this.emitStmt(getExpr.object)

                if(IsPtr(type)) {
                    this.emitStrn("->", 2)
                }
                else {
                    this.emitStrn(".", 1)
                }

                this.emitStrn("__this", 6)
            }
            else {
                // Because the object may have side effects,
                // we must first assign it to a temp variable and
                // reuse the variable
                var buffer:[MAX_SYMBOL_NAME]char;
                var tmpName = this.allocTemp(type, buffer)

                this.emit("(%s = ", tmpName)
                this.emitStmt(getExpr.object)
                this.emit(", %s", tmpName)

                if(IsPtr(type)) {
                    this.emitStrn("->", 2)
                }
                else {
                    this.emitStrn(".", 1)
                }
                this.emitStrn("__vtable)->", 11)

                assert(IsAggregateLike(type))

                var aggInfo = AsAggregate(type)
                var field = aggInfo.getField(getExpr.field.type.name)
                this.emitFieldName(field)

                this.emit("(%s", tmpName)
                if(IsPtr(type)) {
                    this.emitStrn("->", 2)
                }
                else {
                    this.emitStrn(".", 1)
                }
                this.emitStrn("__this", 6)
            }


            if(expr.arguments.size() > 0) {
                this.emitStrn(", ", 2)
            }

            break
        }
        default: {
            assert(false)
        }
    }
}

func (this: using *CGen) emitStaticCompStmt(s: *CompStmt) {
    if(!s.isStatic) {
        return;
    }

    if(s.type.equals(STATIC_IF)) {
        this.emitStrn("#if", 3)
        this.emit(" %.*s\n", s.expr.length, s.expr.buffer)
    }
    else if(s.type.equals(ELSEIF)) {
        this.emitStrn("#elif", 5)
        this.emit(" %.*s\n", s.expr.length, s.expr.buffer)
    }
    else if(s.type.equals(ELSE)) {
        this.emitStrn("#else\n", 6)
    }
    else if(s.type.equals(END)) {
        this.emitStrn("#endif\n", 7)
    }

    var stmts = s.body
    for(var i = 0; i < stmts.size(); i += 1) {
        var n = stmts.get(i)
        this.emitStmt(n)
        if(IsExpr(n)) {
            this.emitStrn(";\n", 2)
        }
        else {
            this.emitStrn("\n", 1)
        }
    }

    if(s.end) {
        this.emitStaticCompStmt(s.end)
    }
}

public func (this: using *CGen) emitStmt(s: *Stmt) {
    if(!s) return;

    this.emitLineInfo(s)

    switch(s.kind) {
        case StmtKind.IMPORT_DECL: {
            return;
        }
        case StmtKind.CONST_DECL:
        case StmtKind.VAR_DECL: {
            var decl = s as (*VarDecl)
            this.emitVarDecl(decl)
            return;
        }
        case StmtKind.TRAIT_DECL:
        case StmtKind.UNION_DECL:
        case StmtKind.STRUCT_DECL: {
            var decl = s as (*AggregateDecl)
            this.emitAggregateDecl(decl)
            return;
        }
        case StmtKind.ENUM_DECL: {
            var decl = s as (*EnumDecl)
            this.emitEnumDecl(decl)
            return;
        }
        case StmtKind.FUNC_DECL: {
            var decl = s as (*FuncDecl)
            this.emitFuncDecl(decl)
            return;
        }
        case StmtKind.TYPEDEF_DECL: {
            return;
        }
        case StmtKind.PARAM_DECL: {
            assert(false)
            return;
        }
        case StmtKind.NATIVE_DECL: {
            assert(false)
            return;
        }
        case StmtKind.POISON_DECL: {
            assert(false)
            return;
        }
        case StmtKind.BLOCK_STMT: {
            var stmt = s as (*BlockStmt)
            this.emitStrn("{", 1)
            {
                this.pushScope(&CGenScope{})
                defer this.popScope()

                for(var i = 0; i < stmt.stmts.size(); i += 1) {
                    var n = stmt.stmts.get(i)
                    this.emitStmt(n)
                    if(IsExpr(n)) {
                        this.emitStrn(";\n", 2)
                    }
                    else {
                        this.emitStrn("\n", 1)
                    }
                }
            }
            this.emitStrn("\n}", 2)
            return;
        }
        case StmtKind.BREAK_STMT: {
            this.popLoopScope(true)
            this.emitStrn("break;", 6)
            return;
        }
        case StmtKind.COMP_STMT: {
            var stmt = s as (*CompStmt)
            if(stmt.isStatic) {
                this.emitStaticCompStmt(stmt)
                return;
            }

            var result = stmt.evaluatedStmt
            if(result) {
                this.emitStmt(result)
            }
            return;
        }
        case StmtKind.CONTINUE_STMT: {
            this.popLoopScope()
            this.emitStrn("continue;", 9)
            return;
        }
        case StmtKind.DEFER_STMT: {
            var stmt = s as (*DeferStmt)
            if(this.currentScope.defers.empty()) {
                this.currentScope.defers.init(16, this.lita.allocator)
            }

            this.currentScope.defers.add(stmt.deferedStmt)
            return;
        }
        case StmtKind.DO_WHILE_STMT: {
            var stmt = s as (*DoWhileStmt)
            this.emitStrn("do {", 4)
            {
                this.pushScope(&CGenScope{.isLoop = true})
                defer this.popScope()

                this.emitStmt(stmt.body)
                if(IsExpr(stmt.body)) {
                    this.emitStrn(";\n", 2)
                }
            }
            this.emitStrn("}\nwhile(", 8)
            this.emitStmt(stmt.cond)
            this.emitStrn(");", 2)
            return;
        }
        case StmtKind.EMPTY_STMT: {
            return;
        }
        case StmtKind.ENUM_FIELD_ENTRY_DECL: {
            assert(false)
            return;
        }
        case StmtKind.FOR_STMT: {
            var stmt = s as (*ForStmt)
            this.emitStrn("for(", 4)
            if(stmt.init) {
                this.emitStmt(stmt.init)
                if(IsExpr(stmt.init)) {
                    this.emitStrn(";\n", 2)
                }
            }
            else {
                this.emitStrn(";", 1)
            }

            if(stmt.cond) {
                this.emitStmt(stmt.cond)
            }

            this.emitStrn(";", 1)

            if(stmt.post) {
                this.emitStmt(stmt.post)
            }
            this.emitStrn(") {", 3)

            if(stmt.body) {
                this.pushScope(&CGenScope{.isLoop = true})
                defer this.popScope()

                this.emitStmt(stmt.body)

                if(IsExpr(stmt.body)) {
                    this.emitStrn(";\n", 2)
                }
            }
            else {
                this.emitStrn(";", 1)
            }
            this.emitStrn("}", 1)
            return;
        }
        case StmtKind.FUNC_BODY_STMT: {
            var stmt = s as (*FuncBodyStmt)
            this.pushScope(&CGenScope{})
            defer this.popScope()

            for(var i = 0; i < stmt.stmts.size(); i += 1) {
                var n = stmt.stmts.get(i)
                this.emitStmt(n)
                if(IsExpr(n)) {
                    this.emitStrn(";\n", 2)
                }
                else {
                    this.emitStrn("\n", 1)
                }
            }
            return;
        }
        case StmtKind.GOTO_STMT: {
            var stmt = s as (*GotoStmt)
            this.emitStrn("goto ", 5)
            this.emitName(stmt.label)
            this.emitStrn(";\n", 2)
            return;
        }
        case StmtKind.IF_STMT: {
            var stmt = s as (*IfStmt)
            this.emitStrn("if(", 3)
            this.emitStmt(stmt.cond)
            this.emitStrn(") {", 3)
            {
                this.pushScope(&CGenScope{})
                defer this.popScope()

                this.emitStmt(stmt.then)
                if(IsExpr(stmt.then)) {
                    this.emitStrn(";", 1)
                }
                this.emitStrn("\n", 1)
            }
            this.emitStrn("} ", 2)
            if(stmt.elseStmt) {
                this.emitStrn("else {", 6)
                {
                    this.pushScope(&CGenScope{})
                    defer this.popScope()

                    this.emitStmt(stmt.elseStmt)
                    if(IsExpr(stmt.elseStmt)) {
                        this.emitStrn(";", 1)
                    }
                }
                this.emitStrn("} ", 2)
            }
            this.emitStrn("\n", 1)
            return;
        }
        case StmtKind.LABEL_STMT: {
            var stmt = s as (*LabelStmt)
            this.emitName(stmt.label)
            this.emitStrn(":;\n", 3)
            return;
        }
        case StmtKind.MODULE_STMT: {
            assert(false)
            return;
        }
        case StmtKind.NOTE_STMT: {
            assert(false)
            return;
        }
        case StmtKind.PARAMETERS_STMT: {
            assert(false)
            return;
        }
        case StmtKind.RETURN_STMT: {
            var stmt = s as (*ReturnStmt)

            if(stmt.expr && stmt.expr.operand.typeInfo != &VOID_TYPE && this.hasPendingDefers()) {
                assert(this.currentFunc != null)
                this.emit("{%s = ", this.cTypeDecl(this.currentFunc.returnType, "___result"))
                if(!this.emitTraitCast(stmt.expr)) {
                    this.emitStmt(stmt.expr)
                }
                this.emitStrn(";\n", 2)

                this.emitDefers()
                this.emitStr("return ___result;\n}\n")
            }
            else {
                this.emitDefers()

                this.emitStrn("return", 6);
                if(stmt.expr) {
                    this.emitStrn(" ", 1)
                    if(!this.emitTraitCast(stmt.expr)) {
                        this.emitStmt(stmt.expr)
                    }
                }
                this.emitStrn(";\n", 2)
            }
            return;
        }

        case StmtKind.SWITCH_CASE_STMT: {
            var stmt = s as (*SwitchCaseStmt)
            this.emitStrn("case ", 5)
            this.emitStmt(stmt.cond)
            this.emitStrn(": ", 2)
            this.emitStmt(stmt.body)
            return;
        }
        case StmtKind.SWITCH_STMT: {
            var stmt = s as (*SwitchStmt)

            this.pushScope(&CGenScope{.isSwitch = true})
            defer this.popScope()

            this.emitStrn("switch(", 7)
            this.emitStmt(stmt.cond)
            this.emitStrn(") {", 3)
            for(var i = 0; i < stmt.cases.size(); i+=1) {
                if(i > 0) this.emitln()
                this.emitStmt(stmt.cases.get(i))
            }

            if(stmt.defaultStmt) {
                this.emitStrn("\ndefault: ", 10)
                this.emitStmt(stmt.defaultStmt)
            }
            this.emitStrn("}", 1)
            return;
        }
        case StmtKind.TRAIT_FIELD_DECL: {
            var decl = s as (*TraitFieldDecl)
            this.emitLineInfo(decl)

            this.emitNotes(&decl.attributes)

            var name: [MAX_SYMBOL_NAME]char;
            var nameStr = StringInit(name, MAX_SYMBOL_NAME, 0)
            nameStr.setStrn(decl.name.str.buffer, decl.name.str.length)

            var aliasNote = decl.getNote("alias")
            if(aliasNote && !aliasNote.arguments.empty()) {
                var aliasName = aliasNote.arguments.get(0)
                if(aliasName.argExpr) {
                    var value = aliasName.argExpr.operand.val.str

                    nameStr.clear()
                    nameStr.setStrn(value.buffer, value.length)
                }
            }

            this.emitStr(this.cTypeDecl(decl.type.typeInfo, nameStr.cStrConst()))
            this.emitStrn(";\n", 2)
            return;
        }
        case StmtKind.VAR_FIELD_DECL: {
            var decl = s as (*VarFieldDecl)
            this.emitLineInfo(decl)

            this.emitNotes(&decl.attributes)

            var name: [MAX_SYMBOL_NAME]char;
            var nameStr = StringInit(name, MAX_SYMBOL_NAME, 0)
            nameStr.setStrn(decl.name.str.buffer, decl.name.str.length)

            var aliasNote = decl.getNote("alias")
            if(aliasNote && !aliasNote.arguments.empty()) {
                var aliasName = aliasNote.arguments.get(0)
                if(aliasName.argExpr) {
                    var value = aliasName.argExpr.operand.val.str

                    nameStr.clear()
                    nameStr.setStrn(value.buffer, value.length)
                }
            }

            this.emitStr(this.cTypeDecl(decl.type.typeInfo, nameStr.cStrConst()))
            this.emitStrn(";\n", 2)
            return;
        }
        case StmtKind.WHILE_STMT: {
            var stmt = s as (*WhileStmt)
            this.emitStrn("while(", 6)
            this.emitStmt(stmt.cond)
            this.emitStrn(") {", 3)
            {
                this.pushScope(&CGenScope{.isLoop = true})
                defer this.popScope()

                this.emitStmt(stmt.body)
                if(IsExpr(stmt.body)) {
                    this.emitStrn(";\n", 2)
                }
            }
            this.emitStrn("}", 1)
            return;
        }

        case StmtKind.ARRAY_DESIGNATION_EXPR: {
            var expr = s as (*ArrayDesignationExpr)
            this.emitStrn("[", 1)
            this.emitStmt(expr.index)
            this.emitStrn("] = ", 4)
            this.emitStmt(expr.value)
            return;
        }
        case StmtKind.ARRAY_INIT_EXPR: {
            var expr = s as (*ArrayInitExpr)

            // TODO: I don't think this is needed?
            // this breaks struct initializers i.e., .TypeInfo {.params = []ParamInfo{} }
            if(false && expr.values.empty()) {
                buf.appendStrn("{}", 2)
            }
            else {
                var requiresCast = false
                if(expr.parent) {
                    requiresCast = expr.parent.kind == StmtKind.RETURN_STMT ||
                                   expr.parent.kind == StmtKind.FUNC_CALL_EXPR;
                }

                if(requiresCast || !expr.expectedType || expr.expectedType.kind == TypeKind.PTR) {
                    this.emitStrn("(", 1)
                    this.emitStr(this.cType(expr.type.typeInfo))
                    this.emitStrn(")", 1)
                }

                this.emitStrn(" {", 2)
                for(var i = 0; i < expr.values.size(); i+=1) {
                    if(i > 0) {
                        this.emitStrn(",\n", 2)
                    }
                    this.emitStmt(expr.values.get(i))
                }

                this.emitStrn("}", 1)
            }
            return;
        }
        case StmtKind.BINARY_EXPR: {
            var expr = s as (*BinaryExpr)
            this.emitStmt(expr.left)
            this.emitStrn(" ", 1)
            this.emitStr(tokenText[expr.operator])
            this.emitStrn(" ", 1)
            this.emitStmt(expr.right)
            break;
        }
        case StmtKind.BOOLEAN_EXPR: {
            var expr = s as (*BooleanExpr)
            this.emitStr(this.options.cPrefix)
            if(expr.boolean) {
                this.emitStrn("true", 4)
            }
            else {
                this.emitStrn("false", 5)
            }
            return;
        }
        case StmtKind.CAST_EXPR: {
            var expr = s as (*CastExpr)
            this.emitStrn("(", 1)
            this.emitStr(this.cType(expr.castTo.typeInfo, true))
            this.emitStrn(")", 1)
            this.emitStmt(expr.exprToCast)
            return;
        }
        case StmtKind.CHAR_EXPR: {
            var expr = s as (*CharExpr)
            var value = expr.character.intValue
            if(value < 256 && value >= 0) {
                var c = escapeStrings[value]
                if(c != 0) {
                    this.buf.append("'%s'", c)
                }
                else {
                    this.buf.append("'%c'", value as (char))
                }
            }
            else {
                this.buf.append("%d", value)
            }
            return;
        }
        case StmtKind.FUNC_CALL_EXPR: {
            var expr = s as (*FuncCallExpr)
            var objectType = expr.object.operand.typeInfo

            // If this is a function call on a trait, we must
            // modify the call so that the trait is passed as
            // the first argument.  This can get tricky because
            // we have to account for side-effects and therefore
            // have to do some code injection to ensure side-effects
            // are only done once
            var isTrait = false
            if(objectType.kind == TypeKind.FUNC_PTR) {
                var funcPtr = objectType
                if(funcPtr.isTrait) {
                    isTrait = true

                    this.emitTraitFuncCall(expr)
                }
            }

            if(!isTrait) {
                this.emitStmt(expr.object)
                this.emitStrn("(", 1)
            }


            // capture the last line position, because
            // default parameters use lineInfo from where
            // they are initially defined -- which is no good,
            // especially for capturing __LINE__ and __FILE__ macros...
            var startPos = expr.startPos

            var i = 0;
            for(; i < expr.arguments.size(); i+=1) {
                if(i > 0) {
                    this.emitStrn(", ", 2)
                }

                var arg = expr.arguments.get(i)
                if(!arg.argExpr) {
                    continue;
                }

                if(!this.emitTraitCast(arg.argExpr)) {
                    if(arg.isDefault) {
                        var oldPos = arg.argExpr.startPos
                        defer arg.argExpr.startPos = oldPos

                        arg.argExpr.startPos.filename = startPos.filename
                        arg.argExpr.startPos.lineNumber = startPos.lineNumber

                        this.emitStmt(arg.argExpr)
                    }
                    else {
                        this.emitStmt(arg.argExpr)
                        startPos = arg.argExpr.startPos
                    }
                }
            }

            // fill out default parameters
            if(objectType.kind == TypeKind.FUNC) {
                var funcType = objectType
                for(; i < funcType.funcDecl.params.size(); i+=1) {
                    var param = funcType.funcDecl.params.get(i)
                    if(param.defaultExpr) {
                        if(i > 0) {
                            this.emitStrn(", ", 2)
                        }
                        this.emitStmt(param.defaultExpr)
                    }
                }
            }
            this.emitStrn(")", 1)
            return;
        }
        case StmtKind.IDENTIFIER_EXPR:
        case StmtKind.FUNC_IDENTIFIER_EXPR: {
            var expr = s as (*IdentifierExpr)

            var type = expr.type.typeInfo
            var sym: *Symbol = (type) ? type.sym : expr.sym;

            if(!sym) {
                this.emitStr(this.options.cPrefix)
                this.emitStrn(expr.type.name.buffer, expr.type.name.length)
            }
            else {
                this.emitSymbol(sym)
            }

            return;
        }
        case StmtKind.GET_EXPR: {
            var expr = s as (*GetExpr)

            // handled by funcCallExpr
            if(expr.flags & GetExprFlags.IS_METHOD_CALL) {
                this.emitStr(this.cTypeName(expr.field.operand.typeInfo))
                return;
            }

            var objectType = expr.object.operand.typeInfo

            if(expr.flags & GetExprFlags.IS_ENUM) {
                // TODO: Allow for Alias field names for foreign types!
                if(objectType.sym && objectType.sym.flags & SymbolFlags.IS_FOREIGN) {
                    buf.appendStrn(expr.field.type.name.buffer, expr.field.type.name.length)
                }
                else {
                    buf.appendStr(this.cName(objectType.sym))
                    buf.appendStrn("_", 1)
                    buf.appendStrn(expr.field.type.name.buffer, expr.field.type.name.length)
                }
                return;
            }

            this.emitStmt(expr.object)

            if(!IsAggregateLike(objectType)) {
                if(objectType.kind == TypeKind.PTR) {
                    buf.appendStrn("->", 2)
                }
                else {
                    buf.appendStrn(".", 1)
                }
                this.emitStmt(expr.field)
                return;
            }

            var baseInfo = objectType.getBaseType()
            assert(baseInfo != null)
            assert(IsAggregate(baseInfo)) //.kind == TypeKind.STRUCT || baseInfo.kind == TypeKind.UNION)

            var aggInfo = baseInfo

            if(expr.flags & GetExprFlags.IS_USING) {
                var path = FieldPath{}
                var isFound = aggInfo.getFieldPath(expr.field.type.name, &path)
                assert(isFound)

                var nextType = objectType
                for(var i = 0; i < path.numOfFields; i+=1) {
                    var field = path.fields[i]
                    if(nextType.kind == TypeKind.PTR) {
                        buf.appendStrn("->", 2)
                    }
                    else {
                        buf.appendStrn(".", 1)
                    }
                    this.emitFieldName(field)
                    nextType = field.typeInfo
                    // TODO: Check for trait!!
                }
            }
            else {
                if(objectType.kind == TypeKind.PTR) {
                    buf.appendStrn("->", 2)
                }
                else {
                    buf.appendStrn(".", 1)
                }
                var field = aggInfo.getField(expr.field.type.name)

                if(baseInfo.kind == TypeKind.TRAIT) {
                    this.emit("__vtable->")
                }

                this.emitFieldName(field)
            }

            return;
        }
        case StmtKind.GROUP_EXPR: {
            var expr = s as (*GroupExpr)
            this.emitStrn("(", 1)
            this.emitStmt(expr.groupedExpr)
            this.emitStrn(")", 1)
            return;
        }
        case StmtKind.INIT_ARG_EXPR: {
            var expr = s as (*InitArgExpr)
            if(expr.fieldName.token.type == TokenType.IDENTIFIER) {
                var parentExpr = expr.parent
                assert(parentExpr && parentExpr.kind == StmtKind.INIT_EXPR)

                var objectType = (parentExpr as (*InitExpr)).type.typeInfo
                assert(objectType != null)

                assert(IsAggregateLike(objectType))
                var baseInfo = objectType.getBaseType()
                assert(baseInfo != null)
                assert(baseInfo.kind == TypeKind.STRUCT || baseInfo.kind == TypeKind.UNION)

                var aggInfo = baseInfo

                var field = aggInfo.getField(expr.fieldName.str)
                if(field.kind == StmtKind.VAR_FIELD_DECL) {
                    this.emitStrn(".", 1)
                    this.emitFieldName(field)
                    this.emitStrn(" = ", 3)
                }
                else if(field.kind == StmtKind.STRUCT_FIELD_DECL ||
                        field.kind == StmtKind.UNION_FIELD_DECL) {
                    var decl = field.aggregateField
                    this.emitStrn(".", 1)
                    this.emitName(decl.name)
                    this.emitStrn(" = ", 3)
                }
                else if(field.kind == StmtKind.ENUM_FIELD_DECL) {
                    var decl = field.enumField
                    this.emitStrn(".", 1)
                    this.emitName(decl.name)
                    this.emitStrn(" = ", 3)
                }
                else {
                    assert(false)
                }
            }

            if(!this.emitTraitCast(expr.value)) {
                this.emitStmt(expr.value)
            }
            return;
        }
        case StmtKind.INIT_EXPR: {
            var expr = s as (*InitExpr)

            var requiresCast = false
            if(expr.parent) {
                requiresCast = expr.parent.kind == StmtKind.RETURN_STMT ||
                               expr.parent.kind == StmtKind.FUNC_CALL_EXPR;
            }

            if(requiresCast || !expr.expectedType || expr.expectedType.kind == TypeKind.PTR) {
                this.emitStrn("(", 1)
                this.emitStr(this.cType(expr.type.typeInfo))
                this.emitStrn(")", 1)
            }
            this.emitStrn(" {", 2)
            for(var i = 0; i < expr.arguments.size(); i += 1) {
                if(i > 0) {
                    this.emitStrn(",\n", 2)
                }
                this.emitStmt(expr.arguments.get(i))
            }
            this.emitStrn("}", 1)
            return;
        }
        case StmtKind.NULL_EXPR: {
            this.emitStrn("NULL", 4)
            return;
        }
        case StmtKind.NUMBER_EXPR: {
            var expr = s as (*NumberExpr)

            var hasDecimal = false
            var isHex = false
            var isBin = false
            var length: usize = expr.startPos.end - expr.startPos.start
            var start = expr.startPos.start

            if(length > 2) {
                var first = expr.startPos.start[0]
                var second = tolower(expr.startPos.start[1])
                if(first == '0' && second == 'x') {
                    isHex = true
                }
                else if(first == '0' && second == 'b') {
                    isBin = true
                }
            }

            for(; start != expr.startPos.end; start += 1) {
                var c = *start

                if(c == '.') {
                    hasDecimal = true
                }
                else if(c == '_') {
                    continue
                }
                else if(isalpha(c)) {
                    if(!isHex && !isBin) {
                        break;
                    }

                    if(isHex) {
                        c = tolower(c)
                        if(c != 'a' &&
                           c != 'b' &&
                           c != 'c' &&
                           c != 'd' &&
                           c != 'e' &&
                           c != 'f' &&
                           c != 'x') {
                           break
                        }
                    }
                    else if(isBin) {
                        c = tolower(c)
                        if(c != 'b') {
                               break
                        }
                    }
                    else {
                        break
                    }
                }

                buf.appendChar(*start)
            }

            var type = expr.operand.typeInfo
            if(!isHex && !isBin) {
                switch(type.kind) {
                    case TypeKind.F32: {
                        if(!hasDecimal) {
                            this.emitStrn(".", 1)
                        }
                        this.emitStrn("f", 1)
                        break;
                    }
                    case TypeKind.F64: {
                        if(!hasDecimal) {
                            this.emitStrn(".0", 2)
                        }
                        break;
                    }
                    case TypeKind.U8:
                    case TypeKind.U16:
                    case TypeKind.U32: {
                        this.emitStrn("U", 1)
                        break;
                    }
                    case TypeKind.U64: {
                        this.emitStrn("UL", 2)
                        break;
                    }
                    case TypeKind.I64: {
                        this.emitStrn("L", 1)
                        break;
                    }
                    default: {

                    }
                }
            }
            return;
        }
        case StmtKind.OFFSET_OF_EXPR: {
            var expr = s as (*OffsetOfExpr)
            this.emit("offsetof(%s, %.*s)", this.cType(expr.type.typeInfo), expr.field.str.length, expr.field.str.buffer)
            return;
        }
        case StmtKind.SET_EXPR: {
            var expr = s as (*SetExpr)
            this.emitStmt(expr.object)

            var objectType = expr.object.operand.typeInfo
            if(expr.flags & GetExprFlags.IS_USING) {
                var baseInfo = objectType.getBaseType()
                assert(baseInfo != null)
                assert(baseInfo.kind == TypeKind.STRUCT || baseInfo.kind == TypeKind.UNION)

                var aggInfo = baseInfo

                var path = FieldPath{}
                var isFound = aggInfo.getFieldPath(expr.field.type.name, &path)
                assert(isFound)

                var nextType = objectType
                for(var i = 0; i < path.numOfFields; i+=1) {
                    var field = path.fields[i]
                    if(nextType.kind == TypeKind.PTR) {
                        buf.appendStrn("->", 2)
                    }
                    else {
                        buf.appendStrn(".", 1)
                    }
                    this.emitStrn(field.varField.name.str.buffer, field.varField.name.str.length)
                    nextType = field.typeInfo
                }

                this.emit(" %s ", tokenText[expr.operator])
            }
            else {
                if(objectType.kind == TypeKind.PTR) {
                    buf.appendStrn("->", 2)
                }
                else {
                    buf.appendStrn(".", 1)
                }
                buf.appendStrn(expr.field.type.name.buffer, expr.field.type.name.length)
                buf.appendStrn(" ", 1)
                buf.appendStr(tokenText[expr.operator])
                buf.appendStrn(" ", 1)
            }

            this.emitStmt(expr.value)
            return;
        }
        case StmtKind.SIZE_OF_EXPR: {
            var expr = s as (*SizeOfExpr)
            this.emitStrn("sizeof(", 7)
            this.emitStmt(expr.sizeOfExpr)
            this.emitStrn(")", 1)
            return;
        }
        case StmtKind.STRING_EXPR: {
            var expr = s as (*StringExpr)

            if(expr.string.mod == Mod.MULTISTR) {
                var str = expr.string.str

                this.buf.appendChar('"') // "
                for(var i = 0; i < str.length;) {
                    var byte = str.buffer[i] as (u8)

                    if(byte < 128) {
                        var c:char = byte as (char)
                        var n = str.buffer[i+1] as (u32)
                        var isSeq = (n == 'u' || n == 'U' || n != 'x')

                        if(c == '\r') {
                            i += 1
                            continue
                        }

                        var escaped = escapeStrings[c as (u32)]
                        if(escaped && !(c == '\\' && isSeq)) {
                            buf.appendStr(escaped)
                            i += 1
                            continue
                        }

                        if(c == '\\') {
                            var n = str.buffer[i+1] as (u32)
                            var escapedChar = escapeChars[n]
                            if(escapedChar) {
                                var chars = escapeChars[n]
                                assert(chars)
                                buf.appendStr(chars)
                                i += 2
                                continue
                            }
                            else if(!isSeq) {
                                buf.appendStrn("\\", 1)
                            }
                        }
                        if(c == '"') {  // "
                            buf.appendStrn("\\", 1)
                        }

                        buf.appendChar(c)
                        i += 1
                    }
                    else {
                        var result: rune = 0
                        var len = Utf8Decode((&str.buffer[i]) as (*const u8), -1, &result) as (i32)
                        assert(len > 0)

                        buf.appendStrn(&str.buffer[i], len)
                        i += len
                    }
                }
                this.buf.appendChar('"') // "
            }
            else {
                this.buf.appendStrn("\"", 1)
                this.buf.appendStrn(expr.string.str.buffer, expr.string.str.length)
                this.buf.appendStrn("\"", 1)
            }
            return;
        }
        case StmtKind.SUBSCRIPT_GET_EXPR: {
            var expr = s as (*SubscriptGetExpr)
            this.emitStmt(expr.object)
            this.emitStrn("[", 1)
            this.emitStmt(expr.index)
            this.emitStrn("]", 1)
            return;
        }
        case StmtKind.SUBSCRIPT_SET_EXPR: {
            var expr = s as (*SubscriptSetExpr)
            this.emitStmt(expr.object)
            this.emitStrn("[", 1)
            this.emitStmt(expr.index)
            this.emitStrn("] ", 2)
            this.emitStr(tokenText[expr.operator])
            this.emitStrn(" ", 1)
            this.emitStmt(expr.value)
            return;
        }
        case StmtKind.TERNARY_EXPR: {
            var expr = s as (*TernaryExpr)
            this.emitStrn("(", 1)
            this.emitStmt(expr.cond)
            this.emitStrn(") ? ", 4)
            this.emitStmt(expr.then)
            this.emitStrn(" : ", 3)
            this.emitStmt(expr.other)
            return;
        }
        case StmtKind.TYPE_IDENTIFIER_EXPR: {
            var expr = s as (*TypeIdentifierExpr)
            // TODO: Simplify this...
            if(expr.type.typeInfo) {
                this.emitStr(this.cType(expr.type.typeInfo))
            }
            else {
                if(expr.sym) {
                    this.emitSymbol(expr.sym)
                }
                else {
                    this.emitTypeSpec(expr.type)
                }
            }
            return;
        }
        case StmtKind.TYPE_OF_EXPR: {
            var expr = s as (*TypeOfExpr)
            if(expr.typeOfExpr) {
                this.emit("%lldLL", expr.typeOfExpr.operand.typeInfo.typeid)
            }
            else if(expr.type) {
                this.emit("%lldLL", expr.type.typeInfo.typeid)
            }
            return;
        }
        case StmtKind.UNARY_EXPR: {
            var expr = s as (*UnaryExpr)
            this.emitStr(tokenText[expr.operator])
            this.emitStrn("(", 1)
            this.emitStmt(expr.unaryExpr)
            this.emitStrn(")", 1)
            return;
        }
        case StmtKind.POISON_EXPR: {
            assert(false)
            return;
        }
        default: {
            //Panic("Unknown statement kind: %d", s.kind)
            this.emit("<%s Not Implemented>", StmtKindAsStr(s.kind))
            assert(false)
        }
    }
}