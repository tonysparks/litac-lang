import "std/string_view"
import "std/string_buffer"
import "std/string"
import "std/array"
import "std/assert"
import "std/libc"
import "std/mem"
import "std/map"

import "ast_new"
import "module"
import "symbols"
import "ast"
import "lex"
import "types_new"
import "common"
import "checker"
import "lita"
import "intern"

@asStr
public enum TypeKind {
    BOOL = 1,
    CHAR,
    I8,
    U8,
    I16,
    U16,
    I32,
    U32,
    I64,
    U64,
    F32,
    F64,
    USIZE,
    NULL,
    VOID,

    STR,
    ARRAY,
    PTR,
    FUNC_PTR,

    STRUCT,
    UNION,
    TRAIT,
    ENUM,
    FUNC,

    CONST,
    GENERIC_PARAM,

    POISON,

    MAX_TYPE_KINDS
}

const typeKindText = [TypeKind.MAX_TYPE_KINDS + 1]*const char {
    [TypeKind.BOOL] = "bool",
    [TypeKind.CHAR] = "char",
    [TypeKind.I8] = "i8",
    [TypeKind.U8] = "u8",
    [TypeKind.I16] = "i16",
    [TypeKind.U16] = "u16",
    [TypeKind.I32] = "i32",
    [TypeKind.U32] = "u32",
    [TypeKind.I64] = "i64",
    [TypeKind.U64] = "u64",
    [TypeKind.F32] = "f32",
    [TypeKind.F64] = "f64",
    [TypeKind.USIZE] = "usize",
    [TypeKind.NULL] = "null",
    [TypeKind.VOID] = "void",

    [TypeKind.STR] = "string",
    [TypeKind.ARRAY] = "array",
    [TypeKind.PTR] = "pointer",
    [TypeKind.FUNC_PTR] = "func_pointer",

    [TypeKind.STRUCT] = "struct",
    [TypeKind.UNION] = "union",
    [TypeKind.TRAIT] = "trait",
    [TypeKind.ENUM] = "enum",
    [TypeKind.FUNC] = "func",

    [TypeKind.CONST] = "const",
    [TypeKind.GENERIC_PARAM] = "generic_param",
    [TypeKind.POISON] = "poison",

    [TypeKind.MAX_TYPE_KINDS] = "",
}

public func TypeKindFromString(str: *const char, len: i32) : TypeKind {
    var view = StringViewInit(str, len)
    for(var i = TypeKind.BOOL; i < TypeKind.MAX_TYPE_KINDS; i += 1) {
        if(view.equals(typeKindText[i])) {
            return i;
        }
    }

    return TypeKind.MAX_TYPE_KINDS
}

public func IsPtr(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    if(type.kind == TypeKind.CONST) {
        var constInfo = type
        return IsPtr(constInfo.constOf)
    }

    return type.kind == TypeKind.PTR
}

public func IsPtrLike(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.PTR:
        case TypeKind.STR:
        case TypeKind.ARRAY: {
            return true;
        }
        case TypeKind.CONST: {
            var constInfo = type
            return IsPtrLike(constInfo.constOf)
        }
        default: {
            return false;
        }
    }
}

public func IsPtrOf(type: *TypeInfo, kind: TypeKind) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.PTR: {
            var ptrInfo = type
            return ptrInfo.ptrOf.kind == kind
        }
        case TypeKind.STR: {
            return kind == TypeKind.CHAR
        }
        case TypeKind.ARRAY: {
            var arrayInfo = type
            return arrayInfo.arrayOf.kind == kind
        }
        case TypeKind.CONST: {
            var constInfo = type
            return constInfo.constOf.kind == kind
        }
        default: {
            return false;
        }
    }
}


public func IsFuncLike(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.FUNC:
        case TypeKind.FUNC_PTR: {
            return true;
        }
        default: {
            return false;
        }
    }
}

public func IsPrimitive(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    return type.kind < TypeKind.STR
}

public func IsNumberLike(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.BOOL:
        case TypeKind.CHAR:
        case TypeKind.I8:
        case TypeKind.U8:
        case TypeKind.I16:
        case TypeKind.U16:
        case TypeKind.I32:
        case TypeKind.U32:
        case TypeKind.I64:
        case TypeKind.U64:
        case TypeKind.F32:
        case TypeKind.F64:
        case TypeKind.USIZE:
        case TypeKind.PTR:
        case TypeKind.STR:
        case TypeKind.ARRAY:
        case TypeKind.NULL:
        case TypeKind.ENUM: {
            return true;
        }
        case TypeKind.CONST: {
            var constInfo = type
            return IsNumberLike(constInfo.constOf)
        }
        default: {
            return false
        }
    }
}

public func IsInteger(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.BOOL:
        case TypeKind.CHAR:
        case TypeKind.I8:
        case TypeKind.U8:
        case TypeKind.I16:
        case TypeKind.U16:
        case TypeKind.I32:
        case TypeKind.U32:
        case TypeKind.I64:
        case TypeKind.U64:
        case TypeKind.USIZE:
        case TypeKind.ENUM: {
            return true;
        }
        case TypeKind.CONST: {
            var constInfo = type
            return IsInteger(constInfo.constOf)
        }
        default: {
            return false
        }
    }
}

public func IsBooleanable(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.BOOL:
        case TypeKind.CHAR:
        case TypeKind.I8:
        case TypeKind.U8:
        case TypeKind.I16:
        case TypeKind.U16:
        case TypeKind.I32:
        case TypeKind.U32:
        case TypeKind.I64:
        case TypeKind.U64:
        case TypeKind.F32:
        case TypeKind.F64:
        case TypeKind.USIZE:
        case TypeKind.PTR:
        case TypeKind.STR:
        case TypeKind.ARRAY:
        case TypeKind.NULL:
        case TypeKind.FUNC_PTR:
        case TypeKind.ENUM: {
            return true;
        }
        case TypeKind.CONST: {
            var constInfo = type
            return IsBooleanable(constInfo.constOf)
        }
        default: {
            return false
        }
    }
}

/**
    Converts the trait method into a function pointer.  This adds the first
    void pointer argument
*/
public func AsTraitFuncPtr(type: *TypeInfo, name: InternedString, typeCache: *TypeCache) : *TypeInfo {
    if(!type) {
        return null
    }

    assert(type.kind == TypeKind.FUNC_PTR)

    var funcPtr = type

    assert(funcPtr.isTrait)

    var params = ArrayInit<*TypeInfo>(funcPtr.paramDecls.size() + 1, typeCache.allocator)
    params.add(typeCache.newPtrTypeInfo(&VOID_TYPE) as (*TypeInfo))
    for(var i = 0; i < funcPtr.paramDecls.size(); i += 1) {
        params.add(funcPtr.paramDecls.get(i))
    }

    var result = typeCache.newFuncPtrTypeInfo(funcPtr.genericParams,
                                              funcPtr.returnType,
                                              params,
                                              funcPtr.hasVarargs)

    result.name = name
    return result

}

public func AsAggregate(type: *TypeInfo) : *TypeInfo {
    assert(IsAggregateLike(type))

    if(IsAggregate(type)) {
        if(type.kind == TypeKind.CONST) {
            var constInfo = type
            return AsAggregate(constInfo.constOf)
        }

        return type
    }

    if(IsPtrAggregate(type)) {
        var ptrInfo: *TypeInfo = null
        if(type.kind == TypeKind.CONST) {
            var constInfo = type
            ptrInfo = constInfo.constOf
        }
        else {
            ptrInfo = type.ptrOf
        }
        return AsAggregate(ptrInfo)
    }

    assert(false)
    return null
}

public func IsAggregateLike(type: *TypeInfo) : bool {
    return IsAggregate(type) || IsPtrAggregate(type)
}

public func IsAggregate(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    if(type.kind == TypeKind.CONST) {
        var constInfo = type
        return IsAggregate(constInfo.constOf)
    }

    return type.kind == TypeKind.STRUCT ||
           type.kind == TypeKind.UNION  ||
           type.kind == TypeKind.TRAIT
}

public func IsPtrAggregate(type: *TypeInfo) : bool {
    if(!IsPtr(type)) {
        return false;
    }
    var ptrInfo: *TypeInfo = null
    if(type.kind == TypeKind.CONST) {
        var constInfo = type
        ptrInfo = constInfo.constOf
    }
    else {
        ptrInfo = type.ptrOf
    }
    return IsAggregate(ptrInfo)
}

public func IsTrait(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    if(type.kind == TypeKind.CONST) {
        var constInfo = type
        return IsTrait(constInfo.constOf)
    }

    return type.kind == TypeKind.TRAIT
}

public func IsPtrTrait(type: *TypeInfo) : bool {
    if(!IsPtr(type)) {
        return false;
    }

    var ptrInfo: *TypeInfo = null
    if(type.kind == TypeKind.CONST) {
        var constInfo = type
        ptrInfo = constInfo.constOf
    }
    else {
        ptrInfo = type.ptrOf
    }
    return IsTrait(ptrInfo)
}

public func IsTraitLike(type: *TypeInfo) : bool {
    return IsTrait(type) || IsPtrTrait(type)
}

public func IsFieldAccessible(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    if(IsAggregate(type) || IsPtrAggregate(type) || type.kind == TypeKind.ENUM) {
        return true
    }

    return false
}

public func IsGenericCapable(type: *TypeInfo) : bool {
    if(!type) {
        return false;
    }

    switch(type.kind) {
        case TypeKind.FUNC:
        case TypeKind.FUNC_PTR:
        case TypeKind.STRUCT:
        case TypeKind.TRAIT:
        case TypeKind.UNION:
            return true
        default:
            return false
    }
}

public func (this: *TypeInfo) getBaseType() : *TypeInfo {
    if(!this) return null;
    switch(this.kind) {
        case TypeKind.PTR: {
            var info = this
            return info.ptrOf.getBaseType()
        }
        case TypeKind.CONST: {
            var info = this
            return info.constOf.getBaseType()
        }
        case TypeKind.ARRAY: {
            var info = this
            if(info.arrayOf.kind == TypeKind.ARRAY) {
                return info.arrayOf.getBaseType()
            }
            return info.arrayOf
        }
        case TypeKind.STR: {
            return &CHAR_TYPE
        }
        default: {
            return this
        }
    }
}

public func (this: *TypeInfo) getTypeOf() : *TypeInfo {
    if(!this) return null;

    switch(this.kind) {
        case TypeKind.PTR: {
            var info = this
            return info.ptrOf
        }
        case TypeKind.CONST: {
            var info = this
            return info.constOf
        }
        case TypeKind.ARRAY: {
            var info = this
            return info.arrayOf
        }
        case TypeKind.STR: {
            return &CHAR_TYPE
        }
        default: {
            return null
        }
    }
}

public func (this: *TypeInfo) toStringDebug() : *const char {
    var sb = StringBufferInit(256)
    this.toString(sb)
    return sb.cStr()
}

public func (this: *TypeInfo) toString(sb: *StringBuffer, fullyQualify: bool = false) {
    if(!this) return;

    switch(this.kind) {
        case TypeKind.BOOL:
        case TypeKind.CHAR:
        case TypeKind.I8:
        case TypeKind.U8:
        case TypeKind.I16:
        case TypeKind.U16:
        case TypeKind.I32:
        case TypeKind.U32:
        case TypeKind.I64:
        case TypeKind.U64:
        case TypeKind.F32:
        case TypeKind.F64:
        case TypeKind.USIZE:
        case TypeKind.NULL:
        case TypeKind.VOID:
        case TypeKind.GENERIC_PARAM: {
            sb.appendStrn(this.name.buffer, this.name.length)
            break;
        }
        case TypeKind.STRUCT:
        case TypeKind.UNION:
        case TypeKind.TRAIT:
        case TypeKind.ENUM: {
            if(fullyQualify && this.sym) {
                var name = this.sym.declared.id.packageName
                sb.append("%.*s::", name.length, name.buffer)
            }
            sb.appendStrn(this.name.buffer, this.name.length)
            break;
        }
        case TypeKind.STR: {
            sb.appendStr("*const char")
            break;
        }
        case TypeKind.ARRAY: {
            var arrayInfo = this
            if(arrayInfo.length) {
                sb.append("[%llu]", arrayInfo.length)
            }
            else {
                sb.appendStrn("[]", 2)
            }
            arrayInfo.arrayOf.toString(sb, fullyQualify)
            break;
        }
        case TypeKind.PTR: {
            var ptrInfo = this
            sb.appendStrn("*", 1)
            ptrInfo.ptrOf.toString(sb, fullyQualify)
            break;
        }
        case TypeKind.CONST: {
            var constInfo = this
            sb.appendStrn("const ", 6)
            constInfo.constOf.toString(sb, fullyQualify)
            break;
        }
        case TypeKind.FUNC_PTR: {
            var funcPtrInfo = this
            sb.appendStrn("func", 4)
            if(!funcPtrInfo.genericParams.empty()) {
                sb.appendStrn("<", 1)
                for(var i = 0; i < funcPtrInfo.genericParams.size(); i += 1) {
                    if(i > 0) sb.appendStrn(",", 1)
                    var t = funcPtrInfo.genericParams.get(i).name
                    sb.appendStrn(t.str.buffer, t.str.length)
                }
                sb.appendStrn(">", 1)
            }
            sb.appendStrn("(", 1)
            for(var i = 0; i < funcPtrInfo.paramDecls.size(); i += 1) {
                if(i > 0) sb.appendStrn(",", 1)
                var paramType = funcPtrInfo.paramDecls.get(i)
                paramType.toString(sb, fullyQualify)
            }
            sb.appendStr(") : ")
            funcPtrInfo.returnType.toString(sb, fullyQualify)
            break;
        }
        case TypeKind.FUNC: {
            var funcInfo = this
            sb.appendStrn("func", 4)
            if(!funcInfo.funcDecl.genericParams.empty()) {
                sb.appendStrn("<", 1)
                for(var i = 0; i < funcInfo.funcDecl.genericParams.size(); i += 1) {
                    if(i > 0) sb.appendStrn(",", 1)
                    var t = funcInfo.funcDecl.genericParams.get(i).name
                    sb.appendStrn(t.str.buffer, t.str.length)
                }
                sb.appendStrn(">", 1)
            }
            sb.appendStrn("(", 1)
            for(var i = 0; i < funcInfo.funcDecl.params.size(); i += 1) {
                if(i > 0) sb.appendStrn(",", 1)
                var paramType = funcInfo.funcDecl.params.get(i)
                paramType.typeInfo.toString(sb, fullyQualify)
            }
            sb.appendStr(") : ")
            funcInfo.returnType.toString(sb, fullyQualify)
            break;
        }
        case TypeKind.POISON: {
            sb.appendStr("<poison>")
            break;
        }
        default: {
            assert(false)
        }
    }
}

public func (this: *TypeInfo) strictEquals(other: *TypeInfo) : bool {
    if(this == other) {
        return true
    }

    if(this && !other) {
        return false
    }

    if(!this && other) {
        return false
    }

    if(this.kind != TypeKind.GENERIC_PARAM &&
       other.kind != TypeKind.GENERIC_PARAM) {

        if(other.kind != this.kind) {
            return false
        }
    }

    switch(this.kind) {
        case TypeKind.PTR: {
            var thisInfo = this
            var otherInfo = other
            return thisInfo.ptrOf.strictEquals(otherInfo.ptrOf)
        }
        case TypeKind.CONST: {
            var thisInfo = this
            var otherInfo = other
            return thisInfo.constOf.strictEquals(otherInfo.constOf)
        }
        case TypeKind.ARRAY: {
            var thisInfo = this
            var otherInfo = other
            if(thisInfo.length != otherInfo.length) {
                return false;
            }
            return thisInfo.arrayOf.strictEquals(otherInfo.arrayOf)
        }
        case TypeKind.FUNC_PTR: {
            var thisInfo = this
            var otherInfo = other
            if(thisInfo.paramDecls.size() != otherInfo.paramDecls.size()) {
                return false;
            }
            if(!thisInfo.returnType.strictEquals(otherInfo.returnType)) {
                return false;
            }
            for(var i = 0; i < thisInfo.paramDecls.size(); i += 1) {
                var a = thisInfo.paramDecls.get(i)
                var b = otherInfo.paramDecls.get(i)
                if(a.strictEquals(b)) {
                    return false;
                }
            }
            return true
        }
        case TypeKind.GENERIC_PARAM: {
            if(other.kind == TypeKind.GENERIC_PARAM) {
                return this.name.addr == other.name.addr
            }

            return true
        }
        default: {
            if(other.kind == TypeKind.GENERIC_PARAM) {
                return true
            }

            return this.typeid == other.typeid
        }
    }

    return false
}

public func (this: *TypeInfo) isAssignable(
        other: *TypeInfo,
        checker: *TypeChecker,
        allowDecay: bool = true,
        allowPtrArithmetic: bool = true) : bool {

    assert(this != null)
    assert(other != null)

    if(other.typeid == this.typeid) {
        return true
    }

    // this = other
    switch(this.kind) {
        case TypeKind.BOOL: {
            if(other.kind == TypeKind.VOID) {
                return false
            }

            return true
        }
        case TypeKind.CHAR: {
            return other.kind <= TypeKind.U32
        }
        case TypeKind.I8: {
            return other.kind <= TypeKind.I8
        }
        case TypeKind.U8: {
            return other.kind <= TypeKind.U8
        }
        case TypeKind.I16: {
            return other.kind <= TypeKind.I16
        }
        case TypeKind.U16: {
            return other.kind <= TypeKind.U16
        }
        case TypeKind.I32: {
            return other.kind <= TypeKind.I32 ||
                   other.kind == TypeKind.ENUM
        }
        case TypeKind.U32: {
            return other.kind <= TypeKind.U32 ||
                   other.kind == TypeKind.ENUM
        }
        case TypeKind.I64: {
            return other.kind <= TypeKind.I64 ||
                   other.kind == TypeKind.ENUM
        }
        case TypeKind.U64: {
            return other.kind <= TypeKind.U64 ||
                   other.kind == TypeKind.ENUM
        }
        case TypeKind.F32: {
            return other.kind == TypeKind.F32 ||
                   other.kind <= TypeKind.U32
        }
        case TypeKind.F64: {
            return other.kind == TypeKind.F32 ||
                   other.kind == TypeKind.F64
        }
        case TypeKind.USIZE: {
            return other.kind <= TypeKind.USIZE ||
                   other.kind == TypeKind.NULL ||
                   IsPtrLike(other);
        }
        case TypeKind.NULL: {
            return other.kind == TypeKind.NULL
        }
        case TypeKind.VOID: {
            return other.kind == TypeKind.VOID
        }

        case TypeKind.STR: {
            // Allow for pointer arithmetic
            if(allowPtrArithmetic && IsInteger(other)) {
                return true
            }
            return this.isDeclarable(other, checker)
        }
        case TypeKind.ARRAY: {

            // Allow for pointer arithmetic
            if(allowPtrArithmetic && IsInteger(other)) {
                return true
            }

            if(allowDecay) {
                return this.isDeclarable(other, checker)
            }

            // Arrays can not be lvalue's...
            return false
        }
        case TypeKind.PTR: {
            // Allow for pointer arithmetic
            if(allowPtrArithmetic && IsInteger(other)) {
                return true
            }
            return this.isDeclarable(other, checker)
        }
        case TypeKind.CONST: {
            var thisInfo = this

            // Allow for *const char = *char
            if(other.kind != TypeKind.CONST) {
                return thisInfo.constOf.isAssignable(other, checker)
            }

            var otherInfo = other
            return thisInfo.constOf.isAssignable(otherInfo.constOf, checker)
        }
        case TypeKind.STRUCT: {
            if(other.kind != TypeKind.STRUCT) {
                return false
            }

            return this.typeid == other.typeid
        }
        case TypeKind.UNION: {
            if(other.kind != TypeKind.UNION) {
                return false
            }
            return this.typeid == other.typeid
        }
        case TypeKind.TRAIT: {
            return this.isDeclarable(other, checker)
        }
        case TypeKind.ENUM: {
            if(IsInteger(other)) {
                return true
            }
            if(other.kind != TypeKind.ENUM) {
                return false
            }
            return this.typeid == other.typeid
        }
        case TypeKind.FUNC_PTR: {
            if(other.kind == TypeKind.NULL) {
                return true
            }

            if(IsPtrOf(other, TypeKind.VOID)) {
                return true
            }

            if(!IsFuncLike(other)) {
                return false
            }

            var thisInfo = this
            if(other.kind != TypeKind.FUNC) {
                return this.isDeclarable(other, checker)
            }

            var funcInfo = other

            if(funcInfo.funcDecl.params.size() != thisInfo.paramDecls.size()) {
                return false
            }

            if(funcInfo.funcDecl.params.isVararg  != thisInfo.hasVarargs) {
                return false
            }
            if(!funcInfo.returnType.strictEquals(thisInfo.returnType)) {
                return false
            }

            for(var i = 0; i < thisInfo.paramDecls.size(); i += 1) {
                var a = thisInfo.paramDecls.get(i)

                var b = funcInfo.funcDecl.params.get(i)
                if(!b.typeInfo) {
                    return false
                }

                if(!a.strictEquals(b.typeInfo)) {
                    return false
                }
            }
            return true
        }
        case TypeKind.FUNC: {
            break;
        }
        case TypeKind.POISON: {
            return false;
        }
        case TypeKind.GENERIC_PARAM: {
            return true;
        }
        default: {
            printf("Type: %s\n", typeKindText[this.kind])
            assert(false)
        }
    }
    return false
}

public func (this: *TypeInfo) isDeclarable(other: *TypeInfo, checker: *TypeChecker) : bool {
    // this = other
    switch(this.kind) {
        case TypeKind.BOOL: {
            return other.kind == TypeKind.BOOL
        }
        case TypeKind.CHAR: {
            return other.kind <= TypeKind.U32
        }
        case TypeKind.I8: {
            return other.kind <= TypeKind.I8
        }
        case TypeKind.U8: {
            return other.kind <= TypeKind.U8
        }
        case TypeKind.I16: {
            return other.kind <= TypeKind.I16
        }
        case TypeKind.U16: {
            return other.kind <= TypeKind.U16
        }
        case TypeKind.I32: {
            return other.kind <= TypeKind.I32 ||
                   other.kind == TypeKind.ENUM
        }
        case TypeKind.U32: {
            return other.kind <= TypeKind.U32 ||
                   other.kind == TypeKind.ENUM
        }
        case TypeKind.I64: {
            return other.kind <= TypeKind.I64 ||
                   other.kind == TypeKind.ENUM
        }
        case TypeKind.U64: {
            return other.kind <= TypeKind.U64 ||
                   other.kind == TypeKind.ENUM
        }
        case TypeKind.F32: {
            return other.kind == TypeKind.F32 ||
                   other.kind <= TypeKind.U32
        }
        case TypeKind.F64: {
            return other.kind == TypeKind.F32 ||
                   other.kind == TypeKind.F64
        }
        case TypeKind.USIZE: {
            return other.kind <= TypeKind.USIZE ||
                   other.kind == TypeKind.NULL ||
                   IsPtrLike(other);
        }
        case TypeKind.NULL: {
            return other.kind == TypeKind.NULL
        }
        case TypeKind.VOID: {
            return other.kind == TypeKind.VOID
        }

        case TypeKind.STR: {
            if(IsPtr(other)) {
                var otherPtr = other
                if(otherPtr.ptrOf.kind == TypeKind.CONST) {
                    var constOf = otherPtr.ptrOf
                    return constOf.constOf.kind == TypeKind.CHAR
                }
                return otherPtr.ptrOf.kind == TypeKind.CHAR
            }
            return other.kind == TypeKind.STR
        }
        case TypeKind.ARRAY: {
            var thisArray = this
            if(other.kind == TypeKind.STR) {
                if(thisArray.arrayOf.kind == TypeKind.CONST) {
                    return IsPtrOf(thisArray.arrayOf, TypeKind.CHAR)
                }
                if(!IsPtrOf(thisArray, TypeKind.CHAR)) {
                    return false
                }

                return true
            }

            if(other.kind == TypeKind.PTR) {
                var otherPtr = other
                return thisArray.arrayOf.isDeclarable(otherPtr.ptrOf, checker)
            }

            if(other.kind != TypeKind.ARRAY) {
                return false
            }
            var otherArray = other

            if(!thisArray.arrayOf.isDeclarable(otherArray.arrayOf, checker)) {
                return false
            }

            if(!thisArray.length) {
                return true
            }
            return thisArray.length == otherArray.length
        }
        case TypeKind.PTR: {
            if(other.kind == TypeKind.NULL) {
                return true
            }

            if(other.kind == TypeKind.FUNC_PTR) {
                if(IsPtrOf(this, TypeKind.VOID)) {
                    return true
                }
            }

            if(!IsPtrLike(other)) {
                return false
            }

            var thisPtr = this
            var isVoidPtr = false
            var isConst = false

            var ptrOf = thisPtr.ptrOf
            if(thisPtr.ptrOf.kind == TypeKind.CONST) {
                var thisConst = thisPtr.ptrOf
                ptrOf = thisConst.constOf
                isConst = true
            }

            if(ptrOf.kind == TypeKind.VOID) {
                isVoidPtr = true
            }

            switch(other.kind) {
                case TypeKind.PTR: {
                    var otherPtr = other

                    // can't assign const to a non const: *x = *const x
                    if(otherPtr.ptrOf.kind == TypeKind.CONST) {
                        if(!isConst) {
                            return false
                        }
                    }

                    // *void or *const void can be assigned any ptr
                    if(isVoidPtr) {
                        return true
                    }

                    // only allow var p: *Trait = *Trait
                    if(IsTrait(ptrOf)) {
                        var otherPtrOf = otherPtr.getBaseType()
                        if(IsTrait(otherPtrOf)) {
                            return ptrOf.typeid == otherPtrOf.typeid
                        }

                        return false
                    }

                    // determine if we can do a using coersion
                    if(IsPtrAggregate(this) && IsPtrAggregate(other)) {
                        var otherAgg = other.getBaseType()
                        var thisAgg = this.getBaseType()

                        if(otherAgg.typeid == thisAgg.typeid) {
                            return true
                        }

                        // if a using field can be found, this can be assigned
                        var field = otherAgg.getFieldByType(thisAgg)
                        return (field.kind == StmtKind.VAR_FIELD_DECL) ||
                               (field.kind == StmtKind.TRAIT_FIELD_DECL)
                    }

                    return thisPtr.ptrOf.isDeclarable(otherPtr.ptrOf, checker)
                }
                case TypeKind.ARRAY: {
                    if(isVoidPtr) {
                        return true
                    }

                    var otherArray = other
                    return thisPtr.ptrOf.isDeclarable(otherArray.arrayOf, checker)
                }
                case TypeKind.STR: {
                    if(!isConst) {
                        return false
                    }

                    if(isVoidPtr) {
                        return true
                    }

                    return thisPtr.ptrOf.isDeclarable(&CHAR_TYPE, checker)
                }
                case TypeKind.CONST: {
                    return false; // can't assign const to non const
                }
                case TypeKind.FUNC_PTR: {
                    return true
                }
                default: {
                    return false
                }
            }

        }
        case TypeKind.CONST: {
            var constInfo = this

            if(other.kind == TypeKind.CONST) {
                var otherConst = other
                other = otherConst.constOf
            }
            return constInfo.constOf.isDeclarable(other, checker)
        }

        case TypeKind.FUNC_PTR: {
            if(other.kind == TypeKind.NULL) {
                return true
            }

            if(IsPtrOf(other, TypeKind.VOID)) {
                return true
            }

            if(other.kind != TypeKind.FUNC_PTR) {
                return false
            }

            var fnPtrInfo = this
            var otherFnPtrInfo = other

            if(fnPtrInfo.paramDecls.size() != otherFnPtrInfo.paramDecls.size()) {
                return false;
            }

            if(fnPtrInfo.hasVarargs != otherFnPtrInfo.hasVarargs) {
                return false;
            }

            if(!fnPtrInfo.returnType.strictEquals(otherFnPtrInfo.returnType)) {
                return false;
            }

            for(var i = 0; i < fnPtrInfo.paramDecls.size(); i += 1) {
                var a = fnPtrInfo.paramDecls.get(i)
                var b = otherFnPtrInfo.paramDecls.get(i)
                if(!a.strictEquals(b)) {
                    return false
                }
            }

            return true;
        }

        case TypeKind.STRUCT: {
            if(other.kind != TypeKind.STRUCT) {
                return false
            }

            if(this.typeid == other.typeid) {
                return true
            }
            var aggInfo = other
            if(aggInfo.aggDecl.fields.empty()) {
                return false
            }

            var field = aggInfo.getFieldByPosition(0)
            return this.isDeclarable(field.typeInfo, checker)
        }
        case TypeKind.UNION: {
            if(other.kind != TypeKind.UNION) {
                return false
            }

            if(this.typeid == other.typeid) {
                return true
            }
            var aggInfo = other
            if(aggInfo.aggDecl.fields.empty()) {
                return false
            }

            var field = aggInfo.getFieldByPosition(0)
            return this.isDeclarable(field.typeInfo, checker)
        }
        case TypeKind.TRAIT: {
            if(this.typeid == other.typeid) {
                return true
            }

            if(!IsPtr(other)) {
                return false
            }

            var aggInfo = other.getBaseType()
            return aggInfo.implementsTrait(this, checker)
        }
        case TypeKind.ENUM: {
            if(other.kind != TypeKind.ENUM) {
                return IsInteger(other)
            }
            return this.typeid == other.typeid
        }
        case TypeKind.FUNC: {
            // TODO
            assert(false)
            break;
        }
        case TypeKind.POISON: {
            return false;
        }
        default: {
            assert(false)
        }
    }
    return false
}


public func (this: *TypeInfo) canCastTo(castTo: *TypeInfo, checker: *TypeChecker) : bool {
    if(IsPtrOf(castTo, TypeKind.VOID)) {
        return true
    }

    if(castTo.kind == TypeKind.NULL) {
        return false
    }

    switch(this.kind) {
        case TypeKind.BOOL: {
            return IsNumberLike(castTo)
        }
        case TypeKind.CHAR: {
            return IsNumberLike(castTo)
        }
        case TypeKind.I8: {
            return IsNumberLike(castTo)
        }
        case TypeKind.U8: {
            return IsNumberLike(castTo)
        }
        case TypeKind.I16: {
            return IsNumberLike(castTo)
        }
        case TypeKind.U16: {
            return IsNumberLike(castTo)
        }
        case TypeKind.I32: {
            return IsNumberLike(castTo)
        }
        case TypeKind.U32: {
            return IsNumberLike(castTo)
        }
        case TypeKind.I64: {
            return IsNumberLike(castTo)
        }
        case TypeKind.U64: {
            return IsNumberLike(castTo)
        }
        case TypeKind.F32: {
            return IsNumberLike(castTo)
        }
        case TypeKind.F64: {
            return IsNumberLike(castTo)
        }
        case TypeKind.USIZE: {
            return IsNumberLike(castTo)
        }
        case TypeKind.NULL: {
            return IsPtrLike(castTo)
        }
        case TypeKind.VOID: {
            return castTo.kind == TypeKind.VOID
        }
        // TODO
        case TypeKind.STR: {
            if(IsPtrLike(castTo)) {
                return true
            }
            return this.isDeclarable(castTo, checker)
        }
        case TypeKind.ARRAY: {
            return IsPtrLike(castTo)
        }
        case TypeKind.PTR: {

            if(castTo.kind == TypeKind.PTR) {
                return true
            }
            if(IsInteger(castTo)) {
                return true
            }
            // TODO: this is wide open right now!
            return this.isDeclarable(castTo, checker)
        }
        case TypeKind.FUNC_PTR: {
            return this.isDeclarable(castTo, checker)
        }

        case TypeKind.STRUCT: {
            return this.isDeclarable(castTo, checker)
        }
        case TypeKind.UNION: {
            return this.isDeclarable(castTo, checker)
        }
        case TypeKind.TRAIT: {
            return this.isDeclarable(castTo, checker)
        }
        case TypeKind.ENUM: {
            if(IsInteger(castTo)) {
                return true
            }
            return this.isDeclarable(castTo, checker)
        }
        case TypeKind.FUNC: {
            return this.isDeclarable(castTo, checker)
        }

        case TypeKind.CONST: {
            if(castTo.kind != TypeKind.CONST) {
                return false
            }
            return this.isDeclarable(castTo, checker)
        }
        case TypeKind.POISON: {
            return false;
        }
        default: {
            assert(false)
        }
    }
    return false
}

public func IsFuncImpl(traitFn: *TypeInfo, fn: *TypeInfo, checker: *TypeChecker) : bool {
    assert(traitFn)
    assert(fn)

    if(fn.kind != TypeKind.FUNC) {
        return false
    }

    var funcInfo = fn

    // to account for the 'self' pointer
    if(funcInfo.funcDecl.params.size() != traitFn.paramDecls.size() + 1) {
        return false
    }

    if(funcInfo.funcDecl.params.isVararg  != traitFn.hasVarargs) {
        return false
    }

    if(!funcInfo.returnType.strictEquals(traitFn.returnType)) {
        return false
    }

    // first parameter must be a pointer
    var firstArg = funcInfo.funcDecl.params.get(0).typeInfo
    if(!IsPtr(firstArg)) {
        return false
    }

    for(var i = 0; i < traitFn.paramDecls.size(); i += 1) {
        var a = traitFn.paramDecls.get(i)

        // skip the first parameter
        var b = funcInfo.funcDecl.params.get(i + 1)
        if(!b.typeInfo) {
            return false
        }

        if(!a.strictEquals(b.typeInfo)) {
            return false
        }
    }
    return true
}

public func (this: *TypeInfo) asTypeSpec(module: *Module) : *TypeSpec {
    var pos = (this.sym) ? this.sym.decl.startPos : SrcPos{};
    var allocator = &module.typeSpecAllocator

    switch(this.kind) {
        case TypeKind.BOOL: {
            return NewNameTypeSpecIntern(pos, BOOL, allocator)
        }
        case TypeKind.CHAR: {
            return NewNameTypeSpecIntern(pos, CHAR, allocator)
        }
        case TypeKind.I8: {
            return NewNameTypeSpecIntern(pos, I8, allocator)
        }
        case TypeKind.U8: {
            return NewNameTypeSpecIntern(pos, U8, allocator)
        }
        case TypeKind.I16: {
            return NewNameTypeSpecIntern(pos, I16, allocator)
        }
        case TypeKind.U16: {
            return NewNameTypeSpecIntern(pos, U16, allocator)
        }
        case TypeKind.I32: {
            return NewNameTypeSpecIntern(pos, I32, allocator)
        }
        case TypeKind.U32: {
            return NewNameTypeSpecIntern(pos, U32, allocator)
        }
        case TypeKind.I64: {
            return NewNameTypeSpecIntern(pos, I64, allocator)
        }
        case TypeKind.U64: {
            return NewNameTypeSpecIntern(pos, U64, allocator)
        }
        case TypeKind.F32: {
            return NewNameTypeSpecIntern(pos, F32, allocator)
        }
        case TypeKind.F64: {
            return NewNameTypeSpecIntern(pos, F64, allocator)
        }
        case TypeKind.USIZE: {
            return NewNameTypeSpecIntern(pos, USIZE, allocator)
        }
        case TypeKind.NULL: {
            return NewNameTypeSpecIntern(pos, NULL, allocator)
        }
        case TypeKind.VOID: {
            return NewNameTypeSpecIntern(pos, VOID, allocator)
        }
        case TypeKind.STR: {
            return NewNameTypeSpecIntern(pos, STRING, allocator)
        }
        case TypeKind.GENERIC_PARAM: {
            var genericParamInfo = this
            return NewNameTypeSpecIntern(pos, genericParamInfo.name, allocator)
        }
        case TypeKind.ARRAY: {
            var arrayInfo = this
            var arrayTypeSpec = NewTypeSpec(TypeSpecKind.ARRAY, pos, allocator)
            arrayTypeSpec.base = arrayInfo.arrayOf.asTypeSpec(module)
            arrayTypeSpec.numElements = arrayInfo.numOfElements
            return arrayTypeSpec
        }
        case TypeKind.PTR: {
            var ptrInfo = this
            var ptrTypeSpec = NewTypeSpec(TypeSpecKind.PTR, pos, allocator)
            ptrTypeSpec.base = ptrInfo.ptrOf.asTypeSpec(module)
            return ptrTypeSpec
        }
        case TypeKind.CONST: {
            var constInfo = this
            var constTypeSpec = NewTypeSpec(TypeSpecKind.CONST, pos, allocator)
            constTypeSpec.base = constInfo.constOf.asTypeSpec(module)
            return constTypeSpec
        }
        case TypeKind.FUNC_PTR: {
            var funcInfo = this
            var args = Array<*TypeSpec>{}
            args.init(funcInfo.paramDecls.size(), module.allocator)
            for(var i = 0; i < funcInfo.paramDecls.size(); i += 1) {
                var param = funcInfo.paramDecls.get(i)
                args.add(param.asTypeSpec(module))
            }

            var result = NewTypeSpec(TypeSpecKind.FUNC_PTR, pos, allocator)
            result.ret = funcInfo.returnType.asTypeSpec(module)
            result.args = args
            result.hasVarargs = funcInfo.hasVarargs
            result.genericParams = funcInfo.genericParams
            return result
        }
        case TypeKind.TRAIT:
        case TypeKind.UNION:
        case TypeKind.STRUCT: {
            var aggInfo = this
            var result = NewNameTypeSpecIntern(pos, aggInfo.name, allocator)

            var args = Array<*TypeSpec>{}
            args.init(aggInfo.aggDecl.genericParams.size(), module.allocator)
            for(var i = 0; i < aggInfo.aggDecl.genericParams.size(); i += 1) {
                var param = aggInfo.aggDecl.genericParams.get(i)
                var name = param.name.str

                args.add(NewNameTypeSpecIntern(pos, name, allocator))
            }

            result.genericArgs = args;
            return result
        }
        case TypeKind.ENUM: {
            var info = this
            return NewNameTypeSpecIntern(pos, info.name, allocator)
        }
        case TypeKind.FUNC: {
            var info = this
            return NewNameTypeSpecIntern(pos, info.name, allocator)
        }
        case TypeKind.POISON: {
            return NewNameTypeSpecIntern(pos, POISON, allocator)
        }
        default: {
            /*printf("TypeId: '%d'\n", this.kind)
            printf("Type: '%s'\n", TypeKindAsStr(this.kind))
            // force crash report
            var x: *char = null
            x[0] = 2
            */
            assert(false)
        }
    }
    return null
}

public func (this: *TypeInfo) asPtr(typeCache: *TypeCache) : *TypeInfo {
    var genericParams = ArrayInit<GenericParam>(this.funcDecl.genericParams.size(), typeCache.allocator)
    genericParams.addAll(this.funcDecl.genericParams)
    var paramDecls = ArrayInit<*TypeInfo>(this.funcDecl.params.size(), typeCache.allocator)
    for(var i = 0; i < this.funcDecl.params.size() ; i += 1) {
        var p = this.funcDecl.params.get(i)
        paramDecls.add(p.typeInfo)
    }
    var funcPtr = typeCache.newFuncPtrTypeInfo(genericParams, this.returnType, paramDecls, this.funcDecl.flags & FuncFlags.HAS_VARARGS)
    funcPtr.name = this.name

    return funcPtr
}


public func (this: *TypeInfo) getEnumField(name: InternedString) : *EnumFieldEntryDecl {
    assert(this != null)
    for(var i = 0; i < this.enumDecl.fields.size(); i+=1) {
        var field = this.enumDecl.fields.get(i)
        if(field.name.str.equals(name)) {
            return field
        }
    }

    return null
}

public func (this: *TypeInfo) getEnumFieldIndex(name: InternedString) : i32 {
    assert(this != null)
    for(var i = 0; i < this.enumDecl.fields.size(); i+=1) {
        var field = this.enumDecl.fields.get(i)
        if(field.name.str.equals(name)) {
            return i
        }
    }

    return -1
}


public func (this: *TypeInfo) getBaseName(name: [MAX_SYMBOL_NAME]char, alias: *InternedString = null) : *const char {
    assert(this != null)

    var index = 0
    var n = this.name.buffer
    var len = this.name.length

    if(alias) {
        for(;index < alias.length && index < MAX_SYMBOL_NAME; index += 1) {
            name[index] = alias.buffer[index]
        }
        name[index+0] = ':';
        name[index+1] = ':';

        index += 2;
        len += index;
    }

    while(*n && index < len && index < MAX_SYMBOL_NAME) {
        var c = *n
        if(c == '<') {
            break;
        }

        name[index] = c

        n += 1;
        index += 1;
    }


    name[index] = '\0'

    return name
}


public func (this: *TypeInfo) getFieldByPosition(position: i32) : FieldStmt {
    assert(this != null)
    if(position < 0 || position >= this.aggDecl.fields.size()) {
        return FieldStmt {
            .kind = StmtKind.POISON_EXPR
        }
    }

    return this.aggDecl.fields.get(position)
}

public func (this: *TypeInfo) getField(name: InternedString) : FieldStmt {
    assert(this != null)

    for(var i = 0; i < this.aggDecl.fields.size(); i+=1) {
        var field = this.aggDecl.fields.get(i)
        switch(field.kind) {
            case StmtKind.TRAIT_FIELD_DECL: {
                var varField = field.traitField
                if(varField.name.str.equals(name)) {
                    if(!field.typeInfo) {
                        goto err;
                    }
                    return field
                }
                break;
            }
            case StmtKind.VAR_FIELD_DECL: {
                var varField = field.varField
                if(varField.name.str.equals(name)) {
                    if(!field.typeInfo) {
                        goto err;
                    }
                    return field
                }
                break;
            }
            case StmtKind.ENUM_FIELD_DECL: {
                var enumField = field.enumField
                if(enumField.name.str.equals(name)) {
                    return field
                }
                break;
            }
            case StmtKind.UNION_FIELD_DECL:
            case StmtKind.STRUCT_FIELD_DECL: {
                var aggField = field.aggregateField

                // if this is an anonymous aggregate, the fields
                // should be looked at for matching
                if(aggField.name.token.type == TokenType.VOID) {
                    var aggType = aggField.sym.type
                    var result = aggType.getField(name)
                    if(result.kind != StmtKind.POISON_EXPR) {
                        return result
                    }
                }

                if(aggField.name.str.equals(name)) {
                    return field
                }
                // TODO: Account for using field aggregates
                break;
            }
            default: {
                goto err;
            }
        }
    }
err:
    return FieldStmt {
        .kind = StmtKind.POISON_EXPR
    }
}

@doc("Gets the field position in this aggregate type (including anonymous aggregates) only")
public func (this: *TypeInfo) getFieldIndex(name: InternedString) : i32 {
    assert(this != null)

    var index = 0
    for(var i = 0; i < this.aggDecl.fields.size(); i+=1) {
        var field = this.aggDecl.fields.get(i)
        switch(field.kind) {
            case StmtKind.TRAIT_FIELD_DECL: {
                var varField = field.traitField
                if(varField.name.str.equals(name)) {
                    if(!field.typeInfo) {
                        goto err;
                    }
                    return index
                }
                break;
            }
            case StmtKind.VAR_FIELD_DECL: {
                var varField = field.varField
                if(varField.name.str.equals(name)) {
                    if(!field.typeInfo) {
                        goto err;
                    }
                    return index
                }
                break;
            }
            case StmtKind.ENUM_FIELD_DECL: {
                var enumField = field.enumField
                if(enumField.name.str.equals(name)) {
                    return index
                }
                break;
            }
            case StmtKind.UNION_FIELD_DECL:
            case StmtKind.STRUCT_FIELD_DECL: {
                var aggField = field.aggregateField

                // if this is an anonymous aggregate, the fields
                // should be looked at for matching
                if(aggField.name.token.type == TokenType.VOID) {
                    var aggType = aggField.sym.type
                    var result = aggType.getFieldIndex(name)

                    // build the appropriate index
                    if(result < 0) {
                        index += aggType.aggDecl.fields.size()
                    }
                    else {
                        return index + result
                    }
                }

                if(aggField.name.str.equals(name)) {
                    return index
                }
                // TODO: Account for using field aggregates
                break;
            }
            default: {
                goto err;
            }
        }
        index += 1
    }
err:
    return -1
}

public struct FieldPositionResult {
    aggInfo: *TypeInfo
    position: i32
}

@doc("Gets the field position in this aggregate type and any using sub aggregates")
public func (this: *TypeInfo) getFieldPosition(name: InternedString) : FieldPositionResult {

    // Find the aggregate type of this field -- we have
    // to do some object traversels because of the 'using'
    var path = FieldPath{}
    if(this.getFieldPath(name, &path)) {
        var aggInfo = this
        var index = path.numOfFields - 1
        while(index > 0) {
            var fieldInfo = path.fields[index].typeInfo
            if(IsAggregate(fieldInfo)) {
                aggInfo = fieldInfo
                break
            }

            index -= 1
        }

        return FieldPositionResult {
            .aggInfo = aggInfo,
            .position = aggInfo.getFieldIndex(name)
        }
    }

    return FieldPositionResult {
        .aggInfo = null,
        .position = -1
    }
}


@doc("""
Gets the first field of the supplied type.  This should only be used for finding 'using'
fields to match against and the supplied type should be an aggregate (i.e., not a pointer)
""")
public func (this: *TypeInfo) getFieldByType(type: *TypeInfo, isParent: bool = true) : FieldStmt {
    assert(this != null)

    var isGenericCapable = type.sym.isGenericCapable()

    for(var i = 0; i < this.aggDecl.fields.size(); i+=1) {
        var field = this.aggDecl.fields.get(i)

        if(!IsAggregateLike(field.typeInfo)) {
            continue
        }

        if(isParent && field.kind == StmtKind.VAR_FIELD_DECL) {
            if(!field.varField.attributes.isUsing) {
                continue
            }
        }

        var fieldBaseType = field.typeInfo.getBaseType()

        if(fieldBaseType.sym.isGenericCapable() && isGenericCapable) {
            if(fieldBaseType.genericTypeid == type.genericTypeid) {
                return field
            }
        }

        if(fieldBaseType.typeid == type.typeid) {
            return field
        }

        switch(field.kind) {
            case StmtKind.TRAIT_FIELD_DECL: {
                break;
            }
            case StmtKind.VAR_FIELD_DECL: {
                break;
            }
            case StmtKind.ENUM_FIELD_DECL: {
                break;
            }
            case StmtKind.UNION_FIELD_DECL:
            case StmtKind.STRUCT_FIELD_DECL: {
                var aggField = field.aggregateField

                // if this is an anonymous aggregate, the fields
                // should be looked at for matching
                if(aggField.name.token.type == TokenType.VOID) {
                    var aggType = aggField.sym.type
                    var result = aggType.getFieldByType(type, false)
                    if(result.kind != StmtKind.POISON_EXPR) {
                        return result
                    }
                }
                break;
            }
            default: {
            }
        }
    }

    return FieldStmt {
        .kind = StmtKind.POISON_EXPR
    }
}


public func (this: *TypeInfo) getFieldWithUsing(name: InternedString) : FieldStmt {
    assert(this != null)

    var fieldStmt = this.getField(name)
    if(fieldStmt.kind != StmtKind.POISON_EXPR) {
        return fieldStmt
    }

    for(var i = 0; i < this.aggDecl.fields.size(); i+=1) {
        var field = this.aggDecl.fields.get(i)
        switch(field.kind) {
            case StmtKind.TRAIT_FIELD_DECL: {
                continue
            }
            case StmtKind.VAR_FIELD_DECL: {
                var varField = field.varField
                if(!varField.attributes.isUsing) {
                    continue;
                }

                if(!IsAggregate(field.typeInfo) && !IsPtrAggregate(field.typeInfo)) {
                    continue;
                }

                var baseType = field.typeInfo.getBaseType()
                assert(baseType.kind == TypeKind.STRUCT || baseType.kind == TypeKind.UNION)

                fieldStmt = baseType.getFieldWithUsing(name)
                if(fieldStmt.kind != StmtKind.POISON_EXPR) {
                    return fieldStmt
                }

                break;
            }
            default: {
                continue;
            }
        }
    }

    return FieldStmt {
        .kind = StmtKind.POISON_EXPR
    }
}


public const MAX_FIELD_PATH = 256
public struct FieldPath {
    fields: [MAX_FIELD_PATH]FieldStmt
    numOfFields: i32
}

func (this: *FieldPath) add(field: FieldStmt) {
    this.fields[this.numOfFields] = field
    this.numOfFields += 1
    assert(this.numOfFields < MAX_FIELD_PATH)
}

func (this: *FieldPath) pop() {
    this.numOfFields -= 1
    if(this.numOfFields < 0) {
        this.numOfFields = 0
    }
}


public func (this: *TypeInfo) getFieldPath(name: InternedString, path: *FieldPath) : bool {
    assert(this != null)

    var fieldStmt = this.getField(name)
    if(fieldStmt.kind != StmtKind.POISON_EXPR) {
        path.add(fieldStmt)
        return true
    }

    for(var i = 0; i < this.aggDecl.fields.size(); i+=1) {
        var field = this.aggDecl.fields.get(i)
        switch(field.kind) {
            case StmtKind.TRAIT_FIELD_DECL: {
                continue
            }
            case StmtKind.VAR_FIELD_DECL: {
                var varField = field.varField
                if(!varField.attributes.isUsing) {
                    continue;
                }

                if(!IsAggregate(field.typeInfo) && !IsPtrAggregate(field.typeInfo)) {
                    continue;
                }

                var baseType = field.typeInfo.getBaseType()
                assert(IsAggregate(baseType))

                path.add(field)

                if(baseType.getFieldPath(name, path)) {
                    return true
                }

                path.pop()

                break;
            }
            default: {
                continue;
            }
        }
    }

    return false
}

public func (this: *TypeInfo) getFieldPathByType(type: *TypeInfo, path: *FieldPath) : bool {
    assert(this != null)

    var fieldStmt = this.getFieldByType(type)
    if(fieldStmt.kind != StmtKind.POISON_EXPR) {
        path.add(fieldStmt)
        return true
    }

    for(var i = 0; i < this.aggDecl.fields.size(); i+=1) {
        var field = this.aggDecl.fields.get(i)
        switch(field.kind) {
            case StmtKind.TRAIT_FIELD_DECL: {
                continue
            }
            case StmtKind.VAR_FIELD_DECL: {
                var varField = field.varField
                if(!varField.attributes.isUsing) {
                    continue;
                }

                if(!IsAggregateLike(field.typeInfo)) {
                    continue;
                }

                var baseType = field.typeInfo.getBaseType()
                assert(baseType.kind == TypeKind.STRUCT || baseType.kind == TypeKind.UNION)

                path.add(field)

                if(baseType.getFieldPathByType(type, path)) {
                    return true
                }

                path.pop()
                break;
            }
            case StmtKind.UNION_FIELD_DECL:
            case StmtKind.STRUCT_FIELD_DECL: {
                var aggField = field.aggregateField

                var baseType = field.typeInfo.getBaseType()
                path.add(field)

                if(baseType.getFieldPathByType(type, path)) {
                    return true
                }

                path.pop()
                break;
            }
            default: {
                continue;
            }
        }
    }

    return false
}

@doc("""
Given a method name, this will return the function name equivalent, which is:
AggregateName_MethodName
""")
public func (this: *TypeInfo) getFunctionName(result: [MAX_SYMBOL_NAME]char, methodName: InternedString, alias: *InternedString) : *const char {
    memset(result, 0, MAX_SYMBOL_NAME)
    this.getBaseName(result, alias);

    var buffer = StringInit(result, MAX_SYMBOL_NAME)
    buffer.appendStrn("_", 1)
    buffer.appendStrn(methodName.buffer, methodName.length)

    return buffer.cStrConst()
}

public struct MethodResult {
    symbol: *Symbol
    name: InternedString
}

public func (this: *TypeInfo) getMethod(strings: *Strings, module: *Module, methodName: InternedString) : MethodResult {
    if(!this.sym) {
        goto not_found;
    }

    var funcName = [MAX_SYMBOL_NAME]char {0};
    this.getFunctionName(funcName, methodName, null)

    var funcNameInterned = strings.internCopy(funcName)
    var methodSym = module.getFuncType(funcNameInterned)
    if(methodSym == null || methodSym.kind != SymbolKind.FUNC) {
        // look up if this is an aliased type
        var alias = module.getImportAlias(this.sym.declared)
        if(!alias) {
            goto not_found;
        }

        this.getFunctionName(funcName, methodName, alias)

        funcNameInterned = strings.internCopy(funcName)
        methodSym = module.getFuncType(funcNameInterned)

        // check again!
        if(methodSym == null || methodSym.kind != SymbolKind.FUNC) {
            goto not_found;
        }
    }

    var decl = methodSym.decl as (*FuncDecl)
    if(!(decl.flags & FuncFlags.IS_METHOD)) {
        goto not_found;
    }

    if(decl.params.empty()) {
        goto not_found;
    }

    var base = decl.params.first().typeInfo.getBaseType()
    if(this == null || base == null) {
        goto not_found;
    }

    // If this is a generic type, we need to compare against the original
    // template types for equality
    if(methodSym.flags & SymbolFlags.IS_GENERIC_TEMPLATE) {
        var thisGenericType = this
        var baseGenericType = base
        if(thisGenericType.genericTypeid == baseGenericType.genericTypeid) {
            return MethodResult {
                .symbol = methodSym,
                .name = funcNameInterned
            }
        }
    }

    if(this.strictEquals(base)) {
        return MethodResult {
            .symbol = methodSym,
            .name = funcNameInterned
        }
    }

    // TODO: Check if this is 'using' base
not_found:
    return MethodResult {
        .symbol = null,
        .name = EMPTY_STR,
    }
}

public func (this: *TypeInfo) implementsTrait(iface : *TypeInfo, checker: *TypeChecker) : bool {
    if(!IsAggregateLike(iface)) {
        return false
    }

    var aggIface = AsAggregate(iface)
    if(!aggIface.sym || !(aggIface.sym.flags & SymbolFlags.IS_TRAIT)) {
        return false
    }

    return checker.implementsTrait(this, aggIface)
}

public typedef i64 as Typeid;
var idGen: Typeid = TypeKind.MAX_TYPE_KINDS as (i64);

public func NextTypeId() : Typeid {
    idGen += 1
    return idGen;
}

@doc("""
The supplied `Strings` must be initialized and pre-populated with interned constants
""")
public func TypesInit(strings: *Strings) {
    idGen = TypeKind.MAX_TYPE_KINDS as (i64)
    BOOL_TYPE.name  = BOOL
    CHAR_TYPE.name  = CHAR
    I8_TYPE.name    = I8
    U8_TYPE.name    = U8
    I16_TYPE.name   = I16
    U16_TYPE.name   = U16
    I32_TYPE.name   = I32
    U32_TYPE.name   = U32
    I64_TYPE.name   = I64
    U64_TYPE.name   = U64
    F32_TYPE.name   = F32
    F64_TYPE.name   = F64
    USIZE_TYPE.name = USIZE
    NULL_TYPE.name  = NULL
    VOID_TYPE.name  = VOID
    STR_TYPE.name   = STRING
    POISON_TYPE.name= POISON
}

public struct TypeInfo {
    kind: TypeKind
    typeid: Typeid
    name: InternedString
    sym: *Symbol
    genericTypeid: Typeid       // The typeid of the original Generic Template
    returnType: *TypeInfo

    union {
        // FuncTypeInfo
        struct {
            funcDecl: *FuncDecl
        }
        // ConstTypeInfo
        struct {
            constOf: *TypeInfo
        }
        // PtrTypeInfo
        struct {
            ptrOf: *TypeInfo
        }
        // ArrayTypeInfo
        struct {
            arrayOf: *TypeInfo
            length: usize
            numOfElements: *Expr
            isLengthDefined: bool
        }
        // FuncPtrTypeInfo
        struct {
            genericParams: Array<GenericParam>
            paramDecls: Array<*TypeInfo>
            hasVarargs: bool
            isTrait: bool
        }
        // EnumTypeInfo
        struct {
            enumDecl: *EnumDecl
        }
        // AggregateTypeInfo (trait/struct/union)
        struct {
            aggDecl: *AggregateDecl
        }
    }
}


public const BOOL_TYPE = TypeInfo {
    .kind = TypeKind.BOOL,
    .typeid = TypeKind.BOOL as (Typeid),
    .sym = null
}

public const CHAR_TYPE = TypeInfo {
    .kind = TypeKind.CHAR,
    .typeid = TypeKind.CHAR as (Typeid),
    .sym = null
}

public const I8_TYPE = TypeInfo {
    .kind = TypeKind.I8,
    .typeid = TypeKind.I8 as (Typeid),
    .sym = null
}

public const U8_TYPE = TypeInfo {
    .kind = TypeKind.U8,
    .typeid = TypeKind.U8 as (Typeid),
    .sym = null
}

public const I16_TYPE = TypeInfo {
    .kind = TypeKind.I16,
    .typeid = TypeKind.I16 as (Typeid),
    .sym = null
}

public const U16_TYPE = TypeInfo {
    .kind = TypeKind.U16,
    .typeid = TypeKind.U16 as (Typeid),
    .sym = null
}

public const I32_TYPE = TypeInfo {
    .kind = TypeKind.I32,
    .typeid = TypeKind.I32 as (Typeid),
    .sym = null
}

public const U32_TYPE = TypeInfo {
    .kind = TypeKind.U32,
    .typeid = TypeKind.U32 as (Typeid),
    .sym = null
}

public const I64_TYPE = TypeInfo {
    .kind = TypeKind.I64,
    .typeid = TypeKind.I64 as (Typeid),
    .sym = null
}

public const U64_TYPE = TypeInfo {
    .kind = TypeKind.U64,
    .typeid = TypeKind.U64 as (Typeid),
    .sym = null
}

public const F32_TYPE = TypeInfo {
    .kind = TypeKind.F32,
    .typeid = TypeKind.F32 as (Typeid),
    .sym = null
}

public const F64_TYPE = TypeInfo {
    .kind = TypeKind.F64,
    .typeid = TypeKind.F64 as (Typeid),
    .sym = null
}

public const USIZE_TYPE = TypeInfo {
    .kind = TypeKind.USIZE,
    .typeid = TypeKind.USIZE as (Typeid),
    .sym = null
}

public const NULL_TYPE = TypeInfo {
    .kind = TypeKind.NULL,
    .typeid = TypeKind.NULL as (Typeid),
    .sym = null
}

public const VOID_TYPE = TypeInfo {
    .kind = TypeKind.VOID,
    .typeid = TypeKind.VOID as (Typeid),
    .sym = null
}

public const STR_TYPE = TypeInfo {
    .kind = TypeKind.STR,
    .typeid = TypeKind.STR as (Typeid),
    .sym = null
}

public const POISON_TYPE = TypeInfo {
    .kind = TypeKind.POISON,
    .typeid = TypeKind.POISON as (Typeid),
    .sym = null
}

public const BUILTIN_TYPES = [TypeKind.MAX_TYPE_KINDS]*TypeInfo {
    [TypeKind.BOOL] = &BOOL_TYPE,
    [TypeKind.CHAR] = &CHAR_TYPE,
    [TypeKind.I8] = &I8_TYPE,
    [TypeKind.U8] = &U8_TYPE,
    [TypeKind.I16] = &I16_TYPE,
    [TypeKind.U16] = &U16_TYPE,
    [TypeKind.I32] = &I32_TYPE,
    [TypeKind.U32] = &U32_TYPE,
    [TypeKind.I64] = &I64_TYPE,
    [TypeKind.U64] = &U64_TYPE,
    [TypeKind.F32] = &F32_TYPE,
    [TypeKind.F64] = &F64_TYPE,
    [TypeKind.USIZE] = &USIZE_TYPE,
    [TypeKind.NULL] = &NULL_TYPE,
    [TypeKind.VOID] = &VOID_TYPE,
    [TypeKind.STR] = &STR_TYPE,
    [TypeKind.POISON] = &POISON_TYPE,
}