import "std/assert"
import "std/string_view"
import "std/string"
import "std/libc"
import "std/array"
import "std/mem"

import "symbols"
import "types"
import "lex"
import "common"
import "module"
import "intern"

@asStr
public enum StmtKind {
    IMPORT_DECL,
    CONST_DECL,
    VAR_DECL,
    STRUCT_DECL,
    UNION_DECL,
    TRAIT_DECL,
    ENUM_DECL,
    FUNC_DECL,
    TYPEDEF_DECL,
    NOTE_DECL,
    PARAM_DECL,
    NATIVE_DECL,
    NOTES_DECL,
    VAR_FIELD_DECL,
    ENUM_FIELD_ENTRY_DECL,
    ENUM_FIELD_DECL,
    STRUCT_FIELD_DECL,
    UNION_FIELD_DECL,
    TRAIT_FIELD_DECL,
    POISON_DECL,

    BLOCK_STMT,
    BREAK_STMT,
    COMP_STMT,
    CONTINUE_STMT,
    DEFER_STMT,
    DO_WHILE_STMT,
    EMPTY_STMT,
    //FIELD_STMT,
    FOR_STMT,
    FUNC_BODY_STMT,
    GOTO_STMT,
    IF_STMT,
    LABEL_STMT,
    MODULE_STMT,
    NOTE_STMT,
    PARAMETERS_STMT,
    RETURN_STMT,
    SWITCH_CASE_STMT,
    SWITCH_STMT,
    WHILE_STMT,

    ARRAY_DESIGNATION_EXPR,
    ARRAY_INIT_EXPR,
    BINARY_EXPR,
    BOOLEAN_EXPR,
    CAST_EXPR,
    CHAR_EXPR,
    FUNC_CALL_EXPR,
    FUNC_IDENTIFIER_EXPR,
    GET_EXPR,
    GROUP_EXPR,
    IDENTIFIER_EXPR,
    INIT_EXPR,
    INIT_ARG_EXPR,
    NULL_EXPR,
    NUMBER_EXPR,
    OFFSET_OF_EXPR,
    SET_EXPR,
    SIZE_OF_EXPR,
    STRING_EXPR,
    SUBSCRIPT_GET_EXPR,
    SUBSCRIPT_SET_EXPR,
    TERNARY_EXPR,
    TYPE_IDENTIFIER_EXPR,
    TYPE_OF_EXPR,
    UNARY_EXPR,
    POISON_EXPR,

    MAX_STMT_KINDS
}

@asStr
public enum TypeSpecKind {
    NONE,
    ARRAY,
    PTR,
    CONST,
    NAME,
    FUNC_PTR,

    MAX_TYPESPEC_KINDS
}

public enum FuncFlags {
    HAS_VARARGS = (1<<0),
    IS_METHOD   = (1<<1),
}

public enum AggregateFlags {
    IS_EMBEDDED  = (1<<0),
    IS_ANONYMOUS = (1<<1),
}

public struct TypeSpec {
    kind: TypeSpecKind
    pos: SrcPos
    base: *TypeSpec
    typeInfo: *TypeInfo    // resolved from the type checker
}

public struct NameTypeSpec {
    spec: using TypeSpec
    //name: *const char
    name: InternedString
    genericArgs: Array<*TypeSpec>
}

public struct ArrayTypeSpec {
    spec: using TypeSpec
    numElements: *Expr
}

public struct PtrTypeSpec {
    spec: using TypeSpec
}

public struct ConstTypeSpec {
    spec: using TypeSpec
}

public struct FuncPtrTypeSpec {
    spec: using TypeSpec
    args: Array<*TypeSpec>
    ret: *TypeSpec
    hasVarargs: bool
    genericParams: Array<GenericParam>
}

public struct Identifier {
    str: InternedString
    token: Token
}

public struct GenericParam {
    name: Identifier
}

public struct Attributes {
    isPublic: bool
    isGlobal: bool
    isUsing: bool
    notes: Array<*NoteStmt>
}


public struct Node {
    kind: StmtKind
    parent: *Node
    startPos: SrcPos
    endPos: SrcPos
}

public func (n: *Node) setSrcPos(start: SrcPos, end: SrcPos) {
    n.startPos = start
    n.endPos = end
}

public func (n: *Node) becomeParentOf<T>(child: *T) : *T {
    if(!child) return null;

    child.parent = n as (*Node)
    return child
}

public func (n: *Node) becomeParentOfChildren<T>(children: *Array<T>) : *Array<T> {
    var size = children.size()
    for(var i = 0; i < size; i += 1) {
        var child = children.get(i)
        if(child) {
            n.becomeParentOf(child)
        }
    }

    return children
}

public func (n: *Node) becomeParentOfChildrenCallArgs(children: *Array<CallArg>) : *Array<CallArg> {
    var size = children.size()
    for(var i = 0; i < size; i += 1) {
        var child = children.get(i).argExpr
        if(child) {
            n.becomeParentOf(child)
        }
    }

    return children
}

public struct Decl {
    stmt: using Stmt
    sym: *Symbol
    name: Identifier
    attributes: Attributes
}

public struct GenericDecl {
    declaration: using Decl
    genericParams: Array<GenericParam>
}

public struct ImportDecl {
    decl: using Decl
    alias: Identifier
    isUsing: bool

    moduleId: *ModuleId
}

// For var or const declarations
public struct VarDecl {
    decl: using Decl
    typeSpec: *TypeSpec
    expr: *Expr
}

public struct ParameterDecl {
    decl: using Decl
    type: *TypeSpec
    defaultExpr: *Expr
    typeInfo: *TypeInfo
}


public struct FuncDecl {
    decl: using GenericDecl
    params: *ParametersStmt
    body: *Stmt
    returnType: *TypeSpec
    flags: i32
}

public struct AggregateDecl {
    decl: using GenericDecl
    fields: Array<FieldStmt>
    flags: i32
}

public struct EnumDecl {
    decl: using Decl
    fields: Array<*EnumFieldEntryDecl>
}

public struct TypedefDecl {
    decl: using GenericDecl
    type: *TypeSpec
}

public struct NativeDecl {
    decl: using Decl
    typeInfo: *TypeInfo
}

public struct NotesDecl {
    decl: using Decl
    notes: Array<*NoteStmt>
}

public struct PoisonDecl {
    decl: using Decl
}

public struct BlockStmt {
    stmt: using Stmt
    stmts: Array<*Stmt>
}

public struct BreakStmt {
    stmt: using Stmt
}

public struct CompStmt {
    stmt: using Stmt
    type: InternedString
    expr: StringView
    end: *CompStmt
    evaluatedStmt: *Stmt
    body: Array<*Stmt>
}

public struct ContinueStmt {
    stmt: using Stmt
}

public struct DeferStmt {
    stmt: using Stmt
    deferedStmt: *Stmt
}

public struct DoWhileStmt {
    stmt: using Stmt
    cond: *Expr
    body: *Stmt
}

public struct EmptyStmt {
    stmt: using Stmt
}

public struct EnumFieldEntryDecl {
    decl: using Decl
    value: *Expr
}

public struct ForStmt {
    stmt: using Stmt
    init: *Stmt
    cond: *Expr
    post: *Stmt
    body: *Stmt
}

public struct FuncBodyStmt {
    stmt: using Stmt
    stmts: Array<*Stmt>
}

public struct GotoStmt {
    stmt: using Stmt
    label: Identifier
}

public struct IfStmt {
    stmt: using Stmt
    cond: *Expr
    then: *Stmt
    elseStmt: *Stmt
}


public struct LabelStmt {
    stmt: using Stmt
    label: Identifier
}

// TODO: should ths be a declaration?
public struct ModuleStmt {
    stmt: using Stmt
    imports: Array<*ImportDecl>
    notes: Array<*NoteStmt>
    declarations: Array<*Decl>
    //TODO: id: ModuleId
}

public struct NoteStmt {
    stmt: using Stmt
    type: *NameTypeSpec
    arguments: Array<CallArg>
}

public struct ParametersStmt {
    stmt: using Stmt
    params: using Array<*ParameterDecl>
    isVararg: bool
}

public struct ReturnStmt {
    stmt: using Stmt
    expr: *Expr
}

public struct SwitchCaseStmt {
    stmt: using Stmt
    cond: *Expr
    body: *Stmt
}

public struct SwitchStmt {
    stmt: using Stmt
    cond: *Expr
    cases: Array<*SwitchCaseStmt>
    defaultStmt: *Stmt
}

public struct VarFieldDecl {
    decl: using Decl
    type: *TypeSpec
    defaultExpr: *Expr
}

public struct TraitFieldDecl {
    decl: using Decl
    type: *TypeSpec
}

public struct FieldStmt {
    kind: StmtKind
    typeInfo: *TypeInfo
    union {
        enumField: *EnumDecl
        aggregateField: *AggregateDecl
        varField: *VarFieldDecl
        traitField: *TraitFieldDecl
        poisonField: *Expr
    }
}

public struct WhileStmt {
    stmt: using Stmt
    cond: *Expr
    body: *Stmt
}


public struct Stmt {
    node: using Node
}

public struct ArrayDesignationExpr {
    expr: using Expr
    index: *Expr
    value: *Expr
}

public struct ArrayInitExpr {
    expr: using Expr
    type: *TypeSpec
    values: Array<*Expr>
}

public struct BinaryExpr {
    expr: using Expr
    left: *Expr
    operator: TokenType
    right: *Expr
}

public struct BooleanExpr {
    expr: using Expr
    boolean: bool
}

public struct CastExpr {
    expr: using Expr
    castTo: *TypeSpec
    exprToCast: *Expr
}

public struct CharExpr {
    expr: using Expr
    character: Token
}

public struct CallArg {
    argExpr: *Expr
    argName: Identifier
    index: i32
    isDefault: bool = false
}

public struct FuncCallExpr {
    expr: using Expr
    object: *Expr
    genericArgs: Array<*TypeSpec>
    arguments: Array<CallArg>
}

public enum GetExprFlags {
    IS_NORMAL      = 0,
    IS_METHOD_CALL = (1<<0),
    IS_ENUM        = (1<<1),
    IS_USING       = (1<<2),
    IS_METHOD_ARG  = (1<<3),
}

public struct GetExpr {
    expr: using Expr
    object: *Expr
    field: *IdentifierExpr
    flags: i32
}

public struct GroupExpr {
    expr: using Expr
    groupedExpr: *Expr
}

public struct IdentifierExpr {
    expr: using Expr
    //genericArgs: Array<*TypeSpec>
    type: *NameTypeSpec
    sym: *Symbol
}

public struct InitArgExpr {
    expr: using Expr
    fieldName: Identifier
    argPosition: i32
    value: *Expr
}

public struct InitExpr {
    expr: using Expr
    genericArgs: Array<*TypeSpec>
    type: *NameTypeSpec
    arguments: Array<*InitArgExpr>
}

public struct NullExpr {
    expr: using Expr
}

public struct NumberExpr {
    expr: using Expr
    number: Token
}

public struct OffsetOfExpr {
    expr: using Expr
    type: *TypeSpec
    field: Identifier
}

public struct SetExpr {
    expr: using Expr
    object: *Expr
    field: *IdentifierExpr
    operator: TokenType
    value: *Expr
    flags: i32
}

public struct SizeOfExpr {
    expr: using Expr
    sizeOfExpr: *Expr
}

public struct StringExpr {
    expr: using Expr
    string: Token // Identifier or Token?
}

public struct SubscriptGetExpr {
    expr: using Expr
    object: *Expr
    index: *Expr
}

public struct SubscriptSetExpr {
    expr: using Expr
    object: *Expr
    index: *Expr
    operator: TokenType
    value: *Expr
}

public struct TernaryExpr {
    expr: using Expr
    cond: *Expr
    then: *Expr
    other: *Expr
}

public struct TypeIdentifierExpr {
    expr: using Expr
    //genericArgs: Array<*TypeSpec>
    type: *TypeSpec
    sym: *Symbol
}

public struct TypeOfExpr {
    expr: using Expr
    typeOfExpr: *Expr
    type: *TypeSpec
}

public struct UnaryExpr {
    expr: using Expr
    operator: TokenType
    unaryExpr: *Expr
}

public struct PoisonExpr {
    expr: using Expr
}

public struct Expr {
    stmt: using Stmt
    operand: Operand
    expectedType: *TypeInfo
}

public struct Operand {
    typeInfo: *TypeInfo
    isRightValue: bool
    isConst: bool
    val: Value
}

public func IsExpr(node: *Node) : bool {
    if(!node) return false;

    switch(node.kind) {
        case StmtKind.ARRAY_DESIGNATION_EXPR:
        case StmtKind.ARRAY_INIT_EXPR:
        case StmtKind.BINARY_EXPR:
        case StmtKind.BOOLEAN_EXPR:
        case StmtKind.CAST_EXPR:
        case StmtKind.CHAR_EXPR:
        case StmtKind.FUNC_CALL_EXPR:
        case StmtKind.FUNC_IDENTIFIER_EXPR:
        case StmtKind.GET_EXPR:
        case StmtKind.GROUP_EXPR:
        case StmtKind.IDENTIFIER_EXPR:
        case StmtKind.INIT_EXPR:
        case StmtKind.INIT_ARG_EXPR:
        case StmtKind.NULL_EXPR:
        case StmtKind.NUMBER_EXPR:
        case StmtKind.OFFSET_OF_EXPR:
        case StmtKind.SET_EXPR:
        case StmtKind.SIZE_OF_EXPR:
        case StmtKind.STRING_EXPR:
        case StmtKind.SUBSCRIPT_GET_EXPR:
        case StmtKind.SUBSCRIPT_SET_EXPR:
        case StmtKind.TERNARY_EXPR:
        case StmtKind.TYPE_IDENTIFIER_EXPR:
        case StmtKind.TYPE_OF_EXPR:
        case StmtKind.UNARY_EXPR:
        case StmtKind.POISON_EXPR:
            return true;
        default:
            return false;
    }
}

public func IsDecl(node: *Node) : bool {
    if(!node) return false;

    switch(node.kind) {
        case StmtKind.IMPORT_DECL:
        case StmtKind.CONST_DECL:
        case StmtKind.VAR_DECL:
        case StmtKind.STRUCT_DECL:
        case StmtKind.UNION_DECL:
        case StmtKind.TRAIT_DECL:
        case StmtKind.ENUM_DECL:
        case StmtKind.FUNC_DECL:
        case StmtKind.TYPEDEF_DECL:
        case StmtKind.PARAM_DECL:
        case StmtKind.NATIVE_DECL:
        case StmtKind.POISON_DECL:
            return true;
        default:
            return false;
    }
}

public func (d: *Decl) hasNotes() : bool {
    if(!d) return false
    return !d.attributes.notes.empty()
}

public func (d: *Decl) hasNote(name: *const char) : bool {
    return d.getNote(name) != null
}


public func (d: *Decl) getNote(name: *const char) : *NoteStmt {
    if(!d) return null;

    if(d.attributes.notes.empty()) {
        return null;
    }

    for(var i = 0; i < d.attributes.notes.size(); i += 1) {
        var note = d.attributes.notes.get(i)
        if(strncmp(note.type.name.buffer, name, note.type.name.length) == 0) {
            return note;
        }
    }
    return null;
}

public func (this: *TypeSpec) getBaseType() : *TypeSpec {
    if(!this) return null;

    switch(this.kind) {
        case TypeSpecKind.NONE: {
            return null;
        }
        case TypeSpecKind.NAME: {
            return this
        }
        case TypeSpecKind.ARRAY:
        case TypeSpecKind.PTR:
        case TypeSpecKind.CONST: {
            return this.base.getBaseType()
        }
        case TypeSpecKind.FUNC_PTR: {
            return this
        }
        default: {
            assert(false)
        }
    }
    return null
}


public func (f: *FuncDecl) getName(name:[MAX_SYMBOL_NAME]char) : bool {
    if(f.name.token.type != TokenType.IDENTIFIER) {
        return false
    }

    if(f.flags & FuncFlags.IS_METHOD) {
        if(f.params.empty()) {
            return false
        }
        var first = f.params.first()
        if(!first.type) {
            return false
        }

        var typeSpec = first.type

        retry:
        if(typeSpec.kind != TypeSpecKind.NAME) {
            if(typeSpec.kind == TypeSpecKind.PTR) {
                var ptrSpec = typeSpec as (*PtrTypeSpec)
                typeSpec = ptrSpec.base
                goto retry;
            }
            else if(typeSpec.kind == TypeSpecKind.CONST) {
                var constSpec = typeSpec as (*ConstTypeSpec)
                typeSpec = constSpec.base
                goto retry;
            }
            return false
        }

        var type = typeSpec as (*NameTypeSpec)
        var totalLen = f.name.str.length + type.name.length + 2 // _ and \0
        if(totalLen > MAX_SYMBOL_NAME) {
            return false
        }

        var nameStr = StringInit(name, MAX_SYMBOL_NAME, 0)
        nameStr.format("%.*s_%.*s",
            type.name.length, type.name.buffer, f.name.str.length, f.name.str.buffer)
        return true
    }

    var nameStr = StringInit(name, MAX_SYMBOL_NAME, 0)
    nameStr.format("%.*s", f.name.str.length, f.name.str.buffer)
    return true
}

public func (expr: *Expr) isIdentifier() : bool {
    if(!expr) {
        return false
    }

    return expr.kind == StmtKind.IDENTIFIER_EXPR ||
           expr.kind == StmtKind.FUNC_IDENTIFIER_EXPR ||
           expr.kind == StmtKind.TYPE_IDENTIFIER_EXPR
}


public func (expr: *Expr) isConstNumberExpr() : bool {
    if(!expr) {
        return false;
    }

    switch(expr.kind) {
        case StmtKind.NUMBER_EXPR:
        case StmtKind.BOOLEAN_EXPR:
        case StmtKind.CHAR_EXPR:
        case StmtKind.IDENTIFIER_EXPR:
        case StmtKind.GET_EXPR: {
            return true
        }
        case StmtKind.SIZE_OF_EXPR: {
            var sizeofExpr = expr as (*SizeOfExpr)
            return sizeofExpr.sizeOfExpr.isConstNumberExpr()
        }
        case StmtKind.GROUP_EXPR: {
            var groupExpr = expr as (*GroupExpr)
            return groupExpr.groupedExpr.isConstNumberExpr()
        }
        case StmtKind.BINARY_EXPR: {
            var binExpr = expr as (*BinaryExpr)
            return binExpr.left.isConstNumberExpr() &&
                   binExpr.right.isConstNumberExpr()
        }
        case StmtKind.UNARY_EXPR: {
            var unaryExpr = expr as (*UnaryExpr)
            return unaryExpr.unaryExpr.isConstNumberExpr()
        }
        default: {
            return false
        }
    }
    return false
}

public func (expr: *Expr) isConstExpr() : bool {
    if(!expr) {
        return false;
    }

    switch(expr.kind) {
        case StmtKind.NUMBER_EXPR:
        case StmtKind.BOOLEAN_EXPR:
        case StmtKind.CHAR_EXPR:
        case StmtKind.IDENTIFIER_EXPR:
        case StmtKind.STRING_EXPR:
        case StmtKind.GET_EXPR: {
            return true
        }
        case StmtKind.SIZE_OF_EXPR: {
            var sizeofExpr = expr as (*SizeOfExpr)
            return sizeofExpr.sizeOfExpr.isConstExpr()
        }
        case StmtKind.GROUP_EXPR: {
            var groupExpr = expr as (*GroupExpr)
            return groupExpr.groupedExpr.isConstExpr()
        }
        case StmtKind.BINARY_EXPR: {
            var binExpr = expr as (*BinaryExpr)
            return binExpr.left.isConstExpr() &&
                   binExpr.right.isConstExpr()
        }
        case StmtKind.UNARY_EXPR: {
            var unaryExpr = expr as (*UnaryExpr)
            return unaryExpr.unaryExpr.isConstExpr()
        }
        default: {
            return false
        }
    }
    return false
}

public func CallArgSort(a: CallArg, b: CallArg) : i32 {
    return a.index - b.index
}