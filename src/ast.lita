import "std/assert"
import "std/string"
import "std/string/buffer"
import "std/libc"
import "std/array"
import "std/mem"

import "symbols"
import "types"
import "lex"
import "common"
import "module"
import "intern"

@asStr
public enum StmtKind {
    IMPORT_DECL,
    CONST_DECL,
    VAR_DECL,
    STRUCT_DECL,
    UNION_DECL,
    TRAIT_DECL,
    ENUM_DECL,
    FUNC_DECL,
    TYPEDEF_DECL,
    NOTE_DECL,
    PARAM_DECL,
    NATIVE_DECL,
    NOTES_DECL,
    VAR_FIELD_DECL,
    ENUM_FIELD_ENTRY_DECL,
    ENUM_FIELD_DECL,
    STRUCT_FIELD_DECL,
    UNION_FIELD_DECL,
    TRAIT_FIELD_DECL,
    POISON_DECL,

    BLOCK_STMT,
    BREAK_STMT,
    COMP_STMT,
    CONTINUE_STMT,
    DEFER_STMT,
    DO_WHILE_STMT,
    EMPTY_STMT,
    //FIELD_STMT,
    FOR_STMT,
    FUNC_BODY_STMT,
    GOTO_STMT,
    IF_STMT,
    LABEL_STMT,
    MODULE_STMT,
    NOTE_STMT,
    PARAMETERS_STMT,
    RETURN_STMT,
    SWITCH_CASE_STMT,
    SWITCH_STMT,
    WHILE_STMT,

    ARRAY_DESIGNATION_EXPR,
    ARRAY_INIT_EXPR,
    BINARY_EXPR,
    BOOLEAN_EXPR,
    CAST_EXPR,
    CHAR_EXPR,
    FUNC_CALL_EXPR,
    FUNC_IDENTIFIER_EXPR,
    GET_EXPR,
    GROUP_EXPR,
    IDENTIFIER_EXPR,
    INIT_EXPR,
    INIT_ARG_EXPR,
    NULL_EXPR,
    NUMBER_EXPR,
    OFFSET_OF_EXPR,
    SET_EXPR,
    SIZE_OF_EXPR,
    STRING_EXPR,
    NATIVE_STRING_EXPR,
    SUBSCRIPT_GET_EXPR,
    SUBSCRIPT_SET_EXPR,
    TERNARY_EXPR,
    TYPE_IDENTIFIER_EXPR,
    TYPE_OF_EXPR,
    NAME_OF_EXPR,
    UNARY_EXPR,
    POISON_EXPR,

    MAX_STMT_KINDS
}

@asStr
public enum TypeSpecKind {
    NONE,
    ARRAY,
    PTR,
    CONST,
    NAME,
    FUNC_PTR,

    MAX_TYPESPEC_KINDS
}

public enum FuncFlags {
    HAS_VARARGS         = (1<<0),
    IS_METHOD           = (1<<1),
    HAS_NATIVE_VARARGS  = (1<<2),
    IS_COROUTINE        = (1<<3),
}

public enum AggregateFlags {
    IS_EMBEDDED  = (1<<0),
    IS_ANONYMOUS = (1<<1),
}


public struct TypeSpec {
    kind: TypeSpecKind
    pos: SrcPos
    base: *TypeSpec        // Ptr/Const
    typeInfo: *TypeInfo    // resolved from the type checker

    union {
        // NamedTypeSpec
        struct {
            name: InternedString
            genericArgs: Array<GenericArg>
        }
        // ArrayTypeSpec
        struct {
            numElements: *Node
        }
        // FuncPtrTypeSpec
        struct {
            args: Array<*TypeSpec>
            ret: *TypeSpec
            genericParams: Array<GenericParam>
            hasVarargs: bool
            hasNativeVararg: bool
        }
    }
}


public struct Identifier {
    str: InternedString
    token: Token
}

public struct GenericParam {
    name: Identifier
    typeConstraint: *TypeSpec
}

public enum GenericArgKind {
    TYPE,
}

public struct GenericArg {
    kind: GenericArgKind

    // Will we want to expand to Expressions?
    union {
        type: *TypeSpec
    }
}

public enum Visibility {
    /* Only visibility within the defined module -- this is the default */
    PRIVATE,

    /* Visible to all modules defined in the folder and sub-folders */
    INTERNAL,

    /* Visible to all */
    PUBLIC,
}

public struct Attributes {
    visibility: Visibility = Visibility.PRIVATE
    isGlobal: bool
    isUsing: bool
    isGenerated: bool // if generated by the compiler
    notes: Array<*NoteStmt>
}


public struct Node {
    kind: StmtKind
    parent: *Node
    startPos: SrcPos
    endPos: SrcPos

    union {
        // Declarations
        importDecl: ImportDecl
        varDecl: VarDecl
        paramDecl: ParameterDecl
        funcDecl: FuncDecl
        aggDecl: AggregateDecl
        enumDecl: EnumDecl
        typedefDecl: TypedefDecl
        nativeDecl: NativeDecl
        notesDecl: NotesDecl
        poisonDecl: PoisonDecl
        // Field Stmts Declarations
        enumFieldEntryDecl: EnumFieldEntryDecl
        varFieldDecl: VarFieldDecl
        traitFieldDecl: TraitFieldDecl

        // Statements
        blockStmt: BlockStmt
        breakStmt: BreakStmt
        compStmt: CompStmt
        continueStmt: ContinueStmt
        deferStmt: DeferStmt
        doWhileStmt: DoWhileStmt
        emptyStmt: EmptyStmt
        forStmt: ForStmt
        funcBodyStmt: FuncBodyStmt
        gotoStmt: GotoStmt
        ifStmt: IfStmt
        labelStmt: LabelStmt
        moduleStmt: ModuleStmt // Move to declarations
        noteStmt: NoteStmt
        parametersStmt: ParametersStmt
        returnStmt: ReturnStmt
        switchCaseStmt: SwitchCaseStmt
        switchStmt: SwitchStmt
        whileStmt: WhileStmt

        // Expressions
        arrayDesignationExpr: ArrayDesignationExpr
        arrayInitExpr: ArrayInitExpr
        binaryExpr: BinaryExpr
        booleanExpr: BooleanExpr
        castExpr: CastExpr
        charExpr: CharExpr
        funcCallExpr: FuncCallExpr
        getExpr: GetExpr
        groupExpr: GroupExpr
        identifierExpr: IdentifierExpr
        initArgExpr: InitArgExpr
        initExpr: InitExpr
        nullExpr: NullExpr
        numberExpr: NumberExpr
        offsetOfExpr: OffsetOfExpr
        setExpr: SetExpr
        sizeOfExpr: SizeOfExpr
        stringExpr: StringExpr
        subscriptGetExpr: SubscriptGetExpr
        subscriptSetExpr: SubscriptSetExpr
        ternaryExpr: TernaryExpr
        typeIdentifierExpr: TypeIdentifierExpr
        typeOfExpr: TypeOfExpr
        unaryExpr: UnaryExpr
        poisonExpr: PoisonExpr
    }
}

public func (n: *Node) setSrcPos(start: SrcPos, end: SrcPos) {
    n.startPos = start
    n.endPos = end
}

public func (n: *Node) becomeParentOf(child: *Node) : *Node {
    if(!child) return null;

    child.parent = n
    return child
}

public func (n: *Node) becomeParentOfChildren(children: *Array<*Node>) : *Array<*Node> {
    var size = children.size()
    for(var i = 0; i < size; i += 1) {
        var child = children.get(i)
        if(child) {
            n.becomeParentOf(child)
        }
    }

    return children
}

public func (n: *Node) becomeParentOfChildrenCallArgs(children: *Array<CallArg>) : *Array<CallArg> {
    var size = children.size()
    for(var i = 0; i < size; i += 1) {
        var child = children.get(i).argExpr
        if(child) {
            n.becomeParentOf(child)
        }
    }

    return children
}

public struct Decl {
//    stmt: using Stmt
    sym: *Symbol
    name: Identifier
    attributes: Attributes
}

public struct GenericDecl {
    declaration: using Decl
    genericParams: Array<GenericParam>
}

public struct ImportDecl {
    decl: using Decl
    alias: Identifier
    isUsing: bool

    moduleId: *ModuleId
}

public enum VarDeclFlags {
    IS_TERNARY   = (1<<0),
    IS_TEMPORARY = (1<<1),
}

// For var or const declarations
public struct VarDecl {
    decl: using Decl
    typeSpec: *TypeSpec
    expr: *Node

    // related to lowered ternary operations
    flags: i32
    scope: *Scope
}

public struct ParameterDecl {
    decl: using Decl
    type: *TypeSpec
    defaultExpr: *Node
    typeInfo: *TypeInfo
}


public struct FuncDecl {
    decl: using GenericDecl
    params: *ParametersStmt
    body: *Node
    returnType: *TypeSpec
    flags: i32
}

public struct AggregateDecl {
    decl: using GenericDecl
    fields: Array<FieldStmt>
    flags: i32
}

public struct EnumDecl {
    decl: using Decl
    fields: Array<*EnumFieldEntryDecl>
}

public struct TypedefDecl {
    decl: using GenericDecl
    type: *TypeSpec
}

public struct NativeDecl {
    decl: using Decl
    typeInfo: *TypeInfo
}

public struct NotesDecl {
    decl: using Decl
    notes: Array<*NoteStmt>
}

public struct PoisonDecl {
    decl: using Decl
}

public struct BlockStmt {
    stmt: using Stmt
    stmts: Array<*Node>
}

public struct BreakStmt {
    stmt: using Stmt
}

public struct CompStmt {
    stmt: using Stmt
    type: InternedString
    expr: String
    end: *CompStmt
    evaluatedStmt: *Node
    body: Array<*Node>
    isScriptLoad: bool
    isStatic: bool
}

public struct ContinueStmt {
    stmt: using Stmt
}

public struct DeferStmt {
    stmt: using Stmt
    deferedStmt: *Node
}

public struct DoWhileStmt {
    stmt: using Stmt
    cond: *Node
    body: *Node
}

public struct EmptyStmt {
    stmt: using Stmt
}

public struct EnumFieldEntryDecl {
    decl: using Decl
    value: *Node
}

public struct ForStmt {
    stmt: using Stmt
    init: *Node
    cond: *Node
    post: *Node
    body: *Node
}

public struct FuncBodyStmt {
    stmt: using Stmt
    stmts: Array<*Node>
}

public struct GotoStmt {
    stmt: using Stmt
    label: Identifier
}

public struct IfStmt {
    stmt: using Stmt
    cond: *Node
    then: *Node
    elseStmt: *Node
}


public struct LabelStmt {
    stmt: using Stmt
    label: Identifier
}

// TODO: should ths be a declaration?
public struct ModuleStmt {
    stmt: using Stmt
    imports: Array<*ImportDecl>
    notes: Array<*NoteStmt>
    declarations: Array<*Node>
    //TODO: id: ModuleId
}

public struct NoteStmt {
    stmt: using Stmt
    type: *TypeSpec
    arguments: Array<CallArg>
}

public struct ParametersStmt {
    stmt: using Stmt
    params: using Array<*ParameterDecl>
    isVararg: bool
    isNativeVararg: bool
}

public struct ReturnStmt {
    stmt: using Stmt
    expr: *Node
}

public struct SwitchCaseStmt {
    stmt: using Stmt
    cond: *Node
    body: *Node
}

public struct SwitchStmt {
    stmt: using Stmt
    cond: *Node
    cases: Array<*SwitchCaseStmt>
    defaultStmt: *Node
}

public struct VarFieldDecl {
    decl: using Decl
    type: *TypeSpec
    defaultExpr: *Node
    bitFieldExpr: *Node
}

public struct TraitFieldDecl {
    decl: using Decl
    type: *TypeSpec
}

public struct FieldStmt {
    kind: StmtKind
    typeInfo: *TypeInfo
    union {
        enumField: *EnumDecl
        aggregateField: *AggregateDecl
        varField: *VarFieldDecl
        traitField: *TraitFieldDecl
        poisonField: *Node
    }
}

public struct WhileStmt {
    stmt: using Stmt
    cond: *Node
    body: *Node
}


public struct Stmt {
    //node: using Node
}

public struct ArrayDesignationExpr {
    expr: using Expr
    index: *Node
    value: *Node
}

public struct ArrayInitExpr {
    expr: using Expr
    type: *TypeSpec
    values: Array<*Node>
}

public struct BinaryExpr {
    expr: using Expr
    left: *Node
    operator: TokenType
    right: *Node

    // if this is a lowered ternary operator,
    // the source variable declaration
    ternaryDecl: *VarDecl
}

public struct BooleanExpr {
    expr: using Expr
    boolean: bool
}

public struct CastExpr {
    expr: using Expr
    castTo: *TypeSpec
    exprToCast: *Node
}

public struct CharExpr {
    expr: using Expr
    character: Token
}

public struct CallArg {
    argExpr: *Node
    argName: Identifier
    index: i32
    isDefault: bool = false
}

public struct FuncCallExpr {
    expr: using Expr
    object: *Node
    genericArgs: Array<GenericArg>
    arguments: Array<CallArg>
    flags: i32
}

public enum FuncCallExprFlags {
    HAS_NATIVE_VARARG = (1<<0),
    USED_AS_STMT      = (1<<1),
}

public enum GetExprFlags {
    IS_NORMAL      = 0,
    IS_METHOD_CALL = (1<<0),
    IS_ENUM        = (1<<1),
    IS_USING       = (1<<2),
    IS_METHOD_ARG  = (1<<3),
}

public struct GetExpr {
    expr: using Expr
    object: *Node
    field: *IdentifierExpr
    flags: i32
}

public struct GroupExpr {
    expr: using Expr
    groupedExpr: *Node
}

public struct IdentifierExpr {
    expr: using Expr
    //genericArgs: Array<*TypeSpec>
    type: *TypeSpec
    sym: *Symbol
}

public struct InitArgExpr {
    expr: using Expr
    fieldName: Identifier
    argPosition: i32
    value: *Node
}

public struct InitExpr {
    expr: using Expr
    genericArgs: Array<GenericArg>
    type: *TypeSpec
    arguments: Array<*InitArgExpr>
}

public struct NullExpr {
    expr: using Expr
}

public struct NumberExpr {
    expr: using Expr
    number: Token
}

public struct OffsetOfExpr {
    expr: using Expr
    type: *TypeSpec
    field: Identifier
}

public struct SetExpr {
    expr: using Expr
    object: *Node
    field: *IdentifierExpr
    operator: TokenType
    value: *Node
    flags: i32
}

public struct SizeOfExpr {
    expr: using Expr
    sizeOfExpr: *Node
}

public struct StringExpr {
    expr: using Expr
    string: Token // Identifier or Token?
}

public struct SubscriptGetExpr {
    expr: using Expr
    object: *Node
    index: *Node
}

public struct SubscriptSetExpr {
    expr: using Expr
    object: *Node
    index: *Node
    operator: TokenType
    value: *Node
}

public struct TernaryExpr {
    expr: using Expr
    cond: *Node
    then: *Node
    other: *Node
}

public struct TypeIdentifierExpr {
    expr: using Expr
    //genericArgs: Array<*TypeSpec>
    type: *TypeSpec
    sym: *Symbol
    isBased: bool
}

public struct TypeOfExpr {
    expr: using Expr
    typeOfExpr: *Node
    type: *TypeSpec
}

public struct UnaryExpr {
    expr: using Expr
    operator: TokenType
    unaryExpr: *Node
}

public struct PoisonExpr {
    expr: using Expr
}

public struct Expr {
    stmt: using Stmt
    operand: Operand
    expectedType: *TypeInfo
}

public struct Operand {
    typeInfo: *TypeInfo
    isRightValue: bool
    isConst: bool
    val: Value
}

public func IsExpr(node: *Node) : bool {
    if(!node) return false;

    switch(node.kind) {
        case StmtKind.ARRAY_DESIGNATION_EXPR:
        case StmtKind.ARRAY_INIT_EXPR:
        case StmtKind.BINARY_EXPR:
        case StmtKind.BOOLEAN_EXPR:
        case StmtKind.CAST_EXPR:
        case StmtKind.CHAR_EXPR:
        case StmtKind.FUNC_CALL_EXPR:
        case StmtKind.FUNC_IDENTIFIER_EXPR:
        case StmtKind.GET_EXPR:
        case StmtKind.GROUP_EXPR:
        case StmtKind.IDENTIFIER_EXPR:
        case StmtKind.INIT_EXPR:
        case StmtKind.INIT_ARG_EXPR:
        case StmtKind.NULL_EXPR:
        case StmtKind.NUMBER_EXPR:
        case StmtKind.OFFSET_OF_EXPR:
        case StmtKind.SET_EXPR:
        case StmtKind.SIZE_OF_EXPR:
        case StmtKind.STRING_EXPR:
        case StmtKind.NATIVE_STRING_EXPR:
        case StmtKind.SUBSCRIPT_GET_EXPR:
        case StmtKind.SUBSCRIPT_SET_EXPR:
        case StmtKind.TERNARY_EXPR:
        case StmtKind.TYPE_IDENTIFIER_EXPR:
        case StmtKind.TYPE_OF_EXPR:
        case StmtKind.NAME_OF_EXPR:
        case StmtKind.UNARY_EXPR:
        case StmtKind.POISON_EXPR:
            return true;
        default:
            return false;
    }
}

public func IsDecl(node: *Node) : bool {
    if(!node) return false;

    switch(node.kind) {
        case StmtKind.IMPORT_DECL:
        case StmtKind.CONST_DECL:
        case StmtKind.VAR_DECL:
        case StmtKind.STRUCT_DECL:
        case StmtKind.UNION_DECL:
        case StmtKind.TRAIT_DECL:
        case StmtKind.ENUM_DECL:
        case StmtKind.FUNC_DECL:
        case StmtKind.TYPEDEF_DECL:
        case StmtKind.PARAM_DECL:
        case StmtKind.NATIVE_DECL:
        case StmtKind.POISON_DECL:
            return true;
        default:
            return false;
    }
}

public func (d: *Node) hasNotes() : bool {
    if(!d) return false
    return !d.attributes.notes.empty()
}

public func (d: *Node) hasNote(name: *const char) : bool {
    return d.getNote(name) != null
}


public func (d: *Node) getNote(name: *const char) : *NoteStmt {
    if(!d) return null;

    if(d.attributes.notes.empty()) {
        return null;
    }

    for(var i = 0; i < d.attributes.notes.size(); i += 1) {
        var note = d.attributes.notes.get(i)
        if(StringEqualLen(note.type.name.buffer, name, note.type.name.length)) {
            return note;
        }
    }
    return null;
}

public func (d: *Node) getNoteArgument(name: *const char, arg: *const char) : *CallArg {
    var note = d.getNote(name)
    if(!note) {
        return null;
    }

    if(note.arguments.empty()) {
        return null;
    }

    for(var i = 0; i < note.arguments.size(); i+=1) {
        var a = note.arguments.getPtr(i)
        if(a.argName.str.equalsStr(arg)) {
            return a;
        }
    }
    return null;
}

public func (this: *TypeSpec) getBaseType() : *TypeSpec {
    if(!this) return null;

    switch(this.kind) {
        case TypeSpecKind.NONE: {
            return null;
        }
        case TypeSpecKind.NAME: {
            return this
        }
        case TypeSpecKind.ARRAY:
        case TypeSpecKind.PTR:
        case TypeSpecKind.CONST: {
            return this.base.getBaseType()
        }
        case TypeSpecKind.FUNC_PTR: {
            return this
        }
        default: {
            assert(false)
        }
    }
    return null
}


public func (f: *FuncDecl) getName(name:[MAX_SYMBOL_NAME]char) : bool {
    if(f.name.token.type != TokenType.IDENTIFIER) {
        return false
    }

    if(f.flags & FuncFlags.IS_METHOD) {
        if(f.params.empty()) {
            return false
        }
        var first = f.params.first()
        if(!first.type) {
            return false
        }

        var typeSpec = first.type
        var prefix = ""

        retry:
        if(typeSpec.kind != TypeSpecKind.NAME) {
            if(typeSpec.kind == TypeSpecKind.PTR ||
               typeSpec.kind == TypeSpecKind.CONST ||
               typeSpec.kind == TypeSpecKind.ARRAY) {
                typeSpec = typeSpec.base
                if(typeSpec.kind == TypeSpecKind.ARRAY) {
                    prefix = "array_"
                }
                goto retry;
            }
            return false
        }

        var totalLen = f.name.str.length + typeSpec.name.length + 2 // _ and \0
        if(totalLen > MAX_SYMBOL_NAME) {
            return false
        }

        var nameStr = StringBufferInit(name, MAX_SYMBOL_NAME, 0)
        nameStr.format("%s%.*s_%.*s",
            prefix,
            typeSpec.name.length, typeSpec.name.buffer,
            f.name.str.length, f.name.str.buffer)

        return true
    }

    var nameStr = StringBufferInit(name, MAX_SYMBOL_NAME, 0)
    nameStr.format("%.*s", f.name.str.length, f.name.str.buffer)
    return true
}

public func (expr: *Node) isIdentifier() : bool {
    if(!expr) {
        return false
    }

    return expr.kind == StmtKind.IDENTIFIER_EXPR ||
           expr.kind == StmtKind.FUNC_IDENTIFIER_EXPR ||
           expr.kind == StmtKind.TYPE_IDENTIFIER_EXPR
}


public func (expr: *Node) isConstNumberExpr() : bool {
    if(!expr) {
        return false;
    }

    switch(expr.kind) {
        case StmtKind.NUMBER_EXPR:
        case StmtKind.BOOLEAN_EXPR:
        case StmtKind.CHAR_EXPR:
        case StmtKind.IDENTIFIER_EXPR:
        case StmtKind.GET_EXPR: {
            return true
        }
        case StmtKind.SIZE_OF_EXPR: {
            var sizeofExpr = expr
            return sizeofExpr.sizeOfExpr.isConstNumberExpr()
        }
        case StmtKind.GROUP_EXPR: {
            var groupExpr = expr
            return groupExpr.groupedExpr.isConstNumberExpr()
        }
        case StmtKind.BINARY_EXPR: {
            var binExpr = expr
            return binExpr.left.isConstNumberExpr() &&
                   binExpr.right.isConstNumberExpr()
        }
        case StmtKind.UNARY_EXPR: {
            var unaryExpr = expr
            return unaryExpr.unaryExpr.isConstNumberExpr()
        }
        default: {
            return false
        }
    }
    return false
}

public func (expr: *Node) isConstExpr() : bool {
    if(!expr) {
        return false;
    }

    switch(expr.kind) {
        case StmtKind.NUMBER_EXPR:
        case StmtKind.BOOLEAN_EXPR:
        case StmtKind.CHAR_EXPR:
        case StmtKind.IDENTIFIER_EXPR:
        case StmtKind.STRING_EXPR:
        case StmtKind.NATIVE_STRING_EXPR:
        case StmtKind.GET_EXPR: {
            return true
        }
        case StmtKind.SIZE_OF_EXPR: {
            var sizeofExpr = expr
            return sizeofExpr.sizeOfExpr.isConstExpr()
        }
        case StmtKind.GROUP_EXPR: {
            var groupExpr = expr
            return groupExpr.groupedExpr.isConstExpr()
        }
        case StmtKind.BINARY_EXPR: {
            var binExpr = expr
            return binExpr.left.isConstExpr() &&
                   binExpr.right.isConstExpr()
        }
        case StmtKind.UNARY_EXPR: {
            var unaryExpr = expr
            return unaryExpr.unaryExpr.isConstExpr()
        }
        default: {
            return false
        }
    }
    return false
}

public func CallArgSort(a: CallArg, b: CallArg) : i32 {
    return a.index - b.index
}