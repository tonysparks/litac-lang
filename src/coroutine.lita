import "std/array"
import "std/mem"
import "std/map"
import "std/libc"
import "std/hash"
import "std/string"
import "std/string/builder"
import "std/string/buffer"
import "std/assert"

import "intern"
import "symbols"
import "types"

import "lita"
import "ast"
import "ast_copy"
import "parser"
import "checker"
import "lex"
import "module"
import "common"
import "lowering"

// public struct ContinuationContext {
//     funcDecl: *FuncDecl
//     stack: *CoroutineStack
//     index: u32

//     initBlock: *BodyStmt
// }

public struct CoroutineStack {
    allocator: *const Allocator
    scopes: Array<Map<InternedString, *Symbol>>
    index: Map<usize, i32>
}

public func (this: *CoroutineStack) init(
    allocator: *const Allocator
) {
    this.allocator = allocator
    this.scopes = ArrayInit<Map<InternedString, *Symbol>>(64, allocator)
    this.index.init(
        -1,
        64,
        allocator,
        0_usize
    )
}

public func (this: *CoroutineStack) free() {
    this.scopes.free()
}

public func (this: *CoroutineStack) pushScope(scope: *Scope) {
    this.index.put(scope as (usize), this.scopes.size())
    this.scopes.add(scope.symbolTypes)
}

public func (this: *CoroutineStack) popScope(scope: *Scope) {
    var index = this.index.get(scope as (usize))
    if (index > -1) {
        this.scopes.set(index, scope.symbolTypes)
    }
}

public func (this: *CoroutineStack) print() {
    for(var i = 0; i < this.scopes.size(); i += 1) {
        // printf("{\n")
        var vars = this.scopes.get(i)
        for(var it = vars.iter(); it.hasNext();) {
            var n = it.next()

            var sym = n.value
            printf("%.*s_%d: %s\n",
                n.key.length, n.key.buffer,
                i,
                sym.type.toStringDebug()
            )
        }
        // printf("}\n")
    }
}

/* ----------------------------------------------------------------------

 Coroutines generation:

 public struct %funcName%__Stack {
    // all stack allocated variables
 }

 public func %funcName%__Coroutine(cont: *Continuation) : ContinuationResult {
    var stack = cont.stack as (*%funcName%__Stack)
    return %funcName%(
        cont,
        // pass args
    )
 }

   ---------------------------------------------------------------------- */


// public func CreateCoroutines(checker: *TypeChecker) : Array<*Decl> {
//     var allocator = checker.current.allocator

//     var sb = StringBuilderInit(2048, allocator)
//     var nameBuffer = StringBuilderInit(MAX_SYMBOL_NAME, allocator)

//     var result = ArrayInit<*Decl>(checker.symbolCoroutines.size(), allocator)
//     for(var i = 0; i < checker.symbolCoroutines.size(); i+=1) {
//         var coSym = checker.symbolCoroutines.get(i)
//         assert(coSym)
//         assert(coSym.decl)
//         assert(coSym.flags & SymbolFlags.IS_COROUTINE)

//         var coName = GetCoroutineName(coSym, nameBuffer)
//         GenerateCoroutineStack(coSym, coName, sb)
//         GenerateCoroutineWrapper(coSym, coName, sb)
//     }

//     printf("%s\n", sb.cStr())
//     return result
// }

public func CreateCoroutine(
    checker: *TypeChecker,
    coSym: *Symbol,
    context: *FuncLowerContext
) : Array<*Decl> {

    assert(coSym)
    assert(coSym.decl)
    assert(coSym.flags & SymbolFlags.IS_COROUTINE)

    var allocator = checker.current.allocator

    var sb = StringBuilderInit(2048, allocator)
    var nameBuffer = StringBuilderInit(MAX_SYMBOL_NAME, allocator)

    var coName = GetCoroutineName(coSym, nameBuffer)
    GenerateCoroutineStack(context, coSym, coName, sb)
    GenerateCoroutineWrapper(context, coSym, coName, sb)

    printf("%s\n", sb.cStr())
    var parser = ParserInit(
        "generated",
        sb.cStr(),
        sb.length,
        checker.current,
        checker.lita
    )

    var stmts = parser.parseModule()
    return stmts.declarations
}

func GenerateCoroutineStack(
    context: *FuncLowerContext,
    coSym: *Symbol,
    coName: String,
    sb: *StringBuilder
) {
    sb.append("@hidden struct %.*s__CoroutineStack {\n", coName.length, coName.buffer)

    var decl = coSym.decl
    assert(decl != null)

    var funcDecl = decl as (*FuncDecl)
    var params = &funcDecl.params.params
    for(var i = 0; i < params.size(); i+=1) {
        var param = params.get(i)

        var sym = param.sym
        assert(sym != null)

        if(sym.flags & (SymbolFlags.IS_TEMP|SymbolFlags.IS_GENERATED)) {
            continue
        }

        sb.append("    __%.*s__%d: ",
            param.name.str.length, param.name.str.buffer, 1
        )
        sym.type.toString(sb, true)
        sb.append("\n")
    }

    if(funcDecl.returnType != null) {
        var returnInfo = funcDecl.returnType.typeInfo
        assert(returnInfo != null)

        sb.append("    __result__0: ")
        returnInfo.toString(sb, true)
        sb.append("\n")
    }

    for(var i = 0; i < context.patches.size(); i+=1) {
        var patch = context.patches.getPtr(i)
        var kind = patch.stmt.getKind()
        if(kind == StmtKind.VAR_DECL || kind == StmtKind.CONST_DECL) {
            var decl = patch.stmt as (*VarDecl)
            var sym = decl.sym
            assert(sym != null)

            sb.append("    %.*s: ", patch.name.length, patch.name.buffer)
            sym.type.toString(sb, true)
            sb.append("\n")
        }
    }

    sb.append("}\n")
}

func GenerateCoroutineWrapper(
    context: *FuncLowerContext,
    coSym: *Symbol,
    coName: String,
    sb: *StringBuilder
) {
    sb.append("@hidden func %.*s__Coroutine(cont: *Continuation) : ContinuationResult {\n", coName.length, coName.buffer)
    sb.append("    var stack = cont.stack as (*%.*s__CoroutineStack)\n", coName.length, coName.buffer)
    sb.append("    return %.*s(cont\n", coName.length, coName.buffer)

    var stack = coSym.coroutine
    assert(stack != null)

    var decl = coSym.decl
    assert(decl != null)

    if(!stack.scopes.empty()) {
        var funcDecl = decl as (*FuncDecl)
        var params = &funcDecl.params.params
        for(var i = 0; i < params.size(); i+=1) {
            var param = params.get(i)

            var sym = param.sym
            assert(sym != null)
            if(sym.flags & (SymbolFlags.IS_TEMP|SymbolFlags.IS_GENERATED)) {
                continue
            }

            sb.append("        , stack.__%.*s__%d",
                param.name.str.length, param.name.str.buffer, 1
            )
            sb.append("\n")
        }
    }

    sb.append("    );\n")
    sb.append("}\n")
}

func GetCoroutineName(sym: *Symbol, sb: *StringBuilder) : String {

    // if this isn't a generic generated trait, just use the symbol name
    if(!(sym.flags & SymbolFlags.IS_FROM_GENERIC_TEMPLATE)) {
        return sym.name.view
    }

    sb.clear()

    // otherwise, we have to calculate the new name using the generic type arguments
    EscapeName(sym.name.buffer, sym.name.length, sb)

    return String {
        .buffer = sb.buffer,
        .length = sb.length
    }
}

public func MakeCoroutine(checker: *TypeChecker, funcDecl: *FuncDecl) {
    var context = ContinuationContext {

    }

    // InjectContinuationState(
    //     &context,
    //     funcDecl.body as (*Node)
    // )
}

struct ContinuationContext {

}
/*
func InjectContinuationState(context: *ContinuationContext, ast: *Node) {
    if(!ast) {
        return;
    }
printf("Here: %s\n", StmtKindAsStr(ast.kind))
    switch(ast.kind) {
        case StmtKind.TRAIT_DECL:
        case StmtKind.UNION_DECL:
        case StmtKind.STRUCT_DECL:
        case StmtKind.FUNC_DECL:
        case StmtKind.IMPORT_DECL:
        case StmtKind.TYPEDEF_DECL:
        case StmtKind.ENUM_DECL:
        case StmtKind.PARAM_DECL:
        case StmtKind.NATIVE_DECL:
        case StmtKind.POISON_DECL: {
            break;
        }
        case StmtKind.CONST_DECL:
        case StmtKind.VAR_DECL: {
            var decl = ast as (*VarDecl)
            if(decl.expr) {
                InjectContinuationState(context, decl.expr)
            }
            break;
        }


        case StmtKind.BLOCK_STMT: {
            var body = ast as (*BlockStmt)
            for(var i = 0; i < body.stmts.size(); i+=1) {
                var s = body.stmts.get(i)
                InjectContinuationState(context, s)
            }
            break;
        }
        case StmtKind.BREAK_STMT: {
            break;
        }
        case StmtKind.COMP_STMT: {
            var comp = ast as (*CompStmt)
            if(comp.evaluatedStmt) {
                InjectContinuationState(context, comp.evaluatedStmt)
            }
            if(comp.end) {
                InjectContinuationState(context, comp.end)
            }
            for(var i = 0; i < comp.body.size(); i+=1) {
                var s = comp.body.get(i)
                InjectContinuationState(context, s)
            }
            break;
        }
        case StmtKind.CONTINUE_STMT: {
            break;
        }
        case StmtKind.DEFER_STMT: {
            var deferStmt = ast as (*DeferStmt)
            InjectContinuationState(context, deferStmt.deferedStmt)
            break;
        }
        case StmtKind.DO_WHILE_STMT: {
            var whileStmt = ast as (*DoWhileStmt)
            InjectContinuationState(context, whileStmt.body)
            InjectContinuationState(context, whileStmt.cond)
            break;
        }
        case StmtKind.EMPTY_STMT: {
            break;
        }
        case StmtKind.FOR_STMT: {
            var forStmt = ast as (*ForStmt)
            if(forStmt.init) {
                InjectContinuationState(context, forStmt.init)
            }
            if(forStmt.cond) {
                InjectContinuationState(context, forStmt.cond)
            }
            if(forStmt.post) {
                InjectContinuationState(context, forStmt.post)
            }
            if(forStmt.body) {
                InjectContinuationState(context, forStmt.body)
            }
            break;
        }
        case StmtKind.FUNC_BODY_STMT: {
            var body = ast as (*FuncBodyStmt)

            for(var i = 0; i < body.stmts.size(); i+=1) {
                var s = body.stmts.get(i)
                InjectContinuationState(context, s)
            }
            break;
        }
        case StmtKind.GOTO_STMT: {
            break;
        }
        case StmtKind.IF_STMT: {
            var ifStmt = ast as (*IfStmt)
            InjectContinuationState(context, ifStmt.cond)
            InjectContinuationState(context, ifStmt.then)
            if(ifStmt.elseStmt) {
                InjectContinuationState(context, ifStmt.elseStmt)
            }
            break;
        }
        case StmtKind.LABEL_STMT: {
            break;
        }
        case StmtKind.MODULE_STMT: {
            break;
        }
        case StmtKind.NOTE_STMT: {
            break;
        }
        case StmtKind.PARAMETERS_STMT: {
            var params = ast as (*ParametersStmt)
            for(var i = 0; i < params.size(); i += 1) {
                var param = params.get(i)
                InjectContinuationState(context, param as (*Node))
            }
            break;
        }
        case StmtKind.RETURN_STMT: {
            var stmt = ast as (*ReturnStmt)
            if(stmt.expr) {
                InjectContinuationState(context, stmt.expr)
            }
            break;
        }
        case StmtKind.SWITCH_CASE_STMT: {
            var caseStmt = ast as (*SwitchCaseStmt)
            InjectContinuationState(context, caseStmt.cond)
            InjectContinuationState(context, caseStmt.body)
            break;
        }
        case StmtKind.SWITCH_STMT:{
            var switchStmt = ast as (*SwitchStmt)
            InjectContinuationState(context, switchStmt.cond)
            for(var i = 0; i < switchStmt.cases.size(); i+=1) {
                var caseStmt = switchStmt.cases.get(i)
                InjectContinuationState(context, caseStmt as (*Node))
            }
            if(switchStmt.defaultStmt) {
                InjectContinuationState(context, switchStmt.defaultStmt)
            }
            break;
        }
        case StmtKind.ENUM_FIELD_DECL:
        case StmtKind.ENUM_FIELD_ENTRY_DECL:
        case StmtKind.STRUCT_FIELD_DECL:
        case StmtKind.UNION_FIELD_DECL:
        case StmtKind.TRAIT_FIELD_DECL:
        case StmtKind.VAR_FIELD_DECL: {
            // TODO: Is this needed??
            break;
        }
        case StmtKind.WHILE_STMT: {
            var whileStmt = ast as (*WhileStmt)
            InjectContinuationState(context, whileStmt.cond)
            InjectContinuationState(context, whileStmt.body)
            break;
        }


        //--------------------------------------
        //    Expressions
        //----------------------------------------
        case StmtKind.ARRAY_DESIGNATION_EXPR: {
            var expr = ast as (*ArrayDesignationExpr)
            InjectContinuationState(context, expr.index)
            InjectContinuationState(context, expr.value)
            break;
        }
        case StmtKind.ARRAY_INIT_EXPR: {
            var expr = ast as (*ArrayInitExpr)
            for(var i = 0; i < expr.values.size(); i += 1) {
                InjectContinuationState(context, expr.values.get(i))
            }
            break;
        }
        case StmtKind.BINARY_EXPR: {
            var expr = ast as (*BinaryExpr)
            InjectContinuationState(context, expr.left)
            InjectContinuationState(context, expr.right)
            break;
        }
        case StmtKind.BOOLEAN_EXPR: {
            break;
        }
        case StmtKind.CAST_EXPR: {
            var expr = ast as (*CastExpr)
            InjectContinuationState(context, expr.exprToCast)
            break;
        }
        case StmtKind.CHAR_EXPR: {
            break;
        }
        case StmtKind.FUNC_CALL_EXPR: {
            var expr = ast as (*FuncCallExpr)

            // var sym = expr.object.operand.typeInfo.sym
            // if(sym.flags & SymbolFlags.IS_COROUTINE) {
            //     var parent = ast.parent

            // }

            // InjectContinuationState(context, expr.object)

            // for(var i = 0; i < expr.arguments.size(); i += 1) {
            //     InjectContinuationState(context, expr.arguments.get(i).argExpr)
            // }
            break;
        }
        case StmtKind.FUNC_IDENTIFIER_EXPR: {
            var expr = ast as (*IdentifierExpr)
            break;
        }
        case StmtKind.GET_EXPR: {
            var expr = ast as (*GetExpr)
            InjectContinuationState(context, expr.object)
            InjectContinuationState(context, expr.field as (*Node))
            break;
        }
        case StmtKind.GROUP_EXPR: {
            var expr = ast as (*GroupExpr)
            InjectContinuationState(context, expr.groupedExpr)
            break;
        }
        case StmtKind.IDENTIFIER_EXPR: {
            var expr = ast as (*IdentifierExpr)
            break;
        }
        case StmtKind.INIT_EXPR: {
            var expr = ast as (*InitExpr)

            for(var i = 0; i < expr.arguments.size(); i += 1) {
                InjectContinuationState(context, expr.arguments.get(i) as (*Node))
            }
            break;
        }
        case StmtKind.INIT_ARG_EXPR: {
            var expr = ast as (*InitArgExpr)
            InjectContinuationState(context, expr.value)
            break;
        }
        case StmtKind.NULL_EXPR: {
            break;
        }
        case StmtKind.NUMBER_EXPR: {
            break;
        }
        case StmtKind.OFFSET_OF_EXPR: {
            var expr = ast as (*OffsetOfExpr)
            break;
        }
        case StmtKind.SET_EXPR: {
            var expr = ast as (*SetExpr)
            InjectContinuationState(context, expr.object)
            InjectContinuationState(context, expr.field as (*Node))
            InjectContinuationState(context, expr.value)
            break;
        }
        case StmtKind.SIZE_OF_EXPR: {
            var expr = ast as (*SizeOfExpr)
            InjectContinuationState(context, expr.sizeOfExpr)
            break;
        }
        case StmtKind.NATIVE_STRING_EXPR: {
            break;
        }
        case StmtKind.STRING_EXPR: {
            break;
        }
        case StmtKind.SUBSCRIPT_GET_EXPR: {
            var expr = ast as (*SubscriptGetExpr)
            InjectContinuationState(context, expr.object)
            InjectContinuationState(context, expr.index)
            break;
        }
        case StmtKind.SUBSCRIPT_SET_EXPR: {
            var expr = ast as (*SubscriptSetExpr)
            InjectContinuationState(context, expr.object)
            InjectContinuationState(context, expr.index)
            InjectContinuationState(context, expr.value)
            break;
        }
        case StmtKind.TERNARY_EXPR: {
            var expr = ast as (*TernaryExpr)
            InjectContinuationState(context, expr.cond)
            InjectContinuationState(context, expr.then)
            InjectContinuationState(context, expr.other)
            break;
        }
        case StmtKind.TYPE_IDENTIFIER_EXPR: {
            var expr = ast as (*TypeIdentifierExpr)
            break;
        }
        case StmtKind.NAME_OF_EXPR:
        case StmtKind.TYPE_OF_EXPR: {
            var expr = ast as (*TypeOfExpr)
            InjectContinuationState(context, expr.typeOfExpr)
            break;
        }
        case StmtKind.UNARY_EXPR: {
            var expr = ast as (*UnaryExpr)
            InjectContinuationState(context, expr.unaryExpr)
            break;
        }
        case StmtKind.POISON_EXPR: {
            break;
        }
        default: {
            printf("Statement Kind: %s\n", StmtKindAsStr(ast.kind))
            assert(false)
        }
    }
}
*/
