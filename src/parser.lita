import "std/string_buffer"
import "std/string_view"
import "std/string"
import "std/mem"
import "std/array"
import "std/libc"
import "std/assert"

import "ast"
import "ast_new"
import "ast_copy"
import "ast_print"
import "lex"
import "symbols"
import "types"
import "phase_result"
import "error_codes"
import "lita"
import "common"
import "module"
import "intern"
import "preprocessor"

const DECL_ADJUST_TOKENS_COUNT = 11
const DECL_ADJUST_TOKENS = [DECL_ADJUST_TOKENS_COUNT]TokenType {
    TokenType.IMPORT,
    TokenType.HASH,
    TokenType.PUBLIC,
    TokenType.VAR,
    TokenType.CONST,
    TokenType.FUNC,
    TokenType.STRUCT,
    TokenType.UNION,
    TokenType.TRAIT,
    TokenType.ENUM,
    TokenType.TYPEDEF,
}

const STMT_ADJUST_TOKENS = []TokenType {
    TokenType.IMPORT,
    TokenType.HASH,
    TokenType.PUBLIC,
    TokenType.VAR,
    TokenType.CONST,
    TokenType.FUNC,
    TokenType.STRUCT,
    TokenType.UNION,
    TokenType.TRAIT,
    TokenType.ENUM,
    TokenType.TYPEDEF
}

public struct Parser {
    allocator: *const Allocator
    typeAllocator: *TypeSpecAllocator
    module: *Module
    result: *PhaseResult
    lita: *Lita
    strings: *Strings
    filename: *const char

    totalLines: i32
    tokens: Array<Token>
    current: i32
    currentPos: SrcPos
    breakLevel: i32
    loopLevel: i32
    switchLevel: i32
    funcLevel: i32
    aggregateLevel: i32
    tryLevel: u32
    tryErrorCounter: u64
    panicMode: bool

    preprocessorLevel: i32
}

public func ParserInit(filename: *const char,
                       text: *const char,
                       length: i64,
                       module: *Module,
                       lita: *Lita) : Parser {

    var parser = Parser {
        .allocator = module.allocator,
        .typeAllocator = &module.typeSpecAllocator,
        .module = module,

        .result = &lita.result,
        .lita = lita,
        .strings = &lita.strings,
        .filename = filename,
        .current = 0,
        .breakLevel = 0,
        .loopLevel = 0,
        .switchLevel = 0,
        .funcLevel = 0,
        .aggregateLevel = 0,
        .tryLevel = 0,
        .tryErrorCounter = 0,
        .preprocessorLevel = 0,
        .panicMode = false,
    }

    var allocator = module.allocator;

    var lex = LexerInit(filename, text, length, allocator)
    parser.tokens.init(1024, allocator)

    while(!lex.eof()) {
        var token = lex.nextToken()
        if(token.type == TokenType.ERROR) {
            parser.result.addError(token.pos, "Error token: %s", lex.errorMsg)
        }

        parser.tokens.add(token)
    }

    parser.totalLines = lex.lineNumber

    // ensure there is always at least one token
    if(parser.tokens.empty()) {
        parser.tokens.add(Token{.type = TokenType.END_OF_FILE})
    }

    return parser
}

public func (p: *Parser) parseModule() : *ModuleStmt {
    var pos = p.pos()

    var imports = Array<*ImportDecl>{}
    imports.init(16, p.allocator)

    var notes = Array<*NoteStmt>{}
    notes.init(2, p.allocator)

    var declarations = Array<*Decl>{}
    declarations.init(16, p.allocator)

    var moduleStmt = NewModuleStmt(pos, pos, imports, notes, declarations, p.allocator) as (*ModuleStmt)

    if(p.atEnd()) {
        return moduleStmt
    }

    while(!p.atEnd()) {
        var errorCount = p.numOfErrors()
        p.parseModuleDeclaration(moduleStmt)

        if(p.numOfErrors() > errorCount) {
            p.adjust(DECL_ADJUST_TOKENS, DECL_ADJUST_TOKENS_COUNT)
        }
    }

    moduleStmt.endPos = p.prevPos()
    return moduleStmt
}

func (p: *Parser) parseModuleDeclaration(moduleStmt: *ModuleStmt) {

    if(p.match(TokenType.IMPORT)) {
        var importDecl = p.importDeclaration()
        if(importDecl) {
            moduleStmt.imports.add(importDecl)
        }
    }
    else if(p.match(TokenType.HASH)) {
        var compStmt = p.compStatement()
        assert(compStmt)

        if(!compStmt || compStmt.kind != StmtKind.COMP_STMT) {
            // TODO: Mark error?
            //assert(false)
            return;
        }

        p.lita.preprocessor.evaluateForModule(p.module, moduleStmt, compStmt as (*CompStmt))
    }
    else {
        var notes = Array<*NoteStmt>{}
        if(!p.notes(&notes)) {
            return;
        }

        var isPublic = p.match(TokenType.PUBLIC)
        if(p.match(TokenType.VAR)) {
            var decl = p.varDeclaration()
            moduleStmt.declarations.add(decl)
        }
        else if(p.match(TokenType.CONST)) {
            var decl = p.constDeclaration()
            moduleStmt.declarations.add(decl)
        }
        else if(p.match(TokenType.FUNC)) {
            var decl = p.funcDeclaration()
            moduleStmt.declarations.add(decl)
        }
        else if(p.match(TokenType.STRUCT)) {
            var decl = p.structDeclaration()
            moduleStmt.declarations.add(decl)
        }
        else if(p.match(TokenType.UNION)) {
            var decl = p.unionDeclaration()
            moduleStmt.declarations.add(decl)
        }
        else if(p.match(TokenType.TRAIT)) {
            var decl = p.traitDeclaration()
            moduleStmt.declarations.add(decl)
        }
        else if(p.match(TokenType.ENUM)) {
            var decl = p.enumDeclaration()
            moduleStmt.declarations.add(decl)
        }
        else if(p.match(TokenType.TYPEDEF)) {
            var decl = p.typedefDeclaration()
            moduleStmt.declarations.add(decl)
        }
        else if(p.match(TokenType.NOTE)) {
            var decl = p.noteDeclaration()
            moduleStmt.declarations.add(decl)
        }
        else if(p.match(TokenType.SEMICOLON)) {
            if(!notes.empty()) {
                moduleStmt.notes.addAll(notes)
            }
            return;
        }
        else {
            p.errorAtToken(p.peek(), ErrorCode.UNEXPECTED_TOKEN)
            return;
        }

        var decl = moduleStmt.declarations.last()
        decl.attributes.notes = notes
        decl.attributes.isPublic = isPublic
        decl.attributes.isGlobal = true
    }
}

func (p: *Parser) parseCompileTimeBody() : *Stmt {

    if(p.match(TokenType.IMPORT)) {
        var importDecl = p.importDeclaration()
        if(!importDecl) {
            goto err;
        }

        return importDecl as (*Stmt)
    }
    else {
        var pos = p.pos()

        var notes = Array<*NoteStmt>{}
        if(!p.notes(&notes)) {
            goto err;
        }

        var isPublic = p.match(TokenType.PUBLIC)
        var decl: *Decl = null

        if(p.match(TokenType.VAR)) {
            decl = p.varDeclaration()
        }
        else if(p.match(TokenType.CONST)) {
            decl = p.constDeclaration()
        }
        else if(p.match(TokenType.FUNC)) {
            decl = p.funcDeclaration()
        }
        else if(p.match(TokenType.STRUCT)) {
            decl = p.structDeclaration()
        }
        else if(p.match(TokenType.UNION)) {
            decl = p.unionDeclaration()
        }
        else if(p.match(TokenType.TRAIT)) {
            decl = p.traitDeclaration()
        }
        else if(p.match(TokenType.ENUM)) {
            decl = p.enumDeclaration()
        }
        else if(p.match(TokenType.TYPEDEF)) {
            decl = p.typedefDeclaration()
        }
        else if(p.match(TokenType.NOTE)) {
            decl = p.noteDeclaration()
        }
        else if(p.match(TokenType.SEMICOLON)) {
            if(!notes.empty()) {
                return NewNotesDecl(pos, p.pos(), notes, p.allocator) as (*Stmt)
            }
            return null;
        }
        else {
            // TODO: What to do about notes?
            return p.statement()
        }

        decl.attributes.notes = notes
        decl.attributes.isPublic = isPublic
        decl.attributes.isGlobal = true

        return decl as (*Stmt);
err:
        return NewPoisonDecl(pos, p.pos(), p.allocator) as (*Stmt)
    }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                            Declarations
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


func (p: *Parser) importDeclaration() : *ImportDecl {
    var pos = p.prevPos()

    var isUsing = p.match(TokenType.USING)
    var moduleNameStr = p.consume(TokenType.STRING, ErrorCode.MISSING_IDENTIFIER);
    if(!moduleNameStr) {
        goto err;
    }
    var moduleName = Identifier {
        .str = p.strings.internStringView(moduleNameStr.value.str),
        .token = *moduleNameStr
    }

    var alias = Identifier {
        .str = EMPTY_STR,
        .token = Token {
            .type = TokenType.VOID
        }
    }

    if(p.match(TokenType.AS)) {
        var identifier = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
        if(!identifier) {
            goto err;
        }

        alias.str = p.strings.internStringView(identifier.value.str)
        alias.token = *identifier
    }

    return NewImportDecl(pos, p.prevPos(), moduleName, alias, isUsing, p.allocator) as (*ImportDecl)

err:
    return null;
}

func (p: *Parser) notes(notes: *Array<*NoteStmt>) : bool {
    if(!p.check(TokenType.AT)) {
        return true
    }

    notes.init(4, p.allocator)
    while(p.match(TokenType.AT)) {
        var pos = p.prevPos()

        var type = p.identifierType(true)
        if(!type) {
            goto err;
        }

        var args = Array<CallArg>{}
        args.init(0, p.allocator)

        if(p.match(TokenType.LEFT_PAREN)) {
            if(!p.arguments(args)) {
                goto err;
            }
        }

        var note = NewNoteStmt(pos, p.prevPos(), type, args, p.allocator) as (*NoteStmt)
        notes.add(note)
    }

    return true
err:
    return false
}

func (p: *Parser) varDeclaration() : *Decl {
    var pos = p.prevPos()

    var identifier = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
    if(!identifier) {
        goto err;
    }

    var name = Identifier {
        .str = p.strings.internStringView(identifier.value.str),
        .token = *identifier
    }

    var type: *TypeSpec = null
    var expr: *Expr = null

    if(p.match(TokenType.COLON)) {
        type = p.type()
        if(!type) {
            goto err;
        }

        if(p.match(TokenType.EQUALS)) {
            expr = p.expression()
        }
    }
    else {
        if(!p.consume(TokenType.EQUALS, ErrorCode.MISSING_EQUALS)) {
            goto err;
        }

        expr = p.expression()
    }

    return NewVarDecl(pos, p.pos(), name, type, expr, p.allocator)

err:
    return p.poisonDecl(pos)
}

func (p: *Parser) constDeclaration() : *Decl {
    var decl = p.varDeclaration()
    if(decl.kind == StmtKind.VAR_DECL) {
        decl.kind = StmtKind.CONST_DECL
    }
    return decl;
}

func (p: *Parser) funcDeclaration() : *Decl {
    var pos = p.prevPos()
    p.funcLevel += 1;

    var objectParam: *ParameterDecl = null
    if(p.match(TokenType.LEFT_PAREN)) {
        objectParam = p.paramDeclaration()
        if(!objectParam) {
            goto err;
        }

        if(!p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)) {
            goto err;
        }
    }

    var identifier = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
    if(!identifier) {
        goto err;
    }

    var name = Identifier {
        .str = p.strings.internStringView(identifier.value.str),
        .token = *identifier
    }

    var genericParams = Array<GenericParam>{}
    if(p.match(TokenType.LESS_THAN)) {
        if(!p.genericParameters(&genericParams)) {
            goto err;
        }
    }

    var parameters = p.parametersStatement();
    if(!parameters) {
        goto err;
    }

    if(objectParam != null) {
        if(parameters.params.empty()) {
            parameters.params.init(1, p.allocator)
        }
        parameters.params.insertAt(0, objectParam);
    }


    var returnType: *TypeSpec = null
    if(p.match(TokenType.COLON)) {
        returnType = p.type();
        if(!returnType) {
            goto err;
        }
    }
    else {
        returnType = NewVoidTypeSpec(p.pos(), p.typeAllocator)
    }

    var flags = 0;
    if(parameters.isVararg) {
        flags |= FuncFlags.HAS_VARARGS;
    }

    if(objectParam != null) {
        flags |= FuncFlags.IS_METHOD;
    }

    var body: *Stmt = null;
    if(p.match(TokenType.SEMICOLON)) {
        body = NewEmptyStmt(p.prevPos(), p.pos(), p.allocator)
    }
    else {
        body = p.statement();

        // convert to FuncBodyStmt from a block stmt, so that
        // downstream systems don't have to do funky scope management
        // with function parameters
        if(body.kind == StmtKind.BLOCK_STMT) {
            body.kind = StmtKind.FUNC_BODY_STMT
        }
    }

    p.funcLevel -= 1;

    return NewFuncDecl(pos, p.prevPos(), name, genericParams, parameters, body, returnType, flags, p.allocator)

err:
    return p.poisonDecl(pos)
}

func (p: *Parser) structDeclaration() : *Decl {
    return p.aggregateDeclaration(StmtKind.STRUCT_DECL)
}

func (p: *Parser) unionDeclaration() : *Decl {
    return p.aggregateDeclaration(StmtKind.UNION_DECL)
}

func (p: *Parser) traitDeclaration() : *Decl {
    return p.aggregateDeclaration(StmtKind.TRAIT_DECL)
}

func (p: *Parser) aggregateDeclaration(kind: StmtKind) : *Decl {
    var pos = p.prevPos()

    var flags = 0;
    if(p.aggregateLevel > 0) {
        flags |= AggregateFlags.IS_EMBEDDED;
    }

    var name = Identifier {
        .str = EMPTY_STR,
        .token = Token {
            .type = TokenType.VOID
        }
    }
    if(p.check(TokenType.IDENTIFIER)) {
        var id = p.identifier();
        name.str = p.strings.internStringView(id.value.str)
        name.token = id
    }
    else {
        flags |= AggregateFlags.IS_ANONYMOUS;
    }

    var genericParams = Array<GenericParam>{}
    if(p.match(TokenType.LESS_THAN)) {
        if(!p.genericParameters(&genericParams)) {
            goto err;
        }
    }

    var fields = Array<FieldStmt>{}
    p.aggregateLevel += 1;

    if(!p.match(TokenType.SEMICOLON)) {
        if(!p.consume(TokenType.LEFT_BRACE, ErrorCode.MISSING_LEFT_BRACE)) {
            goto err;
        }

        fields.init(8, p.allocator)
        do {
            if(p.check(TokenType.RIGHT_BRACE)) {
                break;
            }

            var field = p.fieldStatement(kind);
            if(field.kind == StmtKind.POISON_EXPR) {
                goto err;
            }

            fields.add(field);

            p.eatSemicolon();
        }
        while(!p.atEnd());
        if(!p.consume(TokenType.RIGHT_BRACE, ErrorCode.MISSING_RIGHT_BRACE)) {
            goto err;
        }
    }
    p.aggregateLevel -= 1;

    return NewAggregateDecl(pos, p.prevPos(), kind, name, genericParams, fields, flags, p.allocator)

err:
    return p.poisonDecl(pos)
}

func (p: *Parser) enumDeclaration() : *Decl {
    var pos = p.prevPos()

    var identifier = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
    if(!identifier) {
        goto err;
    }
    var name = Identifier {
        .str = p.strings.internStringView(identifier.value.str),
        .token = *identifier
    }

    if(!p.consume(TokenType.LEFT_BRACE, ErrorCode.MISSING_LEFT_BRACE)) {
        goto err;
    }

    var fields = Array<*EnumFieldEntryDecl>{}
    fields.init(16, p.allocator)

    do {
        if(p.check(TokenType.RIGHT_BRACE)) {
            break;
        }

        var field = p.enumFieldEntryDecl()
        if(!field) {
            goto err;
        }

        fields.add(field);
    }
    while(p.match(TokenType.COMMA));

    if(!p.consume(TokenType.RIGHT_BRACE, ErrorCode.MISSING_RIGHT_BRACE)) {
        goto err;
    }

    return NewEnumDecl(pos, p.prevPos(), name, fields, p.allocator)

err:
    return p.poisonDecl(pos)
}

func (p: *Parser) typedefDeclaration() : *Decl {
    var pos = p.prevPos()
    var aliasedType = p.type()
    if(!aliasedType) {
        goto err;
    }

    p.match(TokenType.AS)

    var identifier = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
    if(!identifier) {
        goto err;
    }

    var name = Identifier {
        .str = p.strings.internStringView(identifier.value.str),
        .token = *identifier
    }

    var genericParams = Array<GenericParam>{}
    if(p.match(TokenType.LESS_THAN)) {
        if(!p.genericParameters(&genericParams)) {
            goto err;
        }
    }

    return NewTypedefDecl(pos, p.pos(), name, genericParams, aliasedType, p.allocator)

err:
    return p.poisonDecl(pos)
}


func (p: *Parser) noteDeclaration() : *Decl {
    var pos = p.prevPos()

    var identifier = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
    if(!identifier) {
        goto err;
    }

    var name = Identifier {
        .str = p.strings.internStringView(identifier.value.str),
        .token = *identifier
    }

    var fields = Array<FieldStmt>{}
    if(!p.match(TokenType.SEMICOLON)) {
        if(!p.consume(TokenType.LEFT_BRACE, ErrorCode.MISSING_LEFT_BRACE)) {
            goto err;
        }

        fields.init(8, p.allocator)
        do {
            if(p.check(TokenType.RIGHT_BRACE)) {
                break;
            }

            var field = p.noteFieldStatement();
            if(field.kind == StmtKind.POISON_EXPR) {
                goto err;
            }

            fields.add(field);

            p.eatSemicolon();
        }
        while(!p.atEnd());

        if(!p.consume(TokenType.RIGHT_BRACE, ErrorCode.MISSING_RIGHT_BRACE)) {
            goto err;
        }
    }

    return NewNoteDecl(pos, p.prevPos(), name, fields, p.allocator)

err:
    return p.poisonDecl(pos)
}


func (p: *Parser) paramDeclaration() : *ParameterDecl {
    var pos = p.pos()

    var identifier = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
    if(!identifier) {
        goto err;
    }

    var name = Identifier {
        .str = p.strings.internStringView(identifier.value.str),
        .token = *identifier
    }

    if(!p.consume(TokenType.COLON, ErrorCode.MISSING_COLON)) {
        goto err;
    }

    var isUsing = p.match(TokenType.USING)
    var type = p.type()
    if(!type) {
        goto err;
    }

    var defaultExpr: *Expr = null
    if(p.match(TokenType.EQUALS)) {
        defaultExpr = p.constExpression()
    }

    return NewParameterDecl(pos, p.pos(), name, type, defaultExpr, isUsing, p.allocator) as (*ParameterDecl)

err:
    return null
}



/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                            Expressions
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

public func (p: *Parser) expression() : *Expr {
    var pos = p.pos()

    var errorCount = p.numOfErrors()
    var expr = p.assignment()
    if(p.numOfErrors() > errorCount) {
        p.adjust()
        if(expr) {
            if(expr.kind == StmtKind.POISON_EXPR) {
                return expr
            }

            p.allocator.free(expr)
        }

        return NewPoisonExpr(pos, p.pos(), p.allocator)
    }

    return expr
}

func (p: *Parser) constExpression() : *Expr {
    var expr = p.expression()
    p.checkConstExpr(expr)

    return expr
}

func (p: *Parser) group() : *Expr {
    var pos = p.prevPos()
    var expr = p.expression()
    p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)
    return NewGroupExpr(pos, p.pos(), expr, p.allocator)
}

func (p: *Parser) arrayInit() : *Expr {
    var pos = p.prevPos()
    var type = p.type()
    if(!type) {
        goto err;
    }

    if(type.kind != TypeSpecKind.ARRAY) {
        p.errorAtPos(type.pos, ErrorCode.MISSING_LEFT_BRACE)
        goto err;
    }

    var values = Array<*Expr>{}
    if(p.match(TokenType.LEFT_BRACE)) {
        if(!p.arrayArguments(&values)) {
            goto err;
        }
    }

    return NewArrayInitExpr(pos, p.pos(), type, values, p.allocator)

err:
    return p.poisonExpr(pos)
}

func (p: *Parser) aggregateInit() : *Expr {
    var pos = p.prevPos()
    var arguments = Array<*InitArgExpr>{}
    p.structArguments(&arguments)

    return NewInitExpr(pos, p.pos(), null, arguments, p.allocator)
}

func (p: *Parser) sizeOf() : *Expr {
    var pos = p.prevPos()

    if(!p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN)) {
        goto err;
    }

    var isType = p.match(TokenType.COLON)
    var expr: *Expr = null
    var type: *TypeSpec = null

    var backtrack = p.current

    if(isType) {
        type = p.type(true)
        if(!type) {
            goto err;
        }

        if(p.check(TokenType.DOT)) {
            p.current = backtrack
            expr = p.unary()
            if(type) {
                p.allocator.free(type)
            }
        }
        else {
            expr = NewTypeIdentifierExpr(type.pos, p.pos(), type, p.allocator)
        }
    }
    else {
        expr = p.unary()
    }

    if(!p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)) {
        goto err;
    }

    return NewSizeOfExpr(pos, p.pos(), expr, p.allocator)

err:
    return p.poisonExpr(pos)

}

func (p: *Parser) typeOf() : *Expr {
    var pos = p.prevPos()

    if(!p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN)) {
        goto err;
    }

    var isType = p.match(TokenType.COLON)
    var expr: *Expr = null
    var type: *TypeSpec = null

    var backtrack = p.current

    if(isType) {
        type = p.type(true)
        if(!type) {
            goto err;
        }

        if(p.check(TokenType.DOT)) {
            p.current = backtrack
            expr = p.unary()
            if(type) {
                p.allocator.free(type)
            }
        }
        else {
            expr = NewTypeIdentifierExpr(type.pos, p.pos(), type, p.allocator)
        }
    }
    else {
        expr = p.unary()
    }

    if(!p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)) {
        goto err;
    }

    return NewTypeOfExpr(pos, p.pos(), expr, type, p.allocator)

err:
    return p.poisonExpr(pos)
}

func (p: *Parser) offsetOf() : *Expr {
    var pos = p.prevPos()
    if(!p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN)) {
        goto err;
    }

    var type = p.type(true)
    if(!type) {
        goto err;
    }

    if(!p.consume(TokenType.COMMA, ErrorCode.MISSING_COMMA)) {
        goto err;
    }

    var fieldName = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
    if(!fieldName) {
        goto err;
    }

    if(!p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)) {
        goto err;
    }

    var name = Identifier {
        .str = p.strings.internStringView(fieldName.value.str),
        .token = *fieldName
    }

    return NewOffsetOfExpr(pos, p.pos(), type, name, p.allocator)

err:
    return p.poisonExpr(pos)
}


func (p: *Parser) assignment() : *Expr {
    @static var checks = []TokenType{
        TokenType.EQUALS,
        TokenType.PLUS_EQ,
        TokenType.MINUS_EQ,
        TokenType.DIV_EQ,
        TokenType.MUL_EQ,
        TokenType.MOD_EQ,
        TokenType.LSHIFT_EQ,
        TokenType.RSHIFT_EQ,
        TokenType.BNOT_EQ,
        TokenType.XOR_EQ,
        TokenType.BAND_EQ,
        TokenType.BOR_EQ
    }

    var expr = p.ternary()
    if(!expr) return null; // TODO: Test, should this be a poisonExpr?

    var pos = p.pos()
    while(p.matches(checks, 12)) {
        var operator = p.previous().type
        var right = p.ternary()

        if(expr.kind == StmtKind.GET_EXPR) {
            var getExpr = expr as (*GetExpr)
            expr = NewSetExpr(pos, p.pos(), getExpr.object, getExpr.field, operator, right, p.allocator)
        }
        else if(expr.kind == StmtKind.SUBSCRIPT_GET_EXPR) {
            var getExpr = expr as (*SubscriptGetExpr)
            expr = NewSubscriptSetExpr(pos, p.pos(), getExpr.object, getExpr.index, operator, right, p.allocator)
        }
        else {
            expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
        }

        pos = p.pos()
    }

    return expr
}

func (p: *Parser) ternary() : *Expr {
    var expr = p.or()
    var pos = p.pos()

    if(p.match(TokenType.QUESTION_MARK)) {
        var then = p.expression()

        if(!p.consume(TokenType.COLON, ErrorCode.MISSING_COLON)) {
            goto err;
        }

        var other = p.expression()
        expr = NewTernaryExpr(pos, p.pos(), expr, then, other, p.allocator)
    }

    return expr

err:
    return p.poisonExpr(pos)
}

func (p: *Parser) or() : *Expr {
    var expr = p.and()
    var pos = p.pos()

    while(p.match(TokenType.OR)) {
        var operator = p.previous().type
        var right = p.and()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }

    return expr
}

func (p: *Parser) and() : *Expr {
    var expr = p.bitOr()
    var pos = p.pos()

    while(p.match(TokenType.AND)) {
        var operator = p.previous().type
        var right = p.bitOr()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }

    return expr
}

func (p: *Parser) bitOr() : *Expr {
    var expr = p.bitXor()
    var pos = p.pos()

    while(p.match(TokenType.BOR)) {
        var operator = p.previous().type
        var right = p.bitXor()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }

    return expr
}

func (p: *Parser) bitXor() : *Expr {
    var expr = p.bitAnd()
    var pos = p.pos()

    while(p.match(TokenType.XOR)) {
        var operator = p.previous().type
        var right = p.bitAnd()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }

    return expr
}

func (p: *Parser) bitAnd() : *Expr {
    var expr = p.equality()
    var pos = p.pos()

    while(p.match(TokenType.BAND)) {
        var operator = p.previous().type
        var right = p.equality()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }

    return expr
}

func (p: *Parser) equality() : *Expr {
    @static var checks = []TokenType{
        TokenType.NOT_EQUALS,
        TokenType.EQUALS_EQUALS
    }

    var expr = p.comparison()
    var pos = p.pos()

    while(p.matches(checks, 2)) {
        var operator = p.previous().type
        var right = p.comparison()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }

    return expr
}

func (p: *Parser) comparison() : *Expr {
    @static var checks = []TokenType{
        TokenType.GREATER_THAN,
        TokenType.GREATER_EQUALS,
        TokenType.LESS_THAN,
        TokenType.LESS_EQUALS
    }

    var expr = p.bitShift()
    var pos = p.pos()

    while(p.matches(checks, 4)) {
        var operator = p.previous().type
        var right = p.bitShift()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }

    return expr
}

func (p: *Parser) bitShift() : *Expr {
    @static var checks = []TokenType{
        TokenType.LSHIFT,
        TokenType.RSHIFT
    }

    var expr = p.term()
    var pos = p.pos()

    var bitExpr = p.tryBitShiftRight(expr)
    if(bitExpr) {
        return bitExpr
    }

    while(p.matches(checks, 2)) {
        var operator = p.previous().type
        var right = p.term()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }

    return expr
}

func (p: *Parser) term() : *Expr {
    @static var checks = []TokenType{
        TokenType.MINUS,
        TokenType.PLUS
    }

    var expr = p.factor()
    var pos = p.pos()

    while(p.matches(checks, 2)) {
        var operator = p.previous().type
        var right = p.factor()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }

    return expr
}

func (p: *Parser) factor() : *Expr {
    @static var checks = []TokenType{
        TokenType.SLASH,
        TokenType.STAR,
        TokenType.MOD
    }

    var expr = p.unary()
    var pos = p.pos()

    while(p.matches(checks, 3)) {
        var operator = p.previous().type
        var right = p.unary()

        expr = NewBinaryExpr(pos, p.pos(), expr, operator, right, p.allocator)
    }

    return expr
}

func (p: *Parser) unary() : *Expr {
    @static var checks = []TokenType{
        TokenType.NOT,
        TokenType.MINUS,
        TokenType.PLUS,
        TokenType.STAR,
        TokenType.BAND,
        TokenType.BNOT
    }

    var pos = p.pos()
    if(p.matches(checks, 6)) {
        var operator = p.previous().type
        var right = p.unary()

        return NewUnaryExpr(pos, p.pos(), operator, right, p.allocator)
    }

    return p.functionCall()
}

func (p: *Parser) functionCall() : *Expr {
    var pos = p.pos()

    var expr = p.primary()
    expr.endPos = p.pos()

    while(true) {
        if(p.match(TokenType.LEFT_PAREN)) {
            expr = p.finishFunctionCall(expr)
            expr.endPos = p.pos()
        }
        else if(p.check(TokenType.LEFT_BRACE)) {
            if(!expr.isIdentifier()) {
                return expr
            }

            p.advance()

            var idExpr = expr as (*IdentifierExpr) // TODO: delete idExpr??

            var arguments = Array<*InitArgExpr>{}
            if(!p.structArguments(&arguments)) {
                goto err;
            }
            expr = NewInitExpr(expr.startPos, p.pos(), idExpr.type, arguments, p.allocator)
        }
        else if(p.match(TokenType.LEFT_BRACKET)) {
            var index = p.expression()
            if(!p.consume(TokenType.RIGHT_BRACKET, ErrorCode.MISSING_RIGHT_BRACKET)) {
                goto err;
            }

            expr = NewSubscriptGetExpr(expr.startPos, p.pos(), expr, index, p.allocator)
        }
        else if(p.match(TokenType.DOT)) {
            var identifier = p.identifierType(true)
            if(!identifier) {
                goto err;
            }

            expr = NewGetExpr(expr.startPos,
                              p.pos(),
                              expr,
                              NewIdentifierExpr(identifier.pos, p.pos(), identifier, p.allocator) as (*IdentifierExpr),
                              p.allocator)
        }
        else if(p.match(TokenType.AS)) {
            expr = p.cast(expr)
        }
        else {
            break;
        }
    }

    return expr

err:
    return p.poisonExpr(pos)
}

func (p: *Parser) primary() : *Expr {
    var token = p.peek()
    var pos = token.pos
    if(p.match(TokenType.TRUE)) {
        return NewBooleanExpr(pos, p.pos(), true, p.allocator)
    }

    if(p.match(TokenType.FALSE)) {
        return NewBooleanExpr(pos, p.pos(), false, p.allocator)
    }

    if(p.match(TokenType.NULL)) {
        return NewNullExpr(pos, p.pos(), p.allocator)
    }

    if(p.match(TokenType.INT_NUMBER) || p.match(TokenType.FLOAT_NUMBER)) {
        return NewNumberExpr(pos, p.pos(), token, p.allocator)
    }

    if(p.match(TokenType.STRING)) {
        return NewStringExpr(pos, p.pos(), token, p.allocator)
    }

    if(p.match(TokenType.CHAR)) {
        return NewCharExpr(pos, p.pos(), token, p.allocator)
    }

    if(p.match(TokenType.LEFT_PAREN)) {
        return p.group()
    }

    if(p.check(TokenType.LEFT_BRACKET)) {
        return p.arrayInit()
    }

    if(p.match(TokenType.LEFT_BRACE)) {
        return p.aggregateInit()
    }

    if(p.match(TokenType.SIZEOF)) {
        return p.sizeOf()
    }

    if(p.match(TokenType.TYPEOF)) {
        return p.typeOf()
    }

    if(p.match(TokenType.OFFSETOF)) {
        return p.offsetOf()
    }

    if(p.check(TokenType.IDENTIFIER)) {
        var name = p.identifierType(true)
        if(!name) {
            goto err;
        }
        return NewIdentifierExpr(pos, p.pos(), name, p.allocator)
    }

    if(p.match(TokenType.ERROR)) {
        return p.poisonExpr(pos)
    }

err:
    p.errorAtToken(token, ErrorCode.UNEXPECTED_TOKEN)
    return p.poisonExpr(pos)
}

func (p: *Parser) finishFunctionCall(expr: *Expr) : *Expr {
    var pos = expr.startPos
    var arguments = Array<CallArg>{}
    if(!p.arguments(&arguments)) {
        goto err;
    }

    var genericArgs = Array<*TypeSpec>{}
    if(expr.isIdentifier()) {
        var idExpr = expr as (*IdentifierExpr)
        expr.kind = StmtKind.FUNC_IDENTIFIER_EXPR
        genericArgs = idExpr.type.genericArgs
    }
    else if(expr.kind == StmtKind.GET_EXPR) {
        var getExpr = expr as (*GetExpr)
        var idExpr = getExpr.field
        idExpr.kind = StmtKind.FUNC_IDENTIFIER_EXPR
        genericArgs = idExpr.type.genericArgs
    }

    return NewFuncCallExpr(pos, p.pos(), expr, arguments, genericArgs, p.allocator)

err:
    return p.poisonExpr(pos)
}

func (p: *Parser) cast(expr: *Expr) : *Expr {
    if(!p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN)) {
        goto err;
    }

    var castTo = p.type(false)
    if(!castTo) {
        goto err;
    }

    if(!p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)) {
        goto err;
    }

    return NewCastExpr(expr.startPos, p.pos(), expr, castTo, p.allocator)

err:
    return p.poisonExpr(expr.startPos)
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                            Statements
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

public func (p: *Parser) statement() : *Stmt {
    var pos = p.pos()
    var errorCount = p.numOfErrors()
    var stmt = p.tryStatement()
    if(p.numOfErrors() > errorCount) {
        p.adjust()
        if(stmt) {
            if(stmt.kind == StmtKind.POISON_EXPR) {
                return stmt
            }

            p.allocator.free(stmt)
        }

        return NewPoisonExpr(pos, p.pos(), p.allocator) as (*Stmt)
    }

    return stmt
}

func (p: *Parser) tryStatement() : *Stmt {
    var pos = p.pos()

    if(p.atEnd()) {
        goto err;
    }

    // check for note declarations
    if(p.check(TokenType.AT)) {
        var notes = Array<*NoteStmt>{}
        if(!p.notes(&notes)) {
            goto err;
        }

        var decl: *Decl = null
        if(p.match(TokenType.VAR)) {
            decl = p.varDeclaration()
        }
        else if(p.match(TokenType.CONST)) {
            decl = p.constDeclaration()
        }
        else {
            p.errorAtToken(p.peek(), ErrorCode.INVALID_NOTE_DECL)
            goto err;
        }

        decl.attributes.notes = notes
        decl.startPos = pos
        return decl as (*Stmt)
    }

    if(p.match(TokenType.HASH)) {
        return p.compStatement()
    }

    if(p.match(TokenType.LEFT_BRACE)) {
        return p.blockStatement()
    }

    if(p.match(TokenType.VAR)) {
        return p.varDeclaration() as (*Stmt)
    }

    if(p.match(TokenType.CONST)) {
        return p.constDeclaration() as (*Stmt)
    }

    if(p.match(TokenType.IF)) {
        return p.ifStatement()
    }

    if(p.match(TokenType.WHILE)) {
        return p.whileStatement()
    }

    if(p.match(TokenType.DO)) {
        return p.doWhileStatement()
    }

    if(p.match(TokenType.FOR)) {
        return p.forStatement()
    }

    if(p.match(TokenType.SWITCH)) {
        return p.switchStatement()
    }

    if(p.match(TokenType.BREAK)) {
        return p.breakStatement()
    }

    if(p.match(TokenType.CONTINUE)) {
        return p.continueStatement()
    }

    if(p.match(TokenType.RETURN)) {
        return p.returnStatement()
    }

    if(p.match(TokenType.DEFER)) {
        return p.deferStatement()
    }

    if(p.match(TokenType.GOTO)) {
        return p.gotoStatement()
    }

    if(p.check(TokenType.IDENTIFIER)) {
        var stmt = p.tryLabelStatement()
        if(stmt) {
            return stmt
        }
    }

    return p.expression() as (*Stmt)

err:
    return p.poisonStatement(pos)
}

func (p: *Parser) compStatement(isStaticIf: bool = false) : *Stmt {
    var pos = p.pos()

    p.preprocessorLevel += 1
    defer p.preprocessorLevel -= 1

    var type: InternedString = EMPTY_STR
    var scriptExpr = StringView{};

    if(p.match(TokenType.IF)) {
        type = IF
    }
    else if(p.match(TokenType.ELSE)) {
        type = ELSE
    }
    else {
        var identifier = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
        if(!identifier) {
            goto err;
        }

        type = NewTokenNameIntern(*identifier, p.lita.strings)
    }

    if(type.equals(STATIC_IF)) {
        isStaticIf = true
    }

    var isIf = type.equals(IF) || type.equals(STATIC_IF);

    if(p.preprocessorLevel > 1) {
        if(isIf) {
            p.result.addError(pos, "'#static_if' and '#if' are only allowed as the first statement in the preprocessor chain")
            goto err;
        }
    }

    if(type.equals(IF) || type.equals(ELSEIF) || type.equals(STATIC_IF)) {
        // read the expression
        var currentLine = pos.lineNumber
        var script = StringBufferInit(128, p.allocator)

        var stream = pos.end
        while(*stream) {
            var c = *stream
            if(c == '\n') {
                break
            }
            if(c == '\\') {
                if(stream[1] == '\r' && stream[2] == '\n') {
                    stream += 3
                    currentLine += 1
                    continue
                }
                else if(stream[1] == '\n') {
                    stream += 2
                    currentLine += 1
                    continue
                }
            }
            if(c == '\r') {
                stream += 1
                continue
            }

            script.appendChar(c)
            stream += 1
        }

        // read the tokens until we are caught up with the
        // eval expression
        while(!p.atEnd()) {
            var token = p.peek()

            var nextLine = token.pos.lineNumber
            if(nextLine > currentLine) {
                break
            }
            p.advance()
        }

        script.trim()
        scriptExpr.buffer = script.cStr()
        scriptExpr.length = script.length

        if(script.length == 0 && isIf) {
            p.result.addError(pos,
                "'#static_if' and '#if' must include a conditional expression")
            goto err;
        }

        var body = ArrayInit<*Stmt>(32, p.allocator)
        while(!p.atEnd()) {
            if(p.check(TokenType.HASH)) {
                break;
            }

            var stmt = p.parseCompileTimeBody()
            if(stmt) {
                body.add(stmt)
            }
        }

        if(!p.consume(TokenType.HASH, ErrorCode.MISSING_COMP_STMT_END)) {
            goto err;
        }

        var end = p.compStatement(isStaticIf)
        if(end && end.kind != StmtKind.COMP_STMT) {
            goto err;
        }
        return NewCompStmt(
            pos,
            p.pos(),
            type,
            scriptExpr,
            body,
            end as (*CompStmt),
            false,
            isStaticIf,
            p.allocator)

    }
    else if(type.equals(PRECHECK)  ||
            type.equals(POSTCHECK) ||
            type.equals(POSTPARSE)) {

        var pos = p.pos()

        var isScriptLoad = false
        var rewind = p.current

        // determine if we're just loading a script vs.
        // an inlined script
        if(p.check(TokenType.STRING)) {
            var filename = p.consume(TokenType.STRING, ErrorCode.MISSING_IDENTIFIER)
            if(p.check(TokenType.HASH) && filename) {
                isScriptLoad = true
                scriptExpr.buffer = filename.str.buffer
                scriptExpr.length = filename.str.length
            }
            else {
                p.current = rewind
            }
        }
        else {
            // read the tokens until we are caught up with the
            // eval expression
            while(!p.atEnd()) {
                var token = p.peek()

                if(p.check(TokenType.HASH)) {
                    break
                }
                p.advance()
            }

            scriptExpr.buffer = pos.start
            scriptExpr.length = (p.pos().start - pos.start) as (i32)
        }

        if(!p.consume(TokenType.HASH, ErrorCode.MISSING_COMP_STMT_END)) {
            goto err;
        }

        var end = p.compStatement()
        if(end && end.kind != StmtKind.COMP_STMT) {
            goto err;
        }
        var body = Array<*Stmt>{}
        return NewCompStmt(
            pos,
            p.pos(),
            type,
            scriptExpr,
            body,
            end as (*CompStmt),
            isScriptLoad,
            false,
            p.allocator)
    }
    else if(type.equals(ELSE)) {
        var body = ArrayInit<*Stmt>(32, p.allocator)
        while(!p.atEnd()) {
            if(p.check(TokenType.HASH)) {
                break;
            }

            var stmt = p.parseCompileTimeBody()
            if(stmt) {
                body.add(stmt)
            }
        }

        if(!p.consume(TokenType.HASH, ErrorCode.MISSING_COMP_STMT_END)) {
            goto err;
        }

        var end = p.compStatement(isStaticIf)
        if(end && end.kind != StmtKind.COMP_STMT) {
            goto err;
        }
        return NewCompStmt(
            pos,
            p.pos(),
            type,
            scriptExpr,
            body,
            end as (*CompStmt),
            false,
            isStaticIf,
            p.allocator)
    }
    else if(type.equals(ELSE_ERROR)) {
        var message = p.consume(TokenType.STRING, ErrorCode.MISSING_ERROR_MESSAGE)
        if(!message) {
            goto err;
        }

        if(!p.consume(TokenType.HASH, ErrorCode.MISSING_COMP_STMT_END)) {
            goto err;
        }

        var end = p.compStatement(isStaticIf)
        if(end && end.kind != StmtKind.COMP_STMT) {
            goto err;
        }

        return NewCompStmt(pos, p.pos(), type, message.str, Array<*Stmt>{}, null, false, isStaticIf, p.allocator)
    }
    else if(type.equals(END)) {
        return NewCompStmt(pos, p.pos(), type, StringView{}, Array<*Stmt>{}, null, false, isStaticIf, p.allocator)
    }
    else {
        p.errorAtToken(p.peek(), ErrorCode.INVALID_COMP_STMT)
        goto err;
    }

err:
    return NewPoisonExpr(pos, p.pos(), p.allocator) as (*Stmt)
}

func (p: *Parser) blockStatement() : *Stmt {
    if(p.breakLevel > 0) {
        p.breakLevel -= 1
    }

    var pos = p.prevPos()

    var stmts = Array<*Stmt>{}
    stmts.init(16, p.allocator)

    do {
        if(p.check(TokenType.RIGHT_BRACE)) {
            break
        }

        var stmt = p.statement()
        stmts.add(stmt)

        p.eatSemicolon()
    }
    while(!p.atEnd())

    if(!p.consume(TokenType.RIGHT_BRACE, ErrorCode.MISSING_RIGHT_BRACE)) {
        goto err;
    }

    return NewBlockStmt(pos, p.pos(), stmts, p.allocator)

err:
    return p.poisonStatement(pos)
}

func (p: *Parser) ifStatement() : *Stmt {
    var pos = p.prevPos()
    if(!p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN)) {
        goto err;
    }


    var cond = p.expression()

    if(!p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)) {
        goto err;
    }

    var then = p.statement();

    var elseStmt: *Stmt = null;
    if(p.match(TokenType.ELSE)) {
        elseStmt = p.statement();
    }

    return NewIfStmt(pos, p.pos(), cond, then, elseStmt, p.allocator);

err:
    return p.poisonStatement(pos)
}

func (p: *Parser) whileStatement() : *Stmt {
    var pos = p.prevPos()
    p.loopLevel += 1;

    if(!p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN)) {
        goto err;
    }

    var cond = p.expression();

    if(!p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)) {
        goto err;
    }

    var body = p.statement();
    p.loopLevel -= 1;

    return NewWhileStmt(pos, p.pos(), cond, body, p.allocator);

err:
    p.loopLevel -= 1;
    return p.poisonStatement(pos)
}

func (p: *Parser) doWhileStatement() : *Stmt {
    var pos = p.prevPos()
    p.loopLevel += 1;
    var body = p.statement();

    if(!p.consume(TokenType.WHILE, ErrorCode.MISSING_WHILE)) {
        goto err;
    }

    if(!p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN)) {
        goto err;
    }

    var cond = p.expression();

    if(!p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)) {
        goto err;
    }

    p.loopLevel -= 1;

    return NewDoWhileStmt(pos, p.pos(), cond, body, p.allocator);

err:
    p.loopLevel -= 1;
    return p.poisonStatement(pos)
}

func (p: *Parser) forStatement() : *Stmt {
    var pos = p.prevPos()
    if(!p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN)) {
        goto err;
    }

    var init = !p.check(TokenType.SEMICOLON) ? p.statement() : null;
    if(!p.consume(TokenType.SEMICOLON, ErrorCode.MISSING_SEMICOLON)) {
        goto err;
    }

    var cond = !p.check(TokenType.SEMICOLON) ? p.expression() : null;
    if(!p.consume(TokenType.SEMICOLON, ErrorCode.MISSING_SEMICOLON)) {
        goto err;
    }

    var post = !p.check(TokenType.RIGHT_PAREN) ? p.statement() : null;
    if(!p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)) {
        goto err;
    }

    p.loopLevel += 1;
    var body = p.statement();
    p.loopLevel -= 1;

    return NewForStmt(pos, p.pos(), init, cond, post, body, p.allocator);

err:
    return p.poisonStatement(pos)
}

func (p: *Parser) switchCaseStatement() : *Stmt {
    var pos = p.prevPos()

    var cond = p.constExpression()
    if(!p.consume(TokenType.COLON, ErrorCode.MISSING_COLON)) {
        return null
    }

    var bodyPos = p.pos()
    var stmts = Array<*Stmt>{}
    stmts.init(8, p.allocator)

    while(!p.atEnd()) {
        if(p.check(TokenType.RIGHT_BRACE) ||
           p.check(TokenType.CASE) ||
           p.check(TokenType.DEFAULT)) {
            break;
        }

        var stmt = p.statement()
        p.eatSemicolon()

        stmts.add(stmt)
    }
    var body: *Stmt = null
    if(stmts.empty()) {
        body = NewEmptyStmt(bodyPos, p.pos(), p.allocator)
    }
    else {
        body = NewBlockStmt(bodyPos, p.pos(), stmts, p.allocator)
    }

    return NewSwitchCaseStmt(pos, p.pos(), cond, body, p.allocator);
}


func (p: *Parser) switchDefaultStatement() : *Stmt {
    var pos = p.prevPos()

    var breakCount = p.breakLevel

    var stmts = Array<*Stmt>{}
    stmts.init(8, p.allocator)

    while(!p.atEnd()) {
        if(p.check(TokenType.RIGHT_BRACE) ||
           p.check(TokenType.CASE)) {
            break;
        }

        var stmt = p.statement()
        p.eatSemicolon()

        stmts.add(stmt)

        if(breakCount != p.breakLevel) {
            p.breakLevel -= 1
            break
        }
    }

    return NewBlockStmt(pos, p.pos(), stmts, p.allocator)
}

func (p: *Parser) switchStatement() : *Stmt {
    var pos = p.prevPos()
    p.switchLevel += 1
    defer p.switchLevel -= 1

    if(!p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN)) {
        goto err;
    }

    var cond = p.expression()

    if(!p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)) {
        goto err;
    }

    var startBrace = p.match(TokenType.LEFT_BRACE)

    var cases = Array<*SwitchCaseStmt>{}
    cases.init(8, p.allocator)

    var defaultStmt: *Stmt = null

    while(!p.atEnd()) {
        if(p.match(TokenType.CASE)) {
            var caseStmt = p.switchCaseStatement() as (*SwitchCaseStmt)
            if(!caseStmt) {
                goto err;
            }
            cases.add(caseStmt)

            p.eatSemicolon()
        }
        else if(p.match(TokenType.DEFAULT)) {
            if(!p.consume(TokenType.COLON, ErrorCode.MISSING_COLON)) {
                goto err;
            }

            defaultStmt = p.switchDefaultStatement()
            p.eatSemicolon()
        }
        else {
            break
        }
    }

    if(startBrace) {
        p.consume(TokenType.RIGHT_BRACE, ErrorCode.MISSING_RIGHT_BRACE);
    }

    return NewSwitchStmt(pos, p.pos(), cond, cases, defaultStmt, p.allocator);

err:
    return p.poisonStatement(pos)
}


func (p: *Parser) breakStatement() : *Stmt {
    var pos = p.prevPos()

    if(p.loopLevel < 1 && p.switchLevel < 1) {
        p.errorAtToken(p.previous(), ErrorCode.INVALID_BREAK)
        goto err;
    }

    if(p.switchLevel > 0 && p.loopLevel < 1) {
        p.breakLevel += 1
    }

    return NewBreakStmt(pos, p.pos(), p.allocator)

err:
    return p.poisonStatement(pos)
}

func (p: *Parser) continueStatement() : *Stmt {
    var pos = p.prevPos()

    if(p.loopLevel < 1) {
        p.errorAtToken(p.previous(), ErrorCode.INVALID_CONTINUE)
        goto err;
    }

    return NewContinueStmt(pos, p.pos(), p.allocator)

err:
    return p.poisonStatement(pos)
}

func (p: *Parser) returnStatement() : *Stmt {
    var pos = p.prevPos()
    var expr: *Expr = null
    if(!p.check(TokenType.SEMICOLON)) {
        expr = p.expression()
    }

    return NewReturnStmt(pos, p.pos(), expr, p.allocator)
}

func (p: *Parser) deferStatement() : *Stmt {
    var pos = p.prevPos()
    var defered = p.statement()
    return NewDeferStmt(pos, p.pos(), defered, p.allocator)
}

func (p: *Parser) gotoStatement() : *Stmt {
    var pos = p.prevPos()
    var label = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
    if(!label) {
        goto err;
    }

    var name = Identifier {
        .str = p.strings.internStringView(label.value.str),
        .token = *label
    }

    return NewGotoStmt(pos, p.pos(), name, p.allocator)

err:
    return p.poisonStatement(pos)
}

func (p: *Parser) tryLabelStatement() : *Stmt {
    var backtrack = p.current
    var pos = p.pos()

    var label = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
    if(!p.match(TokenType.COLON)) {
        p.current = backtrack
        return null
    }

    if(p.funcLevel < 1) {
        p.errorAtToken(p.peek(), ErrorCode.INVALID_LABEL_STMT)
        goto err;
    }

    var name = Identifier {
        .str = p.strings.internStringView(label.value.str),
        .token = *label
    }

    return NewLabelStmt(pos, p.pos(), name, p.allocator)

err:
    return p.poisonStatement(pos)
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        Type Specifications
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


func (p: *Parser) type(disambiguate: bool = false) : *TypeSpec {
    var token = p.peek()
    switch(token.type) {
        case TokenType.BOOL:
        case TokenType.CHAR:
        case TokenType.I8:
        case TokenType.U8:
        case TokenType.I16:
        case TokenType.U16:
        case TokenType.I32:
        case TokenType.U32:
        case TokenType.I64:
        case TokenType.U64:
        case TokenType.F32:
        case TokenType.F64:
        case TokenType.USIZE:
        case TokenType.VOID: {
            p.advance()
            var spec = NewTypeSpec(TypeSpecKind.NAME, token.pos, p.typeAllocator)
            spec.name = NewTokenNameIntern(token, p.lita.strings)

            return spec as (*TypeSpec)
        }
        case TokenType.STAR: {
            p.advance()
            var base = p.type(disambiguate)
            if(!base) return null;

            var spec = NewTypeSpec(TypeSpecKind.PTR, token.pos, p.typeAllocator)
            spec.base = base
            return spec as (*TypeSpec)
        }
        case TokenType.CONST: {
            p.advance()
            var base = p.type(disambiguate)
            if(!base) return null;

            var spec = NewTypeSpec(TypeSpecKind.CONST, token.pos, p.typeAllocator)
            spec.base = base
            return spec as (*TypeSpec)
        }
        case TokenType.IDENTIFIER: {
            return p.identifierType(disambiguate) as (*TypeSpec)
        }
        case TokenType.LEFT_BRACKET: {
            var spec = p.arrayType()
            p.advance()

            if(!spec) return null;

            spec.base = p.type(disambiguate)
            return spec as (*TypeSpec)
        }
        case TokenType.FUNC: {
            p.advance()
            return p.funcPtrType() as (*TypeSpec)
        }
        default: {
            p.errorAtToken(token, ErrorCode.UNEXPECTED_TOKEN)
            break;
        }
    }

    return null
}

func (p: *Parser) identifierType(disambiguate: bool) : *TypeSpec {
    var pos = p.pos()

    var name = p.identifier()
    if(name.type != TokenType.IDENTIFIER) {
        goto err;
    }

    var buffer:[MAX_SYMBOL_NAME]char;
    var sb = StringInit(buffer, MAX_SYMBOL_NAME, 0)
    sb.appendStrn(name.str.buffer, name.str.length)

    if(p.match(TokenType.COLON_COLON)) {
        var identifier = p.identifier()
        if(identifier.type != TokenType.IDENTIFIER) {
            goto err;
        }
        sb.appendStrn("::", 2)
        sb.appendStrn(identifier.str.buffer, identifier.str.length)
    }

    var spec = NewTypeSpec(TypeSpecKind.NAME, pos, p.typeAllocator)
    spec.name = p.lita.strings.internCopy(sb.cStr(), sb.length)

    if(p.check(TokenType.LESS_THAN)) {
        spec.genericArgs = p.tryGenericArguments(disambiguate)
    }

    return spec;

err:
    return null
}

func (p: *Parser) arrayType() : *TypeSpec {
    var spec = NewTypeSpec(TypeSpecKind.ARRAY, p.pos(), p.typeAllocator)
    p.advance()

    if(!p.check(TokenType.RIGHT_BRACKET)) {
        var expr = p.expression()
        if(!expr.isConstNumberExpr()) {
            p.errorAtToken(p.peek(), ErrorCode.INVALID_ARRAY_DIMENSION_EXPR)
            goto err;
        }
        else {
            spec.numElements = expr
        }
    }

    return spec

err:
    return null
}

func (p: *Parser) funcPtrType() : *TypeSpec {
    var pos = p.prevPos()
    var spec = NewTypeSpec(TypeSpecKind.FUNC_PTR, pos, p.typeAllocator)

    if(p.match(TokenType.LESS_THAN))  {
        if(!p.genericParameters(&spec.genericParams)) {
            goto err;
        }
    }

    if(!p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN)) {
        goto err;
    }

    if(!p.check(TokenType.RIGHT_PAREN)) {
        do {
            if(p.match(TokenType.VAR_ARGS)) {
                spec.hasVarargs = true
                if(!p.check(TokenType.RIGHT_PAREN)) {
                    p.errorAtToken(p.peek(), ErrorCode.INVALID_VARARG_POSITION)
                    goto err;
                }
            }
            else {
                var arg = p.type(false)
                if(!arg) {
                    goto err;
                }

                spec.args.add(arg)
            }
        }
        while(p.match(TokenType.COMMA))
    }

    if(!p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)) {
        goto err;
    }

    if(!p.consume(TokenType.COLON, ErrorCode.MISSING_COLON)) {
        goto err;
    }

    spec.ret = p.type(false)
    if(!spec.ret) {
        goto err;
    }

    return spec

err:
    return null
}

func (p: *Parser) parametersStatement() : *ParametersStmt {
    var pos = p.pos()
    var params = Array<*ParameterDecl>{}
    var isVarargs = false;

    if(!p.consume(TokenType.LEFT_PAREN, ErrorCode.MISSING_LEFT_PAREN)) {
        goto err;
    }

    if(!p.check(TokenType.RIGHT_PAREN)) {
        params.init(8, p.allocator)

        do {
            if(p.match(TokenType.VAR_ARGS)) {
                isVarargs = true;

                if(!p.check(TokenType.RIGHT_PAREN)) {
                    p.errorAtToken(p.peek(), ErrorCode.INVALID_VARARG_POSITION);
                    goto err;
                }
            }
            else {
                var param = p.paramDeclaration();
                if(!param) {
                    goto err;
                }

                params.add(param);
            }
        }
        while(p.match(TokenType.COMMA));
    }

    if(!p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)) {
        goto err;
    }

    return NewParametersStmt(pos, p.pos(), params, isVarargs, p.allocator) as (*ParametersStmt)

err:
    return null
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                            Utility
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

func (p: *Parser) structArguments(arguments: *Array<*InitArgExpr>) : bool {
    arguments.init(16, p.allocator)

    var argPosition = 0
    do {
        if(p.check(TokenType.RIGHT_BRACE)) {
            break;
        }

        var pos = p.pos()
        var fieldName = Identifier {
            .str = EMPTY_STR,
            .token = Token{.type = TokenType.VOID}
        }

        if(p.match(TokenType.DOT)) {
            var identifier = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
            if(!identifier) {
                goto err;
            }

            fieldName.str = p.strings.internStringView(identifier.value.str)
            fieldName.token = *identifier

            if(p.check(TokenType.COLON)) {
                p.consume(TokenType.COLON, ErrorCode.MISSING_COLON)
            }
            else if(p.check(TokenType.EQUALS)) {
                p.consume(TokenType.EQUALS, ErrorCode.MISSING_EQUALS)
            }
            else {
                p.errorAtToken(p.peek(), ErrorCode.MISSING_COLON)
                goto err;
            }
        }

        var value = p.expression()
        var arg = NewInitArgExpr(pos, p.pos(), fieldName, argPosition, value, p.allocator) as (*InitArgExpr)
        arguments.add(arg)
        argPosition += 1
    }
    while(p.match(TokenType.COMMA))

    if(!p.consume(TokenType.RIGHT_BRACE, ErrorCode.MISSING_RIGHT_BRACE)) {
        goto err;
    }

    return true

err:
    return false
}

func (p: *Parser) arguments(arguments: *Array<CallArg>) : bool {
    if(!p.check(TokenType.RIGHT_PAREN)) {
        arguments.init(8, p.allocator)

        do {
            var arg = CallArg{}
            if(p.match(TokenType.DOT)) {
                var identifier = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
                if(!identifier) {
                    goto err;
                }

                arg.argName.str = p.strings.internStringView(identifier.value.str)
                arg.argName.token = *identifier

                if(p.check(TokenType.COLON)) {
                    p.consume(TokenType.COLON, ErrorCode.MISSING_COLON)
                }
                else if(p.check(TokenType.EQUALS)) {
                    p.consume(TokenType.EQUALS, ErrorCode.MISSING_EQUALS)
                }
                else {
                    p.errorAtToken(p.peek(), ErrorCode.MISSING_COLON)
                    goto err;
                }
            }

            arg.argExpr = p.expression()
            if(arg.argExpr.kind == StmtKind.POISON_EXPR) {
                goto err
            }

            arguments.add(arg)
        }
        while(p.match(TokenType.COMMA))
    }

    if(!p.consume(TokenType.RIGHT_PAREN, ErrorCode.MISSING_RIGHT_PAREN)) {
        goto err;
    }

    return true

err:
    return false
}


func (p: *Parser) genericParameters(arguments: *Array<GenericParam>) : bool {
    if(!p.check(TokenType.GREATER_THAN)) {
        arguments.init(2, p.allocator)

        do {
            var typeName = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
            if(!typeName) {
                goto err;
            }

            var name = Identifier {
                .str = p.strings.internStringView(typeName.value.str),
                .token = *typeName
            }

            arguments.add(GenericParam {
                .name = name
            })
        }
        while(p.match(TokenType.COMMA))
    }

    if(!p.consume(TokenType.GREATER_THAN, ErrorCode.MISSING_GENERIC_END)) {
        goto err;
    }

    return true

err:
    return false
}

func (p: *Parser) genericArguments() : Array<*TypeSpec> {
    var arguments = Array<*TypeSpec>{}
    if(!p.check(TokenType.GREATER_THAN)) {
        arguments.init(2, p.allocator)

        do {
            var type = p.type(false)

            // we've failed for parse a type
            if(!type) {
                return arguments
            }

            arguments.add(type)
        }
        while(p.match(TokenType.COMMA))
    }

    p.consume(TokenType.GREATER_THAN, ErrorCode.MISSING_GENERIC_END)
    return arguments
}

func (p: *Parser) tryGenericArguments(disambiguate: bool) : Array<*TypeSpec> {
    p.tryLevel += 1
    defer p.tryLevel -= 1

    var backtrack = p.current
    var numOfErrors = p.tryErrorCounter

    p.advance()

    var arguments = p.genericArguments()
    var isFailed = false

    if(p.tryErrorCounter == numOfErrors) {
        if(disambiguate) {
            var token = p.peek()
            switch(token.type) {
                case TokenType.LEFT_PAREN:
                case TokenType.RIGHT_PAREN:
                case TokenType.RIGHT_BRACKET:
                case TokenType.LEFT_BRACE:
                case TokenType.RIGHT_BRACE:
                case TokenType.COLON:
                case TokenType.SEMICOLON:
                case TokenType.COMMA:
                case TokenType.DOT:
                case TokenType.QUESTION_MARK:
                case TokenType.EQUALS_EQUALS:
                case TokenType.NOT_EQUALS:
                case TokenType.OR:
                case TokenType.XOR:
                case TokenType.STAR:
                    return arguments;
                default: {
                    isFailed = true;
                    break;
                }
            }
        }
    }

    if(p.tryErrorCounter > numOfErrors || isFailed) {
        p.rewindTo(backtrack, numOfErrors)
        isFailed = true;
    }

    if(isFailed) {
        for(var i = 0; i < arguments.size(); i += 1) {
            var type = arguments.get(i)
            p.allocator.free(type)
        }
        arguments.free()
        arguments.clear()
    }

    return arguments
}

func (p: *Parser) arrayArguments(arguments: *Array<*Expr>) : bool {
    arguments.init(16, p.allocator)
    do {
        if(p.check(TokenType.RIGHT_BRACE)) {
            break;
        }

        var expr: *Expr = null
        if(p.check(TokenType.LEFT_BRACKET)) {
            expr = p.tryArrayDesignationExpr()
        }

        if(!expr) {
            expr = p.expression()
        }

        arguments.add(expr)
    }
    while(p.match(TokenType.COMMA))

    if(!p.consume(TokenType.RIGHT_BRACE, ErrorCode.MISSING_RIGHT_BRACE)) {
        goto err;
    }

    return true

err:
    return false
}

func (p: *Parser) tryArrayDesignationExpr() : *Expr {
    p.tryLevel += 1
    defer p.tryLevel -= 1

    var backtrack = p.current
    var numOfErrors = p.tryErrorCounter
    var pos = p.pos()

    var designatorExpr: *Expr = null
    if(p.match(TokenType.LEFT_BRACKET)) {
        var index = p.expression()
        p.consume(TokenType.RIGHT_BRACKET, ErrorCode.MISSING_RIGHT_BRACKET)
        p.consume(TokenType.EQUALS, ErrorCode.MISSING_EQUALS)
        var value = p.expression()

        if(p.tryErrorCounter == numOfErrors) {
            designatorExpr = NewArrayDesignationExpr(pos, p.pos(), index, value, p.allocator)
        }
        else {
            p.allocator.free(index)
            p.allocator.free(value)
        }
    }

    if(p.tryErrorCounter > numOfErrors) {
        p.rewindTo(backtrack, numOfErrors)
    }

    return designatorExpr
}

func (p: *Parser) fieldStatement(aggKind: StmtKind) : FieldStmt {
    var pos = p.pos()
    var notes = Array<*NoteStmt>{}
    if(!p.notes(&notes)) {
        goto err;
    }

    var isTrait  = aggKind == StmtKind.TRAIT_DECL
    if(isTrait) {
        var identifier = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
        if(!identifier) {
            goto err;
        }

        var fieldName = Identifier {
            .str = p.strings.internStringView(identifier.value.str),
            .token = *identifier
        }

        if(!p.consume(TokenType.COLON, ErrorCode.MISSING_COLON)) {
            goto err;
        }

        var attributes = Attributes{}
        attributes.notes = notes

        var type = p.type()
        if(!type) {
            goto err;
        }

        if(type.kind != TypeSpecKind.FUNC_PTR) {
            p.errorAtToken(p.previous(), ErrorCode.INVALID_TRAIT_MEMBER)
            goto err;
        }

        var traitField = NewTraitFieldDecl(pos, p.pos(), fieldName, type, attributes, p.allocator);
        return FieldStmt {
            .kind = StmtKind.TRAIT_FIELD_DECL,
            .traitField = traitField as (*TraitFieldDecl)
        }
    }
    else {
        var isStruct = aggKind == StmtKind.STRUCT_DECL

        switch(p.peek().type) {
            case TokenType.IDENTIFIER: {
                var identifier = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
                if(!identifier) {
                    goto err;
                }

                var fieldName = Identifier {
                    .str = p.strings.internStringView(identifier.value.str),
                    .token = *identifier
                }

                if(!p.consume(TokenType.COLON, ErrorCode.MISSING_COLON)) {
                    goto err;
                }

                var attributes = Attributes{}
                attributes.isUsing = p.match(TokenType.USING)
                attributes.notes = notes

                var defaultExpr: *Expr = null
                var type = p.type()
                if(!type) {
                    goto err;
                }

                if(p.match(TokenType.EQUALS)) {
                    if(!isStruct) {
                        p.errorAtToken(p.previous(), ErrorCode.INVALID_DEFAULT_ASSIGNMENT)
                        goto err;
                    }

                    defaultExpr = p.constExpression()
                }

                var varField = NewVarFieldDecl(pos, p.pos(), fieldName, type, attributes, defaultExpr, p.allocator);
                return FieldStmt {
                    .kind = StmtKind.VAR_FIELD_DECL,
                    .varField = varField as (*VarFieldDecl)
                }
            }
            case TokenType.STRUCT: {
                p.advance()
                var structField = p.structDeclaration()
                structField.startPos = pos
                structField.attributes.notes = notes
                return FieldStmt {
                    .kind = StmtKind.STRUCT_FIELD_DECL,
                    .aggregateField = structField as (*AggregateDecl)
                }
            }
            case TokenType.UNION: {
                p.advance()
                var unionField = p.unionDeclaration()
                unionField.startPos = pos
                unionField.attributes.notes = notes
                return FieldStmt {
                    .kind = StmtKind.UNION_FIELD_DECL,
                    .aggregateField = unionField as (*AggregateDecl)
                }
            }
            case TokenType.ENUM: {
                p.advance()
                var enumField = p.enumDeclaration()
                enumField.startPos = pos
                enumField.attributes.notes = notes
                return FieldStmt {
                    .kind = StmtKind.ENUM_FIELD_DECL,
                    .enumField = enumField as (*EnumDecl)
                }
            }
            default: {
                p.errorAtToken(p.peek(), ErrorCode.INVALID_FIELD)
                p.advance()
                goto err;
            }
        }
    }

err:
    return FieldStmt {
        .kind = StmtKind.POISON_EXPR
    }
}

func (p: *Parser) noteFieldStatement() : FieldStmt {
    var pos = p.pos()

    var identifier = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
    if(!identifier) {
        goto err;
    }

    var fieldName = Identifier {
        .str = p.strings.internStringView(identifier.value.str),
        .token = *identifier
    }

    if(!p.consume(TokenType.COLON, ErrorCode.MISSING_COLON)) {
        goto err;
    }

    var attributes = Attributes{}
    var defaultExpr: *Expr = null

    var type = p.type()
    if(!type) {
        goto err;
    }

    if(p.match(TokenType.EQUALS)) {
        defaultExpr = p.constExpression()
    }

    var varField = NewVarFieldDecl(pos, p.pos(), fieldName, type, attributes, defaultExpr, p.allocator);
    return FieldStmt {
        .kind = StmtKind.VAR_FIELD_DECL,
        .varField = varField as (*VarFieldDecl)
    }

err:
    return FieldStmt {
        .kind = StmtKind.POISON_EXPR
    }
}



func (p: *Parser) enumFieldEntryDecl() : *EnumFieldEntryDecl {
    var pos = p.pos()
    var notes = Array<*NoteStmt>{}
    if(!p.notes(&notes)) {
        goto err;
    }

    var identifier = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
    if(!identifier) {
        goto err;
    }

    var fieldName = Identifier {
        .str = p.strings.internStringView(identifier.value.str),
        .token = *identifier
    }

    var value: *Expr = null
    if(p.match(TokenType.EQUALS)) {
        value = p.constExpression()
    }

    var attributes = Attributes {
        .notes = notes
    }

    return NewEnumFieldEntryDecl(pos, p.pos(), fieldName, value, attributes, p.allocator) as (*EnumFieldEntryDecl)

err:
    return null
}

func (p: *Parser) rewindTo(backtrack: i32, numOfErrors: u64) {
    assert(p.tryErrorCounter >= numOfErrors)
    {
        // rewind the parser and errors
        p.current = backtrack
        p.tryErrorCounter = numOfErrors

        /*
        for(var i = p.numOfErrors() - 1; i >= numOfErrors; i -= 1) {
            var error = p.result.errors.removeAt(i)
            p.allocator.free(error.message as (*void))
        }*/
    }
}

// account for generics, we must peek ahead to see if
// this is a bit shift operator or generics
func (p: *Parser) tryBitShiftRight(expr: *Expr) : *Expr {

    if(!p.check(TokenType.GREATER_THAN)) {
        return null
    }

    var prevToken = p.advancep()
    if(!p.check(TokenType.GREATER_THAN)) {
        p.rewind()
        return null
    }

    var nextToken = p.advancep()
    if((nextToken.pos.position - prevToken.pos.position) == 1) {
        var right = p.term()
        return NewBinaryExpr(expr.startPos, p.pos(), expr, TokenType.RSHIFT, right, p.allocator)
    }

    // this wasn't a bit shift attempt, abort!
    p.rewind()
    p.rewind()
    return null
}

func (p: *Parser) eatSemicolon() {
    p.match(TokenType.SEMICOLON)
}

func (p: *Parser) identifier() : Token {
    var name = Token {
        .type = TokenType.ERROR
    }
    var identifier = p.consume(TokenType.IDENTIFIER, ErrorCode.MISSING_IDENTIFIER)
    if(identifier) {
        name = *identifier
    }

    return name
}

func (p: *Parser) checkConstExpr(expr: *Expr) : bool {
    if(!expr) {
        return false;
    }

    switch(expr.kind) {
        case StmtKind.NUMBER_EXPR:
        case StmtKind.BOOLEAN_EXPR:
        case StmtKind.STRING_EXPR:
        case StmtKind.CHAR_EXPR:
        case StmtKind.NULL_EXPR:
        case StmtKind.IDENTIFIER_EXPR:
        case StmtKind.GET_EXPR: {
            return true
        }
        case StmtKind.ARRAY_INIT_EXPR: {
            var arrayInitExpr = expr as (*ArrayInitExpr)
            for(var i = 0; i < arrayInitExpr.values.size(); i+=1) {
                var arg = arrayInitExpr.values.get(i)
                if(!p.checkConstExpr(arg)) {
                    return false
                }
            }
            return true
        }
        case StmtKind.GROUP_EXPR: {
            var groupExpr = expr as (*GroupExpr)
            return p.checkConstExpr(groupExpr.groupedExpr)
        }
        case StmtKind.BINARY_EXPR: {
            var binExpr = expr as (*BinaryExpr)
            return p.checkConstExpr(binExpr.left) &&
                   p.checkConstExpr(binExpr.right)
        }
        case StmtKind.UNARY_EXPR: {
            var unaryExpr = expr as (*UnaryExpr)
            return p.checkConstExpr(unaryExpr.unaryExpr)
        }
        case StmtKind.TYPE_OF_EXPR:
        case StmtKind.SIZE_OF_EXPR:
            return true;
        default: {
            p.errorAtPos(expr.startPos, ErrorCode.INVALID_CONST_EXPR)
        }
    }
    return false
}

func (p: *Parser) poisonStatement(pos: SrcPos) : *Stmt {
    return NewPoisonExpr(pos, p.pos(), p.allocator) as (*Stmt)
}

func (p: *Parser) poisonExpr(pos: SrcPos) : *Expr {
    return NewPoisonExpr(p.prevPos(), p.pos(), p.allocator)
}

func (p: *Parser) poisonDecl(pos: SrcPos) : *Decl {
    return NewPoisonDecl(pos, p.pos(), p.allocator)
}

@inline
func (p: *Parser) pos() : SrcPos {
    return p.tokens.elements[p.current].pos
    /*
    if(!p.atEnd()) {
        return p.peek().pos
    }

    if(p.tokens.empty()) {
        return SrcPos{}
    }

    return p.tokens.last().pos*/
}

func (p: *Parser) prevPos() : SrcPos {
    return p.previous().pos
}

@inline
func (p: *Parser) peek() : *Token {
    /*assert(p.current >= 0 && p.current <= p.tokens.size())
    if(p.current >= p.tokens.size()) {
        return &p.tokens.elements[p.tokens.size() - 1]
    }*/
    return &p.tokens.elements[p.current]
}

func (p: *Parser) rewind() {
    p.current -= 1
    if(p.current < 0) {
        p.current = 0
    }
}

func (p: *Parser) previous() : *Token {
    var index = p.current - 1;
    assert(index < p.tokens.size() && index >= 0)
    return &p.tokens.elements[index]
}

func (p: *Parser) atEnd() : bool {
    // the usual case -- fast check
    if(p.current < p.tokens.size() - 1) {
        return false
    }

    assert(!p.tokens.empty())

    return p.current >= p.tokens.size() ||
           p.peek().type == TokenType.END_OF_FILE
}

func (p: *Parser) advance() {
    if(!p.atEnd()) {
        p.current += 1
    }
}

func (p: *Parser) advancep() : *Token {
    if(!p.atEnd()) {
        p.current += 1
    }
    return p.previous()
}

@inline
func (p: *Parser) check(type: TokenType) : bool {
    var token = p.peek()
    assert(token != null)

    return token.type == type
}

func (p: *Parser) match(type: TokenType) : bool {
    if(p.check(type)) {
        p.advance()
        return true
    }
    return false
}

func (p: *Parser) matches(types: *TokenType, len: i32) : bool {
    var tokenType = p.peek().type
    for(var i = 0; i < len; i += 1) {
        var type = types[i]
        if(tokenType == type) {
            p.advance()
            return true
        }
    }
    return false
}

func (p: *Parser) consume(type: TokenType, errorCode: ErrorCode) : *Token {
    if(p.check(type)) {
        return p.advancep()
    }

    p.errorUnexpectedToken(p.peek(), errorCode)
    return null
}

func (p: *Parser) adjust(types: *TokenType = null, len: i32 = 0) {
    p.panicMode = false

    if(!types || len < 1) {
        p.advance()
        return;
    }

    while(!p.atEnd()) {
        var type = p.peek().type
        for(var i = 0; i < len; i+=1) {
            if(types[i] == type) {
                return;
            }
        }

        p.advance()
    }
}

func (p: *Parser) errorAtToken(token: *Token, errorCode: ErrorCode) {
    if(!token) {
        p.errorAtPos(p.pos(), errorCode)
    }
    else {
        p.errorAtPos(token.pos, errorCode)
    }

}

// TODO: Refactor this into one function
func (p: *Parser) errorAtPos(pos: SrcPos, errorCode: ErrorCode) {
    defer p.advance()

    if(p.tryLevel > 0) {
        p.tryErrorCounter += 1
        return;
    }

    if(p.panicMode) {
        return;
    }
    p.panicMode = true
    p.result.addError(pos, "%s", errorCodeText[errorCode])
}


func (p: *Parser) errorUnexpectedToken(token: *Token, errorCode: ErrorCode) {
    if(token) {
        defer p.advance()

        if(p.tryLevel > 0) {
            p.tryErrorCounter += 1
            return;
        }

        if(p.panicMode) {
            return;
        }

        p.panicMode = true
        //Error("Current index: %d out of %d\n", p.current, p.tokens.size())
        p.result.addError(p.pos(), "Unexpected token: '%s' - %s", tokenText[token.type], errorCodeText[errorCode])
    }
    else {
        p.errorAtPos(p.pos(), errorCode)
    }
}

func (p: *Parser) numOfErrors() : i32 {
    return p.result.errors.size()
}