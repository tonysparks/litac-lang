/**
    The LitaC Package Manager

    This aims to be the simplest solution to address using third party packages.

    Goals:
    1) Make it 'easy' to use 3rd party authored packages within a LitaC project
    2) Make it 'easy' to author a package
    3) Make it as secure as possible knowing this system is about sharing code from
       3rd parties


    Approach:
    * What is a Package?
        A package is a set of litac modules (.lita source files) and associated files that form a logical
        and physical grouping of code that can be re-used by other LitaC packages and
        applications.

        Example project folder structure

        .pkgs/    // stores packages this project depends on
        bin/          // stores the binary output of compilation
        lib/          // stores static libraries
        src/          // stores LitaC code
        pkg.json  // defines this projects package and dependencies

        A package is uniquely defined by these properties:
            * Package Repo - the repository in which the package is hosted.  Example github.com/tonysparks/my-package
            * Package Name - the name of the package
            * Package Version - the version of the package

    * Allow package authors to define their package and any packages they may depend on
        This will just be a simply JSON file and no CLI for creating said JSON file will be
        available.  These are programmers, they can edit/create it themselves.

        Proposed format:

        package.json
        {
            // We have two options here:
            // 1) specify the repository in which this resides in
            // 2) give it a group name (akin to Maven group/artifact)
            // With #1, you are essentially hardcoding "where" to retrieve this
            // package.  Although, we could proxy the repos
            // With #2, it decouples the 'where' with the actual package itself.
            // For simplicity, we'll go with #1 for now...
            "repo": "github.com/tonysparks",
            "name": "c2litac",
            "version": "0.2.1",
            "dependencies": [
                {
                    "repo": "github.com/tonysparks",
                    "name": "example",
                    "version": "0.1.9", // for now, always require a specific version
                                        // I don't want to play the SemVer game and rely
                                        // on developers adhering to it.  Sometimes nice,
                                        // I'm not the biggest fan of allowing the 'latest'
                                        // of a particular major.minor dependency.  I want
                                        // to be specfic in the version I'm using.
                }
            ]
        }
    * Packages may be downloaded from an HTTPS endpoint (other protocols may be supported)
        We'll need the package manager to be able to construct a valid URL to download the
        specific version.

        For instance, github is:
            https://github.com/USERNAME/REPOSITORY/archive/TAGNAME.zip

        We should (eventually) allow for a templated repository configuration to allow arbitrary
        repositories.

        Something like:

        https://{PACKAGE_REPO}/{PACKAGE_NAME}/archive/{PACKAGE_VERSION}.zip

        Downloading packages should be done as an opt-in CLI option, such as:

        litac --pkg-sync

        Which would download packages defined in the 'dependencies' section
        into a .package hidden folder.


    Considerations:
    * Adding include (-I) and library paths (-L) for packages, this perhaps could be in the package.json??
    * Adding static libraries (-l) -- ditto
    * Specifying library type (static/dynamic) of Package
*/
import "std/http"
import "std/mem"
import "std/map"
import "std/hash"
import "std/array"
import "std/libc"
import "std/io"
import "std/system"
import "std/string/buffer"
import "std/assert"
import "std/string/builder"
import "std/string"
import "std/terminal"

import "pkg_mgr/pkg"
import "pkg_mgr/pkg_install"
import "pkg_mgr/pkg_build"
import "pkg_mgr/pkg_run"
import "pkg_mgr/pkg_init"
import "pkg_mgr/pkg_test"

import "build"
import "lita"
import "main"

public struct PackageOptions {
    projectPath: *const char
    pkgDir: *const char = ".pkgs"       // the .pkgs directory
    litaOptions: *LitaOptions
}


public struct PackageInitOptions {
    name: *const char
    version: *const char = "0.0.1"
    type: *const char = "executable"
    repo: *const char = ""
}

public struct PackageBuildOptions {
    isRelease: bool = false
}

public struct PackageInstallOptions {
    fullSync: bool = false              // force a full download of all packages
    httpOptions: HttpOptions            // http options
}

@asStr
public enum PkgStatus {
    OK = 0,
    ERROR_NO_PROJECT_PKG_FOUND,
    ERROR_COMMAND_NOT_DEFINED,
    ERROR_RUNNING_COMMAND,
    ERROR_CREATING_PKG_DIR,
    ERROR_CLEANING_PKG,
    ERROR_UNABLE_TO_OPEN_FILE,
    ERROR_UNABLE_TO_OPEN_PKG_FILE,
    ERROR_UNABLE_TO_EXTRACT_PKG_FILE,
    ERROR_UNABLE_TO_PROCESS_PKG_FILE,
    ERROR_OPENING_LOCAL_FILE_PKG,
    ERROR_READING_LOCAL_FILE_PKG,
    ERROR_WRITING_LOCAL_FILE_PKG,
    ERROR_OPENING_BUILD_FILE,
    ERROR_WRITING_BUILD_FILE,
    ERROR_FINALIZING_LOCAL_FILE_PKG,
    ERROR_PARSING_PKG_JSON,
    ERROR_READING_PKG_FILE,
    ERROR_HTTP_STATUS,
    ERROR_INVALID_DIRECTORY,
    ERROR_INVALID_REPO,
    ERROR_INIT_PACKAGE,
    ERROR_PARSING_BUILD_OPTIONS,
    ERROR_INVALID_BUILD_TARGET,
    ERROR_INVALID_BUILD_OS,
    ERROR_INVALID_BUILD_ARCH,

    ERROR_TEST_SUITE_FAILED,
}

public struct PackageManager {
    options: PackageOptions
    allocator: *const Allocator

    packages: Map<*const char, *PackageDef>
    pkg: *PackageDef   // this projects package definition

    errors: StringBuilder
    warnings: StringBuilder
}

public func (this: *PackageManager) init(
    options: PackageOptions,
    allocator: *const Allocator = defaultAllocator) {

    this.options = options
    this.allocator = allocator
    this.packages = StrMap<*PackageDef>(null, 32, allocator)
    this.errors = StringBuilderInit(128, allocator)
    this.warnings = StringBuilderInit(128, allocator)
}


public func (this: *PackageManager) free() {
    for(var it = this.packages.iter(); it.hasNext();) {
        var n = it.next()
        if(n.value) {
            n.value.free()
            this.allocator.free(n.value)
        }
    }

    this.packages.free()
    this.errors.free()
    this.warnings.free()
    this.pkg = null
}

internal func (this: *PackageManager) isVerbose(): bool {
    return this.options.litaOptions.isVerbose
}

func (this: *PackageManager) printMessages() {
    if(this.warnings.length > 0) {
        printf(
            "%swarning%s: %s\n",
            ConsoleColorsAsStr(ConsoleColors.YELLOW),
            ConsoleColorsAsStr(ConsoleColors.CLEAR),
            this.warnings.cStr()
        )
    }

    if(this.errors.length > 0) {
        printf("%serror%s: %s\n",
            ConsoleColorsAsStr(ConsoleColors.RED),
            ConsoleColorsAsStr(ConsoleColors.CLEAR),
            this.errors.cStr()
        )
    }
}

@doc("""
    Initializes a new LitaC project, writing out scaffolding files
""")
public func (this: *PackageManager) initCommand(options: PackageInitOptions) : PkgStatus {
    defer this.printMessages()
    return PackageInit(this, options)
}

@doc("""
    Initializes a new LitaC project, writing out scaffolding files
""")
public func (this: *PackageManager) buildCommand(
    options: PackageBuildOptions
) : PkgStatus {
    defer this.printMessages()

    var litaOptions = this.options.litaOptions
    // See if we're running the build command for a non-pkg
    // source file
    if (!this.hasProjectPkg()) {
        if(litaOptions.inputFile.empty()) {
            this.errors.append(
                "Missing an input file.  Either create a 'pkg.json' project package file (via the 'init' command) or supply a .lita source file."
            )
            return 1;
        }
        return RunLitac(litaOptions)
    }

    var status = this.readProjectPkg()
    if(status != PkgStatus.OK) {
        return status;
    }

    return PackageBuild(this, options)
}

@doc("""
    Installs all packages defined the pkg.json to the file system.
""")
public func (this: *PackageManager) installCommand(options: PackageInstallOptions) : PkgStatus {
    defer this.printMessages()

    var status = this.readProjectPkg()
    if(status != PkgStatus.OK) {
        return status;
    }

    if(this.isVerbose()) {
        printf("Found '%s/pkg.json' with %d package dependencies.\n",
            this.options.projectPath,
            this.pkg.dependencies.size()
        )

        if(!this.pkg.dependencies.empty()) {
            for(var i = 0; i < this.pkg.dependencies.size(); i+=1) {
                var dep = this.pkg.dependencies.getPtr(i)
                printf("Will install '%s'\n", dep.pkgId.id)
            }
        }
    }

    status = PackageInstall(this, options)
    if(status != PkgStatus.OK) {
        return status
    }

    return this.writeBuildFile()
}

@doc("""
    Updates the build.json file with any dependent package information.  This
    should be called after a sync is made.
""")
public func (this: *PackageManager) createBuildFile(buildFile: *BuildFile) : PkgStatus {
    buildFile.init(this.allocator)

    var projectPath = this.options.projectPath.toString()
    var len = projectPath.length

    for(var it = this.packages.iter(); it.hasNext();) {
        var entry = it.next()

        // TODO: Update all of the other's, include,library,staticLibs, etc.
        var fullPkgPath = StringInit(entry.value.path)
        if(fullPkgPath.startsWith(projectPath)) {
            fullPkgPath = fullPkgPath.substring(.start = len, .end = -1)
        }

        buildFile.pkgPaths.add(StringClone(fullPkgPath.buffer, fullPkgPath.length, this.allocator))
    }
    return PkgStatus.OK
}

public func (this: *PackageManager) writeBuildFile() : PkgStatus {
    var buildFile = BuildFile{}
    defer buildFile.free()

    var status = this.createBuildFile(&buildFile)
    if(status != PkgStatus.OK) {
        return status;
    }

    var temp: [MAX_PATH]char;
    var build = StringBufferInit(temp, MAX_PATH, 0)
    build.format("%s/.build.json", this.options.projectPath)

    var file = File{}
    defer file.close()
    if(file.open(build.cStr(), FileOpenOp.WRITE) != FileStatus.Ok) {
        this.errors.append(
            "unable to open '%s' for writing",
            build.cStr()
        )
        return PkgStatus.ERROR_OPENING_BUILD_FILE
    }

    if(!buildFile.writeTo(&file)) {
        this.errors.append(
            "unable to write to '%s'",
            build.cStr()
        )
        return PkgStatus.ERROR_WRITING_BUILD_FILE
    }

    return PkgStatus.OK
}

@doc("""
    Run a command from the pkg.json:commands[{argument}]
""")
public func (this: *PackageManager) runCommand(cmd: *const char) : PkgStatus {
    defer this.printMessages()

    var status = this.readProjectPkg()
    if(status != PkgStatus.OK) {
        return status;
    }

    return PackageRun(this, cmd)
}

@doc("""
    Recursively scan directory for *_test.lita files and run each test file.
""")
public func (this: *PackageManager) testCommand(options: *LitaOptions) : i32 {
    defer this.printMessages()
    return PackageTest(this, options)
}

public func (this: *PackageManager) hasProjectPkg(): bool {
    // HACK: clean this up... this relies on backtracking
    // on state...
    var errorCount = this.errors.length
    defer this.errors.length = errorCount

    return this.readProjectPkg() == PkgStatus.OK
}
func (this: *PackageManager) readProjectPkg() : PkgStatus {
    var temp:[MAX_PATH]char;

    var pkgDef = StringBufferInit(temp, MAX_PATH, 0)
    pkgDef.format("%s/pkg.json", this.options.projectPath)

    if(!FileExists(pkgDef.cStr())) {
        this.errors.append(
            "could not find 'pkg.json' in '%s'\n",
            this.options.projectPath
        )
        return PkgStatus.ERROR_NO_PROJECT_PKG_FOUND
    }

    if(ParsePackageFile(this, pkgDef.cStr(), &this.pkg) != PkgStatus.OK) {
        this.errors.append("could not parse pkg.json\n")
        return PkgStatus.ERROR_PARSING_PKG_JSON;
    }

    // TODO: Get the actual /src directory -- this can be taken off of
    // LitaOptions..
    var pkgPath = StringBufferInit(this.pkg.path, MAX_PATH, pkgDef.length)
    pkgPath.format("%s/src", this.options.projectPath)
    pkgPath.cStr()

    return PkgStatus.OK
}
/*
@test
func testPackageManagerSync() {
    var pm: PackageManager{}
    pm.init(PackageOptions{})
    defer pm.free()

    var status = pm.install()
    assert(status == PkgStatus.OK)
    // printf("Status: %s\n", PkgStatusAsStr(status))

    var buildFile: BuildFile{}
    defer buildFile.free()

    status = pm.createBuildFile(&buildFile)
    assert(status == PkgStatus.OK)

    assert(buildFile.pkgPaths.size() == 2)
    assert(strcmp(buildFile.pkgPaths.get(0), "C:/Users/antho/git/litac-lang/bin/output/src") == 0)
    assert(strcmp(buildFile.pkgPaths.get(1), "C:/Users/antho/git/litac-lang/bin/output/.pkgs/test-pkg/1.0/test-pkg-1.0/src") == 0)

}*/