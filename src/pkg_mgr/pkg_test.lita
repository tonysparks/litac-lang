import "std/fs"
import "std/io"
import "std/string"
import "std/string/builder"
import "std/string/buffer"
import "std/array"
import "std/process" as sub
import "std/system"
import "std/libc"
import "std/mem"
import "std/terminal"

import "pkg_mgr"
import "lita"

public func PackageTest(pm: *PackageManager, options: *LitaOptions) : PkgStatus {
    var startTime = SystemTimeMSec()

    var allFiles = ArrayInit<String>(64, pm.allocator)

    // look in the src folder
    {
        var scanDirBuf = [MAX_PATH]char{0}
        var scanDirStr = StringBufferInit(scanDirBuf, MAX_PATH, 0)
        scanDirStr.format("%s/src", options.projectPath)

        var status = FindTestFiles(scanDirStr.toString(), &allFiles, pm.allocator)
        if(status != PkgStatus.OK) return status
    }
    // look in the test folder
    {
        var scanDirBuf = [MAX_PATH]char{0}
        var scanDirStr = StringBufferInit(scanDirBuf, MAX_PATH, 0)
        scanDirStr.format("%s/test", options.projectPath)

        var status = FindTestFiles(scanDirStr.toString(), &allFiles, pm.allocator)
        if(status != PkgStatus.OK) return status
    }

    var testPaths = ArrayInit<*char>(allFiles.size(), pm.allocator)

    var suffix = $"_test.lita"
    for(var i = 0; i < allFiles.size(); i += 1) {
        var path = allFiles.get(i)
        if(path.endsWith(suffix)) {
            var c = path.toCStr(pm.allocator)
            if(c) {
                testPaths.add(c)
            }
        }
    }

    if(testPaths.empty()) {
        return PkgStatus.OK
    }

    var testPackage = $""
    var buffer = [MAX_PATH]char{0}
    if(options.testPackage != null) {
        var bufferStr = StringBufferInit(buffer, MAX_PATH, 0)
        bufferStr.format("%s/%s", options.projectPath, options.testPackage)
        testPackage = bufferStr.toString()
    }

    var failed = 0
    var successful = 0

    for(var i = 0; i < testPaths.size(); i += 1) {
        var path = testPaths.get(i)

        if(!testPackage.empty()) {
            var pathStr = path.toString()

            if(!pathStr.startsWith(testPackage)) {
                continue
            }
        }

        printf("Running '%s'\n", path)

        var cmd = StringBuilderInit(256, pm.allocator)
        cmd.append(
            "cd %s && litac test",
            options.projectPath
        )

        if(options.testsRegex != null) {
            cmd.append(" -regex \"%s\"", options.testsRegex)
        }

        cmd.append(
            " -file \"%s\"",
            path
        )

        var result = system(cmd.cStr())
        if(result != 0) {
            printf(
                "Test %s %sfailed%s with exit code %d\n",
                path,
                ConsoleColorsAsStr(ConsoleColors.RED),
                ConsoleColorsAsStr(ConsoleColors.CLEAR),
                result
            )
            failed += 1
        } else {
            successful += 1
        }
    }

    var totalTime = SystemTimeMSec() - startTime

    printf(
        "%d test file(s) ran in %.3f seconds\n",
        successful,
        totalTime
    )

    printf(
        "%d/%d test file(s) %spassed%s ✅\n",
        successful,
        successful+failed,
        ConsoleColorsAsStr(ConsoleColors.GREEN),
        ConsoleColorsAsStr(ConsoleColors.CLEAR)
    )

    if(failed > 0) {
        printf(
            "%d test file(s) %sfailed%s ❌\n",
            failed,
            ConsoleColorsAsStr(ConsoleColors.RED),
            ConsoleColorsAsStr(ConsoleColors.CLEAR)
        )
        return PkgStatus.ERROR_TEST_SUITE_FAILED
    }

    return PkgStatus.OK
}

func FindTestFiles(scanDirStr: String, allFiles: *Array<String>, allocator: *const Allocator):PkgStatus {
    var status = ListFiles(scanDirStr, allFiles, ListFileFlags.RECURSE_DIRECTORIES, allocator)
    if(status != FileStatus.Ok) {
        printf(
            "Could not scan directory '%.*s', error: %s\n",
            scanDirStr.length, scanDirStr.buffer,
            FileStatusAsStr(status)
        )
        return PkgStatus.ERROR_INVALID_DIRECTORY
    }
    return PkgStatus.OK
}
