import "std/fs"
import "std/io"
import "std/string"
import "std/string/builder"
import "std/string/buffer"
import "std/array"
import "std/process" as sub
import "std/system"
import "std/libc"
import "std/mem"

import "pkg_mgr"
import "lita"
import "error_codes"

public func PackageTest(pm: *PackageManager, options: *LitaOptions) : PkgStatus {
    var startTime = SystemTimeMSec()

    var allFiles = ArrayInit<String>(64, pm.allocator)

    // look in the src folder
    {
        var scanDirBuf = [MAX_PATH]char{0}
        var scanDirStr = StringBufferInit(scanDirBuf, MAX_PATH, 0)
        scanDirStr.format("%s/src", options.projectPath)

        var status = FindTestFiles(scanDirStr.toString(), &allFiles, pm.allocator)
        if(status != PkgStatus.OK) return status
    }
    // look in the test folder
    {
        var scanDirBuf = [MAX_PATH]char{0}
        var scanDirStr = StringBufferInit(scanDirBuf, MAX_PATH, 0)
        scanDirStr.format("%s/test", options.projectPath)

        var status = FindTestFiles(scanDirStr.toString(), &allFiles, pm.allocator)
        if(status != PkgStatus.OK) return status
    }

    var testPaths = ArrayInit<*char>(allFiles.size(), pm.allocator)

    var suffix = $"_test.lita"
    for(var i = 0; i < allFiles.size(); i += 1) {
        var path = allFiles.get(i)
        if(path.endsWith(suffix)) {
            var c = path.toCStr(pm.allocator)
            if(c) {
                testPaths.add(c)
            }
        }
    }

    if(testPaths.empty()) {
        return PkgStatus.OK
    }

    var failed = 0
    for(var i = 0; i < testPaths.size(); i += 1) {
        var path = testPaths.get(i)
        printf("pkg-test: running '%s'\n", path)

        var cmd = StringBuilderInit(256, pm.allocator)
        cmd.append(
            "cd %s && litac -colors -pkg-build -run -testFile %s",
            options.projectPath,
            path
        )
        var result = system(cmd.cStr())

/*
        var argv = ArrayInit<*const char>(16, pm.allocator)
        defer argv.free()
        argv.add("litac")
        argv.add("-colors")
        argv.add("-pkg-build")
        argv.add("-testFile")
        argv.add("-run")
        argv.add(path as (*const char))
        argv.add(null)

        var proc = sub::Process{}
        if(proc.create(argv.elements, null, sub::ProcessOption.COMBINE_STDOUT_STDERR | sub::ProcessOption.INHERIT_ENVIRONMENT) != 0) {
            printf("pkg-test: failed to run process for %s\n", path)
            failed += 1
            continue
        }
        defer proc.destroy()

        var result: i32 = 0
        proc.join(&result)
*/

        if(result != 0) {
            printf("pkg-test: %s failed with exit code %d\n", path, result)
            failed += 1
        }
    }

    var totalTime = SystemTimeMSec() - startTime

    printf(
        "pkg-test: %d test file(s) ran in %.3f seconds\n",
        testPaths.size(),
        totalTime
    )

    printf(
        "pkg-test: %d/%d test file(s) %spassed%s\n",
        testPaths.size()-failed,
        testPaths.size(),
        ConsoleColorsAsStr(ConsoleColors.GREEN),
        ConsoleColorsAsStr(ConsoleColors.CLEAR)
    )

    if(failed > 0) {
        printf(
            "pkg-test: %d test file(s) %sfailed%s\n",
            failed,
            ConsoleColorsAsStr(ConsoleColors.RED),
            ConsoleColorsAsStr(ConsoleColors.CLEAR)
        )
        return PkgStatus.ERROR_TEST_SUITE_FAILED
    }

    return PkgStatus.OK
}

func FindTestFiles(scanDirStr: String, allFiles: *Array<String>, allocator: *const Allocator):PkgStatus {
    var status = ListFiles(scanDirStr, allFiles, ListFileFlags.RECURSE_DIRECTORIES, allocator)
    if(status != FileStatus.Ok) {
        printf(
            "pkg-test: could not scan directory '%.*s', error: %s\n",
            scanDirStr.length, scanDirStr.buffer,
            FileStatusAsStr(status)
        )
        return PkgStatus.ERROR_INVALID_DIRECTORY
    }
    return PkgStatus.OK
}