import "std/array"
import "std/string/builder"
import "std/string"
import "std/mem"
import "std/libc"
import "std/json"
import "std/json/from_json"
import "std/json/to_json"

import "lex"
import "common"

@json
public enum ErrorType {
    WARN,
    ERROR
}

@json
public struct PhaseError {
    type: ErrorType
    message: *const char
    pos: SrcPos
}

@json
public struct PhaseResult {
    @json(.ignore = true)
    allocator: *const Allocator

    errors: Array<PhaseError>

    @json(.ignore = true)
    enabled: bool

    @json(.ignore = true)
    isReadable: bool
}

public func PhaseResultInit(allocator: *const Allocator) : PhaseResult {
    var result = PhaseResult {
        .allocator = allocator,
        .enabled = true,
        .isReadable = true
    }

    result.errors.init(16, allocator)
    return result
}

public func (r: *PhaseResult) addError(pos: SrcPos, format: *const char, ...) {
    var sb = StringBuilderInit(256, r.allocator)
    var args: va_list;
    va_start(args, format);
    sb.appendArgs(format, args)
    va_end(args)

    r.addErrorStr(pos, sb)
}

public func (r: *PhaseResult) addErrorStr(pos: SrcPos, sb: *StringBuilder) {
    if(!r.enabled) {
        return;
    }

    r.errors.add(PhaseError {
        .type = ErrorType.ERROR,
        .message = sb.cStr(),
        .pos = pos
    })
}

public func (r: *PhaseResult) hasErrors() : bool {
    return !r.errors.empty()
}

public func (r: *PhaseResult) clear() {
    r.errors.clear()
}
