import "std/mem"
import "std/array"
import "std/bucket_list"
import "std/string"
import "std/assert"

import "ast"
import "lex"
import "symbols"
import "types"
import "common"
import "module"
import "lita"
import "intern"


public struct TypeSpecAllocator {
    allocator: *const Allocator
    typeSpecs: BucketList<TypeSpec>
}

public func (this: *TypeSpecAllocator) init(allocator: *const Allocator) {
    this.allocator = allocator
    this.typeSpecs.init(1024, allocator)
}

public func (this: *TypeSpecAllocator) free() {
    this.typeSpecs.free()
}

public func (this: *TypeSpecAllocator) clear() {
    this.typeSpecs.clear()
}

public func (this: *TypeSpecAllocator) alloc() : *TypeSpec {
    this.typeSpecs.add(TypeSpec{})
    return this.typeSpecs.lastPtr()
}


public func NewVoidTypeSpec(pos: SrcPos, typeAllocator: *TypeSpecAllocator) : *TypeSpec {
    var voidSpec = NewTypeSpec(TypeSpecKind.NAME, pos, typeAllocator)
    voidSpec.name = VOID
    return voidSpec as (*TypeSpec)
}

public func NewNameTypeSpecIntern(pos: SrcPos, name: InternedString, typeAllocator: *TypeSpecAllocator) : *TypeSpec {
    var result = typeAllocator.alloc()
    result.kind = TypeSpecKind.NAME
    result.pos = pos
    result.base = null
    result.name = name
    result.genericArgs.init(0, typeAllocator.allocator)
    return result
}

public func NewTypeSpec(kind: TypeSpecKind, pos: SrcPos, typeAllocator: *TypeSpecAllocator) : *TypeSpec {
    switch(kind) {
        case TypeSpecKind.NONE: {
            var result = typeAllocator.alloc()
            result.kind = TypeSpecKind.NONE
            result.pos = pos
            result.base = null
            return result
        }
        case TypeSpecKind.ARRAY: {
            var result = typeAllocator.alloc()
            result.kind = TypeSpecKind.ARRAY
            result.pos = pos
            result.base = null
            result.numElements = null
            return result as (*TypeSpec)
        }
        case TypeSpecKind.PTR: {
            var result = typeAllocator.alloc()
            result.kind = TypeSpecKind.PTR
            result.pos = pos
            result.base = null
            return result as (*TypeSpec)
        }
        case TypeSpecKind.CONST: {
            var result = typeAllocator.alloc()
            result.kind = TypeSpecKind.CONST
            result.pos = pos
            result.base = null
            return result as (*TypeSpec)
        }
        case TypeSpecKind.NAME: {
            var result = typeAllocator.alloc()
            result.kind = TypeSpecKind.NAME
            result.pos = pos
            result.base = null
            result.name = EMPTY_STR
            result.genericArgs.init(0, typeAllocator.allocator)
            return result as (*TypeSpec)
        }
        case TypeSpecKind.FUNC_PTR: {
            var result = typeAllocator.alloc()
            result.kind = TypeSpecKind.FUNC_PTR
            result.pos = pos
            result.base = null
            result.args.init(0, typeAllocator.allocator)
            result.ret = null
            result.hasVarargs = false
            result.genericParams.init(0, typeAllocator.allocator)
            return result as (*TypeSpec)
        }
        default: {
            Panic("Invalid TypeSpecKind: '%d'\n", kind)
        }
    }

    return null
}

public func NewIdentifier(
    name: *const char,
    pos: SrcPos,
    strings: *Strings
) : Identifier {

    var str = strings.intern(name, name.length())
    var identifier = Identifier {
        .str = str,
        .token = Token {
            .type = TokenType.IDENTIFIER,
            .pos = pos,
            .value = Value {
                .str = str.view
            }
        }
    }
    return identifier
}

@inline
func NewNode(allocator: *const Allocator): *Node {
    // TODO: Create from array now that nodes are equal sized
    return new<Node>(allocator)
}

public func NewImportDecl(startPos: SrcPos,
                          endPos: SrcPos,
                          name: Identifier,
                          alias: Identifier,
                          isUsing: bool,
                          allocator: *const Allocator) : *Node {
    var decl = NewNode(allocator)
    decl.kind = StmtKind.IMPORT_DECL;
    decl.startPos = startPos
    decl.endPos = endPos

    decl.importDecl.name = name
    decl.importDecl.alias = alias
    decl.importDecl.isUsing = isUsing

    return decl
}

public func NewVarDecl(startPos: SrcPos,
                       endPos: SrcPos,
                       name: Identifier,
                       type: *TypeSpec,
                       expr: *Expr,
                       allocator: *const Allocator) : *Node {
    var decl = NewNode(allocator)
    decl.kind = StmtKind.VAR_DECL;
    decl.startPos = startPos
    decl.endPos = endPos

    decl.varDecl.name = name
    decl.varDecl.typeSpec = type
    decl.varDecl.expr = expr

    decl.varDecl.flags = 0
    decl.varDecl.scope = null

    return decl
}

public func NewFuncDecl(startPos: SrcPos,
                         endPos: SrcPos,
                         name: Identifier,
                         genericParams: Array<GenericParam>,
                         params: *ParametersStmt,
                         body: *Stmt,
                         returnType: *TypeSpec,
                         flags: i32,
                         allocator: *const Allocator) : *Node {
    var decl = NewNode(allocator)
    decl.kind = StmtKind.FUNC_DECL;
    decl.startPos = startPos
    decl.endPos = endPos

    decl.funcDecl.name = name
    decl.funcDecl.genericParams = genericParams
    decl.funcDecl.params = decl.becomeParentOf(params)
    decl.funcDecl.body = decl.becomeParentOf(body)
    decl.funcDecl.returnType = returnType
    decl.funcDecl.flags = flags

    return decl
}

public func NewAggregateDecl(startPos: SrcPos,
                      endPos: SrcPos,
                      kind: StmtKind,
                      name: Identifier,
                      genericParams: Array<GenericParam>,
                      fields: Array<FieldStmt>,
                      flags: i32,
                      allocator: *const Allocator) : *Node {
    var decl = NewNode(allocator)
    decl.kind = kind
    decl.startPos = startPos
    decl.endPos = endPos

    decl.aggDecl.name = name
    decl.aggDecl.genericParams = genericParams
    decl.aggDecl.fields = fields
    decl.aggDecl.flags = flags

    for(var i = 0; i < fields.size(); i += 1) {
        var field = fields.get(i)
        switch(field.kind) {
            case StmtKind.ENUM_FIELD_DECL: {
                decl.becomeParentOf(field.enumField)
                break
            }
            case StmtKind.UNION_FIELD_DECL:
            case StmtKind.STRUCT_FIELD_DECL: {
                decl.becomeParentOf(field.aggregateField)
                break
            }
            case StmtKind.TRAIT_FIELD_DECL: {
                decl.becomeParentOf(field.traitField)
                break
            }
            case StmtKind.VAR_FIELD_DECL: {
                decl.becomeParentOf(field.varField)
                break
            }
            case StmtKind.POISON_EXPR: {
                decl.becomeParentOf(field.poisonField)
                break;
            }
            default: {
                assert(false)
            }
        }
    }

    return decl
}

public func NewStructDecl(startPos: SrcPos,
                          endPos: SrcPos,
                          name: Identifier,
                          genericParams: Array<GenericParam>,
                          fields: Array<FieldStmt>,
                          flags: i32,
                          allocator: *const Allocator) : *Node {
    return NewAggregateDecl(startPos, endPos, StmtKind.STRUCT_DECL,
                                name, genericParams, fields, flags, allocator)
}

public func NewUnionDecl(startPos: SrcPos,
                         endPos: SrcPos,
                         name: Identifier,
                         genericParams: Array<GenericParam>,
                         fields: Array<FieldStmt>,
                         flags: i32,
                         allocator: *const Allocator) : *Node {

    return NewAggregateDecl(startPos, endPos, StmtKind.UNION_DECL,
                                name, genericParams, fields, flags, allocator)
}

public func NewTraitDecl(startPos: SrcPos,
                         endPos: SrcPos,
                         name: Identifier,
                         genericParams: Array<GenericParam>,
                         fields: Array<FieldStmt>,
                         flags: i32,
                         allocator: *const Allocator) : *Node {

    return NewAggregateDecl(startPos, endPos, StmtKind.TRAIT_DECL,
                                name, genericParams, fields, flags, allocator)
}

public func NewEnumDecl(startPos: SrcPos,
                         endPos: SrcPos,
                         name: Identifier,
                         fields: Array<*EnumFieldEntryDecl>,
                         allocator: *const Allocator) : *Node {
    var decl = NewNode(allocator)
    decl.kind = StmtKind.ENUM_DECL;
    decl.startPos = startPos
    decl.endPos = endPos
    decl.enumDecl.name = name
    decl.enumDecl.fields = *decl.becomeParentOfChildren(fields)

    return decl
}

public func NewTypedefDecl(startPos: SrcPos,
                         endPos: SrcPos,
                         name: Identifier,
                         genericParams: Array<GenericParam>,
                         type: *TypeSpec,
                         allocator: *const Allocator) : *Node {
    var decl = NewNode(allocator)
    decl.kind = StmtKind.TYPEDEF_DECL;
    decl.startPos = startPos
    decl.endPos = endPos
    decl.typedefDecl.name = name
    decl.typedefDecl.genericParams = genericParams
    decl.typedefDecl.type = type

    return decl
}


public func NewNoteDecl(startPos: SrcPos,
                        endPos: SrcPos,
                        name: Identifier,
                        fields: Array<FieldStmt>,
                        allocator: *const Allocator) : *Node {
    return NewAggregateDecl(startPos, endPos, StmtKind.NOTE_DECL,
                                name, Array<GenericParam>{}, fields, 0, allocator)
}


public func NewParameterDecl(startPos: SrcPos,
                         endPos: SrcPos,
                         name: Identifier,
                         type: *TypeSpec,
                         defaultExpr: *Expr,
                         isUsing: bool,
                         allocator: *const Allocator) : *Node {
    var decl = NewNode(allocator)
    decl.kind = StmtKind.PARAM_DECL;
    decl.startPos = startPos
    decl.endPos = endPos

    decl.paramDecl.name = name
    decl.paramDecl.type = type
    decl.paramDecl.defaultExpr = decl.becomeParentOf(defaultExpr)
    decl.paramDecl.attributes.isUsing = isUsing

    return decl
}

public func NewNotesDecl(startPos: SrcPos,
                         endPos: SrcPos,
                         notes: Array<*NoteStmt>,
                         allocator: *const Allocator) : *Node {
    var decl = NewNode(allocator)
    decl.kind = StmtKind.NOTES_DECL;
    decl.startPos = startPos
    decl.endPos = endPos
    decl.notesDecl.notes = notes
    return decl
}

public func NewBuiltinDecl(startPos: SrcPos,
                           endPos: SrcPos,
                           type: *TypeInfo,
                           allocator: *const Allocator) : *Node {
    var decl = NewNode(allocator)
    decl.kind = StmtKind.NATIVE_DECL;
    decl.startPos = startPos
    decl.endPos = endPos
    decl.nativeDecl.typeInfo = type
    return decl
}

public func NewPoisonDecl(startPos: SrcPos,
                          endPos: SrcPos,
                          allocator: *const Allocator) : *Node {
    var decl = NewNode(allocator)
    decl.kind = StmtKind.POISON_DECL;
    decl.startPos = startPos
    decl.endPos = endPos
    return decl
}

public func NewTernaryExpr(startPos: SrcPos,
                           endPos: SrcPos,
                           cond: *Expr,
                           then: *Expr,
                           other: *Expr,
                           allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.TERNARY_EXPR;
    expr.startPos = startPos
    expr.endPos = endPos
    expr.ternaryExpr.cond = expr.becomeParentOf(cond)
    expr.ternaryExpr.then = expr.becomeParentOf(then)
    expr.ternaryExpr.other = expr.becomeParentOf(other)

    return expr
}

public func NewBinaryExpr(startPos: SrcPos,
                          endPos: SrcPos,
                          left: *Expr,
                          operator: TokenType,
                          right: *Expr,
                          allocator: *const Allocator) : *Node {
    var binExpr = NewNode(allocator)
    binExpr.kind = StmtKind.BINARY_EXPR;
    binExpr.startPos = startPos
    binExpr.endPos = endPos

    binExpr.binaryExpr.left = binExpr.becomeParentOf(left)
    binExpr.binaryExpr.operator = operator
    binExpr.binaryExpr.right = binExpr.becomeParentOf(right)
    binExpr.binaryExpr.ternaryDecl = null

    return binExpr
}

public func NewUnaryExpr(startPos: SrcPos,
                         endPos: SrcPos,
                         operator: TokenType,
                         expr: *Expr,
                         allocator: *const Allocator) : *Node {
    var unaryExpr = NewNode(allocator)
    unaryExpr.kind = StmtKind.UNARY_EXPR;
    unaryExpr.startPos = startPos
    unaryExpr.endPos = endPos

    unaryExpr.unaryExpr.unaryExpr = unaryExpr.becomeParentOf(expr)
    unaryExpr.unaryExpr.operator = operator

    return unaryExpr
}

public func NewInitExpr(startPos: SrcPos,
                        endPos: SrcPos,
                        type: *TypeSpec,
                        arguments: Array<*InitArgExpr>,
                        allocator: *const Allocator) : *Node {
    var initExpr = NewNode(allocator)
    initExpr.kind = StmtKind.INIT_EXPR
    initExpr.startPos = startPos
    initExpr.endPos = endPos

    initExpr.initExpr.type = type
    initExpr.initExpr.arguments = arguments
    initExpr.becomeParentOfChildren(initExpr.initExpr.arguments)

    return initExpr
}

public func NewFuncCallExpr(startPos: SrcPos,
                            endPos: SrcPos,
                            object: *Expr,
                            arguments: Array<CallArg>,
                            genericArgs: Array<GenericArg>,
                            allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.FUNC_CALL_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.funcCallExpr.object = expr.becomeParentOf(object)
    expr.funcCallExpr.genericArgs = genericArgs
    for(var i = 0; i < arguments.size(); i+= 1) {
        expr.becomeParentOf(arguments.get(i).argExpr)
    }
    expr.funcCallExpr.arguments = arguments
    return expr
}

public func NewSubscriptGetExpr(startPos: SrcPos,
                                endPos: SrcPos,
                                object: *Expr,
                                index: *Expr,
                                allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.SUBSCRIPT_GET_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.subscriptGetExpr.object = expr.becomeParentOf(object)
    expr.subscriptGetExpr.index = expr.becomeParentOf(index)

    return expr
}

public func NewSubscriptSetExpr(startPos: SrcPos,
                                endPos: SrcPos,
                                object: *Expr,
                                index: *Expr,
                                operator: TokenType,
                                value: *Expr,
                                allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.SUBSCRIPT_SET_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.subscriptSetExpr.object = expr.becomeParentOf(object)
    expr.subscriptSetExpr.index = expr.becomeParentOf(index)
    expr.subscriptSetExpr.operator = operator
    expr.subscriptSetExpr.value = expr.becomeParentOf(value)

    return expr
}

public func NewGetExpr(startPos: SrcPos,
                       endPos: SrcPos,
                       object: *Expr,
                       field: *IdentifierExpr,
                       allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.GET_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.getExpr.object = expr.becomeParentOf(object)
    expr.getExpr.field = expr.becomeParentOf(field)

    return expr
}

public func NewSetExpr(startPos: SrcPos,
                       endPos: SrcPos,
                       object: *Expr,
                       field: *IdentifierExpr,
                       operator: TokenType,
                       value: *Expr,
                       allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.SET_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.setExpr.object = expr.becomeParentOf(object)
    expr.setExpr.field = expr.becomeParentOf(field)
    expr.setExpr.operator = operator
    expr.setExpr.value = expr.becomeParentOf(value)

    return expr
}

public func NewIdentifierExpr(startPos: SrcPos,
                              endPos: SrcPos,
                              type: *TypeSpec,
                              allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.IDENTIFIER_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.identifierExpr.type = type

    return expr
}

public func NewTypeIdentifierExpr(startPos: SrcPos,
                                  endPos: SrcPos,
                                  type: *TypeSpec,
                                  isBased: bool,
                                  allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.TYPE_IDENTIFIER_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.typeIdentifierExpr.type = type
    expr.typeIdentifierExpr.isBased = isBased

    return expr
}

public func NewCastExpr(startPos: SrcPos,
                       endPos: SrcPos,
                       castExpr: *Expr,
                       castTo: *TypeSpec,
                       allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.CAST_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.castExpr.exprToCast = expr.becomeParentOf(castExpr)
    expr.castExpr.castTo = castTo

    return expr
}

public func NewArrayDesignationExpr(startPos: SrcPos,
                                    endPos: SrcPos,
                                    index: *Expr,
                                    value: *Expr,
                                    allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.ARRAY_DESIGNATION_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.arrayDesignationExpr.index = expr.becomeParentOf(index)
    expr.arrayDesignationExpr.value = expr.becomeParentOf(value)

    return expr
}

public func NewInitArgExpr(startPos: SrcPos,
                           endPos: SrcPos,
                           fieldName: Identifier,
                           position: i32,
                           value: *Expr,
                           allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.INIT_ARG_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.initArgExpr.fieldName = fieldName
    expr.initArgExpr.argPosition = position
    expr.initArgExpr.value = expr.becomeParentOf(value)

    return expr
}

public func NewBooleanExpr(startPos: SrcPos,
                           endPos: SrcPos,
                           boolean: bool,
                           allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.BOOLEAN_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.booleanExpr.boolean = boolean
    return expr
}

public func NewNullExpr(startPos: SrcPos,
                        endPos: SrcPos,
                        allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.NULL_EXPR
    expr.startPos = startPos
    expr.endPos = endPos
    return expr
}

public func NewNumberExpr(startPos: SrcPos,
                          endPos: SrcPos,
                          number: Token,
                          allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.NUMBER_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.numberExpr.number = number
    return expr
}

public func NewStringExpr(startPos: SrcPos,
                          endPos: SrcPos,
                          string: Token,
                          allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.STRING_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.stringExpr.string = string
    return expr
}

public func NewNativeStringExpr(startPos: SrcPos,
                          endPos: SrcPos,
                          string: Token,
                          allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.NATIVE_STRING_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.stringExpr.string = string
    return expr
}

public func NewCharExpr(startPos: SrcPos,
                          endPos: SrcPos,
                          character: Token,
                          allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.CHAR_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.charExpr.character = character
    return expr
}

public func NewGroupExpr(startPos: SrcPos,
                         endPos: SrcPos,
                         groupedExpr: *Expr,
                         allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.GROUP_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.groupExpr.groupedExpr = expr.becomeParentOf(groupedExpr)
    return expr
}

public func NewArrayInitExpr(startPos: SrcPos,
                             endPos: SrcPos,
                             type: *TypeSpec,
                             values: Array<*Expr>,
                             allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.ARRAY_INIT_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.arrayInitExpr.type = type
    expr.arrayInitExpr.values = *expr.becomeParentOfChildren(values)

    assert(expr.arrayInitExpr.type.kind == TypeSpecKind.ARRAY)

    // if we are relying on the values to determine the
    // size, create the AST number
    var arrayType = expr.arrayInitExpr.type
    if(!arrayType.numElements && !expr.arrayInitExpr.values.empty()) {
        var token = Token {
            .type = TokenType.USIZE,
            .typeInfo = &USIZE_TYPE,
            .pos = startPos, // TODO: fix this...
            .value = Value {
                .intValue = expr.arrayInitExpr.values.size()
            }
        }
        arrayType.numElements = &NewNumberExpr(startPos, startPos, token, allocator).asExpr
    }

    return expr
}

public func NewSizeOfExpr(startPos: SrcPos,
                         endPos: SrcPos,
                         sizeOfExpr: *Expr,
                         allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.SIZE_OF_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.sizeOfExpr.sizeOfExpr = expr.becomeParentOf(sizeOfExpr)

    return expr
}


public func NewTypeOfExpr(startPos: SrcPos,
                          endPos: SrcPos,
                          typeOfExpr: *Expr,
                          type: *TypeSpec,
                          allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.TYPE_OF_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.typeOfExpr.typeOfExpr = expr.becomeParentOf(typeOfExpr)
    expr.typeOfExpr.type = type

    return expr
}

public func NewNameOfExpr(startPos: SrcPos,
                          endPos: SrcPos,
                          typeOfExpr: *Expr,
                          type: *TypeSpec,
                          allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.NAME_OF_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.typeOfExpr.typeOfExpr = expr.becomeParentOf(typeOfExpr)
    expr.typeOfExpr.type = type
    return expr
}

public func NewOffsetOfExpr(startPos: SrcPos,
                          endPos: SrcPos,
                          type: *TypeSpec,
                          field: Identifier,
                          allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.OFFSET_OF_EXPR
    expr.startPos = startPos
    expr.endPos = endPos

    expr.offsetOfExpr.type = type
    expr.offsetOfExpr.field = field
    return expr
}

public func NewPoisonExpr(startPos: SrcPos,
                          endPos: SrcPos,
                          allocator: *const Allocator) : *Node {
    var expr = NewNode(allocator)
    expr.kind = StmtKind.POISON_EXPR
    expr.startPos = startPos
    expr.endPos = endPos
    return expr
}

public func NewModuleStmt(startPos: SrcPos,
                          endPos: SrcPos,
                          imports: Array<*ImportDecl>,
                          notes: Array<*NoteStmt>,
                          declarations: Array<*Decl>,
                          allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.MODULE_STMT
    stmt.startPos = startPos
    stmt.endPos = endPos

    stmt.moduleStmt.imports = imports
    stmt.moduleStmt.notes = notes
    stmt.moduleStmt.declarations = declarations
    return stmt
}

public func NewCompStmt(startPos: SrcPos,
                        endPos: SrcPos,
                        type: InternedString,
                        expr: String,
                        body: Array<*Stmt>,
                        end: *CompStmt,
                        isScriptLoad: bool,
                        isStatic: bool,
                        allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.COMP_STMT
    stmt.startPos = startPos
    stmt.endPos = endPos

    stmt.compStmt.type = type
    stmt.compStmt.expr = expr
    stmt.compStmt.end = end
    stmt.compStmt.body = body
    stmt.compStmt.evaluatedStmt = null
    stmt.compStmt.isScriptLoad = isScriptLoad
    stmt.compStmt.isStatic = isStatic
    return stmt
}

public func NewFuncBodyStmt(startPos: SrcPos,
                         endPos: SrcPos,
                         stmts: Array<*Stmt>,
                         allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.FUNC_BODY_STMT
    stmt.startPos = startPos
    stmt.endPos = endPos

    stmt.blockStmt.stmts = *stmt.becomeParentOfChildren(stmts)
    return stmt
}


public func NewBlockStmt(startPos: SrcPos,
                         endPos: SrcPos,
                         stmts: Array<*Stmt>,
                         allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.BLOCK_STMT
    stmt.startPos = startPos
    stmt.endPos = endPos

    stmt.blockStmt.stmts = *stmt.becomeParentOfChildren(stmts)
    return stmt
}

public func NewIfStmt(startPos: SrcPos,
                      endPos: SrcPos,
                      cond: *Expr,
                      then: *Stmt,
                      other: *Stmt,
                      allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.IF_STMT
    stmt.startPos = startPos
    stmt.endPos = endPos

    stmt.ifStmt.cond = stmt.becomeParentOf(cond)
    stmt.ifStmt.then = stmt.becomeParentOf(then)
    stmt.ifStmt.elseStmt = stmt.becomeParentOf(other)
    return stmt
}


public func NewWhileStmt(startPos: SrcPos,
                         endPos: SrcPos,
                         cond: *Expr,
                         body: *Stmt,
                         allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.WHILE_STMT
    stmt.startPos = startPos
    stmt.endPos = endPos

    stmt.whileStmt.cond = stmt.becomeParentOf(cond)
    stmt.whileStmt.body = stmt.becomeParentOf(body)
    return stmt
}

public func NewDoWhileStmt(startPos: SrcPos,
                           endPos: SrcPos,
                           cond: *Expr,
                           body: *Stmt,
                           allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.DO_WHILE_STMT
    stmt.startPos = startPos
    stmt.endPos = endPos

    stmt.doWhileStmt.cond = stmt.becomeParentOf(cond)
    stmt.doWhileStmt.body = stmt.becomeParentOf(body)
    return stmt
}

public func NewForStmt(startPos: SrcPos,
                       endPos: SrcPos,
                       init: *Stmt,
                       cond: *Expr,
                       post: *Stmt,
                       body: *Stmt,
                       allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.FOR_STMT
    stmt.startPos = startPos
    stmt.endPos = endPos

    stmt.forStmt.init = stmt.becomeParentOf(init)
    stmt.forStmt.cond = stmt.becomeParentOf(cond)
    stmt.forStmt.post = stmt.becomeParentOf(post)
    stmt.forStmt.body = stmt.becomeParentOf(body)
    return stmt
}

public func NewSwitchCaseStmt(startPos: SrcPos,
                              endPos: SrcPos,
                              cond: *Expr,
                              body: *Stmt,
                              allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.SWITCH_CASE_STMT
    stmt.startPos = startPos
    stmt.endPos = endPos

    stmt.switchCaseStmt.cond = stmt.becomeParentOf(cond)
    stmt.switchCaseStmt.body = stmt.becomeParentOf(body)
    return stmt
}

public func NewSwitchStmt(startPos: SrcPos,
                              endPos: SrcPos,
                              cond: *Expr,
                              cases: Array<*SwitchCaseStmt>,
                              defaultStmt: *Stmt,
                              allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.SWITCH_STMT
    stmt.startPos = startPos
    stmt.endPos = endPos

    stmt.switchStmt.cond = stmt.becomeParentOf(cond)
    stmt.switchStmt.cases = *stmt.becomeParentOfChildren(cases)
    stmt.switchStmt.defaultStmt = stmt.becomeParentOf(defaultStmt)
    return stmt
}

public func NewBreakStmt(startPos: SrcPos,
                         endPos: SrcPos,
                         allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.BREAK_STMT
    stmt.startPos = startPos
    stmt.endPos = endPos
    return stmt
}

public func NewContinueStmt(startPos: SrcPos,
                            endPos: SrcPos,
                            allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.CONTINUE_STMT
    stmt.startPos = startPos
    stmt.endPos = endPos
    return stmt
}

public func NewReturnStmt(startPos: SrcPos,
                          endPos: SrcPos,
                          expr: *Expr,
                          allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.RETURN_STMT
    stmt.startPos = startPos
    stmt.endPos = endPos

    stmt.returnStmt.expr = stmt.becomeParentOf(expr)
    return stmt
}

public func NewDeferStmt(startPos: SrcPos,
                         endPos: SrcPos,
                         defered: *Stmt,
                         allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.DEFER_STMT
    stmt.startPos = startPos
    stmt.endPos = endPos

    stmt.deferStmt.deferedStmt = stmt.becomeParentOf(defered)
    return stmt
}

public func NewGotoStmt(startPos: SrcPos,
                        endPos: SrcPos,
                        label: Identifier,
                        allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.GOTO_STMT
    stmt.startPos = startPos
    stmt.endPos = endPos

    stmt.gotoStmt.label = label
    return stmt
}

public func NewLabelStmt(startPos: SrcPos,
                         endPos: SrcPos,
                         label: Identifier,
                         allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.LABEL_STMT
    stmt.startPos = startPos
    stmt.endPos = endPos

    stmt.labelStmt.label = label
    return stmt
}

public func NewNoteStmt(startPos: SrcPos,
                        endPos: SrcPos,
                        type: *TypeSpec,
                        arguments: Array<CallArg>,
                        allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.NOTE_STMT
    stmt.startPos = startPos
    stmt.endPos = endPos

    stmt.noteStmt.type = type
    stmt.noteStmt.arguments = arguments
    return stmt
}

public func NewEmptyStmt(startPos: SrcPos,
                         endPos: SrcPos,
                         allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.EMPTY_STMT
    stmt.startPos = startPos
    stmt.endPos = endPos
    return stmt
}

public func NewParametersStmt(startPos: SrcPos,
                              endPos: SrcPos,
                              params: Array<*ParameterDecl>,
                              isVararg: bool,
                              isNativeVararg: bool,
                              allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.PARAMETERS_STMT
    stmt.startPos = startPos
    stmt.endPos = endPos

    stmt.parametersStmt.params = *stmt.becomeParentOfChildren(params)
    stmt.parametersStmt.isVararg = isVararg
    stmt.parametersStmt.isNativeVararg = isNativeVararg
    return stmt
}


public func NewVarFieldDecl(startPos: SrcPos,
                            endPos: SrcPos,
                            fieldName: Identifier,
                            type: *TypeSpec,
                            attributes: Attributes,
                            defaultExpr: *Expr,
                            bitFieldExpr: *Expr,
                            allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.VAR_FIELD_DECL
    stmt.startPos = startPos
    stmt.endPos = endPos

    stmt.varFieldDecl.name = fieldName
    stmt.varFieldDecl.type = type
    stmt.varFieldDecl.attributes = attributes
    stmt.varFieldDecl.defaultExpr = stmt.becomeParentOf(defaultExpr)
    stmt.varFieldDecl.bitFieldExpr = stmt.becomeParentOf(bitFieldExpr)
    return stmt
}

public func NewTraitFieldDecl(startPos: SrcPos,
                            endPos: SrcPos,
                            fieldName: Identifier,
                            type: *TypeSpec,
                            attributes: Attributes,
                            allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.TRAIT_FIELD_DECL
    stmt.startPos = startPos
    stmt.endPos = endPos

    stmt.traitFieldDecl.name = fieldName
    stmt.traitFieldDecl.type = type
    stmt.traitFieldDecl.attributes = attributes
    return stmt
}


public func NewEnumFieldEntryDecl(startPos: SrcPos,
                            endPos: SrcPos,
                            fieldName: Identifier,
                            value: *Expr,
                            attributes: Attributes,
                            allocator: *const Allocator) : *Node {
    var stmt = NewNode(allocator)
    stmt.kind = StmtKind.ENUM_FIELD_ENTRY_DECL
    stmt.startPos = startPos
    stmt.endPos = endPos

    stmt.enumFieldEntryDecl.name = fieldName
    stmt.enumFieldEntryDecl.attributes = attributes
    stmt.enumFieldEntryDecl.value = stmt.becomeParentOf(value)
    return stmt
}


@test
func typeSpecAllocator() {
    var specs = TypeSpecAllocator{}
    specs.init(defaultAllocator)

    var x = specs.alloc()
    x.name = InternedString{}
    specs.free()
}
