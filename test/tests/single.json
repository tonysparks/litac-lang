{
    "description": "Single",
    "disabled": false,
    "includeTypeInfos": true,
    "program": `
        @include("assert.h");
        @foreign func assert(e:bool):void;

        %definitions%

        // @suspend
        func main(len:i32, args:**char):i32 {
            %code%
        }
    `,
    "tests": [
        {
            "name": "Coroutine ternary operation",
            "definitions": `
                import "std/coroutine"
                var global: i32 = 0
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    global += 1
                    return a + b
                }
/*
                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = aCoroutine(a, 1)
                    if (x) {
                        x = 12
                        var x = 10
                    } else {
                        var y = 22
                        var x = 33
                        x = 22
                    }

                    return x
                }*/
            `,
            "code": `
            /*
                var dispatcher: Dispatcher
                dispatcher.init()

                // option 1: manual creation
                var co = Coroutine {
                    .function = bCoroutine,
                    .stack = bCoroutineStack {
                        .a = 1
                    }
                }
                dispatcher.submit(co)

                // option 2: compiler helper
                var co = @coroutine(bCoroutine, 1)
                dispatcher.submit(co)

                // option 3: magic function?
                dispatcher.submit(
                    bCoroutine,
                    1
                )*/
/*
                assert(
                    bCoroutine(1) == 12
                )
                assert(global == 1)

                global = 0
*/

            `,
        },/*
        {
            "name": "Coroutine ternary operation",
            "definitions": `
                var global: i32 = 0
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    global += 1
                    return a + b
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = aCoroutine(a, 1)
                        ? aCoroutine(a, 1) : 11
                    return x
                }
            `,
            "code": `
                assert(
                    bCoroutine(1) == 2
                )
                assert(global == 2)

                global = 0

                assert(
                    bCoroutine(-1) == 11
                )
                assert(global == 1)

            `,
        },
        {
            "name": "Coroutine for statement empty",
            "definitions": `
                var global: i32 = 0
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    global += 1
                    return a + b
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var total = 0
                    var y = 0
                    for(;;) {
                        total += aCoroutine(1, a)
                        break
                    }
                    return total
                }
            `,
            "code": `
                assert(
                    bCoroutine(0) == 1
                )
                assert(global == 1)

                global = 0


            `,
        },
        {
            "name": "Coroutine get/set[] expr",
            "definitions": `
                struct TestStruct {
                    a:i32
                }

                var global: i32 = 0
                var order: i32 = 0
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    if (order % 2 == 0)
                        global += b
                    else
                        global -= b
                    order += 1
                    return a
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x:[2]TestStruct
                    x[0].a = aCoroutine(1, a+1)
                    x[1] = TestStruct {
                        .a = aCoroutine(1, a+2)
                    }
                    var y:[2]i32;
                    y[0] = aCoroutine(1, a+3)

                    return global
                }
            `,
            "code": `
                assert(
                    bCoroutine(0) == 2
                )
            `,
        },
        {
            "name": "Coroutine set expr",
            "definitions": `
                struct TestStruct {
                    a:i32
                }

                var global: i32 = 0
                var order: i32 = 0
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    if (order % 2 == 0)
                        global += b
                    else
                        global -= b
                    order += 1
                    return a
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = TestStruct {}
                    x.a = aCoroutine(1, a)
                    return x.a
                }
            `,
            "code": `
                assert(
                    bCoroutine(0) == 1
                )
            `,
        },
        {
            "name": "Coroutine call with coroutine args",
            "definitions": `
                var global: i32 = 0
                var order: i32 = 0
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    if (order % 2 == 0)
                        global += b
                    else
                        global -= b
                    order += 1
                    return a
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = aCoroutine(
                        aCoroutine(1, a+1),
                        aCoroutine(1, a+2)
                    )
                    return global
                }
            `,
            "code": `
                assert(
                    bCoroutine(0) == 0
                )
                assert(order == 3)
            `,
        },
        {
            "name": "Coroutine init expression",
            "definitions": `
                var global: i32 = 0
                var order: i32 = 0
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    if (order % 2 == 0)
                        global += b
                    else
                        global -= b
                    order += 1
                    return a
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = aCoroutine(1, a+1) + aCoroutine(1, a+2)
                    return global
                }
            `,
            "code": `
                assert(
                    bCoroutine(0) == -1
                )
                assert(order == 2)
            `,
        },
        {
            "name": "Coroutine init expression",
            "definitions": `
                import "std/libc"
                var global: i32 = 0
                var order: i32 = 0
                struct TestStruct {
                    a: i32
                    b: i32
                }

                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    if (order % 2 == 0)
                        global += b
                    else
                        global -= b
                    order += 1
                    return a
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = aCoroutine(1, a+1)
                    var y = aCoroutine(2, a+2)
                    var t = TestStruct {
                        .a = aCoroutine(3, a+3),
                        .b = aCoroutine(5, a+5),
                    }
                    aCoroutine(6, a+6)
                    return global
                }
            `,
            "code": `
                //printf("%d\n",

                // this runs init expressions from bottom to top!!
                // if reversed this should be 3
                assert(
                    bCoroutine(0) == 3
                )
                assert(order == 5)
            `,
        },
        {
            "name": "Coroutine for statement",
            "definitions": `
                var global: i32 = 0
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    global += 1
                    return a + b
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var total = 0
                    var y = 0
                    for(
                        var x = aCoroutine(a, 0);
                        (y = aCoroutine(0, a) + x) < 2;
                        //aCoroutine(0, a);
                        x+=1
                    ) {
                        total += aCoroutine(1, a)
                    }
                    return total
                }
            `,
            "code": `
                assert(
                    bCoroutine(0) == 2
                )
                assert(global == 6)

                global = 0

                assert(
                    bCoroutine(10) == 0
                )
                assert(global == 2)

                global = 0

            `,
        },
        {
            "name": "Coroutine goto statement",
            "definitions": `
                var global: i32 = 0
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    global += 1
                    return a + b
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    if(aCoroutine(a, 1) > 1) {
                        goto end2
                    }

                    goto end1
                    if(aCoroutine(a, 1)) {
                        goto end3
                    }

                    end3: return -1
                    end2: return 2
                    end1: return 1
                }
            `,
            "code": `
                assert(
                    bCoroutine(3) == 2
                )
                assert(global == 1)

                global = 0

                assert(
                    bCoroutine(0) == 1
                )
                assert(global == 1)

                global = 0
            `,
        },
        {
            "name": "Coroutine do while statement",
            "definitions": `
                var global: i32 = 0
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    global += 1
                    return a + b
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = 0
                    do {
                        x += 1
                    } while(aCoroutine(a, x) < 3)
                    return x
                }
            `,
            "code": `
                assert(
                    bCoroutine(3) == 1
                )
                assert(global == 1)

                global = 0

                assert(
                    bCoroutine(0) == 3
                )
                assert(global == 3)

                global = 0
            `,
        },
        {
            "name": "Coroutine switch statement",
            "definitions": `
                var global: i32 = 0
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    global += 1
                    return a + b
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = 0
                    switch(aCoroutine(a, 1)) {
                        case 0: aCoroutine(a, 1); x = 1 break;
                        case 1: x = aCoroutine(a, 1); break;
                        default:
                            aCoroutine(a, 1); x = 3 break;
                    }
                    return x
                }
            `,
            "code": `
                assert(
                    bCoroutine(0) == 1
                )
                assert(global == 2)

                global = 0

                assert(
                    bCoroutine(-1) == 1
                )
                assert(global == 2)

                global = 0

                assert(
                    bCoroutine(55) == 3
                )
                assert(global == 2)

            `,
        },
        {
            "name": "Coroutine ternary operation",
            "definitions": `
                var global: i32 = 0
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    global += 1
                    return a + b
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = aCoroutine(a, 1)
                        ? aCoroutine(a, 1) : 11
                    return x
                }
            `,
            "code": `
                assert(
                    bCoroutine(1) == 2
                )
                assert(global == 2)

                global = 0

                assert(
                    bCoroutine(-1) == 11
                )
                assert(global == 1)

            `,
        },
        {
            "name": "Coroutine ternary operation grouping",
            "definitions": `
                var global: i32 = 0
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    global += 1
                    return a + b
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = (aCoroutine(a, 1)
                        ? aCoroutine(a, 1) : 11)
                        + 1
                    return x
                }
            `,
            "code": `
                assert(
                    bCoroutine(1) == 3
                )
                assert(global == 2)

                global = 0

                assert(
                    bCoroutine(-1) == 12
                )
                assert(global == 1)

            `,
        },
        {
            "name": "Coroutine if with AND stmt",
            "definitions": `
                var global: i32 = 0
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    global += 1
                    return a + b
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = 0
                    if (aCoroutine(a, 1) > 2 &&
                        aCoroutine(a, 1) > 4
                    ) {
                        x = 11
                    } else x = 22
                    return x
                }
            `,
            "code": `
                assert(
                    bCoroutine(1) == 22
                )
                assert(global == 1)

                global = 0

                assert(
                    bCoroutine(5) == 11
                )
                assert(global == 2)

            `,
        },
        {
            "name": "Coroutine if with OR stmt",
            "definitions": `
                var global: i32 = 0
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    global += 1
                    return a + b
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = 0
                    if (aCoroutine(a, 1) > 4 ||
                        aCoroutine(a, 1) > 2
                    ) {
                        x = 11
                    } else x = 22
                    return x
                }
            `,
            "code": `
                assert(
                    bCoroutine(1) == 22
                )
                assert(global == 2)

                global = 0

                assert(
                    bCoroutine(5) == 11
                )
                assert(global == 1)

            `,
        },
        {
            "name": "Coroutine if while stmt",
            "definitions": `
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    return a + b
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = 0
                    if (aCoroutine(a, 1) > 4) {
                        while(x < a) {
                            x+=1
                        }
                    } else x = 22
                    return x
                }
            `,
            "code": `
                assert(
                    bCoroutine(1) == 22
                )
                assert(
                    bCoroutine(2) == 22
                )
                assert(
                    bCoroutine(3) == 22
                )
                assert(
                    bCoroutine(4) == 4
                )
            `,
        },
        {
            "name": "Coroutine if else stmt",
            "definitions": `
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    return a + b
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = 0
                    if (aCoroutine(a, 1) > 4) {
                        x = 3
                    } else if (aCoroutine(a, 1) > 3) {
                        x = 2
                    }
                    else if (aCoroutine(a, 1) > 2) {
                        x = 1
                    }
                    return x
                }
            `,
            "code": `
                assert(
                    bCoroutine(1) == 0
                )
                assert(
                    bCoroutine(2) == 1
                )
                assert(
                    bCoroutine(3) == 2
                )
                assert(
                    bCoroutine(4) == 3
                )
            `,
        },
        {
            "name": "Coroutine if stmt",
            "definitions": `
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    return a + b
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = 0
                    if (aCoroutine(a, 1) > 2) {
                        x += 1
                    }
                    return x
                }
            `,
            "code": `
                assert(
                    bCoroutine(1) == 0
                )
                assert(
                    bCoroutine(2) == 1
                )
            `,
        },
        {
            "name": "Coroutine while loop",
            "definitions": `
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    return a + b - a
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = 0
                    while(aCoroutine(a, x) < a) {
                        x += 1
                    }
                    return x
                }
            `,
            "code": `
                assert(
                    bCoroutine(1) == 1
                )
                assert(
                    bCoroutine(2) == 2
                )
                assert(
                    bCoroutine(3) == 3
                )
                assert(
                    bCoroutine(0) == 0
                )
            `,
        },
/*
        {
            "name": "Coroutine Symbols",
            "definitions": `
                @suspend
                func aCoroutine(a: i32, b: f32) : bool {
                    var x = a + 1
                    if (x == 2) {
                        var innerY = x + 3
                        while (innerY) {
                            innerY -= 1
                            if (innerY < 0) {
                                var xxx = 3
                                break
                            }
                        }
                    } else {
                        var innerY = b
                        var xxx = "hello world"
                    }

                    var result = (x > 3);
                    return result
                }
            `,
            "code": `
                var r = aCoroutine(3, 4)
            `,
        },

        {
            "name": "Coroutine called in a non Coroutine",
            "definitions": `
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    return a + b
                }

                func nonCoroutine() : i32 {
                    return aCoroutine(4, 6)
                }
            `,
            "code": `
                var r = nonCoroutine()
            `,
        },*/

        /*
        {
            "name": "Foreign funcPtr alias variable",
            "symbolPrefix": "litaC__",
            "definitions": `
                @raw("""
                    int testViewport(int x, int y) {
                        return x + y;
                    }

                    typedef int (*PFNGLVIEWPORTPROC)(int x, int y);
                    PFNGLVIEWPORTPROC glad_glViewport = testViewport;
                    #define glViewport glad_glViewport
                """);

                @foreign public typedef func(i32, i32) : i32 as PFNGLVIEWPORTPROC;

                @foreign public const glViewport: PFNGLVIEWPORTPROC
            `,
            "code": `
                var r = glViewport(2, 6)
                assert(r == 8)
            `,
        },
        {
            "name": "Foreign byte alias",
            "symbolPrefix": "litaC__",
            "definitions": `
                @foreign public typedef char as GLchar;

                func (this: char) isSpace() : bool {
                    return this == ' '
                }
            `,
            "code": `
                var c1 = 'x' as (GLchar)
                var c2 = ' ' as (GLchar)
                assert(c1.isSpace() == false)
                assert(c2.isSpace() == true)
            `,
        },
        {
            "name" : "Test foreign names",
            "definitions": `
                @raw("""
                    typedef __attribute__((aligned(16))) float vec4[4];
                    typedef __attribute__((aligned(16))) vec4     mat4[4];
                    #define GLM_MAT4_IDENTITY_INIT  {{1.0f, 0.0f, 0.0f, 0.0f},                   \
                                                    {0.0f, 1.0f, 0.0f, 0.0f},                    \
                                                    {0.0f, 0.0f, 1.0f, 0.0f},                    \
                                                    {0.0f, 0.0f, 0.0f, 1.0f}}
                """);
                @foreign(.strict = true)
                public typedef [4][4]f32 as mat4;

                @foreign(.strict = true)
                public var GLM_MAT4_IDENTITY_INIT: mat4;

                func Clear(m: mat4) {
                    @raw("__attribute__((aligned(16)))") var v: mat4 = GLM_MAT4_IDENTITY_INIT;
                }
            `,
            "code": `
                @raw("__attribute__((aligned(16)))") var v: mat4 = mat4 {
                    [4]f32 { 0f, 2f, 0f, 2f },
                    [4]f32 { 0f, 2f, 0f, 2f },
                    [4]f32 { 0f, 2f, 0f, 2f },
                    [4]f32 { 0f, 2f, 0f, 2f },
                };
                assert(v[0][0] == 0f)
                assert(v[1][1] == 2f)
                Clear(v)
            `,
        },
        {
            "name": "Foreign funcPtr",
            "symbolPrefix": "litaC__",
            "definitions": `
                @raw("""
                typedef int (*SomeFunc)(int x);

                int nativeFn(SomeFunc aFn) {
                    return aFn(4);
                }

                """);

                @foreign
                func nativeFn(aFn: SomeFunc) : i32;

                @foreign
                typedef func(i32) : i32 as SomeFunc;

                func test(x: i32) : i32 {
                    return x
                }

                func testFn(aFn: SomeFunc) : i32 {
                    return aFn(4)
                }
            `,
            "code": `
                var fn = &test

                assert(fn(4)== 4)
                assert(testFn(fn) == 4)
                assert(nativeFn(fn) == 4)

            `,
        },
        /*
        {
            "name": "array assigned to array",
            "definitions": `
                @include("<string.h>");
                @foreign func strcmp(a:*const char, b:*const char) : i32;

                struct Test {
                    name: *char
                    x: [32]char
                }

                struct X {
                    x: [32]char
                }
            `,
            "code": `
                var m : [32]char = "Brett"
                var x = X{m}
                var t = Test{
                    .name = m,
                    .x = x.x

                }
            `,
            "error": "'[32]char' is not assignable as arrays are not mutable lvalues"
        },
        {
            "name" : "Test foreign names",
            "definitions": `
                @raw("""
                    typedef float vec2[2];
                """);
                @foreign public typedef [2]f32 as vec2;
            `,
            "code": `
                @raw("__attribute__((aligned(16)))") var v: vec2 = vec2 { 0f, 2f };
                assert(v[0] == 0f)
                assert(v[1] == 2f)
            `,
        },*/
    ]
}