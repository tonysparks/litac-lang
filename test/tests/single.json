{
    "description": "Single",
    "disabled": false,
    "includeTypeInfos": true,
    "program": `
        @include("assert.h");
        @foreign func assert(e:bool):void;

        %definitions%

        @suspend
        func main(len:i32, args:**char):i32 {
            %code%
        }
    `,
    "tests": [
        {
            "name": "Coroutine if with AND stmt",
            "definitions": `
                var global: i32 = 0
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    global += 1
                    return a + b
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = 0
                    if (aCoroutine(a, 1) > 2 &&
                        aCoroutine(a, 1) > 4
                    ) {
                        x = 11
                    } else x = 22
                    return x
                }
            `,
            "code": `
                assert(
                    bCoroutine(1) == 22
                )
                assert(global == 1)

                global = 0

                assert(
                    bCoroutine(5) == 11
                )
                assert(global == 2)

            `,
        },
        {
            "name": "Coroutine if with OR stmt",
            "definitions": `
                var global: i32 = 0
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    global += 1
                    return a + b
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = 0
                    if (aCoroutine(a, 1) > 4 ||
                        aCoroutine(a, 1) > 2
                    ) {
                        x = 11
                    } else x = 22
                    return x
                }
            `,
            "code": `
                assert(
                    bCoroutine(1) == 22
                )
                assert(global == 2)

                global = 0

                assert(
                    bCoroutine(5) == 11
                )
                assert(global == 1)

            `,
        },/*
        {
            "name": "Coroutine if while stmt",
            "definitions": `
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    return a + b
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = 0
                    if (aCoroutine(a, 1) > 4) {
                        while(x < a) {
                            x+=1
                        }
                    } else x = 22
                    return x
                }
            `,
            "code": `
                assert(
                    bCoroutine(1) == 22
                )
                assert(
                    bCoroutine(2) == 22
                )
                assert(
                    bCoroutine(3) == 22
                )
                assert(
                    bCoroutine(4) == 4
                )
            `,
        },
        {
            "name": "Coroutine if else stmt",
            "definitions": `
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    return a + b
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = 0
                    if (aCoroutine(a, 1) > 4) {
                        x = 3
                    } else if (aCoroutine(a, 1) > 3) {
                        x = 2
                    }
                    else if (aCoroutine(a, 1) > 2) {
                        x = 1
                    }
                    return x
                }
            `,
            "code": `
                assert(
                    bCoroutine(1) == 0
                )
                assert(
                    bCoroutine(2) == 1
                )
                assert(
                    bCoroutine(3) == 2
                )
                assert(
                    bCoroutine(4) == 3
                )
            `,
        },/*
        {
            "name": "Coroutine if stmt",
            "definitions": `
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    return a + b
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = 0
                    if (aCoroutine(a, 1) > 2) {
                        x += 1
                    }
                    return x
                }
            `,
            "code": `
                assert(
                    bCoroutine(1) == 0
                )
                assert(
                    bCoroutine(2) == 1
                )
            `,
        },
        {
            "name": "Coroutine while loop",
            "definitions": `
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    return a + b - a
                }

                @suspend
                func bCoroutine(a: i32) : i32 {
                    var x = 0
                    while(aCoroutine(a, x) < a) {
                        x += 1
                    }
                    return x
                }
            `,
            "code": `
                assert(
                    bCoroutine(1) == 1
                )
                assert(
                    bCoroutine(2) == 2
                )
                assert(
                    bCoroutine(3) == 3
                )
                assert(
                    bCoroutine(0) == 0
                )
            `,
        },*/
/*
        {
            "name": "Coroutine Symbols",
            "definitions": `
                @suspend
                func aCoroutine(a: i32, b: f32) : bool {
                    var x = a + 1
                    if (x == 2) {
                        var innerY = x + 3
                        while (innerY) {
                            innerY -= 1
                            if (innerY < 0) {
                                var xxx = 3
                                break
                            }
                        }
                    } else {
                        var innerY = b
                        var xxx = "hello world"
                    }

                    var result = (x > 3);
                    return result
                }
            `,
            "code": `
                var r = aCoroutine(3, 4)
            `,
        },

        {
            "name": "Coroutine called in a non Coroutine",
            "definitions": `
                @suspend
                func aCoroutine(a: i32, b: i32) : i32 {
                    return a + b
                }

                func nonCoroutine() : i32 {
                    return aCoroutine(4, 6)
                }
            `,
            "code": `
                var r = nonCoroutine()
            `,
        },*/

        /*
        {
            "name": "Foreign funcPtr alias variable",
            "symbolPrefix": "litaC__",
            "definitions": `
                @raw("""
                    int testViewport(int x, int y) {
                        return x + y;
                    }

                    typedef int (*PFNGLVIEWPORTPROC)(int x, int y);
                    PFNGLVIEWPORTPROC glad_glViewport = testViewport;
                    #define glViewport glad_glViewport
                """);

                @foreign public typedef func(i32, i32) : i32 as PFNGLVIEWPORTPROC;

                @foreign public const glViewport: PFNGLVIEWPORTPROC
            `,
            "code": `
                var r = glViewport(2, 6)
                assert(r == 8)
            `,
        },
        {
            "name": "Foreign byte alias",
            "symbolPrefix": "litaC__",
            "definitions": `
                @foreign public typedef char as GLchar;

                func (this: char) isSpace() : bool {
                    return this == ' '
                }
            `,
            "code": `
                var c1 = 'x' as (GLchar)
                var c2 = ' ' as (GLchar)
                assert(c1.isSpace() == false)
                assert(c2.isSpace() == true)
            `,
        },
        {
            "name" : "Test foreign names",
            "definitions": `
                @raw("""
                    typedef __attribute__((aligned(16))) float vec4[4];
                    typedef __attribute__((aligned(16))) vec4     mat4[4];
                    #define GLM_MAT4_IDENTITY_INIT  {{1.0f, 0.0f, 0.0f, 0.0f},                   \
                                                    {0.0f, 1.0f, 0.0f, 0.0f},                    \
                                                    {0.0f, 0.0f, 1.0f, 0.0f},                    \
                                                    {0.0f, 0.0f, 0.0f, 1.0f}}
                """);
                @foreign(.strict = true)
                public typedef [4][4]f32 as mat4;

                @foreign(.strict = true)
                public var GLM_MAT4_IDENTITY_INIT: mat4;

                func Clear(m: mat4) {
                    @raw("__attribute__((aligned(16)))") var v: mat4 = GLM_MAT4_IDENTITY_INIT;
                }
            `,
            "code": `
                @raw("__attribute__((aligned(16)))") var v: mat4 = mat4 {
                    [4]f32 { 0f, 2f, 0f, 2f },
                    [4]f32 { 0f, 2f, 0f, 2f },
                    [4]f32 { 0f, 2f, 0f, 2f },
                    [4]f32 { 0f, 2f, 0f, 2f },
                };
                assert(v[0][0] == 0f)
                assert(v[1][1] == 2f)
                Clear(v)
            `,
        },
        {
            "name": "Foreign funcPtr",
            "symbolPrefix": "litaC__",
            "definitions": `
                @raw("""
                typedef int (*SomeFunc)(int x);

                int nativeFn(SomeFunc aFn) {
                    return aFn(4);
                }

                """);

                @foreign
                func nativeFn(aFn: SomeFunc) : i32;

                @foreign
                typedef func(i32) : i32 as SomeFunc;

                func test(x: i32) : i32 {
                    return x
                }

                func testFn(aFn: SomeFunc) : i32 {
                    return aFn(4)
                }
            `,
            "code": `
                var fn = &test

                assert(fn(4)== 4)
                assert(testFn(fn) == 4)
                assert(nativeFn(fn) == 4)

            `,
        },
        /*
        {
            "name": "array assigned to array",
            "definitions": `
                @include("<string.h>");
                @foreign func strcmp(a:*const char, b:*const char) : i32;

                struct Test {
                    name: *char
                    x: [32]char
                }

                struct X {
                    x: [32]char
                }
            `,
            "code": `
                var m : [32]char = "Brett"
                var x = X{m}
                var t = Test{
                    .name = m,
                    .x = x.x

                }
            `,
            "error": "'[32]char' is not assignable as arrays are not mutable lvalues"
        },
        {
            "name" : "Test foreign names",
            "definitions": `
                @raw("""
                    typedef float vec2[2];
                """);
                @foreign public typedef [2]f32 as vec2;
            `,
            "code": `
                @raw("__attribute__((aligned(16)))") var v: vec2 = vec2 { 0f, 2f };
                assert(v[0] == 0f)
                assert(v[1] == 2f)
            `,
        },*/
    ]
}