import "std/mem"
import "std/assert"
import "std/libc" as c

/**
=========================================================
// Bucket allocator
=========================================================
*/
struct Bucket {
    prev: *Bucket
    mem: *u8
    size: usize

    // memory alignment; not used
    padding: *void
}

public struct BucketAllocator {
    allocator: using Allocator
    decorated: *const Allocator

    buckets: *Bucket
    head: *Bucket

    bucketSize: usize
    currentOffset: usize
    totalAllocations: u32
    totalBytesAllocated: usize  // total number of bytes requested to be allocated
    totalGrossBytesAllocated: usize
    totalBuckets: u32
}

public func (this: *BucketAllocator) init(decorated: *const Allocator, bucketSize: usize) {
    this.allocator = Allocator {
        .allocFn:   &GenericMalloc<BucketAllocator>,
        .callocFn:  &GenericCalloc<BucketAllocator>,
        .reallocFn: &GenericRealloc<BucketAllocator>,
        .freeFn:    &BucketFree
    }
    this.decorated = decorated

    bucketSize = c::MAX(bucketSize, LITAC_DEFAULT_ALIGNMENT)

    var requestSize = sizeof(:Bucket) + bucketSize
    var memory = decorated.alloc(requestSize) as (*u8)
    assert(memory)

    this.buckets = memory as (*Bucket)
    this.buckets.mem = memory + sizeof(:Bucket)
    this.buckets.size = bucketSize
    this.buckets.prev = null

    this.head = this.buckets
    this.bucketSize = bucketSize

    this.totalGrossBytesAllocated = 0
    this.totalBytesAllocated = 0
    this.totalAllocations = 0
    this.currentOffset = 0
    this.totalBuckets = 1

    this.totalGrossBytesAllocated += requestSize
}

public func (this: *BucketAllocator) clear() {
    assert(this.buckets != null)

    var n = this.head
    while(n && n != this.buckets) {
        var prev = n.prev
        this.decorated.free(n as (*void))
        n = prev
    }

    this.head = this.buckets
    //c::memset(this.head.mem, 0, this.head.size)

    this.totalBytesAllocated = 0
    this.totalAllocations = 0
    this.currentOffset = 0
    this.totalBuckets = 1
}

@doc("Free all memory associated with this allocator.")
public func (this: *BucketAllocator) free() {
    var n = this.head
    while(n) {
        var prev = n.prev
        this.decorated.free(n as (*void))
        n = prev
    }

    this.head = null
    this.buckets = null

    this.totalBytesAllocated = 0
    this.totalAllocations = 0
    this.currentOffset = 0
    this.totalBuckets = 0
    this.totalGrossBytesAllocated = 0
}

public func (this: *BucketAllocator) malloc(size: usize) : *void {
    assert(this.head != null)

    var headBaseAddr = this.head.mem as (usize)
    var currentAbsolutePtr = headBaseAddr + this.currentOffset

    var alignedAbsolutePtr = alignForward(currentAbsolutePtr, LITAC_DEFAULT_ALIGNMENT)
    var offsetRelative = alignedAbsolutePtr - headBaseAddr
    var newRelativeOffset = offsetRelative + size

    var allocationSize = newRelativeOffset - this.currentOffset;

    // doesn't fix in the current bucket, need to allocate
    // a new bucket
    if(newRelativeOffset > this.head.size) {
        var newBucketSize = c::MAX(newRelativeOffset, this.bucketSize)

        var requestSize = sizeof(:Bucket) + newBucketSize
        var memory = this.decorated.alloc(requestSize) as (*u8)
        if(!memory) {
            return null
        }

        var bucket = memory as (*Bucket)
        bucket.prev = this.head
        bucket.mem = memory + sizeof(:Bucket)
        bucket.size = newBucketSize

        this.head = bucket

        headBaseAddr = this.head.mem as (usize)
        alignedAbsolutePtr = alignForward(headBaseAddr, LITAC_DEFAULT_ALIGNMENT)
        offsetRelative = alignedAbsolutePtr - headBaseAddr
        newRelativeOffset = offsetRelative + size

        assert(newRelativeOffset <= this.head.size)
        allocationSize = newRelativeOffset

        // update stats
        this.totalBuckets += 1
        this.totalGrossBytesAllocated += requestSize
    }

    assert(newRelativeOffset <= this.head.size)
    assert(allocationSize > 0)

    this.currentOffset = newRelativeOffset
    this.totalBytesAllocated += allocationSize
    this.totalAllocations += 1

    var result = this.head.mem + offsetRelative
    return result as (*void)
}

/*

    var currPtr = this.head.mem as (usize) + this.currentOffset
    var offset = alignForward(currPtr, LITAC_DEFAULT_ALIGNMENT)
    offset -= this.head.mem as (usize)

    var newOffset = offset + size
    var allocationSize:usize = newOffset - this.currentOffset


    // check to see if there is enough room in this bucket
    if(newOffset > this.head.size) {
        const bucketSize = c::MAX(size, this.bucketSize)

        var requestSize = sizeof(:Bucket) + bucketSize
        var memory = this.decorated.alloc(requestSize) as (*u8)
        assert(memory)

        if(!memory) {
            return null
        }

        var bucket = memory as (*Bucket)
        bucket.prev = this.head
        bucket.mem = memory + sizeof(:Bucket)
        bucket.size = bucketSize

        this.head = bucket

        this.currentOffset = 0
        this.totalBuckets += 1

        currPtr = this.head.mem as (usize)
        offset = alignForward(currPtr, LITAC_DEFAULT_ALIGNMENT)
        allocationSize = size + (offset - currPtr)

        offset -= this.head.mem as (usize)
        newOffset = offset + size

        this.totalGrossBytesAllocated += requestSize
    }

    this.currentOffset = newOffset
    this.totalBytesAllocated += allocationSize
    this.totalAllocations += 1
    var ptr = this.head.mem + offset
    return ptr;
}*/

func BucketFree(alloc: *const Allocator, ptr: *void) {
    // DO NOTHING
}
