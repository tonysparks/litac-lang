import "std/string_buffer";
import "std/string";
import "std/string_view";
import "std/map";
import "std/array";
import "std/json"

public func (this: *u8) fromJson(context: *JsonContext, json: *JsonNode) {
    if(!json) {
        return;
    }
    *this = json.asInt() as (u8)
}
public func (this: *i8) fromJson(context: *JsonContext, json: *JsonNode) {
    if(!json) {
        return;
    }
    *this = json.asInt() as (i8)
}
public func (this: *u16) fromJson(context: *JsonContext, json: *JsonNode) {
    if(!json) {
        return;
    }
    *this = json.asInt() as (u16)
}
public func (this: *i16) fromJson(context: *JsonContext, json: *JsonNode) {
    if(!json) {
        return;
    }
    *this = json.asInt() as (i16)
}
public func (this: *u32) fromJson(context: *JsonContext, json: *JsonNode) {
    if(!json) {
        return;
    }
    *this = json.asInt() as (u32)
}
public func (this: *i32) fromJson(context: *JsonContext, json: *JsonNode) {
    if(!json) {
        return;
    }
    *this = json.asInt() as (i32)
}
public func (this: *u64) fromJson(context: *JsonContext, json: *JsonNode) {
    if(!json) {
        return;
    }
    *this = json.asLong() as (u64)
}
public func (this: *i64) fromJson(context: *JsonContext, json: *JsonNode) {
    if(!json) {
        return;
    }
    *this = json.asLong() as (i64)
}
public func (this: *usize) fromJson(context: *JsonContext, json: *JsonNode) {
    if(!json) {
        return;
    }
    *this = json.asLong() as (usize)
}

public func (this: *f64) fromJson(context: *JsonContext, json: *JsonNode) {
    if(!json) {
        return;
    }
    *this = json.asFloat() as (f64)
}
public func (this: *f32) fromJson(context: *JsonContext, json: *JsonNode) {
    if(!json) {
        return;
    }
    *this = json.asFloat() as (f32)
}

public func (this: *bool) fromJson(context: *JsonContext, json: *JsonNode) {
    if(!json) {
        return;
    }
    *this = json.asBool()
}

public func (this: **const char) fromJson(context: *JsonContext, json: *JsonNode) {
    if(!json) {
        return;
    }
    *this = json.asString()
}

public func (this: *StringView) fromJson(context: *JsonContext, json: *JsonNode) {
    if(!json) {
        return;
    }
    *this = StringViewInit(json.asString())
}

public func (this: *String) fromJson(context: *JsonContext, json: *JsonNode) {
    if(!json) {
        return;
    }
    this.format("%s", json.asString())
}

public func (this: *StringBuffer) fromJson(context: *JsonContext, json: *JsonNode) {
    if(!json) {
        return;
    }
    this.append("%s", json.asString())
}

// public func (this: *T) fromJson<T>(json: *JsonNode) {
//     var value = *this
//     value.fromJson(sb)
// }

public func (this: *Map<K, V>) fromJson<K, V>(context: *JsonContext, json: *JsonNode) {
    if(!json) {
        return;
    }
    if(!json.isObject()) {
        return;
    }

    var makeFn = context.maker;
    for(var it = json.iter(); it.hasNext();) {

        var entry = it.next()

#if getTypeInfo("this").base.symbol.genericArgs["V"].isPrimitive
        var value: V;
        var valuePtr = &value;

        valuePtr.fromJson(context, entry.value)
        this.put<K,V>(entry.key, value)
/*
#elseif getTypeInfo("this").base.symbol.genericArgs["V"].name == "String"
        var value = StringInit(1024, context.allocator)
#elseif getTypeInfo("this").base.symbol.genericArgs["V"].name == "StringView"
        var value = StringViewInit("temp")
        */
#else
        var value = makeFn != null ?
            makeFn(typeof(:V), context, entry.value) as (V) :
            context.allocator.alloc(sizeof(:V)) as (V)

        this.put<K,V>(entry.key, value)
#end

    }
}


public func (this: *Array<V>) fromJson<V>(context: *JsonContext, json: *JsonNode) {
    if(!json || !json.isArray()) {
        return;
    }

    var makeFn = context.getMakeFn(typeof(:V))
    for(var i = 0; i < json.size(); i += 1) {
        var element = json.at(i)
#if isPrimitive("this.emptyValue")
        var value: V;
//#elseif
#else
        var value = makeFn != null ?
            makeFn() as (V) :
            context.allocator.alloc(sizeof(:V)) as (V)
#end
    }
}