
import "std/string"

@raw("""
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <arpa/inet.h>


typedef struct sockaddr sockaddr;
typedef struct sockaddr_in sockaddr_in;
""");

@foreign
typedef void as socklen_t;

@foreign
struct sockaddr {
    sa_family: i32
    sa_data: [14]char
}

@foreign
struct sockaddr_in {
    sin_family: i32;     /* AF_INET */
    sin_port: u16;       /* Port number */
    sin_addr: in_addr;   /* IPv4 address */
};

@foreign
struct in_addr {
    s_addr: u64
};



@foreign
func socket(domain: i32, type: i32, protocol: i32) : i32;

@foreign
func bind(socket: i32, addr: *sockaddr, addrlen: socklen_t) : i32;

@foreign
func accept(socket: i32, addr: *sockaddr, addrlen: *socklen_t) : i32;

@foreign
func listen(socket: i32, backlog: i32) : i32;

@foreign
func recv(socket: i32, buf: *void, len: usize, flags: i32) : i64;

@foreign
func send(socket: i32, buf: *void, len: usize, flags: i32) : i64;

@foreign
func close(socket: i32) : i32;

@foreign
const AF_INET: i32;

@foreign
const AF_INET6: i32;

@foreign
const SOCK_STREAM: i32;

@foreign
const SOCK_DGRAM: i32;

@foreign
const SOCK_NONBLOCK: i32;

@foreign
const INET_ADDRSTRLEN: i32;

@foreign
const INADDR_ANY: i32;

@foreign
func htonl(hostlong: u32) : u32;

@foreign
func htons(hostshort: u16) : u16;

@foreign
func ntohl(netlong: u32) : u32;

@foreign
func ntohs(netshort: u16) : u16;

@foreign
func inet_pton(af: i32, src: *const char, dst: *void): i32;

@foreign
func inet_ntop(af: i32, src: *const void, dst: *void, size: socklen_t): *const char;

/*
===================================================
Address API
===================================================
*/

public const MAX_ADDRESS_SIZE = INET_ADDRSTRLEN;

public enum AddressType {
    IPV4,
    IPV6,
}

public enum SocketType {
    DATAGRAM,
    STREAM,
}

public struct SocketAddress {
    type: AddressType;
    address: [MAX_ADDRESS_SIZE]char
    port: i32

    // internal implementation information
    addr: sockaddr_in
}

public func FromIPAddress(ip: *const char, port: u16, result: *SocketAddress) : *SocketAddress {
    memset(&result.addr, 0, sizeof(result.addr))
    if(inet_pton(AF_INET, ip, (&result.addr.sin_addr) as (*void)) < 0) {
        return null
    }

    StringCopy(.src = ip, .dest = result.address, .size = MAX_ADDRESS_SIZE)
    result.port = port
    result.type = AddressType.IPV4

    result.addr.sin_family = AF_INET
    result.addr.sin_port = htons(port)

    return result
}

public func FromPort(port: u16, result: *SocketAddress) : *SocketAddress {
    StringCopy(.src = "0.0.0.0", .dest = result.address, .size = MAX_ADDRESS_SIZE)
    result.port = port
    result.type = AddressType.IPV4

    memset(&result.addr, 0, sizeof(result.addr))
    result.addr.sin_family = AF_INET
    result.addr.sin_addr.s_addr = INADDR_ANY
    result.addr.sin_port = htons(port)

    return result
}

public func (this: *SocketAddress) toString() : *const char {
    @static var buffer:[INET_ADDRSTRLEN]char;
    inet_ntop(AF_INET, &this.addr.sin_addr, buffer, INET_ADDRSTRLEN);
}

/*
===================================================
Socket API
===================================================
*/

public struct Socket {
    socket: i32
    address: SocketAddress
}

public func (this: *Socket) create(type: SocketType = SocketType.STREAM) : bool {
    var sck = type == SocketType.STREAM ? SOCK_STREAM : SOCK_DGRAM;

    this.socket = socket(AF_INET, sck, 0)
    return this.socket > -1
}

public func (this: *Socket) bind() : bool {
    var addr = (&this.address.addr) as (*sockaddr);
    var len = sizeof(this.address.addr) as (socklen_t);
    return bind(this.socket, addr, len) > -1
}

public func (this: *Socket) listen(backlog: i32 = 128) : bool {
    return listen(this.socket, backlog) > -1
}

public func (this: *Socket) accept(clientSocket: *Socket) : *Socket {
    var socketLen: socklen_t = sizeof(clientSocket.address.addr) as (socklen_t)
    var addr = (&clientSocket.address.addr) as (*sockaddr)


    clientSocket.socket = accept(this.socket, addr, &socketLen)
    if(clientSocket.socket < 0) {
        return null
    }

    inet_ntop(AF_INET, &clientSocket.address.addr.sin_addr, clientSocket.address.address, INET_ADDRSTRLEN);
    clientSocket.address.port = ntohs(clientSocket.address.addr.sin_port)

    return clientSocket
}

public func (this: *Socket) read(buffer: *void, len: usize) : i64 {
    return recv(this.socket, buffer, len, 0)
}

public func (this: *Socket) write(buffer: *void, len: usize) : i64 {
    return send(this.socket, buffer, len, 0)
}

public func (this: *Socket) close() {
    close(this.socket)
}

import "std/assert"
import "std/libc"

@test
func testSockets() {
    var serverSocket:Socket;
    if(!serverSocket.create()) {
        printf("Unable to create socket!\n")
        return;
    }

    defer serverSocket.close();


    assert(FromPort(8083_u16, &serverSocket.address))
    var addr = serverSocket.address

    if(!serverSocket.bind()) {
        printf("Unable to bind to address: %s:%d -> errono: %d\n", addr.address, addr.port, errno)
        perror("bind")
        return;
    }


    if(!serverSocket.listen()) {
        printf("Unable to listen on address: %s:%d\n", addr.address, addr.port)
        return;
    }

    printf("Listening on port: %d\n", addr.port)

    const BUFFER_SIZE = 1024;
    var buffer:[BUFFER_SIZE]char;

    while(true) {
        var clientSocket: Socket;
        defer clientSocket.close();

        if(!serverSocket.accept(&clientSocket)) {
            printf("Failed to connect client\n")
            perror("accept")
            continue;
        }
        printf("Client connected!\n")

        var bytesReceived: i64;
        do {
            bytesReceived = clientSocket.read(buffer, BUFFER_SIZE);
            if(bytesReceived > 0) {
                printf("Received '%.*s'\n", bytesReceived as (i32), buffer)

                var echo = "Server says: ";
                clientSocket.write(echo as (*void), strlen(echo))
                clientSocket.write(buffer, bytesReceived)
            }
        }
        while(bytesReceived > 0);
    }

}

/**
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define MAX_BUFFER_SIZE 1024

int main() {
    int server_socket, client_socket;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_addr_len = sizeof(client_addr);
    char buffer[MAX_BUFFER_SIZE];

    // Create socket
    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }

    // Initialize server address struct
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    // Bind the socket
    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        perror("Binding failed");
        close(server_socket);
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    if (listen(server_socket, 5) == -1) {
        perror("Listening failed");
        close(server_socket);
        exit(EXIT_FAILURE);
    }

    printf("Server listening on port %d...\n", PORT);

    while (1) {
        // Accept a connection from a client
        if ((client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &client_addr_len)) == -1) {
            perror("Acceptance failed");
            continue;
        }

        printf("Connection accepted from %s:%d\n", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));

        // Receive and echo back data
        ssize_t bytes_received;
        while ((bytes_received = recv(client_socket, buffer, sizeof(buffer), 0)) > 0) {
            buffer[bytes_received] = '\0'; // Null-terminate the received data
            printf("Received: %s", buffer);

            // Echo back to the client
            send(client_socket, buffer, bytes_received, 0);
        }

        if (bytes_received == 0) {
            printf("Client disconnected.\n");
        } else if (bytes_received == -1) {
            perror("Receiving failed");
        }

        // Close the client socket
        close(client_socket);
    }

    // Close the server socket
    close(server_socket);

    return 0;
}
*/