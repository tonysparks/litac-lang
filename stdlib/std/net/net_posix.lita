
import "std/string"
import "std/net"
import "std/libc"

@raw("""
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <arpa/inet.h>


typedef struct sockaddr sockaddr;
typedef struct sockaddr_in sockaddr_in;
""");

@foreign
typedef void as socklen_t;

@foreign
struct sockaddr {
    sa_family: i32
    sa_data: [14]char
}

@foreign
struct sockaddr_in {
    sin_family: i32;     /* AF_INET */
    sin_port: u16;       /* Port number */
    sin_addr: in_addr;   /* IPv4 address */
};

@foreign
struct in_addr {
    s_addr: u64
};

@foreign
const SO_DEBUG:i32
@foreign
const SO_BROADCAST:i32
@foreign
const SO_REUSEADDR:i32
@foreign
const SO_KEEPALIVE:i32
@foreign
const SO_LINGER:i32
@foreign
const SO_OOBINLINE:i32
@foreign
const SO_SNDBUF:i32
@foreign
const SO_RCVBUF:i32
@foreign
const SO_DONTROUTE:i32
@foreign
const SO_RCVLOWAT:i32
@foreign
const SO_RCVTIMEO:i32
@foreign
const SO_SNDLOWAT:i32
@foreign
const SO_SNDTIMEO:i32

@foreign
const SOL_SOCKET:i32


@foreign
const MSG_CONFIRM:i32
@foreign
const MSG_DONTROUTE:i32
@foreign
const MSG_DONTWAIT:i32
@foreign
const MSG_EOR:i32
@foreign
const MSG_MORE:i32
@foreign
const MSG_NOSIGNAL:i32
@foreign
const MSG_OOB:i32
@foreign
const MSG_FASTOPEN:i32

@generated
public enum SocketFlags {
    MSG_CONFIRM     = MSG_CONFIRM,
    MSG_DONTROUTE   = MSG_DONTROUTE,
    MSG_DONTWAIT    = MSG_DONTWAIT,
    MSG_EOR         = MSG_EOR,
    MSG_MORE        = MSG_MORE,
    MSG_NOSIGNAL    = MSG_NOSIGNAL,
    MSG_OOB         = MSG_OOB,
    MSG_FASTOPEN    = MSG_FASTOPEN,
}


@foreign
func socket(domain: i32, type: i32, protocol: i32) : i32;

@foreign
func bind(socket: i32, addr: *sockaddr, addrlen: socklen_t) : i32;

@foreign
func accept(socket: i32, addr: *sockaddr, addrlen: *socklen_t) : i32;

@foreign
func listen(socket: i32, backlog: i32) : i32;

@foreign
func recv(socket: i32, buf: *void, len: usize, flags: i32) : i64;

@foreign
func send(socket: i32, buf: *void, len: usize, flags: i32) : i64;

@foreign
func setsockopt(socket: i32, level: i32, option_name: i32, option_value: *const void, option_len: socklen_t) : i32;

@foreign
func close(socket: i32) : i32;

@foreign
const AF_INET: i32;

@foreign
const AF_INET6: i32;

@foreign
const SOCK_STREAM: i32;

@foreign
const SOCK_DGRAM: i32;

@foreign
const SOCK_NONBLOCK: i32;

@foreign
const INET_ADDRSTRLEN: i32;

@foreign
const INADDR_ANY: i32;

@foreign
func htonl(hostlong: u32) : u32;

@foreign
func htons(hostshort: u16) : u16;

@foreign
func ntohl(netlong: u32) : u32;

@foreign
func ntohs(netshort: u16) : u16;

@foreign
func inet_pton(af: i32, src: *const char, dst: *void): i32;

@foreign
func inet_ntop(af: i32, src: *const void, dst: *void, size: socklen_t): *const char;

/*
===================================================
Address API
===================================================
*/

@generated
public const MAX_ADDRESS_SIZE = INET_ADDRSTRLEN;

@generated
public struct SocketAddress {
    type: AddressType;
    _address: [MAX_ADDRESS_SIZE]char
    _port: u16

    // internal implementation information
    addr: sockaddr_in
}

@generated
public func FromIPAddress(ip: *const char, port: u16, result: *SocketAddress) : *SocketAddress {
    memset(&result.addr, 0, sizeof(result.addr))
    if(inet_pton(AF_INET, ip, (&result.addr.sin_addr) as (*void)) < 0) {
        return null
    }

    StringCopy(.src = ip, .dest = result._address, .size = MAX_ADDRESS_SIZE)
    result._port = port
    result.type = AddressType.IPV4

    result.addr.sin_family = AF_INET
    result.addr.sin_port = htons(port)

    return result
}

@generated
public func FromPort(port: u16, result: *SocketAddress) : *SocketAddress {
    StringCopy(.src = "0.0.0.0", .dest = result._address, .size = MAX_ADDRESS_SIZE)
    result._port = port
    result.type = AddressType.IPV4

    memset(&result.addr, 0, sizeof(result.addr))
    result.addr.sin_family = AF_INET
    result.addr.sin_addr.s_addr = INADDR_ANY
    result.addr.sin_port = htons(port)

    return result
}

@generated
public func (this: *SocketAddress) address(): *const char {
    return this._address;
}

@generated
public func (this: *SocketAddress) port(): u16 {
    return this._port
}

public func (this: *SocketAddress) toString() : *const char {
    @static var buffer:[INET_ADDRSTRLEN]char;
    inet_ntop(AF_INET, &this.addr.sin_addr, buffer, INET_ADDRSTRLEN);
    return buffer
}

/*
===================================================
Socket API
===================================================
*/

@generated
public struct Socket {
    socket: i32
    address: SocketAddress
}

@generated
public func (this: *Socket) create(type: SocketType = SocketType.STREAM) : bool {
    var sck = type == SocketType.STREAM ? SOCK_STREAM : SOCK_DGRAM;

    this.socket = socket(AF_INET, sck, 0)
    return this.socket > -1
}

@generated
public func (this: *Socket) socketAddress() : *SocketAddress {
    return &this.address
}

@generated
public func (this: *Socket) bind() : bool {
    var addr = (&this.address.addr) as (*sockaddr);
    var len = sizeof(this.address.addr) as (socklen_t);
    return bind(this.socket, addr, len) > -1
}

@generated
public func (this: *Socket) listen(backlog: i32 = 128) : bool {
    return listen(this.socket, backlog) > -1
}

@generated
public func (this: *Socket) accept(clientSocket: *Socket) : *Socket {
    var socketLen: socklen_t = sizeof(clientSocket.address.addr) as (socklen_t)
    var addr = (&clientSocket.address.addr) as (*sockaddr)


    clientSocket.socket = accept(this.socket, addr, &socketLen)
    if(clientSocket.socket < 0) {
        return null
    }

    inet_ntop(AF_INET, &clientSocket.address.addr.sin_addr, clientSocket.address._address, INET_ADDRSTRLEN);
    clientSocket.address._port = ntohs(clientSocket.address.addr.sin_port)

    return clientSocket
}

@generated
public func (this: *Socket) setSocketOpt(option: SocketOption, value: *const void, len: usize) : i32 {
    var nativeOption = 0
    switch(option) {
        case SocketOption.SO_DEBUG: nativeOption = SO_DEBUG; break;
        case SocketOption.SO_BROADCAST: nativeOption = SO_BROADCAST; break;
        case SocketOption.SO_REUSEADDR: nativeOption = SO_REUSEADDR; break;
        case SocketOption.SO_KEEPALIVE: nativeOption = SO_KEEPALIVE; break;
        case SocketOption.SO_LINGER: nativeOption = SO_LINGER; break;
        case SocketOption.SO_OOBINLINE: nativeOption = SO_OOBINLINE; break;
        case SocketOption.SO_SNDBUF: nativeOption = SO_SNDBUF; break;
        case SocketOption.SO_RCVBUF: nativeOption = SO_RCVBUF; break;
        case SocketOption.SO_DONTROUTE: nativeOption = SO_DONTROUTE; break;
        case SocketOption.SO_RCVLOWAT: nativeOption = SO_RCVLOWAT; break;
        case SocketOption.SO_RCVTIMEO: nativeOption = SO_RCVTIMEO; break;
        case SocketOption.SO_SNDLOWAT: nativeOption = SO_SNDLOWAT; break;
        case SocketOption.SO_SNDTIMEO: nativeOption = SO_SNDTIMEO; break;
        default: return -1;
    }
    return setsockopt(this.socket, SOL_SOCKET, nativeOption, value, len as (socklen_t))
}

@generated
public func (this: *Socket) read(buffer: *void, len: usize) : i64 {
    return recv(this.socket, buffer, len, 0)
}

@generated
public func (this: *Socket) write(buffer: *void, len: usize, flags: i32 = 0) : i64 {
    return send(this.socket, buffer, len, flags)
}

@generated
public func (this: *Socket) handle() : i32 {
    return this.socket
}

@generated
public func (this: *Socket) close() {
    close(this.socket)
}
