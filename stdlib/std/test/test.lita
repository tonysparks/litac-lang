import "std/array"
import "std/mem"
import "std/string"
import "std/string/builder"
import "std/libc"
import "std/assert"
import "std/terminal"

@include("<setjmp.h>");

@foreign
public struct jmp_buf;

@foreign
func longjmp(env: jmp_buf, result: i32);

@foreign
public func setjmp(env: jmp_buf) : i32;

public var testSuite = TestSuite{}

public struct AssertEntry {
    filename: *const char
    lineNumber: usize
    errorMessage: *const char
}

public struct TestSuite {
    allocator: *const Allocator
    testCases: Array<TestCase>
    currentCase: *TestCase
    env: jmp_buf        // jump to the next test

    dynamicTestCases: Array<TestCase>
    index: i32
}

public struct TestCase {
    testSuite: *TestSuite
    errors: Array<AssertEntry>

    name: *const char
    userData: *void
    testFn: func(testCase: *TestCase, userData: *void) : void;
    cleanupFn: func(testCase: *TestCase, userData: *void) : void;
}


public func (this: *TestSuite) init(allocator: *const Allocator = defaultAllocator) {
    this.allocator = allocator
    this.testCases = ArrayInit<TestCase>(64, allocator)
    this.dynamicTestCases = ArrayInit<TestCase>(64, allocator)
    this.index = 0
}

public func (this: *TestSuite) free() {
    for(var i = 0; i < this.testCases.size(); i+=1) {
        var t = this.testCases.get(i)
        t.free()
    }
    this.testCases.free()

    for(var i = 0; i < this.dynamicTestCases.size(); i+=1) {
        var t = this.dynamicTestCases.get(i)
        t.free()
    }
    this.dynamicTestCases.free()
}

public func (this: *TestSuite) enterTest() : *TestCase {
    this.testCases.add(
        TestCase{}
    )
    this.currentCase = this.testCases.lastPtr()
    this.currentCase.init(this)
    return this.currentCase
}


public func (this: *TestSuite) addDynamicTest(
    name: *const char,
    userData: *void,
    testFn: func(testCase: *TestCase, userData: *void) : void,
    cleanupFn: func(testCase: *TestCase, userData: *void) : void = null
) : *TestCase {
    this.dynamicTestCases.add(
        TestCase{}
    )
    var testCase = this.dynamicTestCases.lastPtr()
    testCase.init(this)
    testCase.name = name
    testCase.userData = userData
    testCase.testFn = testFn
    testCase.cleanupFn = cleanupFn
    return testCase
}

public func (this: *TestSuite) enterDynamicTest() : *TestCase {
    if(this.index >= this.dynamicTestCases.size() || this.index < 0) {
        return null
    }
    this.currentCase = this.dynamicTestCases.getPtr(this.index)
    this.index += 1
    return this.currentCase
}

public func (this: *TestSuite) executeDynamicTest() {
    if(!this.currentCase || !this.currentCase.testFn) {
        return;
    }

    this.currentCase.testFn(this.currentCase, this.currentCase.userData)
    if(this.currentCase.cleanupFn) {
        this.currentCase.cleanupFn(this.currentCase, this.currentCase.userData)
    }
}

public func (this: *TestSuite) printDynamicTest() {
    if(!this.currentCase || !this.currentCase.testFn) {
        return;
    }

    this.currentCase.print(this.currentCase.name)
}



public func (this: *TestCase) init(testSuite: *TestSuite) {
    this.testSuite = testSuite
    this.errors = ArrayInit<AssertEntry>(32, testSuite.allocator)
}

public func (this: *TestCase) free() {
    this.errors.free()
}

public func (this: *TestCase) reset() {
    this.errors.clear()
}

public func (this: *TestCase) addError(
    error: *const char,
    filename: *const char = __FILE__,
    lineNumber: usize = __LINE__
) {
    this.errors.add(
        AssertEntry {
            .filename = filename,
            .lineNumber = lineNumber,
            .errorMessage = error
        }
    )
}


public func (this: *TestCase) print(name: *const char) {
    var resultText =
        this.errors.empty() ? "SUCCESS" : "FAILED"

    var dots = $"..............................................................."
    var nDots = MAX(0, dots.length - name.length() - resultText.length())

    var resultColor =
        this.errors.empty() ? ConsoleColors.GREEN : ConsoleColors.RED

    printf(
        "Testing '%s'",
        name
    )
    printf(
        "%.*s",
        nDots,
        dots.buffer
    )
    printf(
        "%s%s%s\n",
        ConsoleColorsAsStr(resultColor),
        resultText,
        ConsoleColorsAsStr(ConsoleColors.CLEAR)
    )
    for(var i = 0; i < this.errors.size(); i +=1) {
        printf("%s\n", this.errors.get(i).errorMessage)
    }
}


public func AssertCStr(
    expected: *const char,
    actual: *const char,
    filename: *const char = __FILE__,
    lineNumber: usize = __LINE__
) {
    Assert(
        StringEqual(expected, actual),
        filename,
        lineNumber
    )
}


public func AssertFloat<F>(
    expected: F,
    actual: F,
    tolerance: F = 0.01f64,
    filename: *const char = __FILE__,
    lineNumber: usize = __LINE__
) {
    const r = ABS(expected - actual)
    Assert(
        r <= tolence,
        filename,
        lineNumber
    )
}


public func Assert(
    cond: bool,
    filename: *const char = __FILE__,
    lineNumber: usize = __LINE__
) {
    if(!testSuite.allocator) {
        testSuite.init(defaultAllocator)
        testSuite.enterTest()
    }

    if(!cond) {
        var sb = StringBuilderInit(256, testSuite.allocator)
        sb.append(
            "%s:%zu: Assertion failed",
            filename,
            lineNumber
        )
        testSuite.currentCase.errors.add(
            AssertEntry {
                .filename = filename,
                .lineNumber = lineNumber,
                .errorMessage = sb.cStr()
            }
        )
        // jump to the next test case, we've failed this one
        longjmp(testSuite.env, 1)
    }
}
