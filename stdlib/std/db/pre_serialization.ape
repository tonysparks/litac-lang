

fn getColumnName(field) {
    if(field.notes) {
        for(note in field.notes) {
            if(note.name == "column") {
                for(arg in note.arguments) {
                    if(arg.name == "name") {
                        return arg.value
                    }
                }
            }
        }
    }
    return field.name
}

fn getColumnType(field) {
    if(field.notes) {
        for(note in field.notes) {
            if(note.name == "column") {
                for(arg in note.arguments) {
                    if(arg.name == "columnType") {
                        return arg.value
                    }
                }
            }
        }
    }
    return null
}

fn getTableName(sym) {
    var tableName = sym.name
    if(sym.notes) {
        for(note in sym.notes) {
            if(note.name == "table") {
                for(arg in note.arguments) {
                    if(arg.name == "name") {
                        return arg.value
                    }
                }
            }
        }
    }
    return tableName
}

fn getColumnTypeDriverName(field) {
    var result = getColumnType(field)
    if(result != null) {
        return result
    }

    // TODO: the names are not fully qualified!!
    var typeInfo = field.typeInfo
    if(typeInfo == null) {
        error(`TypeInfo is null for ${field}`)
        return null
    }
    if(typeInfo.isString) {
        return "Text"
    }

    if(typeInfo.isPrimitive || typeInfo.isEnum) {
        if(typeInfo.kind == "F64" || typeInfo.kind == "F32") {
            return "Double"
        }
        if(typeInfo.kind == "I64") {
            return "Int64"
        }
        return "Int32"
    }

      if(typeInfo.name == "DateTime") {
        return "DateTime"
      }

//    if(typeInfo.name == "std::builtin::String") {
//        return "String"
//    }

//    if(typeInfo.name == "std::time::Date" ||
//       typeInfo.name == "std::time::Time"
//    ) {
//        return "String"
//    }

    // TODO: Expose this thru API?
    // TODO: UUID type
    // TODO: JSON type
    return "String"
}

fn isString(columnType) {
    if(columnType == null) {
        return false
    }
    if(columnType == "String" || columnType == "Text") {
        return true
    }
    return false
}


fn getIdField(sym, fields) {
    // TODO error if no @id ??
    if(fields == null) {
        error(`No fields defined for ${sym.name}`)
        return null
    }

    var idField = null
    for(field in fields) {
        if(field.notes) {
            for(note in field.notes) {
                if(note.name == "id") {
                    var autogenerated = false
                    for(arg in note.arguments) {
                        if(arg.name == "autogenerated") {
                            autogenerated = arg.value != 0
                        }
                    }
                    return {
                        "field": field,
                        "autogenerated": autogenerated,
                        "name": getColumnName(field),
                        "type": getColumnTypeDriverName(field)
                    }
                }
            }
        }
    }

    error(`No @id field defined for ${sym.name}`)
    return null
}

fn EmitDBFunctions(sym) {
    if(sym.kind != "STRUCT_DECL") {
        return;
    }

    var structDecl = sym.structDecl

    var tableName = getTableName(sym)
    var idField = getIdField(sym, structDecl.fields)
    var idName = idField.name

    // INSERT
    {
        emit(
            `
            public func (this: *${sym.name}) getSqlInsert(): String {
                return
                    $"""
                    INSERT INTO ${tableName}
                    (`
        )
        emit(`\n`)
        var isFirst = true
        for(field in structDecl.fields) {
            if(field == idField.field && idField.autogenerated) {
                continue
            }

            if(!isFirst) {
                emit(`,\n`)
            }
            emit(`                        ${getColumnName(field)}`)
            isFirst = false
        }
        emit(`\n                    ) VALUES (\n`)

        isFirst = true
        for(field in structDecl.fields) {
            if(field == idField.field && idField.autogenerated) {
                continue
            }

            if(!isFirst) {
                emit(`,\n`)
            }
            // emit(`                        :${getColumnName(field)}`)
            emit(`                        ?`)
            isFirst = false
        }
        emit(`\n                    );"""`)
        emit(
            `
            }
            `
        )
    }

    // SELECT ONE
    {
        emit(
            `
            public func (this: *${sym.name}) getSqlSelectOneById(): String {
                return
                    $"""
                    SELECT`
        )
        emit(`\n`)
        var isFirst = true
        for(field in structDecl.fields) {
            if(!isFirst) {
                emit(`,\n`)
            }
            emit(`                        ${getColumnName(field)}`)
            isFirst = false
        }
        emit(`\n                    FROM ${tableName}`)
        emit(`\n                    WHERE ${idName} = ?;"""`)
        emit(
            `
            }
            `
        )
    }

    // SELECT
    {
        emit(
            `
            public func (this: *${sym.name}) getSqlSelect(): String {
                return
                    $"""
                    SELECT`
        )
        emit(`\n`)
        var isFirst = true
        for(field in structDecl.fields) {
            if(!isFirst) {
                emit(`,\n`)
            }
            emit(`                        ${getColumnName(field)}`)
            isFirst = false
        }
        emit(`\n                    FROM ${tableName}"""`)
        emit(
            `
            }
            `
        )
    }

    // SELECT ALIAS
    {
        emit(
            `
            public func (this: *${sym.name}) getSqlSelectWithAlias(
                sb: *StringBuilder,
                alias: String
            ) {
                sb.append(
                    """
                    SELECT`
        )
        emit(`\n`)

        var isFirst = true
        var count = 1
        for(field in structDecl.fields) {
            if(!isFirst) {
                emit(`,\n`)
            }
            emit(`                        %%.*s.${getColumnName(field)}`)
            isFirst = false
            count += 1
        }
        emit(`\n                    FROM ${tableName} AS %%.*s.""",\n`)
        isFirst = true
        for(var i = 0; i < count; i++) {
            if(!isFirst) {
                emit(`,\n`)
            }
            emit(`                alias.length, alias.buffer`)
            isFirst =false
        }
        emit(
            `)
            }
            `
        )
    }

    // DELETE ONE
    {
        emit(
            `
            public func (this: *${sym.name}) getSqlDeleteOneById(): String {
                return
                    $"""
                    DELETE`
        )
        emit(`\n`)
        emit(`\n                    FROM ${tableName}`)
        emit(`\n                    WHERE ${idName} = :id;"""`)
        emit(
            `
            }
            `
        )
    }

    // DELETE
    {
        emit(
            `
            public func (this: *${sym.name}) getSqlDelete(): String {
                return
                    $"""
                    DELETE`
        )
        emit(`\n                    FROM ${tableName}"""`)
        emit(
            `
            }
            `
        )
    }

    // UPDATE ONE
    {
        emit(
            `
            public func (this: *${sym.name}) getSqlUpdateOneById(): String {
                return
                    $"""
                    UPDATE ${tableName}
                    SET`
        )
        emit(`\n`)
        var isFirst = true
        for(field in structDecl.fields) {
            if(!isFirst) {
                emit(`,\n`)
            }
            emit(`                        ${getColumnName(field)} = :${getColumnName(field)}`)
            isFirst = false
        }
        emit(`\n                    WHERE ${idName} = :id;"""`)
        emit(
            `
            }
            `
        )
    }

    ////////////////////////////////////////
    // API functions
    ////////////////////////////////////////

    // fromResultSet
    {
        emit(
            `
            public func (this: *${sym.name}) fromResultSet(
                resultSet: *SqlResultSet,
                fromIndex: i32,
                sb: *StringBuilder
            ) : i32 {
                var len = 0
            `
        )

        for(field in structDecl.fields) {
            var columnType = getColumnTypeDriverName(field)
            var columnName = getColumnName(field)
            if(isString(columnType)) {
                emit(
                `
                len = sb.append("s", resultSet.column${columnType}(fromIndex += 1))
                this.${columnName} = sb.substring(sb.length - len, sb.length)
                `
                )
            } else {
                emit(
                `
                this.${columnName} = resultSet.column${columnType}(fromIndex += 1)
                `
                )
            }
        }

        emit(
            `
                return fromIndex
            }
            `
        )
    }

    // bindId
    {
        var idFieldColumnType = idField.type
        emit(
            `
            public func (this: *${sym.name}) bindId(
                stmt: *SqlStatement,
                id: ${idField.field.typeInfo.name},
                fromIndex: i32
            ) : i32 {
                stmt.bind${idFieldColumnType}(fromIndex += 1, id)
                return fromIndex
            }
            `
        )
    }

    // bindIdValue
    {
        var idFieldColumnType = idField.type
        emit(
            `
            public func (this: *${sym.name}) bindIdValue(
                stmt: *SqlStatement,
                fromIndex: i32
            ) : i32 {
                stmt.bind${idFieldColumnType}(fromIndex += 1, this.${idField.name})
                return fromIndex
            }
            `
        )
    }

    // bindValues
    {
        emit(
            `
            public func (this: *${sym.name}) bindValues(
                stmt: *SqlStatement
            ) : i32 {
                var index = 0
            `
        )

        for(field in structDecl.fields) {
            var columnType = getColumnTypeDriverName(field)
            var columnName = getColumnName(field)

            if(field == idField.field && idField.autogenerated) {
                continue
            }

            emit(
                `
                stmt.bind${columnType}(index += 1, this.${columnName})
                `
            )

        }
        emit(
            `
                return index
            }
            `
        )
    }

    return true
}

fn DBSymbols(sym) {
   if(sym.kind == "STRUCT_DECL" || sym.kind == "ENUM_DECL") {
      return EmitDBFunctions(sym)
   }
   return false
}

var symbols = getSymbolsByNote("table")
for(sym in symbols) {
   emitClear()

   if(DBSymbols(sym)) {
      //println(emitStr() + " in module: " + sym.moduleFilename)
      //replaceDeclaration(sym.moduleFilename, emitStr())
      addDeclaration(sym.moduleFilename, emitStr())
   }
}
