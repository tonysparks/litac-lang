
import "std/libc"
import "std/mem"
import "std/mem/bucket_allocator"
import "std/string"
import "std/string/builder"
import "std/string/buffer"
import "std/array"

import "std/db"
import "std/db/sqlite"
import "std/db/sqlite/sqlite_db"
import "std/db/orm"

@table(
    .name = "team"
)
public struct Team {
    @id(.autogenerated = true)
    @column
    id: i64

    @column
    name: String

    @column
    city: String

    @column
    state: String
}

import "std/assert"

@test
func testDatabase() {
    var allocator = BucketAllocator{}
    allocator.init(defaultAllocator, 32)
    defer allocator.free()

    var conn = SqliteConnection{};
    defer conn.close()

    Connect(
        ":memory:",
        &conn,
        SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE,
        true,
        &allocator.allocator
    )

    conn.execute(
        """
        CREATE TABLE IF NOT EXISTS team (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            city TEXT NOT NULL,
            state TEXT NOT NULL
        );
        """
    )

    conn.begin()
    conn.execute(
        """
        INSERT INTO
            team (name, city, state)
        VALUES
            ('Green Bay Packers', 'Green Bay', 'WI'),
            ('Chicago Bears', 'Chicago', 'IL'),
            ('Minnesota Vikings', 'Minneapolis', 'MN'),
            ('Detroit Lions', 'Detroit', 'MI');
        """
    )

    if(conn.commit().isError()) {
        var error = conn.lastError()
        printf("Database error: '%.*s', rolling back\n", error.length, error.buffer)
        conn.rollback()
        assert(false)
    }

    assert(conn.lastResult().isOk())

    var resultSet: SqlResultSet
    // TODO: Fix
    //defer resultSet.closeAndReleaseAll()
    conn.connection.query(
        &resultSet,
        $"""
        select count(*)
        from team t
        where t.state = ?
        """,
        $"WI"
    )
    assert(resultSet.hasNext())
    resultSet.next()
    assert(resultSet.columnInt32(0))

    // Query By ORM for one
    {
        var packers = Team{}
        var result = conn.connection.queryOneById(&packers, 1)
        assert(result == 1)
        assert(packers.name.equals($"Green Bay Packers"))
        assert(packers.city.equals($"Green Bay"))
        assert(packers.state.equals($"WI"))
    }

    // Query via ORM for Many
    {
        var teams = ArrayInit<Team>(16, &allocator.allocator)
        var result = conn.connection.queryMany(
            &allocator.allocator,
            &teams,
            .alias = $"t",
            .sql = $"""
                where
                    t.state = ? or t.state = ?
                order by t.id
                """,
            $"WI",
            $"IL"
        )

        assert(result == 2)
        assert(teams.size() == 2)
        var packers = teams.getPtr(0)
        assert(packers.state.equals($"WI"))
        var bears = teams.getPtr(1)
        assert(bears.state.equals($"IL"))
    }

    // Insert via ORM many
    {
        var buc = Team {
            .name = $"Buccaneers",
            .city = $"Tampa Bay",
            .state = $"FL",
        }

        var falcons = Team {
            .name = $"Falcons",
            .city = $"Atlanta",
            .state = $"GA",
        }

        var newTeams = ArrayInit<Team>(2, &allocator.allocator)
        newTeams.add(buc)
        newTeams.add(falcons)

        var numOfInserts = conn.connection.insertMany(newTeams)
        assert(!conn.hasError())
        assert(numOfInserts == 2)

        var readTeams = ArrayInit<Team>(16, &allocator.allocator)
        conn.connection.queryMany(
            &allocator.allocator,
            &readTeams,
            .alias = $"t",
            .sql = $"where state in (?, ?) order by t.id",
            $"GA", $"FL"
        )
        assert(readTeams.size() == 2)
        var t1 = readTeams.get(0)
        assert(t1.state.equals($"FL"))
        var t2 = readTeams.get(1)
        assert(t2.state.equals($"GA"))

    }

    // Insert One, queryByOneId, deleteOneById
    {
        var panthers = Team {
            .name = $"Panthers",
            .city = $"Carolina",
            .state = $"SC",
        }
        // TODO: get the id generated... postgres and sqlite offer
        // different ways of doing this..
        var inserted = conn.connection.insertOne(&panthers)
        assert(inserted == 1)
        assert(conn.lastResult().isOk())

        var readTeams = ArrayInit<Team>(16, &allocator.allocator)
        conn.connection.queryMany(
            &allocator.allocator,
            &readTeams,
            .alias = $"t",
            .sql = $"where state = ?",
            $"SC"
        )
        assert(readTeams.size() == 1)
        var t1 = readTeams.getPtr(0)

        var result = Team{}
        var numRead = conn.connection.queryOneById(&result, t1.id)
        assert(numRead == 1)

        assert(result.id == t1.id)
        assert(result.name.equals(panthers.name))
        assert(result.city.equals(panthers.city))
        assert(result.state.equals(panthers.state))

        var numDeleted = conn.connection.deleteById<Team, i64>(t1.id)
        assert(numDeleted == 1)

        var result2 = Team{}
        numRead = conn.connection.queryOneById(&result2, t1.id)
        assert(numRead == 0)
    }

    /*
        // Query using raw SQL
    {
        var stmt = SqlStatement{}
        defer stmt.close()

        conn.prepare(
            &stmt,
            $"""
                SELECT
                    t.id,
                    t.name,
                    t.state,
                    t.city
                FROM team t
                WHERE t.state = :STATE
            """
        )

        var attempts = 0
        var results = SqlResultSet{}
        do {

            stmt.bindString(1, $"WI")
            stmt.execute(results)

            var i = 0
            while(results.hasNext()) {
                results.next()

                printf(
                    "%3d) id: %ld name: '%s', city: '%s', state: '%s'\n",
                    i += 1,
                    results.columnInt64(0),
                    results.columnText(1),
                    results.columnText(2),
                    results.columnText(3)
                )
            }

            stmt.reset()
            attempts += 1
        } while(attempts < 0);
    }

*/
}