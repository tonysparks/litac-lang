import "std/string/builder"
import "std/string/buffer"
import "std/string"
import "std/array"
import "std/mem"
import "std/libc"

import "std/db"

// ---------------------------------------------------------
// ORM API
// ---------------------------------------------------------
/*
public func (this: *SqlConnection) queryMany<T>(
    allocator: *const Allocator,
    result: *Array<T>,
    where: String,
    $...
) : i32 {
    if (this.hasError()) return 0

    // TODO: Handler memory much better!
    var sb = StringBuilderInit(1024, allocator)
    defer sb.free()

    var resultType = T{}
    var select = resultType.getSqlSelect()
    sb.append("%.*s WHERE %.*s",
        select.length, select.buffer,
        where.length, where.buffer
    )

    // var stmt = this.prepare(
    //     sb.toString()
    // )
    // if(!stmt) {
    //     return 0
    // }

    // defer stmt.close()
    var stmt: SqlStatement;
    this.prepare(
        &stmt,
        sb.toString()
    )
    defer stmt.close()

    if(this.hasError()) {
        return 0
    }

    var index = 1

    var list: va_list
    va_start(list, where)
    var vargs = va_arg<NativeVararg>(list)
    for(var i = 0; i < vargs.numberOfArgs; i+=1) {
        var typeid = vargs.args[i]
        switch(typeid) {
            case typeof(:bool):
            case typeof(:i8):
            case typeof(:u8):
            case typeof(:i16):
            case typeof(:u16):
            case typeof(:u32):
            case typeof(:i32): {
                stmt.bindInt32(index, va_arg<i32>(list))
                break
            }
            case typeof(:usize):
            case typeof(:u64):
            case typeof(:i64): {
                stmt.bindInt64(index, va_arg<i64>(list))
                break
            }
            case typeof(:f32):
            case typeof(:f64): {
                stmt.bindFloat64(index, va_arg<f64>(list))
                break
            }
            case typeof(:String): {
                var str = va_arg<String>(list)
                stmt.bindString(index, str)
                break
            }
            case typeof(:*const char):
            case typeof(""): {
                var str = va_arg<*const char>(list)
                stmt.bindText(index, str, strlen(str))
                break
            }
            case typeof(:DateTime): {
                var datetime = va_arg<DateTime>(list)
                stmt.bindDateTime(index, datetime)
                break
            }
            default: {
                var msg = StringBuilderInit(256, allocator)
                msg.append("Unsupported parameter type: %lu", typeid)
                this.setError(
                    SqlResult {
                        .type = SqlResultType.ERROR,
                        .description = msg.toString()
                    }
                )
                return 0
            }
        }
        index += 1
    }
    var output = StringBuilderInit(1024, allocator)

    var resultSet: SqlResultSet
    stmt.execute(&resultSet)

    while(resultSet.hasNext()) {
        result.add(T{})

        var row = result.lastPtr()
        row.fromResultSet(&resultSet, -1, &output)
    }

    return result.size()
}
*/
public func (this: *SqlConnection) queryMany<T>(
    allocator: *const Allocator,
    result: *Array<T>,
    alias: String,
    sql: String,
    $...
) : i32 {
    assert(allocator)

    if (this.hasError()) return 0

    // TODO: Handler memory much better!
    var sb = StringBuilderInit(1024, allocator)
    defer sb.free()

    var resultType = T{}
    resultType.getSqlSelectWithAlias(sb, alias)
    sb.append("  %.*s",
        sql.length, sql.buffer
    )

    var stmt: SqlStatement;
    this.prepare(
        &stmt,
        sb.toString()
    )
    defer stmt.close()

    if(this.hasError()) {
        return 0
    }

    var index = 1

    var list: va_list
    va_start(list, sql)
    var vargs = va_arg<NativeVararg>(list)
    for(var i = 0; i < vargs.numberOfArgs; i+=1) {
        var typeid = vargs.args[i]
        switch(typeid) {
            case typeof(:bool):
            case typeof(:i8):
            case typeof(:u8):
            case typeof(:i16):
            case typeof(:u16):
            case typeof(:u32):
            case typeof(:i32): {
                stmt.bindInt32(index, va_arg<i32>(list))
                break
            }
            case typeof(:usize):
            case typeof(:u64):
            case typeof(:i64): {
                stmt.bindInt64(index, va_arg<i64>(list))
                break
            }
            case typeof(:f32):
            case typeof(:f64): {
                stmt.bindFloat64(index, va_arg<f64>(list))
                break
            }
            case typeof(:String): {
                var str = va_arg<String>(list)
                stmt.bindString(index, str)
                break
            }
            case typeof(:*const char):
            case typeof(""): {
                var str = va_arg<*const char>(list)
                stmt.bindText(index, str, strlen(str))
                break
            }
            case typeof(:DateTime): {
                var datetime = va_arg<DateTime>(list)
                stmt.bindDateTime(index, datetime)
                break
            }
            default: {
                var msg = StringBuilderInit(256, allocator)
                msg.append("Unsupported parameter type: %lu", typeid)
                this.setError(
                    SqlResult {
                        .type = SqlResultType.ERROR,
                        .description = msg.toString()
                    }
                )
                return 0
            }
        }
        index += 1
    }
    var output = StringBuilderInit(1024, allocator)

    var resultSet: SqlResultSet
    stmt.execute(&resultSet)

    while(resultSet.hasNext()) {
        result.add(T{})

        var row = result.lastPtr()
        row.fromResultSet(&resultSet, -1, &output)
    }

    return result.size()
}

public func (this: *SqlConnection) queryOneById<T, ID>(
    result: *T,
    id: ID
) : i32 {
    if (this.hasError()) return 0

    var stmt: SqlStatement;
    this.prepare(
        &stmt,
        result.getSqlSelectOneById()
    )
    defer stmt.close()

    result.bindId(&stmt, id, 0)

    var resultSet: *SqlResultSet = null
    stmt.execute(&resultSet)

    if (!resultSet.hasNext()) {
        return 0
    }

    var sb = StringBuilderInit(1024, this.allocator)
    resultSet.next()
    result.fromResultSet(&resultSet, -1, &sb)

    return 1
}



/* ---------------------------------------------------
   Inserts
------------------------------------------------------ */

public func (this: *SqlConnection) insertMany<T>(
    items: *Array<T>
) : i32 {

    if (this.hasError()) return 0

    var resultType = T{}
    var stmt: SqlStatement;
    this.prepare(
        &stmt,
        resultType.getSqlInsert()
    )
    defer stmt.close()

    var inserts = 0
    for(var i = 0; i < items.size(); i +=1) {
        var item = items.get(i)
        item.bindValues(&stmt)

        if (stmt.step().isOk()) {
            inserts += 1
        }
        stmt.reset()
    }

    return inserts
}

public func (this: *SqlConnection) insertOne<T>(
    item: *T
) : i32 {
    if (this.hasError()) return 0

    var stmt: SqlStatement;
    this.prepare(
        &stmt,
        item.getSqlInsert()
    )
    defer stmt.close()

    item.bindValues(&stmt)

    var inserts = 0
    if (stmt.step().isOk()) {
        inserts += 1
    }

    return inserts
}


/* ---------------------------------------------------
   Delete
------------------------------------------------------ */

public func (this: *SqlConnection) deleteOne<T>(
    entity: *T
) : i32 {

    if (this.hasError()) return 0

    var stmt: SqlStatement;
    this.prepare(
        &stmt,
        entity.getSqlDeleteOneById()
    )
    defer stmt.close()

    entity.bindId(&stmt, entity.id, 0)

    var deletes = 0
    if (stmt.step().isOk()) {
        deletes += 1
    }

    return deletes
}

public func (this: *SqlConnection) deleteById<T, ID>(
    id: ID
) : i32 {

    if (this.hasError()) return 0

    var resultType = T{}
    var stmt: SqlStatement;
    this.prepare(
        &stmt,
        resultType.getSqlDeleteOneById()
    )
    defer stmt.close()

    resultType.bindId(&stmt, id, 0)

    var deletes = 0
    if (stmt.step().isOk()) {
        deletes += 1
    }

    return deletes
}

public func (this: *SqlConnection) deleteMany<T>(
    entities: *Array<T>
) : i32 {

    if (this.hasError()) return 0

    var resultType = T{}
    var stmt: SqlStatement;
    this.prepare(
        &stmt,
        resultType.getSqlDeleteOneById()
    )
    defer stmt.close()

    var deletes = 0
    for(var i = 0; i < entities.size(); i+=1) {
        var row = entities.get(i)
        row.bindIdValue(&stmt, 0)

        if (stmt.step().isOk()) {
            deletes += 1
        }
        stmt.reset()
    }

    return deletes
}


/* ---------------------------------------------------
   Update
------------------------------------------------------ */

public func (this: *SqlConnection) updateOne<T>(
    entity: *T
) : i32 {

    if (this.hasError() || entity == null) return 0

    var stmt: SqlStatement;
    this.prepare(
        &stmt,
        entity.getSqlUpdateOneById()
    )
    defer stmt.close()

    var index = entity.bindValues(&stmt)
    entity.bindIdValue(&stmt, index)

    var updates = 0
    if (stmt.step().isOk()) {
        updates += 1
    }

    return updates
}

public func (this: *SqlConnection) updateMany<T>(
    entities: *Array<T>
) : i32 {

    if (this.hasError() || entities == null || entities.empty()) return 0

    var entity = T{}
    var stmt: SqlStatement;
    this.prepare(
        &stmt,
        entity.getSqlUpdateOneById()
    )
    defer stmt.close()

    var updates = 0
    for(var i = 0; i < entities.size(); i+=1) {
        var row = entities.get(i)

        var index = row.bindValues(&stmt)
        row.bindIdValue(&stmt, index)

        if (stmt.step().isOk()) {
            updates += 1
        }
        stmt.reset()
    }

    return updates
}