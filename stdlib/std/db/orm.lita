import "std/string/builder"
import "std/string/buffer"
import "std/string"
import "std/array"
import "std/mem"
import "std/libc"

import "std/db"
import "std/db/sqlite"

public struct Team {
    id: i64
    name: String
    city: String
    state: String
}

public func (this: *Team) getSqlSelectOneById() : String {
    return
        $"""
        SELECT
            t.id,
            t.name,
            t.city,
            t.state
        FROM team t
        WHERE t.id = :ID
        """
}

public func (this: *Team) getSqlSelect() : String {
    return
        $"""
        SELECT
            t.id,
            t.name,
            t.city,
            t.state
        FROM team t
        """
}

public func (this: *Team) getSqlInsert() : String {
    return
        $"""
        INSERT INTO team
            (name, city, state)
        VALUES
            (:name, :city, :state);
        """
}

public func (this: *Team) getSqlDeleteOneById() : String {
    return
        $"""
        DELETE
        FROM team
        WHERE id = :id;
        """
}

public func (this: *Team) getSqlDelete() : String {
    return
        $"""
        DELETE
        FROM team
        """
}


public func (this: *Team) getSqlUpdateOneById() : String {
    return
        $"""
        UPDATE team
        SET
            name = ?,
            city = ?,
            state = ?
        WHERE
            id = :id;
        """
}

public func (this: *Team) fromResultSet(
    resultSet: *SqlResultSet,
    fromIndex: i32,
    allocator: *const Allocator
) : i32 {
    this.id = resultSet.columnInt64(fromIndex += 1)

    var sb = StringBuilderInit(1024, allocator)
    var len = 0

    len = sb.append("%s", resultSet.columnString(fromIndex += 1))
    this.name = sb.substring(sb.length - len, sb.length)

    len = sb.append("%s", resultSet.columnString(fromIndex += 1))
    this.city = sb.substring(sb.length - len, sb.length)

    len = sb.append("%s", resultSet.columnString(fromIndex += 1))
    this.state = sb.substring(sb.length - len, sb.length)

    return fromIndex
}

public func (this: *Team) bindId(
    stmt: *SqlStatement,
    id: i64,
    fromIndex: i32
) : i32 {
    stmt.bindInt64(fromIndex += 1, id)
    return fromIndex
}

public func (this: *Team) bindValues(
    stmt: *SqlStatement
) {
    var index = 0
    stmt.bindString(index += 1, this.name)
    stmt.bindString(index += 1, this.city)
    stmt.bindString(index += 1, this.state)
}


// ---------------------------------------------------------
// ORM API
// ---------------------------------------------------------

public func (this: *SqlConnection) queryMany<T>(
    result: *Array<T>,
    where: String,
    $...
) : SqlResult {

    if (this.hasError()) return this.error

    // TODO: Cache these prepared statements per entity type
    var stmt = SqlStatement{}
    defer stmt.close()

    var sb = StringBuilderInit(1024, this.allocator)
    defer sb.free()

    var resultType = T{}
    var select = resultType.getSqlSelect()
    sb.append("%.*s WHERE %.*s",
        select.length, select.buffer,
        where.length, where.buffer
    )

    this.prepare(
        &stmt,
        sb.toString()
    )

    var index = 1

    var list: va_list
    va_start(list, where)
    var vargs = va_arg<NativeVararg>(list)
    for(var i = 0; i < vargs.numberOfArgs; i+=1) {
        var typeid = vargs.args[i]
        switch(typeid) {
            case typeof(:bool):
            case typeof(:i8):
            case typeof(:u8):
            case typeof(:i16):
            case typeof(:u16):
            case typeof(:u32):
            case typeof(:i32): {
                stmt.bindInt32(index, va_arg<i32>(list))
                break
            }
            case typeof(:usize):
            case typeof(:u64):
            case typeof(:i64): {
                stmt.bindInt64(index, va_arg<i64>(list))
                break
            }
            case typeof(:f32):
            case typeof(:f64): {
                stmt.bindFloat64(index, va_arg<f64>(list))
                break
            }
            case typeof(:String): {
                var str = va_arg<String>(list)
                stmt.bindString(index, str)
                break
            }
            case typeof(:*const char):
            case typeof(""): {
                var str = va_arg<*const char>(list)
                stmt.bindText(index, str, strlen(str))
                break
            }
            default: {
                var msg = StringBuilderInit(256, this.allocator)
                msg.append("Unsupported parameter type: %lu", typeid)
                this.error = SqlResult {
                    .type = SqlResultType.ERROR,
                    .description = msg.toString()
                }
                return this.error
            }
        }
        index += 1
    }

    var resultSet = SqlResultSet{}
    stmt.execute(&resultSet)

    while(resultSet.hasNext()) {
        result.add(T{})

        var row = result.lastPtr()
        row.fromResultSet(&resultSet, -1, this.allocator)
    }

    stmt.reset()

    return this.error
}

public func (this: *SqlConnection) queryOneById<T, ID>(
    result: *T,
    id: ID
) : SqlResult {
    // TODO: Cache these prepared statements per entity type
    var stmt = SqlStatement{}
    defer stmt.close()

    this.prepare(
        &stmt,
        result.getSqlSelectOneById()
    )

    result.bindId(&stmt, id, 0)

    var resultSet = SqlResultSet{}
    stmt.execute(&resultSet)

    if (!resultSet.hasNext()) {
        return SqlResult {
            .type = SqlResultType.OK,
            .category = SqlResultCategory.EMPTY_RESULTS,
            .description = $"Empty result"
        }
    }

    resultSet.next()
    result.fromResultSet(&resultSet, -1, this.allocator)

    return this.error
}



/* ---------------------------------------------------
   Inserts
------------------------------------------------------ */

public func (this: *SqlConnection) insertMany<T>(
    items: *Array<T>
) : i32 {

    if (this.hasError()) return 0

    // TODO: Cache these prepared statements per entity type
    var stmt = SqlStatement{}
    defer stmt.close()

    var sb = StringBuilderInit(1024, this.allocator)

    var resultType = T{}
    var insert = resultType.getSqlInsert()
    sb.append("%.*s",
        insert.length, insert.buffer
    )

    this.prepare(
        &stmt,
        sb.toString()
    )

    var inserts = 0
    for(var i = 0; i < items.size(); i +=1) {
        var item = items.get(i)
        item.bindValues(&stmt)

        if (stmt.step() == SQLITE_DONE) {
            inserts += 1
        }
        stmt.reset()
    }

    return inserts
}


/* ---------------------------------------------------
   Delete
------------------------------------------------------ */

public func (this: *SqlConnection) deleteOne<T>(
    entity: *T
) : i32 {

    if (this.hasError()) return 0

    // TODO: Cache these prepared statements per entity type
    var stmt = SqlStatement{}
    defer stmt.close()

    var sb = StringBuilderInit(1024, this.allocator)
    var delete = entity.getSqlDeleteOneById()
    sb.append("%.*s",
        delete.length, delete.buffer
    )

    this.prepare(
        &stmt,
        sb.toString()
    )

    entity.bindId(&stmt, entity.id, 0)

    var deletes = 0
    if (stmt.step() == SQLITE_DONE) {
        deletes += 1
    }

    return deletes
}

public func (this: *SqlConnection) deleteById<T, ID>(
    id: ID
) : i32 {

    if (this.hasError()) return 0

    // TODO: Cache these prepared statements per entity type
    var stmt = SqlStatement{}
    defer stmt.close()

    var sb = StringBuilderInit(1024, this.allocator)

    var resultType = T{}
    var delete = resultType.getSqlDeleteOneById()
    sb.append("%.*s",
        delete.length, delete.buffer
    )

    this.prepare(
        &stmt,
        sb.toString()
    )

    resultType.bindId(&stmt, id, 0)

    var deletes = 0
    if (stmt.step() == SQLITE_DONE) {
        deletes += 1
    }

    return deletes
}

/*
public func (this: *SqlConnection) deleteMany<T>(
    entities: *Array<T>
) : i32 {

    if (this.hasError()) return 0

    // TODO: Cache these prepared statements per entity type
    var stmt = SqlStatement{}
    defer stmt.close()

    var sb = StringBuilderInit(1024, this.allocator)

    var resultType = T{}
    var delete = resultType.getSqlDeleteOneById()
    sb.append("%.*s",
        delete.length, delete.buffer
    )

    this.prepare(
        &stmt,
        sb.toString()
    )

    resultType.bindId(&stmt, id, 0)

    var deletes = 0
    if (stmt.step() == SQLITE_DONE) {
        deletes += 1
    }

    return deletes
}*/