import "std/string/builder"
import "std/string/buffer"
import "std/string"
import "std/mem"
import "std/mem/bucket_allocator"
import "std/array"
import "std/time"
import "std/libc"


#precheck
    "pre_serialization.ape"
#end


public @note table {
    schema: *const char
    name: *const char
}

public @note column {
    name: *const char
    nullable: bool = true
    length: i32 = -1
}

public @note sql {
    query: *const char
}

public @note id {
    autogenerated: bool
}

public enum SqlResultType {
    OK,
    ERROR,
}

public enum SqlResultCategory {
    NONE,
    EMPTY_RESULTS,
    OUT_OF_MEMORY,
}

public struct SqlResult {
    type: SqlResultType
    category: SqlResultCategory
    errorCode: i32
    description: String
}

public trait SqlConnection {
    getAllocator: func(): *const Allocator

    lastError: func(): String;
    lastResult: func(): SqlResult;
    hasError: func(): bool;
    clearError: func(): void;
    setError: func(error: SqlResult): void;

    execute: func(sql: *const char): SqlResult;
    // TODO: This stupid compiler author needs to figure out
    // how to get var args working for traits...idiot
    //query: func(sql: String, results: *SqlResultSet, $...): SqlResult;

    begin: func(): SqlResult;
    commit: func(): SqlResult;
    rollback: func(): SqlResult;

    prepare: func(stmt: *SqlStatement, sql: String): SqlResult;
    release: func(stmt: SqlStatement): SqlResult;
    close: func(): SqlResult;
}


public trait SqlStatement {
    bindBlob: func(index: i32, data: *const void, size: i32): SqlResult
    bindBlob64: func(index: i32, data: *const void, size: u64): SqlResult
    bindFloat64: func(index: i32, value: f64): SqlResult
    bindInt32: func(index: i32, value: i32): SqlResult
    bindInt64: func(index: i32, value: i64): SqlResult
    bindNull: func(index: i32): SqlResult
    bindPointer: func(index: i32, ptr: *void, type: *const char): SqlResult
    bindText: func(index: i32, data: *const char, len: i32): SqlResult
    bindText64: func(index: i32, data: *const char, len: u64, enc: u8): SqlResult
    bindString: func(index: i32, str: String): SqlResult
    bindDateTime: func(index: i32, dateTime: DateTime): SqlResult

    parameterCount: func() : i32
    parameterName: func(index: i32) : *const char
    parameterIndex: func(name: *const char) : i32
    clearBindings: func() : SqlResult

    step: func(): SqlResult
    reset: func(): SqlResult
    finalize: func(): SqlResult
    close: func(): SqlResult

    execute: func(results: *SqlResultSet): SqlResult
    release: func(results: SqlResultSet): SqlResult

    connection: func(): SqlConnection
}

public enum SqlColumnType {
    UNKNOWN,
    NULL,
    INT,
    BIGINT,
    STRING,
    TEXT,
    BLOB,
    DOUBLE,

    DATE,
    DATETIME,
    TIME,

    CUSTOM,
}

public trait SqlResultSet {
    hasNext: func() : bool
    next: func() : SqlResult
    columnCount: func() : i32
    columnBlob: func(column: i32) : *const void
    columnDouble: func(column: i32) : f64
    columnInt32: func(column: i32) : i32
    columnInt64: func(column: i32) : i64
    columnText: func(column: i32) : *const char
    columnString: func(column: i32) : String
    columnDateTime: func(column: i32) : DateTime
    columnType: func(column: i32) : SqlColumnType

    statement: func(): SqlStatement

    // Closes this result set, the statement and releases both
    closeAndReleaseAll: func(): SqlResult
}


public func (this: SqlResult) isError() : bool {
    return this.type == SqlResultType.ERROR
}

public func (this: SqlResult) isOk() : bool {
    return this.type == SqlResultType.OK
}

public func (this: SqlResult) isEmptyResults() : bool {
    return this.type == SqlResultType.OK &&
           this.category == SqlResultCategory.EMPTY_RESULTS
}

public func (this: *SqlConnection) query(
    resultSet: *SqlResultSet,
    sql: String,
    $...
) : SqlResult {
    if (this.hasError()) return this.lastResult()

    var stmt: SqlStatement;
    this.prepare(
        &stmt,
        sql
    )

    if(this.hasError()) {
        return this.lastResult()
    }

    var index = 1

    var list: va_list
    va_start(list, sql)
    defer va_end(list)

    var vargs = va_arg<NativeVararg>(list)
    for(var i = 0; i < vargs.numberOfArgs; i+=1) {
        var typeid = vargs.args[i]
        switch(typeid) {
            case typeof(:bool):
            case typeof(:i8):
            case typeof(:u8):
            case typeof(:i16):
            case typeof(:u16):
            case typeof(:u32):
            case typeof(:i32): {
                stmt.bindInt32(index, va_arg<i32>(list))
                break
            }
            case typeof(:usize):
            case typeof(:u64):
            case typeof(:i64): {
                stmt.bindInt64(index, va_arg<i64>(list))
                break
            }
            case typeof(:f32):
            case typeof(:f64): {
                stmt.bindFloat64(index, va_arg<f64>(list))
                break
            }
            case typeof(:String): {
                var str = va_arg<String>(list)
                stmt.bindString(index, str)
                break
            }
            case typeof(:*const char):
            case typeof(""): {
                var str = va_arg<*const char>(list)
                stmt.bindText(index, str, strlen(str))
                break
            }
            case typeof(:DateTime): {
                var datetime = va_arg<DateTime>(list)
                stmt.bindDateTime(index, datetime)
                break
            }
            default: {
                // TODO: Make this more descriptive error message
                //var msg = StringBuilderInit(256, defaultAllocator/*this.allocator*/)
                //msg.append("Unsupported parameter type: %s", nameof(typeid))
                this.setError(
                    SqlResult {
                        .type = SqlResultType.ERROR,
                        .description = $"Unsupported parameter type"
                    }
                )
                return this.lastResult()
            }
        }
        index += 1
    }

    return stmt.execute(resultSet)
}