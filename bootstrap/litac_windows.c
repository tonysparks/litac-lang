#ifndef _LITAC_HEADER_H
#define _LITAC_HEADER_H

// Generated on Thu Dec 14 00:55:29 2023

#include <stdint.h>
#include <stddef.h>
typedef int8_t    litaC_i8;
typedef int16_t   litaC_i16;
typedef int32_t   litaC_i32;
typedef int64_t   litaC_i64;
typedef uint8_t   litaC_u8;
typedef uint16_t  litaC_u16;
typedef uint32_t  litaC_u32;
typedef uint64_t  litaC_u64;
typedef float     litaC_f32;
typedef double    litaC_f64;
//typedef int8_t    litaC_bool;
typedef size_t    litaC_usize;

#if _MSC_VER
#define LITAC_THREADLOCAL __declspec(thread)
#define LITAC_INLINE static inline __forceinline
#define LITAC_NOINLINE __declspec(noinline)
#define LITAC_PACKED __pragma(pack(push, 1))
#define LITAC_PACKED_POP __pragma(pack(pop))
#define LITAC_EXPORT __declspec(dllexport)
#endif

#if __GNUC__
#define LITAC_THREADLOCAL __thread
#define LITAC_INLINE static inline __attribute__((always_inline))
#define LITAC_NOINLINE __attribute__((noinline))
#define LITAC_PACKED _Pragma("pack(push)")
#define LITAC_PACKED_POP _Pragma("pack(pop)")
#define LITAC_EXPORT __attribute__((visibility("default")))
#endif

#if __TINYC__
#define LITAC_THREADLOCAL
#define LITAC_INLINE
#define LITAC_NOINLINE
#define LITAC_PACKED __attribute__((packed))
#define LITAC_PACKED_POP
#define LITAC_EXPORT __attribute__((dllexport))
#endif

typedef int8_t litaC_bool;
#define litaC_true (1)
#define litaC_false (0)
#define litaC_void void
typedef char   litaC_char;

#define litaC_std__mem__KiB (1024)

#define litaC_std__mem__MiB (1024 * litaC_std__mem__KiB)

#define litaC_std__mem__GiB (1024 * litaC_std__mem__MiB)

#define litaC_std__cmdline__MAX_MESSAGE_SIZE (256)

#define litaC_std__array__MAX_LEVELS (300)

#define litaC_std__string_buffer__MAX_BUFFER_SIZE (32)

#define litaC_lex__MAX_KEYWORD_CACHE (9)


#define litaC_std__unicode__utf8__INVALID_RUNE (0xefbfbd)


#define litaC_std__unicode__utf8__MAX_RUNE (0x10ffff)


#define litaC_std__unicode__utf8__MAX_RUNE_BYTES (4)

#define litaC_types__MAX_FIELD_PATH (256)

#define litaC_symbols__MAX_SYMBOL_NAME (256)

#define litaC_module__MAX_METHODS_FOR_TYPE (2048)
litaC_usize litaC_std__mem__arena_allocator__PAGE_SIZE = (litaC_usize)4096UL;

#define litaC_lita__MAX_PREFIX_SIZE (32)

#define litaC_checker__MAX_LABELS (256)

#define litaC_checker__MAX_LABEL_NAME (32)

#define litaC_intern__MAX_SOMETHING (0)

#define litaC_generics__MAX_GENERIC_NAME (1024)

#define litaC_std__json__MAX_MESSAGE_SIZE (256)

#define litaC_parser__DECL_ADJUST_TOKENS_COUNT (12)

#define litaC_lsp__lsp__IN_BUFFER_SIZE (1024 * 1024 * 2)

#define litaC_cgen__MAX_COMPILATION_UNITS (256)

#define litaC_pkg_mgr__pkg__SEPARATOR_LENGTH (1)
// The latest version of this library is available on GitHub;
// https://github.com/sheredom/utf8.h

// This is free and unencumbered software released into the public domain.
//
// Anyone is free to copy, modify, publish, use, compile, sell, or
// distribute this software, either in source code form or as a compiled
// binary, for any purpose, commercial or non-commercial, and by any
// means.
//
// In jurisdictions that recognize copyright laws, the author or authors
// of this software dedicate any and all copyright interest in the
// software to the public domain. We make this dedication for the benefit
// of the public at large and to the detriment of our heirs and
// successors. We intend this dedication to be an overt act of
// relinquishment in perpetuity of all present and future rights to this
// software under copyright law.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
//
// For more information, please refer to <http://unlicense.org/>

#ifndef SHEREDOM_UTF8_H_INCLUDED
#define SHEREDOM_UTF8_H_INCLUDED

#if defined(_MSC_VER)
#pragma warning(push)

/* disable warning: no function prototype given: converting '()' to '(void)' */
#pragma warning(disable : 4255)

/* disable warning: '__cplusplus' is not defined as a preprocessor macro,
 * replacing with '0' for '#if/#elif' */
#pragma warning(disable : 4668)

/* disable warning: bytes padding added after construct */
#pragma warning(disable : 4820)
#endif

#include <stddef.h>
#include <stdlib.h>

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

#if defined(_MSC_VER) && (_MSC_VER < 1920)
typedef __int32 utf8_int32_t;
#else
#include <stdint.h>
typedef int32_t utf8_int32_t;
#endif

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wold-style-cast"
#pragma clang diagnostic ignored "-Wcast-qual"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(_MSC_VER)
#define utf8_nonnull
#define utf8_pure
#define utf8_restrict __restrict
#define utf8_weak __inline
#elif defined(__clang__) || defined(__GNUC__) || defined(__TINYC__)
#define utf8_nonnull __attribute__((nonnull))
#define utf8_pure __attribute__((pure))
#define utf8_restrict __restrict__
#define utf8_weak __attribute__((weak))
#else
#error Non clang, non gcc, non MSVC, non TinyCC compiler found!
#endif

#ifdef __cplusplus
#define utf8_null NULL
#else
#define utf8_null 0
#endif

// Return less than 0, 0, greater than 0 if src1 < src2, src1 == src2, src1 >
// src2 respectively, case insensitive.
utf8_nonnull utf8_pure utf8_weak int utf8casecmp(const void *src1,
                                                 const void *src2);

// Append the utf8 string src onto the utf8 string dst.
utf8_nonnull utf8_weak void *utf8cat(void *utf8_restrict dst,
                                     const void *utf8_restrict src);

// Find the first match of the utf8 codepoint chr in the utf8 string src.
utf8_nonnull utf8_pure utf8_weak void *utf8chr(const void *src,
                                               utf8_int32_t chr);

// Return less than 0, 0, greater than 0 if src1 < src2,
// src1 == src2, src1 > src2 respectively.
utf8_nonnull utf8_pure utf8_weak int utf8cmp(const void *src1,
                                             const void *src2);

// Copy the utf8 string src onto the memory allocated in dst.
utf8_nonnull utf8_weak void *utf8cpy(void *utf8_restrict dst,
                                     const void *utf8_restrict src);

// Number of utf8 codepoints in the utf8 string src that consists entirely
// of utf8 codepoints not from the utf8 string reject.
utf8_nonnull utf8_pure utf8_weak size_t utf8cspn(const void *src,
                                                 const void *reject);

// Duplicate the utf8 string src by getting its size, malloc'ing a new buffer
// copying over the data, and returning that. Or 0 if malloc failed.
utf8_weak void *utf8dup(const void *src);

// Number of utf8 codepoints in the utf8 string str,
// excluding the null terminating byte.
utf8_nonnull utf8_pure utf8_weak size_t utf8len(const void *str);

// Similar to utf8len, except that only at most n bytes of src are looked.
utf8_nonnull utf8_pure utf8_weak size_t utf8nlen(const void *str, size_t n);

// Return less than 0, 0, greater than 0 if src1 < src2, src1 == src2, src1 >
// src2 respectively, case insensitive. Checking at most n bytes of each utf8
// string.
utf8_nonnull utf8_pure utf8_weak int utf8ncasecmp(const void *src1,
                                                  const void *src2, size_t n);

// Append the utf8 string src onto the utf8 string dst,
// writing at most n+1 bytes. Can produce an invalid utf8
// string if n falls partway through a utf8 codepoint.
utf8_nonnull utf8_weak void *utf8ncat(void *utf8_restrict dst,
                                      const void *utf8_restrict src, size_t n);

// Return less than 0, 0, greater than 0 if src1 < src2,
// src1 == src2, src1 > src2 respectively. Checking at most n
// bytes of each utf8 string.
utf8_nonnull utf8_pure utf8_weak int utf8ncmp(const void *src1,
                                              const void *src2, size_t n);

// Copy the utf8 string src onto the memory allocated in dst.
// Copies at most n bytes. If n falls partway through a utf8
// codepoint, or if dst doesn't have enough room for a null
// terminator, the final string will be cut short to preserve
// utf8 validity.

utf8_nonnull utf8_weak void *utf8ncpy(void *utf8_restrict dst,
                                      const void *utf8_restrict src, size_t n);

// Similar to utf8dup, except that at most n bytes of src are copied. If src is
// longer than n, only n bytes are copied and a null byte is added.
//
// Returns a new string if successful, 0 otherwise
utf8_weak void *utf8ndup(const void *src, size_t n);

// Locates the first occurrence in the utf8 string str of any byte in the
// utf8 string accept, or 0 if no match was found.
utf8_nonnull utf8_pure utf8_weak void *utf8pbrk(const void *str,
                                                const void *accept);

// Find the last match of the utf8 codepoint chr in the utf8 string src.
utf8_nonnull utf8_pure utf8_weak void *utf8rchr(const void *src, int chr);

// Number of bytes in the utf8 string str,
// including the null terminating byte.
utf8_nonnull utf8_pure utf8_weak size_t utf8size(const void *str);

// Similar to utf8size, except that the null terminating byte is excluded.
utf8_nonnull utf8_pure utf8_weak size_t utf8size_lazy(const void *str);

// Similar to utf8size, except that only at most n bytes of src are looked and
// the null terminating byte is excluded.
utf8_nonnull utf8_pure utf8_weak size_t utf8nsize_lazy(const void *str, size_t n);

// Number of utf8 codepoints in the utf8 string src that consists entirely
// of utf8 codepoints from the utf8 string accept.
utf8_nonnull utf8_pure utf8_weak size_t utf8spn(const void *src,
                                                const void *accept);

// The position of the utf8 string needle in the utf8 string haystack.
utf8_nonnull utf8_pure utf8_weak void *utf8str(const void *haystack,
                                               const void *needle);

// The position of the utf8 string needle in the utf8 string haystack, case
// insensitive.
utf8_nonnull utf8_pure utf8_weak void *utf8casestr(const void *haystack,
                                                   const void *needle);

// Return 0 on success, or the position of the invalid
// utf8 codepoint on failure.
utf8_nonnull utf8_pure utf8_weak void *utf8valid(const void *str);

// Similar to utf8valid, except that only at most n bytes of src are looked.
utf8_nonnull utf8_pure utf8_weak void *utf8nvalid(const void *str, size_t n);

// Given a null-terminated string, makes the string valid by replacing invalid
// codepoints with a 1-byte replacement. Returns 0 on success.
utf8_nonnull utf8_weak int utf8makevalid(void *str,
                                         const utf8_int32_t replacement);

// Sets out_codepoint to the current utf8 codepoint in str, and returns the
// address of the next utf8 codepoint after the current one in str.
utf8_nonnull utf8_weak void *
utf8codepoint(const void *utf8_restrict str,
              utf8_int32_t *utf8_restrict out_codepoint);

// Calculates the size of the next utf8 codepoint in str.
utf8_nonnull utf8_weak size_t utf8codepointcalcsize(const void *str);

// Returns the size of the given codepoint in bytes.
utf8_weak size_t utf8codepointsize(utf8_int32_t chr);

// Write a codepoint to the given string, and return the address to the next
// place after the written codepoint. Pass how many bytes left in the buffer to
// n. If there is not enough space for the codepoint, this function returns
// null.
utf8_nonnull utf8_weak void *utf8catcodepoint(void *str, utf8_int32_t chr,
                                              size_t n);

// Returns 1 if the given character is lowercase, or 0 if it is not.
utf8_weak int utf8islower(utf8_int32_t chr);

// Returns 1 if the given character is uppercase, or 0 if it is not.
utf8_weak int utf8isupper(utf8_int32_t chr);

// Transform the given string into all lowercase codepoints.
utf8_nonnull utf8_weak void utf8lwr(void *utf8_restrict str);

// Transform the given string into all uppercase codepoints.
utf8_nonnull utf8_weak void utf8upr(void *utf8_restrict str);

// Make a codepoint lower case if possible.
utf8_weak utf8_int32_t utf8lwrcodepoint(utf8_int32_t cp);

// Make a codepoint upper case if possible.
utf8_weak utf8_int32_t utf8uprcodepoint(utf8_int32_t cp);

// Sets out_codepoint to the current utf8 codepoint in str, and returns the
// address of the previous utf8 codepoint before the current one in str.
utf8_nonnull utf8_weak void *
utf8rcodepoint(const void *utf8_restrict str,
               utf8_int32_t *utf8_restrict out_codepoint);

// Duplicate the utf8 string src by getting its size, calling alloc_func_ptr to
// copy over data to a new buffer, and returning that. Or 0 if alloc_func_ptr
// returned null.
utf8_weak void *utf8dup_ex(const void *src,
                           void *(*alloc_func_ptr)(void *, size_t),
                           void *user_data);

// Similar to utf8dup, except that at most n bytes of src are copied. If src is
// longer than n, only n bytes are copied and a null byte is added.
//
// Returns a new string if successful, 0 otherwise.
utf8_weak void *utf8ndup_ex(const void *src, size_t n,
                            void *(*alloc_func_ptr)(void *, size_t),
                            void *user_data);

#undef utf8_weak
#undef utf8_pure
#undef utf8_nonnull

int utf8casecmp(const void *src1, const void *src2) {
  utf8_int32_t src1_lwr_cp, src2_lwr_cp, src1_upr_cp, src2_upr_cp, src1_orig_cp,
      src2_orig_cp;

  for (;;) {
    src1 = utf8codepoint(src1, &src1_orig_cp);
    src2 = utf8codepoint(src2, &src2_orig_cp);

    // lower the srcs if required
    src1_lwr_cp = utf8lwrcodepoint(src1_orig_cp);
    src2_lwr_cp = utf8lwrcodepoint(src2_orig_cp);

    // lower the srcs if required
    src1_upr_cp = utf8uprcodepoint(src1_orig_cp);
    src2_upr_cp = utf8uprcodepoint(src2_orig_cp);

    // check if the lowered codepoints match
    if ((0 == src1_orig_cp) && (0 == src2_orig_cp)) {
      return 0;
    } else if ((src1_lwr_cp == src2_lwr_cp) || (src1_upr_cp == src2_upr_cp)) {
      continue;
    }

    // if they don't match, then we return the difference between the characters
    return src1_lwr_cp - src2_lwr_cp;
  }
}

void *utf8cat(void *utf8_restrict dst, const void *utf8_restrict src) {
  char *d = (char *)dst;
  const char *s = (const char *)src;

  // find the null terminating byte in dst
  while ('\0' != *d) {
    d++;
  }

  // overwriting the null terminating byte in dst, append src byte-by-byte
  while ('\0' != *s) {
    *d++ = *s++;
  }

  // write out a new null terminating byte into dst
  *d = '\0';

  return dst;
}

void *utf8chr(const void *src, utf8_int32_t chr) {
  char c[5] = {'\0', '\0', '\0', '\0', '\0'};

  if (0 == chr) {
    // being asked to return position of null terminating byte, so
    // just run s to the end, and return!
    const char *s = (const char *)src;
    while ('\0' != *s) {
      s++;
    }
    return (void *)s;
  } else if (0 == ((utf8_int32_t)0xffffff80 & chr)) {
    // 1-byte/7-bit ascii
    // (0b0xxxxxxx)
    c[0] = (char)chr;
  } else if (0 == ((utf8_int32_t)0xfffff800 & chr)) {
    // 2-byte/11-bit utf8 code point
    // (0b110xxxxx 0b10xxxxxx)
    c[0] = (char) (0xc0 | (char)(chr >> 6));
    c[1] = (char) (0x80 | (char)(chr & 0x3f));
  } else if (0 == ((utf8_int32_t)0xffff0000 & chr)) {
    // 3-byte/16-bit utf8 code point
    // (0b1110xxxx 0b10xxxxxx 0b10xxxxxx)
    c[0] = (char) (0xe0 | (char)(chr >> 12));
    c[1] = (char) (0x80 | (char)((chr >> 6) & 0x3f));
    c[2] = (char) (0x80 | (char)(chr & 0x3f));
  } else { // if (0 == ((int)0xffe00000 & chr)) {
    // 4-byte/21-bit utf8 code point
    // (0b11110xxx 0b10xxxxxx 0b10xxxxxx 0b10xxxxxx)
    c[0] = (char) (0xf0 | (char)(chr >> 18));
    c[1] = (char) (0x80 | (char)((chr >> 12) & 0x3f));
    c[2] = (char) (0x80 | (char)((chr >> 6) & 0x3f));
    c[3] = (char) (0x80 | (char)(chr & 0x3f));
  }

  // we've made c into a 2 utf8 codepoint string, one for the chr we are
  // seeking, another for the null terminating byte. Now use utf8str to
  // search
  return utf8str(src, c);
}

int utf8cmp(const void *src1, const void *src2) {
  const unsigned char *s1 = (const unsigned char *)src1;
  const unsigned char *s2 = (const unsigned char *)src2;

  while (('\0' != *s1) || ('\0' != *s2)) {
    if (*s1 < *s2) {
      return -1;
    } else if (*s1 > *s2) {
      return 1;
    }

    s1++;
    s2++;
  }

  // both utf8 strings matched
  return 0;
}

int utf8coll(const void *src1, const void *src2);

void *utf8cpy(void *utf8_restrict dst, const void *utf8_restrict src) {
  char *d = (char *)dst;
  const char *s = (const char *)src;

  // overwriting anything previously in dst, write byte-by-byte
  // from src
  while ('\0' != *s) {
    *d++ = *s++;
  }

  // append null terminating byte
  *d = '\0';

  return dst;
}

size_t utf8cspn(const void *src, const void *reject) {
  const char *s = (const char *)src;
  size_t chars = 0;

  while ('\0' != *s) {
    const char *r = (const char *)reject;
    size_t offset = 0;

    while ('\0' != *r) {
      // checking that if *r is the start of a utf8 codepoint
      // (it is not 0b10xxxxxx) and we have successfully matched
      // a previous character (0 < offset) - we found a match
      if ((0x80 != (0xc0 & *r)) && (0 < offset)) {
        return chars;
      } else {
        if (*r == s[offset]) {
          // part of a utf8 codepoint matched, so move our checking
          // onwards to the next byte
          offset++;
          r++;
        } else {
          // r could be in the middle of an unmatching utf8 code point,
          // so we need to march it on to the next character beginning,

          do {
            r++;
          } while (0x80 == (0xc0 & *r));

          // reset offset too as we found a mismatch
          offset = 0;
        }
      }
    }

    // found a match at the end of *r, so didn't get a chance to test it
    if (0 < offset) {
      return chars;
    }

    // the current utf8 codepoint in src did not match reject, but src
    // could have been partway through a utf8 codepoint, so we need to
    // march it onto the next utf8 codepoint starting byte
    do {
      s++;
    } while ((0x80 == (0xc0 & *s)));
    chars++;
  }

  return chars;
}

void *utf8dup(const void *src) { return utf8dup_ex(src, utf8_null, utf8_null); }

void *utf8dup_ex(const void *src, void *(*alloc_func_ptr)(void *, size_t),
                 void *user_data) {
  const char *s = (const char *)src;
  char *n = utf8_null;

  // figure out how many bytes (including the terminator) we need to copy first
  size_t bytes = utf8size(src);

  if (alloc_func_ptr) {
    n = (char *)alloc_func_ptr(user_data, bytes);
  } else {
    n = (char *)malloc(bytes);
  }

  if (utf8_null == n) {
    // out of memory so we bail
    return utf8_null;
  } else {
    bytes = 0;

    // copy src byte-by-byte into our new utf8 string
    while ('\0' != s[bytes]) {
      n[bytes] = s[bytes];
      bytes++;
    }

    // append null terminating byte
    n[bytes] = '\0';
    return n;
  }
}

void *utf8fry(const void *str);

size_t utf8len(const void *str) {
  return utf8nlen(str, SIZE_MAX);
}

size_t utf8nlen(const void *str, size_t n) {
  const unsigned char *s = (const unsigned char *)str;
  const unsigned char *t = s;
  size_t length = 0;

  while ((size_t) (s-t) < n && '\0' != *s) {
    if (0xf0 == (0xf8 & *s)) {
      // 4-byte utf8 code point (began with 0b11110xxx)
      s += 4;
    } else if (0xe0 == (0xf0 & *s)) {
      // 3-byte utf8 code point (began with 0b1110xxxx)
      s += 3;
    } else if (0xc0 == (0xe0 & *s)) {
      // 2-byte utf8 code point (began with 0b110xxxxx)
      s += 2;
    } else { // if (0x00 == (0x80 & *s)) {
      // 1-byte ascii (began with 0b0xxxxxxx)
      s += 1;
    }

    // no matter the bytes we marched s forward by, it was
    // only 1 utf8 codepoint
    length++;
  }

  if ((size_t) (s-t) > n) {
    length--;
  }
  return length;
}

int utf8ncasecmp(const void *src1, const void *src2, size_t n) {
  utf8_int32_t src1_lwr_cp, src2_lwr_cp, src1_upr_cp, src2_upr_cp, src1_orig_cp,
      src2_orig_cp;

  do {
    const unsigned char *const s1 = (const unsigned char *)src1;
    const unsigned char *const s2 = (const unsigned char *)src2;

    // first check that we have enough bytes left in n to contain an entire
    // codepoint
    if (0 == n) {
      return 0;
    }

    if ((1 == n) && ((0xc0 == (0xe0 & *s1)) || (0xc0 == (0xe0 & *s2)))) {
      const utf8_int32_t c1 = (0xe0 & *s1);
      const utf8_int32_t c2 = (0xe0 & *s2);

      if (c1 < c2) {
        return c1 - c2;
      } else {
        return 0;
      }
    }

    if ((2 >= n) && ((0xe0 == (0xf0 & *s1)) || (0xe0 == (0xf0 & *s2)))) {
      const utf8_int32_t c1 = (0xf0 & *s1);
      const utf8_int32_t c2 = (0xf0 & *s2);

      if (c1 < c2) {
        return c1 - c2;
      } else {
        return 0;
      }
    }

    if ((3 >= n) && ((0xf0 == (0xf8 & *s1)) || (0xf0 == (0xf8 & *s2)))) {
      const utf8_int32_t c1 = (0xf8 & *s1);
      const utf8_int32_t c2 = (0xf8 & *s2);

      if (c1 < c2) {
        return c1 - c2;
      } else {
        return 0;
      }
    }

    src1 = utf8codepoint(src1, &src1_orig_cp);
    src2 = utf8codepoint(src2, &src2_orig_cp);
    n -= utf8codepointsize(src1_orig_cp);

    src1_lwr_cp = utf8lwrcodepoint(src1_orig_cp);
    src2_lwr_cp = utf8lwrcodepoint(src2_orig_cp);

    src1_upr_cp = utf8uprcodepoint(src1_orig_cp);
    src2_upr_cp = utf8uprcodepoint(src2_orig_cp);

    // check if the lowered codepoints match
    if ((0 == src1_orig_cp) && (0 == src2_orig_cp)) {
      return 0;
    } else if ((src1_lwr_cp == src2_lwr_cp) || (src1_upr_cp == src2_upr_cp)) {
      continue;
    }

    // if they don't match, then we return the difference between the characters
    return src1_lwr_cp - src2_lwr_cp;
  } while (0 < n);

  // both utf8 strings matched
  return 0;
}

void *utf8ncat(void *utf8_restrict dst, const void *utf8_restrict src,
               size_t n) {
  char *d = (char *)dst;
  const char *s = (const char *)src;

  // find the null terminating byte in dst
  while ('\0' != *d) {
    d++;
  }

  // overwriting the null terminating byte in dst, append src byte-by-byte
  // stopping if we run out of space
  do {
    *d++ = *s++;
  } while (('\0' != *s) && (0 != --n));

  // write out a new null terminating byte into dst
  *d = '\0';

  return dst;
}

int utf8ncmp(const void *src1, const void *src2, size_t n) {
  const unsigned char *s1 = (const unsigned char *)src1;
  const unsigned char *s2 = (const unsigned char *)src2;

  while ((0 != n--) && (('\0' != *s1) || ('\0' != *s2))) {
    if (*s1 < *s2) {
      return -1;
    } else if (*s1 > *s2) {
      return 1;
    }

    s1++;
    s2++;
  }

  // both utf8 strings matched
  return 0;
}

void *utf8ncpy(void *utf8_restrict dst, const void *utf8_restrict src,
               size_t n) {
  char *d = (char *)dst;
  const char *s = (const char *)src;
  size_t index, check_index;

  if (n == 0) {
    return dst;
  }

  // overwriting anything previously in dst, write byte-by-byte
  // from src
  for (index = 0; index < n; index++) {
    d[index] = s[index];
    if ('\0' == s[index]) {
      break;
    }
  }

  for ( check_index = index - 1; check_index > 0 && 0x80 == (0xc0 & d[check_index]); check_index--) {
    // just moving the index
  }

  if (check_index < index && (index - check_index) < utf8codepointsize(d[check_index])) {
    index = check_index;
  }

  // append null terminating byte
  for (; index < n; index++) {
    d[index] = 0;
  }

  return dst;
}

void *utf8ndup(const void *src, size_t n) {
  return utf8ndup_ex(src, n, utf8_null, utf8_null);
}

void *utf8ndup_ex(const void *src, size_t n,
                  void *(*alloc_func_ptr)(void *, size_t), void *user_data) {
  const char *s = (const char *)src;
  char *c = utf8_null;
  size_t bytes = 0;

  // Find the end of the string or stop when n is reached
  while ('\0' != s[bytes] && bytes < n) {
    bytes++;
  }

  // In case bytes is actually less than n, we need to set it
  // to be used later in the copy byte by byte.
  n = bytes;

  if (alloc_func_ptr) {
    c = (char *)alloc_func_ptr(user_data, bytes + 1);
  } else {
    c = (char *)malloc(bytes + 1);
  }

  if (utf8_null == c) {
    // out of memory so we bail
    return utf8_null;
  }

  bytes = 0;

  // copy src byte-by-byte into our new utf8 string
  while ('\0' != s[bytes] && bytes < n) {
    c[bytes] = s[bytes];
    bytes++;
  }

  // append null terminating byte
  c[bytes] = '\0';
  return c;
}

void *utf8rchr(const void *src, int chr) {
  const char *s = (const char *)src;
  const char *match = utf8_null;
  char c[5] = {'\0', '\0', '\0', '\0', '\0'};

  if (0 == chr) {
    // being asked to return position of null terminating byte, so
    // just run s to the end, and return!
    while ('\0' != *s) {
      s++;
    }
    return (void *)s;
  } else if (0 == ((int)0xffffff80 & chr)) {
    // 1-byte/7-bit ascii
    // (0b0xxxxxxx)
    c[0] = (char)chr;
  } else if (0 == ((int)0xfffff800 & chr)) {
    // 2-byte/11-bit utf8 code point
    // (0b110xxxxx 0b10xxxxxx)
    c[0] = (char) (0xc0 | (char)(chr >> 6));
    c[1] = (char) (0x80 | (char)(chr & 0x3f));
  } else if (0 == ((int)0xffff0000 & chr)) {
    // 3-byte/16-bit utf8 code point
    // (0b1110xxxx 0b10xxxxxx 0b10xxxxxx)
    c[0] = (char) (0xe0 | (char)(chr >> 12));
    c[1] = (char) (0x80 | (char)((chr >> 6) & 0x3f));
    c[2] = (char) (0x80 | (char)(chr & 0x3f));
  } else { // if (0 == ((int)0xffe00000 & chr)) {
    // 4-byte/21-bit utf8 code point
    // (0b11110xxx 0b10xxxxxx 0b10xxxxxx 0b10xxxxxx)
    c[0] = (char) (0xf0 | (char)(chr >> 18));
    c[1] = (char) (0x80 | (char)((chr >> 12) & 0x3f));
    c[2] = (char) (0x80 | (char)((chr >> 6) & 0x3f));
    c[3] = (char) (0x80 | (char)(chr & 0x3f));
  }

  // we've created a 2 utf8 codepoint string in c that is
  // the utf8 character asked for by chr, and a null
  // terminating byte

  while ('\0' != *s) {
    size_t offset = 0;

    while (s[offset] == c[offset]) {
      offset++;
    }

    if ('\0' == c[offset]) {
      // we found a matching utf8 code point
      match = s;
      s += offset;
    } else {
      s += offset;

      // need to march s along to next utf8 codepoint start
      // (the next byte that doesn't match 0b10xxxxxx)
      if ('\0' != *s) {
        do {
          s++;
        } while (0x80 == (0xc0 & *s));
      }
    }
  }

  // return the last match we found (or 0 if no match was found)
  return (void *)match;
}

void *utf8pbrk(const void *str, const void *accept) {
  const char *s = (const char *)str;

  while ('\0' != *s) {
    const char *a = (const char *)accept;
    size_t offset = 0;

    while ('\0' != *a) {
      // checking that if *a is the start of a utf8 codepoint
      // (it is not 0b10xxxxxx) and we have successfully matched
      // a previous character (0 < offset) - we found a match
      if ((0x80 != (0xc0 & *a)) && (0 < offset)) {
        return (void *)s;
      } else {
        if (*a == s[offset]) {
          // part of a utf8 codepoint matched, so move our checking
          // onwards to the next byte
          offset++;
          a++;
        } else {
          // r could be in the middle of an unmatching utf8 code point,
          // so we need to march it on to the next character beginning,

          do {
            a++;
          } while (0x80 == (0xc0 & *a));

          // reset offset too as we found a mismatch
          offset = 0;
        }
      }
    }

    // we found a match on the last utf8 codepoint
    if (0 < offset) {
      return (void *)s;
    }

    // the current utf8 codepoint in src did not match accept, but src
    // could have been partway through a utf8 codepoint, so we need to
    // march it onto the next utf8 codepoint starting byte
    do {
      s++;
    } while ((0x80 == (0xc0 & *s)));
  }

  return utf8_null;
}

size_t utf8size(const void *str) {
  return utf8size_lazy(str) + 1;
}

size_t utf8size_lazy(const void *str) {
  return utf8nsize_lazy(str, SIZE_MAX);
}

size_t utf8nsize_lazy(const void *str, size_t n) {
  const char *s = (const char *)str;
  size_t size = 0;
  while (size < n && '\0' != s[size]) {
    size++;
  }
  return size;
}

size_t utf8spn(const void *src, const void *accept) {
  const char *s = (const char *)src;
  size_t chars = 0;

  while ('\0' != *s) {
    const char *a = (const char *)accept;
    size_t offset = 0;

    while ('\0' != *a) {
      // checking that if *r is the start of a utf8 codepoint
      // (it is not 0b10xxxxxx) and we have successfully matched
      // a previous character (0 < offset) - we found a match
      if ((0x80 != (0xc0 & *a)) && (0 < offset)) {
        // found a match, so increment the number of utf8 codepoints
        // that have matched and stop checking whether any other utf8
        // codepoints in a match
        chars++;
        s += offset;
        offset = 0;
        break;
      } else {
        if (*a == s[offset]) {
          offset++;
          a++;
        } else {
          // a could be in the middle of an unmatching utf8 codepoint,
          // so we need to march it on to the next character beginning,
          do {
            a++;
          } while (0x80 == (0xc0 & *a));

          // reset offset too as we found a mismatch
          offset = 0;
        }
      }
    }

    // found a match at the end of *a, so didn't get a chance to test it
    if (0 < offset) {
      chars++;
      s += offset;
      continue;
    }

    // if a got to its terminating null byte, then we didn't find a match.
    // Return the current number of matched utf8 codepoints
    if ('\0' == *a) {
      return chars;
    }
  }

  return chars;
}

void *utf8str(const void *haystack, const void *needle) {
  const char *h = (const char *)haystack;
  utf8_int32_t throwaway_codepoint;

  // if needle has no utf8 codepoints before the null terminating
  // byte then return haystack
  if ('\0' == *((const char *)needle)) {
    return (void *)haystack;
  }

  while ('\0' != *h) {
    const char *maybeMatch = h;
    const char *n = (const char *)needle;

    while (*h == *n && (*h != '\0' && *n != '\0')) {
      n++;
      h++;
    }

    if ('\0' == *n) {
      // we found the whole utf8 string for needle in haystack at
      // maybeMatch, so return it
      return (void *)maybeMatch;
    } else {
      // h could be in the middle of an unmatching utf8 codepoint,
      // so we need to march it on to the next character beginning
      // starting from the current character
      h = (const char *)utf8codepoint(maybeMatch, &throwaway_codepoint);
    }
  }

  // no match
  return utf8_null;
}

void *utf8casestr(const void *haystack, const void *needle) {
  const void *h = haystack;

  // if needle has no utf8 codepoints before the null terminating
  // byte then return haystack
  if ('\0' == *((const char *)needle)) {
    return (void *)haystack;
  }

  for (;;) {
    const void *maybeMatch = h;
    const void *n = needle;
    utf8_int32_t h_cp, n_cp;

    // Get the next code point and track it
    const void *nextH = h = utf8codepoint(h, &h_cp);
    n = utf8codepoint(n, &n_cp);

    while ((0 != h_cp) && (0 != n_cp)) {
      h_cp = utf8lwrcodepoint(h_cp);
      n_cp = utf8lwrcodepoint(n_cp);

      // if we find a mismatch, bail out!
      if (h_cp != n_cp) {
        break;
      }

      h = utf8codepoint(h, &h_cp);
      n = utf8codepoint(n, &n_cp);
    }

    if (0 == n_cp) {
      // we found the whole utf8 string for needle in haystack at
      // maybeMatch, so return it
      return (void *)maybeMatch;
    }

    if (0 == h_cp) {
      // no match
      return utf8_null;
    }

    // Roll back to the next code point in the haystack to test
    h = nextH;
  }
}

void *utf8valid(const void *str) {
  return utf8nvalid(str, SIZE_MAX);
}

void *utf8nvalid(const void *str, size_t n) {
  const char *s = (const char *)str;
  const char *t = s;
  size_t consumed, remained;

  while ((void) (consumed = (size_t) (s-t)), consumed < n && '\0' != *s) {
    remained = n - consumed;

    if (0xf0 == (0xf8 & *s)) {
      // ensure that there's 4 bytes or more remained
      if (remained < 4) {
        return (void *)s;
      }

      // ensure each of the 3 following bytes in this 4-byte
      // utf8 codepoint began with 0b10xxxxxx
      if ((0x80 != (0xc0 & s[1])) || (0x80 != (0xc0 & s[2])) ||
          (0x80 != (0xc0 & s[3]))) {
        return (void *)s;
      }

      // ensure that our utf8 codepoint ended after 4 bytes
      if (0x80 == (0xc0 & s[4])) {
        return (void *)s;
      }

      // ensure that the top 5 bits of this 4-byte utf8
      // codepoint were not 0, as then we could have used
      // one of the smaller encodings
      if ((0 == (0x07 & s[0])) && (0 == (0x30 & s[1]))) {
        return (void *)s;
      }

      // 4-byte utf8 code point (began with 0b11110xxx)
      s += 4;
    } else if (0xe0 == (0xf0 & *s)) {
      // ensure that there's 3 bytes or more remained
      if (remained < 3) {
        return (void *)s;
      }

      // ensure each of the 2 following bytes in this 3-byte
      // utf8 codepoint began with 0b10xxxxxx
      if ((0x80 != (0xc0 & s[1])) || (0x80 != (0xc0 & s[2]))) {
        return (void *)s;
      }

      // ensure that our utf8 codepoint ended after 3 bytes
      if (0x80 == (0xc0 & s[3])) {
        return (void *)s;
      }

      // ensure that the top 5 bits of this 3-byte utf8
      // codepoint were not 0, as then we could have used
      // one of the smaller encodings
      if ((0 == (0x0f & s[0])) && (0 == (0x20 & s[1]))) {
        return (void *)s;
      }

      // 3-byte utf8 code point (began with 0b1110xxxx)
      s += 3;
    } else if (0xc0 == (0xe0 & *s)) {
      // ensure that there's 2 bytes or more remained
      if (remained < 2) {
        return (void *)s;
      }

      // ensure the 1 following byte in this 2-byte
      // utf8 codepoint began with 0b10xxxxxx
      if (0x80 != (0xc0 & s[1])) {
        return (void *)s;
      }

      // ensure that our utf8 codepoint ended after 2 bytes
      if (0x80 == (0xc0 & s[2])) {
        return (void *)s;
      }

      // ensure that the top 4 bits of this 2-byte utf8
      // codepoint were not 0, as then we could have used
      // one of the smaller encodings
      if (0 == (0x1e & s[0])) {
        return (void *)s;
      }

      // 2-byte utf8 code point (began with 0b110xxxxx)
      s += 2;
    } else if (0x00 == (0x80 & *s)) {
      // 1-byte ascii (began with 0b0xxxxxxx)
      s += 1;
    } else {
      // we have an invalid 0b1xxxxxxx utf8 code point entry
      return (void *)s;
    }
  }

  return utf8_null;
}

int utf8makevalid(void *str, const utf8_int32_t replacement) {
  char *read = (char *)str;
  char *write = read;
  const char r = (char)replacement;
  utf8_int32_t codepoint;

  if (replacement > 0x7f) {
    return -1;
  }

  while ('\0' != *read) {
    if (0xf0 == (0xf8 & *read)) {
      // ensure each of the 3 following bytes in this 4-byte
      // utf8 codepoint began with 0b10xxxxxx
      if ((0x80 != (0xc0 & read[1])) || (0x80 != (0xc0 & read[2])) ||
          (0x80 != (0xc0 & read[3]))) {
        *write++ = r;
        read++;
        continue;
      }

      // 4-byte utf8 code point (began with 0b11110xxx)
      read = (char *)utf8codepoint(read, &codepoint);
      write = (char *)utf8catcodepoint(write, codepoint, 4);
    } else if (0xe0 == (0xf0 & *read)) {
      // ensure each of the 2 following bytes in this 3-byte
      // utf8 codepoint began with 0b10xxxxxx
      if ((0x80 != (0xc0 & read[1])) || (0x80 != (0xc0 & read[2]))) {
        *write++ = r;
        read++;
        continue;
      }

      // 3-byte utf8 code point (began with 0b1110xxxx)
      read = (char *)utf8codepoint(read, &codepoint);
      write = (char *)utf8catcodepoint(write, codepoint, 3);
    } else if (0xc0 == (0xe0 & *read)) {
      // ensure the 1 following byte in this 2-byte
      // utf8 codepoint began with 0b10xxxxxx
      if (0x80 != (0xc0 & read[1])) {
        *write++ = r;
        read++;
        continue;
      }

      // 2-byte utf8 code point (began with 0b110xxxxx)
      read = (char *)utf8codepoint(read, &codepoint);
      write = (char *)utf8catcodepoint(write, codepoint, 2);
    } else if (0x00 == (0x80 & *read)) {
      // 1-byte ascii (began with 0b0xxxxxxx)
      read = (char *)utf8codepoint(read, &codepoint);
      write = (char *)utf8catcodepoint(write, codepoint, 1);
    } else {
      // if we got here then we've got a dangling continuation (0b10xxxxxx)
      *write++ = r;
      read++;
      continue;
    }
  }

  *write = '\0';

  return 0;
}

void *utf8codepoint(const void *utf8_restrict str,
                    utf8_int32_t *utf8_restrict out_codepoint) {
  const char *s = (const char *)str;

  if (0xf0 == (0xf8 & s[0])) {
    // 4 byte utf8 codepoint
    *out_codepoint = ((0x07 & s[0]) << 18) | ((0x3f & s[1]) << 12) |
                     ((0x3f & s[2]) << 6) | (0x3f & s[3]);
    s += 4;
  } else if (0xe0 == (0xf0 & s[0])) {
    // 3 byte utf8 codepoint
    *out_codepoint =
        ((0x0f & s[0]) << 12) | ((0x3f & s[1]) << 6) | (0x3f & s[2]);
    s += 3;
  } else if (0xc0 == (0xe0 & s[0])) {
    // 2 byte utf8 codepoint
    *out_codepoint = ((0x1f & s[0]) << 6) | (0x3f & s[1]);
    s += 2;
  } else {
    // 1 byte utf8 codepoint otherwise
    *out_codepoint = s[0];
    s += 1;
  }

  return (void *)s;
}

size_t utf8codepointcalcsize(const void *str) {
  const char *s = (const char *)str;

  if (0xf0 == (0xf8 & s[0])) {
    // 4 byte utf8 codepoint
    return 4;
  } else if (0xe0 == (0xf0 & s[0])) {
    // 3 byte utf8 codepoint
    return 3;
  } else if (0xc0 == (0xe0 & s[0])) {
    // 2 byte utf8 codepoint
    return 2;
  }

  // 1 byte utf8 codepoint otherwise
  return 1;
}

size_t utf8codepointsize(utf8_int32_t chr) {
  if (0 == ((utf8_int32_t)0xffffff80 & chr)) {
    return 1;
  } else if (0 == ((utf8_int32_t)0xfffff800 & chr)) {
    return 2;
  } else if (0 == ((utf8_int32_t)0xffff0000 & chr)) {
    return 3;
  } else { // if (0 == ((int)0xffe00000 & chr)) {
    return 4;
  }
}

void *utf8catcodepoint(void *str, utf8_int32_t chr, size_t n) {
  char *s = (char *)str;

  if (0 == ((utf8_int32_t)0xffffff80 & chr)) {
    // 1-byte/7-bit ascii
    // (0b0xxxxxxx)
    if (n < 1) {
      return utf8_null;
    }
    s[0] = (char)chr;
    s += 1;
  } else if (0 == ((utf8_int32_t)0xfffff800 & chr)) {
    // 2-byte/11-bit utf8 code point
    // (0b110xxxxx 0b10xxxxxx)
    if (n < 2) {
      return utf8_null;
    }
    s[0] = (char) (0xc0 | (char)((chr >> 6) & 0x1f));
    s[1] = (char) (0x80 | (char)(chr & 0x3f));
    s += 2;
  } else if (0 == ((utf8_int32_t)0xffff0000 & chr)) {
    // 3-byte/16-bit utf8 code point
    // (0b1110xxxx 0b10xxxxxx 0b10xxxxxx)
    if (n < 3) {
      return utf8_null;
    }
    s[0] = (char) (0xe0 | (char)((chr >> 12) & 0x0f));
    s[1] = (char) (0x80 | (char)((chr >> 6) & 0x3f));
    s[2] = (char) (0x80 | (char)(chr & 0x3f));
    s += 3;
  } else { // if (0 == ((int)0xffe00000 & chr)) {
    // 4-byte/21-bit utf8 code point
    // (0b11110xxx 0b10xxxxxx 0b10xxxxxx 0b10xxxxxx)
    if (n < 4) {
      return utf8_null;
    }
    s[0] = (char) (0xf0 | (char)((chr >> 18) & 0x07));
    s[1] = (char) (0x80 | (char)((chr >> 12) & 0x3f));
    s[2] = (char) (0x80 | (char)((chr >> 6) & 0x3f));
    s[3] = (char) (0x80 | (char)(chr & 0x3f));
    s += 4;
  }

  return s;
}

int utf8islower(utf8_int32_t chr) { return chr != utf8uprcodepoint(chr); }

int utf8isupper(utf8_int32_t chr) { return chr != utf8lwrcodepoint(chr); }

void utf8lwr(void *utf8_restrict str) {
  void *p, *pn;
  utf8_int32_t cp;

  p = (char *)str;
  pn = utf8codepoint(p, &cp);

  while (cp != 0) {
    const utf8_int32_t lwr_cp = utf8lwrcodepoint(cp);
    const size_t size = utf8codepointsize(lwr_cp);

    if (lwr_cp != cp) {
      utf8catcodepoint(p, lwr_cp, size);
    }

    p = pn;
    pn = utf8codepoint(p, &cp);
  }
}

void utf8upr(void *utf8_restrict str) {
  void *p, *pn;
  utf8_int32_t cp;

  p = (char *)str;
  pn = utf8codepoint(p, &cp);

  while (cp != 0) {
    const utf8_int32_t lwr_cp = utf8uprcodepoint(cp);
    const size_t size = utf8codepointsize(lwr_cp);

    if (lwr_cp != cp) {
      utf8catcodepoint(p, lwr_cp, size);
    }

    p = pn;
    pn = utf8codepoint(p, &cp);
  }
}

utf8_int32_t utf8lwrcodepoint(utf8_int32_t cp) {
  if (((0x0041 <= cp) && (0x005a >= cp)) ||
      ((0x00c0 <= cp) && (0x00d6 >= cp)) ||
      ((0x00d8 <= cp) && (0x00de >= cp)) ||
      ((0x0391 <= cp) && (0x03a1 >= cp)) ||
      ((0x03a3 <= cp) && (0x03ab >= cp)) ||
      ((0x0410 <= cp) && (0x042f >= cp))) {
    cp += 32;
  } else if ((0x0400 <= cp) && (0x040f >= cp)) {
    cp += 80;
  } else if (((0x0100 <= cp) && (0x012f >= cp)) ||
             ((0x0132 <= cp) && (0x0137 >= cp)) ||
             ((0x014a <= cp) && (0x0177 >= cp)) ||
             ((0x0182 <= cp) && (0x0185 >= cp)) ||
             ((0x01a0 <= cp) && (0x01a5 >= cp)) ||
             ((0x01de <= cp) && (0x01ef >= cp)) ||
             ((0x01f8 <= cp) && (0x021f >= cp)) ||
             ((0x0222 <= cp) && (0x0233 >= cp)) ||
             ((0x0246 <= cp) && (0x024f >= cp)) ||
             ((0x03d8 <= cp) && (0x03ef >= cp)) ||
             ((0x0460 <= cp) && (0x0481 >= cp)) ||
             ((0x048a <= cp) && (0x04ff >= cp))) {
    cp |= 0x1;
  } else if (((0x0139 <= cp) && (0x0148 >= cp)) ||
             ((0x0179 <= cp) && (0x017e >= cp)) ||
             ((0x01af <= cp) && (0x01b0 >= cp)) ||
             ((0x01b3 <= cp) && (0x01b6 >= cp)) ||
             ((0x01cd <= cp) && (0x01dc >= cp))) {
    cp += 1;
    cp &= ~0x1;
  } else {
    switch (cp) {
    default:
      break;
    case 0x0178:
      cp = 0x00ff;
      break;
    case 0x0243:
      cp = 0x0180;
      break;
    case 0x018e:
      cp = 0x01dd;
      break;
    case 0x023d:
      cp = 0x019a;
      break;
    case 0x0220:
      cp = 0x019e;
      break;
    case 0x01b7:
      cp = 0x0292;
      break;
    case 0x01c4:
      cp = 0x01c6;
      break;
    case 0x01c7:
      cp = 0x01c9;
      break;
    case 0x01ca:
      cp = 0x01cc;
      break;
    case 0x01f1:
      cp = 0x01f3;
      break;
    case 0x01f7:
      cp = 0x01bf;
      break;
    case 0x0187:
      cp = 0x0188;
      break;
    case 0x018b:
      cp = 0x018c;
      break;
    case 0x0191:
      cp = 0x0192;
      break;
    case 0x0198:
      cp = 0x0199;
      break;
    case 0x01a7:
      cp = 0x01a8;
      break;
    case 0x01ac:
      cp = 0x01ad;
      break;
    case 0x01af:
      cp = 0x01b0;
      break;
    case 0x01b8:
      cp = 0x01b9;
      break;
    case 0x01bc:
      cp = 0x01bd;
      break;
    case 0x01f4:
      cp = 0x01f5;
      break;
    case 0x023b:
      cp = 0x023c;
      break;
    case 0x0241:
      cp = 0x0242;
      break;
    case 0x03fd:
      cp = 0x037b;
      break;
    case 0x03fe:
      cp = 0x037c;
      break;
    case 0x03ff:
      cp = 0x037d;
      break;
    case 0x037f:
      cp = 0x03f3;
      break;
    case 0x0386:
      cp = 0x03ac;
      break;
    case 0x0388:
      cp = 0x03ad;
      break;
    case 0x0389:
      cp = 0x03ae;
      break;
    case 0x038a:
      cp = 0x03af;
      break;
    case 0x038c:
      cp = 0x03cc;
      break;
    case 0x038e:
      cp = 0x03cd;
      break;
    case 0x038f:
      cp = 0x03ce;
      break;
    case 0x0370:
      cp = 0x0371;
      break;
    case 0x0372:
      cp = 0x0373;
      break;
    case 0x0376:
      cp = 0x0377;
      break;
    case 0x03f4:
      cp = 0x03b8;
      break;
    case 0x03cf:
      cp = 0x03d7;
      break;
    case 0x03f9:
      cp = 0x03f2;
      break;
    case 0x03f7:
      cp = 0x03f8;
      break;
    case 0x03fa:
      cp = 0x03fb;
      break;
    }
  }

  return cp;
}

utf8_int32_t utf8uprcodepoint(utf8_int32_t cp) {
  if (((0x0061 <= cp) && (0x007a >= cp)) ||
      ((0x00e0 <= cp) && (0x00f6 >= cp)) ||
      ((0x00f8 <= cp) && (0x00fe >= cp)) ||
      ((0x03b1 <= cp) && (0x03c1 >= cp)) ||
      ((0x03c3 <= cp) && (0x03cb >= cp)) ||
      ((0x0430 <= cp) && (0x044f >= cp))) {
    cp -= 32;
  } else if ((0x0450 <= cp) && (0x045f >= cp)) {
    cp -= 80;
  } else if (((0x0100 <= cp) && (0x012f >= cp)) ||
             ((0x0132 <= cp) && (0x0137 >= cp)) ||
             ((0x014a <= cp) && (0x0177 >= cp)) ||
             ((0x0182 <= cp) && (0x0185 >= cp)) ||
             ((0x01a0 <= cp) && (0x01a5 >= cp)) ||
             ((0x01de <= cp) && (0x01ef >= cp)) ||
             ((0x01f8 <= cp) && (0x021f >= cp)) ||
             ((0x0222 <= cp) && (0x0233 >= cp)) ||
             ((0x0246 <= cp) && (0x024f >= cp)) ||
             ((0x03d8 <= cp) && (0x03ef >= cp)) ||
             ((0x0460 <= cp) && (0x0481 >= cp)) ||
             ((0x048a <= cp) && (0x04ff >= cp))) {
    cp &= ~0x1;
  } else if (((0x0139 <= cp) && (0x0148 >= cp)) ||
             ((0x0179 <= cp) && (0x017e >= cp)) ||
             ((0x01af <= cp) && (0x01b0 >= cp)) ||
             ((0x01b3 <= cp) && (0x01b6 >= cp)) ||
             ((0x01cd <= cp) && (0x01dc >= cp))) {
    cp -= 1;
    cp |= 0x1;
  } else {
    switch (cp) {
    default:
      break;
    case 0x00ff:
      cp = 0x0178;
      break;
    case 0x0180:
      cp = 0x0243;
      break;
    case 0x01dd:
      cp = 0x018e;
      break;
    case 0x019a:
      cp = 0x023d;
      break;
    case 0x019e:
      cp = 0x0220;
      break;
    case 0x0292:
      cp = 0x01b7;
      break;
    case 0x01c6:
      cp = 0x01c4;
      break;
    case 0x01c9:
      cp = 0x01c7;
      break;
    case 0x01cc:
      cp = 0x01ca;
      break;
    case 0x01f3:
      cp = 0x01f1;
      break;
    case 0x01bf:
      cp = 0x01f7;
      break;
    case 0x0188:
      cp = 0x0187;
      break;
    case 0x018c:
      cp = 0x018b;
      break;
    case 0x0192:
      cp = 0x0191;
      break;
    case 0x0199:
      cp = 0x0198;
      break;
    case 0x01a8:
      cp = 0x01a7;
      break;
    case 0x01ad:
      cp = 0x01ac;
      break;
    case 0x01b0:
      cp = 0x01af;
      break;
    case 0x01b9:
      cp = 0x01b8;
      break;
    case 0x01bd:
      cp = 0x01bc;
      break;
    case 0x01f5:
      cp = 0x01f4;
      break;
    case 0x023c:
      cp = 0x023b;
      break;
    case 0x0242:
      cp = 0x0241;
      break;
    case 0x037b:
      cp = 0x03fd;
      break;
    case 0x037c:
      cp = 0x03fe;
      break;
    case 0x037d:
      cp = 0x03ff;
      break;
    case 0x03f3:
      cp = 0x037f;
      break;
    case 0x03ac:
      cp = 0x0386;
      break;
    case 0x03ad:
      cp = 0x0388;
      break;
    case 0x03ae:
      cp = 0x0389;
      break;
    case 0x03af:
      cp = 0x038a;
      break;
    case 0x03cc:
      cp = 0x038c;
      break;
    case 0x03cd:
      cp = 0x038e;
      break;
    case 0x03ce:
      cp = 0x038f;
      break;
    case 0x0371:
      cp = 0x0370;
      break;
    case 0x0373:
      cp = 0x0372;
      break;
    case 0x0377:
      cp = 0x0376;
      break;
    case 0x03d1:
      cp = 0x0398;
      break;
    case 0x03d7:
      cp = 0x03cf;
      break;
    case 0x03f2:
      cp = 0x03f9;
      break;
    case 0x03f8:
      cp = 0x03f7;
      break;
    case 0x03fb:
      cp = 0x03fa;
      break;
    }
  }

  return cp;
}

void *utf8rcodepoint(const void *utf8_restrict str,
                     utf8_int32_t *utf8_restrict out_codepoint) {
  const char *s = (const char *)str;

  if (0xf0 == (0xf8 & s[0])) {
    // 4 byte utf8 codepoint
    *out_codepoint = ((0x07 & s[0]) << 18) | ((0x3f & s[1]) << 12) |
                     ((0x3f & s[2]) << 6) | (0x3f & s[3]);
  } else if (0xe0 == (0xf0 & s[0])) {
    // 3 byte utf8 codepoint
    *out_codepoint =
        ((0x0f & s[0]) << 12) | ((0x3f & s[1]) << 6) | (0x3f & s[2]);
  } else if (0xc0 == (0xe0 & s[0])) {
    // 2 byte utf8 codepoint
    *out_codepoint = ((0x1f & s[0]) << 6) | (0x3f & s[1]);
  } else {
    // 1 byte utf8 codepoint otherwise
    *out_codepoint = s[0];
  }

  do {
    s--;
  } while ((0 != (0x80 & s[0])) && (0x80 == (0xc0 & s[0])));

  return (void *)s;
}

#undef utf8_restrict
#undef utf8_null

#ifdef __cplusplus
} // extern "C"
#endif

#if defined(__clang__)
#pragma clang diagnostic pop
#endif

#endif // SHEREDOM_UTF8_H_INCLUDED



#include <stdlib.h>

#include <stdio.h>
#include <time.h>


typedef enum Lita_OSType {
    Lita_OSType_WINDOWS,
    Lita_OSType_ANDROID,
    Lita_OSType_LINUX,
    Lita_OSType_BSD,
    Lita_OSType_IOS,
    Lita_OSType_MAC,
    Lita_OSType_OTHER
} Lita_OSType;


#if defined(_WIN32)
    // Windows
    Lita_OSType litaOS = Lita_OSType_WINDOWS;
#elif defined(_WIN64)
    // Windows
    Lita_OSType litaOS = Lita_OSType_WINDOWS;
#elif defined(__CYGWIN__) && !defined(_WIN32)
    // Windows (Cygwin POSIX under Microsoft Window)
    Lita_OSType litaOS = Lita_OSType_WINDOWS;
#elif defined(__ANDROID__)
    // Android (implies Linux, so it must come first)
    Lita_OSType litaOS = Lita_OSType_ANDROID;
#elif defined(__linux__)
    // Debian, Ubuntu, Gentoo, Fedora, openSUSE, RedHat, Centos and other
    Lita_OSType litaOS = Lita_OSType_LINUX;
#elif defined(__unix__) || !defined(__APPLE__) && defined(__MACH__)
    #include <sys/param.h>
    #if defined(BSD)
        // FreeBSD, NetBSD, OpenBSD, DragonFly BSD
        Lita_OSType litaOS = Lita_OSType_BSD;
    #endif
#elif defined(__hpux)
    // HP-UX
    Lita_OSType litaOS = Lita_OSType_OTHER;
#elif defined(_AIX)
    // IBM AIX
    Lita_OSType litaOS = Lita_OSType_OTHER;
#elif defined(__APPLE__) && defined(__MACH__) // Apple OSX and iOS (Darwin)
    #include <TargetConditionals.h>
    #if TARGET_IPHONE_SIMULATOR == 1
        // Apple iOS
        Lita_OSType litaOS = Lita_OSType_IOS;
    #elif TARGET_OS_IPHONE == 1
        // Apple iOS
        Lita_OSType litaOS = Lita_OSType_IOS;
    #elif TARGET_OS_MAC == 1
        // Apple OSX
        Lita_OSType litaOS = Lita_OSType_MAC;
    #endif
#elif defined(__sun) && defined(__SVR4)
    // Oracle Solaris, Open Indiana
    Lita_OSType litaOS = Lita_OSType_OTHER;
#else
    Lita_OSType litaOS = Lita_OSType_OTHER;
#endif


typedef struct tm tm;



typedef enum Lita_ArchType {
    Lita_ArchType_UNKNOWN,
    Lita_ArchType_ARM32,
    Lita_ArchType_ARM64,
    Lita_ArchType_X86,
    Lita_ArchType_X86_64,
    Lita_ArchType_SPARC,
} Lita_ArchType;

#if defined(_M_IX86) || defined(__i386__) || defined(__i386) || defined(__i486__) || defined(__i486) || defined(i386)
#define LITA_X86 1
#else
#define LITA_X86 0
#endif

#if defined(_M_X64) || defined(__ia64__) || defined(__x86_64__)
#define LITA_X64 1
#else
#define LITA_X64 0
#endif

#if defined(__arm__)
#define LITA_ARM32 1
#else
#define LITA_ARM32 0
#endif

#if defined(__aarch64__)
#define LITA_ARM64 1
#else
#define LITA_ARM64 0
#endif

#if defined(__sparc__)
#define LITA_SPARC 1
#else
#define LITA_SPARC 0
#endif

#if LITA_ARM32
    Lita_ArchType litaArch = Lita_ArchType_ARM32;
#elif LITA_ARM64
    Lita_ArchType litaArch = Lita_ArchType_ARM64;
#elif LITA_X86
    Lita_ArchType litaArch = Lita_ArchType_X86;
#elif LITA_X64
    Lita_ArchType litaArch = Lita_ArchType_X86_64;
#elif LITA_SPARC
    Lita_ArchType litaArch = Lita_ArchType_SPARC;
#else
    Lita_ArchType litaArch = Lita_ArchType_UNKNOWN;
#endif


/*
 *
 * Mini regex-module inspired by Rob Pike's regex code described in:
 *
 * http://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html
 *
 *
 *
 * Supports:
 * ---------
 *   '.'        Dot, matches any character
 *   '^'        Start anchor, matches beginning of string
 *   '$'        End anchor, matches end of string
 *   '*'        Asterisk, match zero or more (greedy)
 *   '+'        Plus, match one or more (greedy)
 *   '?'        Question, match zero or one (non-greedy)
 *   '[abc]'    Character class, match if one of {'a', 'b', 'c'}
 *   '[^abc]'   Inverted class, match if NOT one of {'a', 'b', 'c'} -- NOTE: feature is currently broken!
 *   '[a-zA-Z]' Character ranges, the character set of the ranges { a-z | A-Z }
 *   '\s'       Whitespace, \t \f \r \n \v and spaces
 *   '\S'       Non-whitespace
 *   '\w'       Alphanumeric, [a-zA-Z0-9_]
 *   '\W'       Non-alphanumeric
 *   '\d'       Digits, [0-9]
 *   '\D'       Non-digits
 *
 *
 */



/*
 *
 * Mini regex-module inspired by Rob Pike's regex code described in:
 *
 * http://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html
 *
 *
 *
 * Supports:
 * ---------
 *   '.'        Dot, matches any character
 *   '^'        Start anchor, matches beginning of string
 *   '$'        End anchor, matches end of string
 *   '*'        Asterisk, match zero or more (greedy)
 *   '+'        Plus, match one or more (greedy)
 *   '?'        Question, match zero or one (non-greedy)
 *   '[abc]'    Character class, match if one of {'a', 'b', 'c'}
 *   '[^abc]'   Inverted class, match if NOT one of {'a', 'b', 'c'} -- NOTE: feature is currently broken!
 *   '[a-zA-Z]' Character ranges, the character set of the ranges { a-z | A-Z }
 *   '\s'       Whitespace, \t \f \r \n \v and spaces
 *   '\S'       Non-whitespace
 *   '\w'       Alphanumeric, [a-zA-Z0-9_]
 *   '\W'       Non-alphanumeric
 *   '\d'       Digits, [0-9]
 *   '\D'       Non-digits
 *
 *
 */

#ifndef _TINY_REGEX_C
#define _TINY_REGEX_C


#ifndef RE_DOT_MATCHES_NEWLINE
/* Define to 0 if you DON'T want '.' to match '\r' + '\n' */
#define RE_DOT_MATCHES_NEWLINE 1
#endif

#ifdef __cplusplus
extern "C"{
#endif



/* Typedef'd pointer to get abstract datatype. */
typedef struct regex_t* re_t;


/* Compile regex string pattern to a regex_t-array. */
re_t re_compile(const char* pattern);


/* Find matches of the compiled pattern inside text. */
int  re_matchp(re_t pattern, const char* text, int* matchlength);


/* Find matches of the txt pattern inside text (will compile automatically first). */
int  re_match(const char* pattern, const char* text, int* matchlength);


#ifdef __cplusplus
}
#endif

#endif /* ifndef _TINY_REGEX_C */

#include <stdio.h>

/* Definitions: */

#define MAX_REGEXP_OBJECTS      30    /* Max number of regex symbols in expression. */
#define MAX_CHAR_CLASS_LEN      40    /* Max length of character-class buffer in.   */


enum { UNUSED, DOT, BEGIN, END, QUESTIONMARK, STAR, PLUS, RE_CHAR, CHAR_CLASS, INV_CHAR_CLASS, DIGIT, NOT_DIGIT, ALPHA, NOT_ALPHA, WHITESPACE, NOT_WHITESPACE, /* BRANCH */ };

typedef struct regex_t
{
  unsigned char  type;   /* CHAR, STAR, etc.                      */
  union
  {
    unsigned char  ch;   /*      the character itself             */
    unsigned char* ccl;  /*  OR  a pointer to characters in class */
  };
} regex_t;



/* Private function declarations: */
static int matchpattern(regex_t* pattern, const char* text, int* matchlength);
static int matchcharclass(char c, const char* str);
static int matchstar(regex_t p, regex_t* pattern, const char* text, int* matchlength);
static int matchplus(regex_t p, regex_t* pattern, const char* text, int* matchlength);
static int matchone(regex_t p, char c);
static int matchdigit(char c);
static int matchalpha(char c);
static int matchwhitespace(char c);
static int matchmetachar(char c, const char* str);
static int matchrange(char c, const char* str);
static int matchdot(char c);
static int ismetachar(char c);



/* Public functions: */
int re_match(const char* pattern, const char* text, int* matchlength)
{
  return re_matchp(re_compile(pattern), text, matchlength);
}

int re_matchp(re_t pattern, const char* text, int* matchlength)
{
  *matchlength = 0;
  if (pattern != 0)
  {
    if (pattern[0].type == BEGIN)
    {
      return ((matchpattern(&pattern[1], text, matchlength)) ? 0 : -1);
    }
    else
    {
      int idx = -1;

      do
      {
        idx += 1;

        if (matchpattern(pattern, text, matchlength))
        {
          if (text[0] == '\0')
            return -1;

          return idx;
        }
      }
      while (*text++ != '\0');
    }
  }
  return -1;
}

re_t re_compile(const char* pattern)
{
  /* The sizes of the two static arrays below substantiates the static RAM usage of this module.
     MAX_REGEXP_OBJECTS is the max number of symbols in the expression.
     MAX_CHAR_CLASS_LEN determines the size of buffer for chars in all char-classes in the expression. */
  static regex_t re_compiled[MAX_REGEXP_OBJECTS];
  static unsigned char ccl_buf[MAX_CHAR_CLASS_LEN];
  int ccl_bufidx = 1;

  char c;     /* current char in pattern   */
  int i = 0;  /* index into pattern        */
  int j = 0;  /* index into re_compiled    */

  while (pattern[i] != '\0' && (j+1 < MAX_REGEXP_OBJECTS))
  {
    c = pattern[i];

    switch (c)
    {
      /* Meta-characters: */
      case '^': {    re_compiled[j].type = BEGIN;           } break;
      case '$': {    re_compiled[j].type = END;             } break;
      case '.': {    re_compiled[j].type = DOT;             } break;
      case '*': {    re_compiled[j].type = STAR;            } break;
      case '+': {    re_compiled[j].type = PLUS;            } break;
      case '?': {    re_compiled[j].type = QUESTIONMARK;    } break;
/*    case '|': {    re_compiled[j].type = BRANCH;          } break; <-- not working properly */

      /* Escaped character-classes (\s \w ...): */
      case '\\':
      {
        if (pattern[i+1] != '\0')
        {
          /* Skip the escape-char '\\' */
          i += 1;
          /* ... and check the next */
          switch (pattern[i])
          {
            /* Meta-character: */
            case 'd': {    re_compiled[j].type = DIGIT;            } break;
            case 'D': {    re_compiled[j].type = NOT_DIGIT;        } break;
            case 'w': {    re_compiled[j].type = ALPHA;            } break;
            case 'W': {    re_compiled[j].type = NOT_ALPHA;        } break;
            case 's': {    re_compiled[j].type = WHITESPACE;       } break;
            case 'S': {    re_compiled[j].type = NOT_WHITESPACE;   } break;

            /* Escaped character, e.g. '.' or '$' */
            default:
            {
              re_compiled[j].type = RE_CHAR;
              re_compiled[j].ch = pattern[i];
            } break;
          }
        }
        /* '\\' as last char in pattern -> invalid regular expression. */
/*
        else
        {
          re_compiled[j].type = CHAR;
          re_compiled[j].ch = pattern[i];
        }
*/
      } break;

      /* Character class: */
      case '[':
      {
        /* Remember where the char-buffer starts. */
        int buf_begin = ccl_bufidx;

        /* Look-ahead to determine if negated */
        if (pattern[i+1] == '^')
        {
          re_compiled[j].type = INV_CHAR_CLASS;
          i += 1; /* Increment i to avoid including '^' in the char-buffer */
          if (pattern[i+1] == 0) /* incomplete pattern, missing non-zero char after '^' */
          {
            return 0;
          }
        }
        else
        {
          re_compiled[j].type = CHAR_CLASS;
        }

        /* Copy characters inside [..] to buffer */
        while (    (pattern[++i] != ']')
                && (pattern[i]   != '\0')) /* Missing ] */
        {
          if (pattern[i] == '\\')
          {
            if (ccl_bufidx >= MAX_CHAR_CLASS_LEN - 1)
            {
              //fputs("exceeded internal buffer!\n", stderr);
              return 0;
            }
            if (pattern[i+1] == 0) /* incomplete pattern, missing non-zero char after '\\' */
            {
              return 0;
            }
            ccl_buf[ccl_bufidx++] = pattern[i++];
          }
          else if (ccl_bufidx >= MAX_CHAR_CLASS_LEN)
          {
              //fputs("exceeded internal buffer!\n", stderr);
              return 0;
          }
          ccl_buf[ccl_bufidx++] = pattern[i];
        }
        if (ccl_bufidx >= MAX_CHAR_CLASS_LEN)
        {
            /* Catches cases such as [00000000000000000000000000000000000000][ */
            //fputs("exceeded internal buffer!\n", stderr);
            return 0;
        }
        /* Null-terminate string end */
        ccl_buf[ccl_bufidx++] = 0;
        re_compiled[j].ccl = &ccl_buf[buf_begin];
      } break;

      /* Other characters: */
      default:
      {
        re_compiled[j].type = RE_CHAR;
        re_compiled[j].ch = c;
      } break;
    }
    /* no buffer-out-of-bounds access on invalid patterns - see https://github.com/kokke/tiny-regex-c/commit/1a279e04014b70b0695fba559a7c05d55e6ee90b */
    if (pattern[i] == 0)
    {
      return 0;
    }

    i += 1;
    j += 1;
  }
  /* 'UNUSED' is a sentinel used to indicate end-of-pattern */
  re_compiled[j].type = UNUSED;

  return (re_t) re_compiled;
}

void re_print(regex_t* pattern)
{
  const char* types[] = { "UNUSED", "DOT", "BEGIN", "END", "QUESTIONMARK", "STAR", "PLUS", "CHAR", "CHAR_CLASS", "INV_CHAR_CLASS", "DIGIT", "NOT_DIGIT", "ALPHA", "NOT_ALPHA", "WHITESPACE", "NOT_WHITESPACE", "BRANCH" };

  int i;
  int j;
  char c;
  for (i = 0; i < MAX_REGEXP_OBJECTS; ++i)
  {
    if (pattern[i].type == UNUSED)
    {
      break;
    }

    printf("type: %s", types[pattern[i].type]);
    if (pattern[i].type == CHAR_CLASS || pattern[i].type == INV_CHAR_CLASS)
    {
      printf(" [");
      for (j = 0; j < MAX_CHAR_CLASS_LEN; ++j)
      {
        c = pattern[i].ccl[j];
        if ((c == '\0') || (c == ']'))
        {
          break;
        }
        printf("%c", c);
      }
      printf("]");
    }
    else if (pattern[i].type == RE_CHAR)
    {
      printf(" '%c'", pattern[i].ch);
    }
    printf("\n");
  }
}



/* Private functions: */
static int matchdigit(char c)
{
  return ((c >= '0') && (c <= '9'));
}
static int matchalpha(char c)
{
  return ((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'));
}
static int matchwhitespace(char c)
{
  return ((c == ' ') || (c == '\t') || (c == '\n') || (c == '\r') || (c == '\f') || (c == '\v'));
}
static int matchalphanum(char c)
{
  return ((c == '_') || matchalpha(c) || matchdigit(c));
}
static int matchrange(char c, const char* str)
{
  return (    (c != '-')
           && (str[0] != '\0')
           && (str[0] != '-')
           && (str[1] == '-')
           && (str[2] != '\0')
           && (    (c >= str[0])
                && (c <= str[2])));
}
static int matchdot(char c)
{
#if defined(RE_DOT_MATCHES_NEWLINE) && (RE_DOT_MATCHES_NEWLINE == 1)
  (void)c;
  return 1;
#else
  return c != '\n' && c != '\r';
#endif
}
static int ismetachar(char c)
{
  return ((c == 's') || (c == 'S') || (c == 'w') || (c == 'W') || (c == 'd') || (c == 'D'));
}

static int matchmetachar(char c, const char* str)
{
  switch (str[0])
  {
    case 'd': return  matchdigit(c);
    case 'D': return !matchdigit(c);
    case 'w': return  matchalphanum(c);
    case 'W': return !matchalphanum(c);
    case 's': return  matchwhitespace(c);
    case 'S': return !matchwhitespace(c);
    default:  return (c == str[0]);
  }
}

static int matchcharclass(char c, const char* str)
{
  do
  {
    if (matchrange(c, str))
    {
      return 1;
    }
    else if (str[0] == '\\')
    {
      /* Escape-char: increment str-ptr and match on next char */
      str += 1;
      if (matchmetachar(c, str))
      {
        return 1;
      }
      else if ((c == str[0]) && !ismetachar(c))
      {
        return 1;
      }
    }
    else if (c == str[0])
    {
      if (c == '-')
      {
        return ((str[-1] == '\0') || (str[1] == '\0'));
      }
      else
      {
        return 1;
      }
    }
  }
  while (*str++ != '\0');

  return 0;
}

static int matchone(regex_t p, char c)
{
  switch (p.type)
  {
    case DOT:            return matchdot(c);
    case CHAR_CLASS:     return  matchcharclass(c, (const char*)p.ccl);
    case INV_CHAR_CLASS: return !matchcharclass(c, (const char*)p.ccl);
    case DIGIT:          return  matchdigit(c);
    case NOT_DIGIT:      return !matchdigit(c);
    case ALPHA:          return  matchalphanum(c);
    case NOT_ALPHA:      return !matchalphanum(c);
    case WHITESPACE:     return  matchwhitespace(c);
    case NOT_WHITESPACE: return !matchwhitespace(c);
    default:             return  (p.ch == c);
  }
}

static int matchstar(regex_t p, regex_t* pattern, const char* text, int* matchlength)
{
  int prelen = *matchlength;
  const char* prepoint = text;
  while ((text[0] != '\0') && matchone(p, *text))
  {
    text++;
    (*matchlength)++;
  }
  while (text >= prepoint)
  {
    if (matchpattern(pattern, text--, matchlength))
      return 1;
    (*matchlength)--;
  }

  *matchlength = prelen;
  return 0;
}

static int matchplus(regex_t p, regex_t* pattern, const char* text, int* matchlength)
{
  const char* prepoint = text;
  while ((text[0] != '\0') && matchone(p, *text))
  {
    text++;
    (*matchlength)++;
  }
  while (text > prepoint)
  {
    if (matchpattern(pattern, text--, matchlength))
      return 1;
    (*matchlength)--;
  }

  return 0;
}

static int matchquestion(regex_t p, regex_t* pattern, const char* text, int* matchlength)
{
  if (p.type == UNUSED)
    return 1;
  if (matchpattern(pattern, text, matchlength))
      return 1;
  if (*text && matchone(p, *text++))
  {
    if (matchpattern(pattern, text, matchlength))
    {
      (*matchlength)++;
      return 1;
    }
  }
  return 0;
}


#if 0

/* Recursive matching */
static int matchpattern(regex_t* pattern, const char* text, int *matchlength)
{
  int pre = *matchlength;
  if ((pattern[0].type == UNUSED) || (pattern[1].type == QUESTIONMARK))
  {
    return matchquestion(pattern[1], &pattern[2], text, matchlength);
  }
  else if (pattern[1].type == STAR)
  {
    return matchstar(pattern[0], &pattern[2], text, matchlength);
  }
  else if (pattern[1].type == PLUS)
  {
    return matchplus(pattern[0], &pattern[2], text, matchlength);
  }
  else if ((pattern[0].type == END) && pattern[1].type == UNUSED)
  {
    return text[0] == '\0';
  }
  else if ((text[0] != '\0') && matchone(pattern[0], text[0]))
  {
    (*matchlength)++;
    return matchpattern(&pattern[1], text+1);
  }
  else
  {
    *matchlength = pre;
    return 0;
  }
}

#else

/* Iterative matching */
static int matchpattern(regex_t* pattern, const char* text, int* matchlength)
{
  int pre = *matchlength;
  do
  {
    if ((pattern[0].type == UNUSED) || (pattern[1].type == QUESTIONMARK))
    {
      return matchquestion(pattern[0], &pattern[2], text, matchlength);
    }
    else if (pattern[1].type == STAR)
    {
      return matchstar(pattern[0], &pattern[2], text, matchlength);
    }
    else if (pattern[1].type == PLUS)
    {
      return matchplus(pattern[0], &pattern[2], text, matchlength);
    }
    else if ((pattern[0].type == END) && pattern[1].type == UNUSED)
    {
      return (text[0] == '\0');
    }
/*  Branching is not working properly
    else if (pattern[1].type == BRANCH)
    {
      return (matchpattern(pattern, text) || matchpattern(&pattern[2], text));
    }
*/
  (*matchlength)++;
  }
  while ((text[0] != '\0') && matchone(*pattern++, *text++));

  *matchlength = pre;
  return 0;
}

#endif


#include <stdatomic.h>


#ifndef LIBTCC_H
#define LIBTCC_H

#ifndef LIBTCCAPI
# define LIBTCCAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif

struct TCCState;

typedef struct TCCState TCCState;

/* create a new TCC compilation context */
LIBTCCAPI TCCState *tcc_new(void);

/* free a TCC compilation context */
LIBTCCAPI void tcc_delete(TCCState *s);

/* set CONFIG_TCCDIR at runtime */
LIBTCCAPI void tcc_set_lib_path(TCCState *s, const char *path);

/* set error/warning display callback */
LIBTCCAPI void tcc_set_error_func(TCCState *s, void *error_opaque,
    void (*error_func)(void *opaque, const char *msg));

/* set options as from command line (multiple supported) */
LIBTCCAPI void tcc_set_options(TCCState *s, const char *str);

/*****************************/
/* preprocessor */

/* add include path */
LIBTCCAPI int tcc_add_include_path(TCCState *s, const char *pathname);

/* add in system include path */
LIBTCCAPI int tcc_add_sysinclude_path(TCCState *s, const char *pathname);

/* define preprocessor symbol 'sym'. Can put optional value */
LIBTCCAPI void tcc_define_symbol(TCCState *s, const char *sym, const char *value);

/* undefine preprocess symbol 'sym' */
LIBTCCAPI void tcc_undefine_symbol(TCCState *s, const char *sym);

/*****************************/
/* compiling */

/* add a file (C file, dll, object, library, ld script). Return -1 if error. */
LIBTCCAPI int tcc_add_file(TCCState *s, const char *filename);

/* compile a string containing a C source. Return -1 if error. */
LIBTCCAPI int tcc_compile_string(TCCState *s, const char *buf);

/*****************************/
/* linking commands */

/* set output type. MUST BE CALLED before any compilation */
LIBTCCAPI int tcc_set_output_type(TCCState *s, int output_type);
#define TCC_OUTPUT_MEMORY   1 /* output will be run in memory (default) */
#define TCC_OUTPUT_EXE      2 /* executable file */
#define TCC_OUTPUT_DLL      3 /* dynamic library */
#define TCC_OUTPUT_OBJ      4 /* object file */
#define TCC_OUTPUT_PREPROCESS 5 /* only preprocess (used internally) */

/* equivalent to -Lpath option */
LIBTCCAPI int tcc_add_library_path(TCCState *s, const char *pathname);

/* the library name is the same as the argument of the '-l' option */
LIBTCCAPI int tcc_add_library(TCCState *s, const char *libraryname);

/* add a symbol to the compiled program */
LIBTCCAPI int tcc_add_symbol(TCCState *s, const char *name, const void *val);

/* output an executable, library or object file. DO NOT call
   tcc_relocate() before. */
LIBTCCAPI int tcc_output_file(TCCState *s, const char *filename);

/* link and run main() function and return its value. DO NOT call
   tcc_relocate() before. */
LIBTCCAPI int tcc_run(TCCState *s, int argc, char **argv);

/* do all relocations (needed before using tcc_get_symbol()) */
LIBTCCAPI int tcc_relocate(TCCState *s1, void *ptr);
/* possible values for 'ptr':
   - TCC_RELOCATE_AUTO : Allocate and manage memory internally
   - NULL              : return required memory size for the step below
   - memory address    : copy code to memory passed by the caller
   returns -1 if error. */
#define TCC_RELOCATE_AUTO (void*)1

/* return symbol value or NULL if not found */
LIBTCCAPI void *tcc_get_symbol(TCCState *s, const char *name);

#ifdef __cplusplus
}
#endif

#endif










#if LITA_X86 || LITA_X64
#define LIBTCC_AVAILABLE 1
#else
#define LIBTCC_AVAILABLE 0
#endif


#include <stdlib.h>

#if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || defined(__MINGW32__) || defined(__BORLANDC__)
#define OS_WIN
#endif

#if defined(OS_WIN) && !defined(__TINYC__)
#include <windows.h>
#include <libloaderapi.h>
#endif

#if defined(__TINYC__)
#include <winapi/windows.h>
#endif

#include <sys/stat.h>
#include <sys/types.h>

typedef struct _stat FileStat;

//#if defined(__TINYC__)
//#include <sys/unistd.h>
//size_t __cdecl strnlen(const char *_Str,size_t _MaxCount);
//#endif

#include <errno.h>



#include <stdarg.h>

#include <stdio.h>

#include <stdlib.h>

#include <math.h>

#include <ctype.h>

#include <limits.h>

#include <string.h>

#include <errno.h>


#ifndef MIN
#define MIN(x, y) ((x) <= (y) ? (x) : (y))
#endif

#ifndef MAX
#define MAX(x, y) ((x) >= (y) ? (x) : (y))
#endif

#ifndef ABS
#define ABS(x)    ((x < 0) ? (x) * -1 : (x))
#endif

#if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || defined(__MINGW32__) || defined(__BORLANDC__)
#define OS_WIN
#endif

#if !defined(OS_WIN) || defined(__TINYC__)
size_t strnlen(const char * s, size_t len) {
    size_t i = 0;
    for ( ; i < len && s[i] != '\0'; ++i);
    return i;
}
#endif

#if defined(_MSC_VER) || defined(__TINYC__) && (defined(_WIN32) || defined(_WIN64))
#include <io.h>

#define ftruncate(fd, sz) (-(_chsize_s((fd), (sz)) != 0))
#define fileno _fileno
#endif


#include "assert.h"

#ifndef MINIZ_EXPORT
#define MINIZ_EXPORT
#endif
/* miniz.c 3.0.0 - public domain deflate/inflate, zlib-subset, ZIP reading/writing/appending, PNG writing
   See "unlicense" statement at the end of this file.
   Rich Geldreich <richgel99@gmail.com>, last updated Oct. 13, 2013
   Implements RFC 1950: http://www.ietf.org/rfc/rfc1950.txt and RFC 1951: http://www.ietf.org/rfc/rfc1951.txt

   Most API's defined in miniz.c are optional. For example, to disable the archive related functions just define
   MINIZ_NO_ARCHIVE_APIS, or to get rid of all stdio usage define MINIZ_NO_STDIO (see the list below for more macros).

   * Low-level Deflate/Inflate implementation notes:

     Compression: Use the "tdefl" API's. The compressor supports raw, static, and dynamic blocks, lazy or
     greedy parsing, match length filtering, RLE-only, and Huffman-only streams. It performs and compresses
     approximately as well as zlib.

     Decompression: Use the "tinfl" API's. The entire decompressor is implemented as a single function
     coroutine: see tinfl_decompress(). It supports decompression into a 32KB (or larger power of 2) wrapping buffer, or into a memory
     block large enough to hold the entire file.

     The low-level tdefl/tinfl API's do not make any use of dynamic memory allocation.

   * zlib-style API notes:

     miniz.c implements a fairly large subset of zlib. There's enough functionality present for it to be a drop-in
     zlib replacement in many apps:
        The z_stream struct, optional memory allocation callbacks
        deflateInit/deflateInit2/deflate/deflateReset/deflateEnd/deflateBound
        inflateInit/inflateInit2/inflate/inflateReset/inflateEnd
        compress, compress2, compressBound, uncompress
        CRC-32, Adler-32 - Using modern, minimal code size, CPU cache friendly routines.
        Supports raw deflate streams or standard zlib streams with adler-32 checking.

     Limitations:
      The callback API's are not implemented yet. No support for gzip headers or zlib static dictionaries.
      I've tried to closely emulate zlib's various flavors of stream flushing and return status codes, but
      there are no guarantees that miniz.c pulls this off perfectly.

   * PNG writing: See the tdefl_write_image_to_png_file_in_memory() function, originally written by
     Alex Evans. Supports 1-4 bytes/pixel images.

   * ZIP archive API notes:

     The ZIP archive API's where designed with simplicity and efficiency in mind, with just enough abstraction to
     get the job done with minimal fuss. There are simple API's to retrieve file information, read files from
     existing archives, create new archives, append new files to existing archives, or clone archive data from
     one archive to another. It supports archives located in memory or the heap, on disk (using stdio.h),
     or you can specify custom file read/write callbacks.

     - Archive reading: Just call this function to read a single file from a disk archive:

      void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name,
        size_t *pSize, mz_uint zip_flags);

     For more complex cases, use the "mz_zip_reader" functions. Upon opening an archive, the entire central
     directory is located and read as-is into memory, and subsequent file access only occurs when reading individual files.

     - Archives file scanning: The simple way is to use this function to scan a loaded archive for a specific file:

     int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);

     The locate operation can optionally check file comments too, which (as one example) can be used to identify
     multiple versions of the same file in an archive. This function uses a simple linear search through the central
     directory, so it's not very fast.

     Alternately, you can iterate through all the files in an archive (using mz_zip_reader_get_num_files()) and
     retrieve detailed info on each file by calling mz_zip_reader_file_stat().

     - Archive creation: Use the "mz_zip_writer" functions. The ZIP writer immediately writes compressed file data
     to disk and builds an exact image of the central directory in memory. The central directory image is written
     all at once at the end of the archive file when the archive is finalized.

     The archive writer can optionally align each file's local header and file data to any power of 2 alignment,
     which can be useful when the archive will be read from optical media. Also, the writer supports placing
     arbitrary data blobs at the very beginning of ZIP archives. Archives written using either feature are still
     readable by any ZIP tool.

     - Archive appending: The simple way to add a single file to an archive is to call this function:

      mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name,
        const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);

     The archive will be created if it doesn't already exist, otherwise it'll be appended to.
     Note the appending is done in-place and is not an atomic operation, so if something goes wrong
     during the operation it's possible the archive could be left without a central directory (although the local
     file headers and file data will be fine, so the archive will be recoverable).

     For more complex archive modification scenarios:
     1. The safest way is to use a mz_zip_reader to read the existing archive, cloning only those bits you want to
     preserve into a new archive using using the mz_zip_writer_add_from_zip_reader() function (which compiles the
     compressed file data as-is). When you're done, delete the old archive and rename the newly written archive, and
     you're done. This is safe but requires a bunch of temporary disk space or heap memory.

     2. Or, you can convert an mz_zip_reader in-place to an mz_zip_writer using mz_zip_writer_init_from_reader(),
     append new files as needed, then finalize the archive which will write an updated central directory to the
     original archive. (This is basically what mz_zip_add_mem_to_archive_file_in_place() does.) There's a
     possibility that the archive's central directory could be lost with this method if anything goes wrong, though.

     - ZIP archive support limitations:
     No spanning support. Extraction functions can only handle unencrypted, stored or deflated files.
     Requires streams capable of seeking.

   * This is a header file library, like stb_image.c. To get only a header file, either cut and paste the
     below header, or create miniz.h, #define MINIZ_HEADER_FILE_ONLY, and then include miniz.c from it.

   * Important: For best perf. be sure to customize the below macros for your target platform:
     #define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1
     #define MINIZ_LITTLE_ENDIAN 1
     #define MINIZ_HAS_64BIT_REGISTERS 1

   * On platforms using glibc, Be sure to "#define _LARGEFILE64_SOURCE 1" before including miniz.c to ensure miniz
     uses the 64-bit variants: fopen64(), stat64(), etc. Otherwise you won't be able to process large files
     (i.e. 32-bit stat() fails for me on files > 0x7FFFFFFF bytes).
*/
// #pragma once
#ifndef MINIZ_H
#define MINIZ_H



/* Defines to completely disable specific portions of miniz.c:
   If all macros here are defined the only functionality remaining will be CRC-32 and adler-32. */

/* Define MINIZ_NO_STDIO to disable all usage and any functions which rely on stdio for file I/O. */
/*#define MINIZ_NO_STDIO */

/* If MINIZ_NO_TIME is specified then the ZIP archive functions will not be able to get the current time, or */
/* get/set file times, and the C run-time funcs that get/set times won't be called. */
/* The current downside is the times written to your archives will be from 1979. */
/*#define MINIZ_NO_TIME */

/* Define MINIZ_NO_DEFLATE_APIS to disable all compression API's. */
/*#define MINIZ_NO_DEFLATE_APIS */

/* Define MINIZ_NO_INFLATE_APIS to disable all decompression API's. */
/*#define MINIZ_NO_INFLATE_APIS */

/* Define MINIZ_NO_ARCHIVE_APIS to disable all ZIP archive API's. */
/*#define MINIZ_NO_ARCHIVE_APIS */

/* Define MINIZ_NO_ARCHIVE_WRITING_APIS to disable all writing related ZIP archive API's. */
/*#define MINIZ_NO_ARCHIVE_WRITING_APIS */

/* Define MINIZ_NO_ZLIB_APIS to remove all ZLIB-style compression/decompression API's. */
/*#define MINIZ_NO_ZLIB_APIS */

/* Define MINIZ_NO_ZLIB_COMPATIBLE_NAME to disable zlib names, to prevent conflicts against stock zlib. */
/*#define MINIZ_NO_ZLIB_COMPATIBLE_NAMES */

/* Define MINIZ_NO_MALLOC to disable all calls to malloc, free, and realloc.
   Note if MINIZ_NO_MALLOC is defined then the user must always provide custom user alloc/free/realloc
   callbacks to the zlib and archive API's, and a few stand-alone helper API's which don't provide custom user
   functions (such as tdefl_compress_mem_to_heap() and tinfl_decompress_mem_to_heap()) won't work. */
/*#define MINIZ_NO_MALLOC */

#ifdef MINIZ_NO_INFLATE_APIS
#define MINIZ_NO_ARCHIVE_APIS
#endif

#ifdef MINIZ_NO_DEFLATE_APIS
#define MINIZ_NO_ARCHIVE_WRITING_APIS
#endif

#if defined(__TINYC__) && (defined(__linux) || defined(__linux__))
/* TODO: Work around "error: include file 'sys\utime.h' when compiling with tcc on Linux */
#define MINIZ_NO_TIME
#endif

#include <stddef.h>

#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_ARCHIVE_APIS)
#include <time.h>
#endif

#if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) || defined(__i386) || defined(__i486__) || defined(__i486) || defined(i386) || defined(__ia64__) || defined(__x86_64__)
/* MINIZ_X86_OR_X64_CPU is only used to help set the below macros. */
#define MINIZ_X86_OR_X64_CPU 1
#else
#define MINIZ_X86_OR_X64_CPU 0
#endif

/* Set MINIZ_LITTLE_ENDIAN only if not set */
#if !defined(MINIZ_LITTLE_ENDIAN)
#if defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__)

#if (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
/* Set MINIZ_LITTLE_ENDIAN to 1 if the processor is little endian. */
#define MINIZ_LITTLE_ENDIAN 1
#else
#define MINIZ_LITTLE_ENDIAN 0
#endif

#else

#if MINIZ_X86_OR_X64_CPU
#define MINIZ_LITTLE_ENDIAN 1
#else
#define MINIZ_LITTLE_ENDIAN 0
#endif

#endif
#endif

/* Using unaligned loads and stores causes errors when using UBSan */
#if defined(__has_feature)
#if __has_feature(undefined_behavior_sanitizer)
#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 0
#endif
#endif

/* Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES only if not set */
#if !defined(MINIZ_USE_UNALIGNED_LOADS_AND_STORES)
#if MINIZ_X86_OR_X64_CPU
/* Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES to 1 on CPU's that permit efficient integer loads and stores from unaligned addresses. */
#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 0
#define MINIZ_UNALIGNED_USE_MEMCPY
#else
#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 0
#endif
#endif

#if defined(_M_X64) || defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__) || defined(__ia64__) || defined(__x86_64__)
/* Set MINIZ_HAS_64BIT_REGISTERS to 1 if operations on 64-bit integers are reasonably fast (and don't involve compiler generated calls to helper functions). */
#define MINIZ_HAS_64BIT_REGISTERS 1
#else
#define MINIZ_HAS_64BIT_REGISTERS 0
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* ------------------- zlib-style API Definitions. */

/* For more compatibility with zlib, miniz.c uses unsigned long for some parameters/struct members. Beware: mz_ulong can be either 32 or 64-bits! */
typedef unsigned long mz_ulong;

/* mz_free() internally uses the MZ_FREE() macro (which by default calls free() unless you've modified the MZ_MALLOC macro) to release a block allocated from the heap. */
MINIZ_EXPORT void mz_free(void *p);

#define MZ_ADLER32_INIT (1)
/* mz_adler32() returns the initial adler-32 value to use when called with ptr==NULL. */
MINIZ_EXPORT mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len);

#define MZ_CRC32_INIT (0)
/* mz_crc32() returns the initial CRC-32 value to use when called with ptr==NULL. */
MINIZ_EXPORT mz_ulong mz_crc32(mz_ulong crc, const unsigned char *ptr, size_t buf_len);

/* Compression strategies. */
enum
{
    MZ_DEFAULT_STRATEGY = 0,
    MZ_FILTERED = 1,
    MZ_HUFFMAN_ONLY = 2,
    MZ_RLE = 3,
    MZ_FIXED = 4
};

/* Method */
#define MZ_DEFLATED 8

/* Heap allocation callbacks.
Note that mz_alloc_func parameter types purposely differ from zlib's: items/size is size_t, not unsigned long. */
typedef void *(*mz_alloc_func)(void *opaque, size_t items, size_t size);
typedef void (*mz_free_func)(void *opaque, void *address);
typedef void *(*mz_realloc_func)(void *opaque, void *address, size_t old_items, size_t old_size, size_t items, size_t size);

/* Compression levels: 0-9 are the standard zlib-style levels, 10 is best possible compression (not zlib compatible, and may be very slow), MZ_DEFAULT_COMPRESSION=MZ_DEFAULT_LEVEL. */
enum
{
    MZ_NO_COMPRESSION = 0,
    MZ_BEST_SPEED = 1,
    MZ_BEST_COMPRESSION = 9,
    MZ_UBER_COMPRESSION = 10,
    MZ_DEFAULT_LEVEL = 6,
    MZ_DEFAULT_COMPRESSION = -1
};

#define MZ_VERSION "11.0.1"
#define MZ_VERNUM 0xB001
#define MZ_VER_MAJOR 11
#define MZ_VER_MINOR 1
#define MZ_VER_REVISION 0
#define MZ_VER_SUBREVISION 0

#ifndef MINIZ_NO_ZLIB_APIS

/* Flush values. For typical usage you only need MZ_NO_FLUSH and MZ_FINISH. The other values are for advanced use (refer to the zlib docs). */
enum
{
    MZ_NO_FLUSH = 0,
    MZ_PARTIAL_FLUSH = 1,
    MZ_SYNC_FLUSH = 2,
    MZ_FULL_FLUSH = 3,
    MZ_FINISH = 4,
    MZ_BLOCK = 5
};

/* Return status codes. MZ_PARAM_ERROR is non-standard. */
enum
{
    MZ_OK = 0,
    MZ_STREAM_END = 1,
    MZ_NEED_DICT = 2,
    MZ_ERRNO = -1,
    MZ_STREAM_ERROR = -2,
    MZ_DATA_ERROR = -3,
    MZ_MEM_ERROR = -4,
    MZ_BUF_ERROR = -5,
    MZ_VERSION_ERROR = -6,
    MZ_PARAM_ERROR = -10000
};

/* Window bits */
#define MZ_DEFAULT_WINDOW_BITS 15

struct mz_internal_state;

/* Compression/decompression stream struct. */
typedef struct mz_stream_s
{
    const unsigned char *next_in; /* pointer to next byte to read */
    unsigned int avail_in;        /* number of bytes available at next_in */
    mz_ulong total_in;            /* total number of bytes consumed so far */

    unsigned char *next_out; /* pointer to next byte to write */
    unsigned int avail_out;  /* number of bytes that can be written to next_out */
    mz_ulong total_out;      /* total number of bytes produced so far */

    char *msg;                       /* error msg (unused) */
    struct mz_internal_state *state; /* internal state, allocated by zalloc/zfree */

    mz_alloc_func zalloc; /* optional heap allocation function (defaults to malloc) */
    mz_free_func zfree;   /* optional heap free function (defaults to free) */
    void *opaque;         /* heap alloc function user pointer */

    int data_type;     /* data_type (unused) */
    mz_ulong adler;    /* adler32 of the source or uncompressed data */
    mz_ulong reserved; /* not used */
} mz_stream;

typedef mz_stream *mz_streamp;

/* Returns the version string of miniz.c. */
MINIZ_EXPORT const char *mz_version(void);

#ifndef MINIZ_NO_DEFLATE_APIS

/* mz_deflateInit() initializes a compressor with default options: */
/* Parameters: */
/*  pStream must point to an initialized mz_stream struct. */
/*  level must be between [MZ_NO_COMPRESSION, MZ_BEST_COMPRESSION]. */
/*  level 1 enables a specially optimized compression function that's been optimized purely for performance, not ratio. */
/*  (This special func. is currently only enabled when MINIZ_USE_UNALIGNED_LOADS_AND_STORES and MINIZ_LITTLE_ENDIAN are defined.) */
/* Return values: */
/*  MZ_OK on success. */
/*  MZ_STREAM_ERROR if the stream is bogus. */
/*  MZ_PARAM_ERROR if the input parameters are bogus. */
/*  MZ_MEM_ERROR on out of memory. */
MINIZ_EXPORT int mz_deflateInit(mz_streamp pStream, int level);

/* mz_deflateInit2() is like mz_deflate(), except with more control: */
/* Additional parameters: */
/*   method must be MZ_DEFLATED */
/*   window_bits must be MZ_DEFAULT_WINDOW_BITS (to wrap the deflate stream with zlib header/adler-32 footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate/no header or footer) */
/*   mem_level must be between [1, 9] (it's checked but ignored by miniz.c) */
MINIZ_EXPORT int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy);

/* Quickly resets a compressor without having to reallocate anything. Same as calling mz_deflateEnd() followed by mz_deflateInit()/mz_deflateInit2(). */
MINIZ_EXPORT int mz_deflateReset(mz_streamp pStream);

/* mz_deflate() compresses the input to output, consuming as much of the input and producing as much output as possible. */
/* Parameters: */
/*   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members. */
/*   flush may be MZ_NO_FLUSH, MZ_PARTIAL_FLUSH/MZ_SYNC_FLUSH, MZ_FULL_FLUSH, or MZ_FINISH. */
/* Return values: */
/*   MZ_OK on success (when flushing, or if more input is needed but not available, and/or there's more output to be written but the output buffer is full). */
/*   MZ_STREAM_END if all input has been consumed and all output bytes have been written. Don't call mz_deflate() on the stream anymore. */
/*   MZ_STREAM_ERROR if the stream is bogus. */
/*   MZ_PARAM_ERROR if one of the parameters is invalid. */
/*   MZ_BUF_ERROR if no forward progress is possible because the input and/or output buffers are empty. (Fill up the input buffer or free up some output space and try again.) */
MINIZ_EXPORT int mz_deflate(mz_streamp pStream, int flush);

/* mz_deflateEnd() deinitializes a compressor: */
/* Return values: */
/*  MZ_OK on success. */
/*  MZ_STREAM_ERROR if the stream is bogus. */
MINIZ_EXPORT int mz_deflateEnd(mz_streamp pStream);

/* mz_deflateBound() returns a (very) conservative upper bound on the amount of data that could be generated by deflate(), assuming flush is set to only MZ_NO_FLUSH or MZ_FINISH. */
MINIZ_EXPORT mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len);

/* Single-call compression functions mz_compress() and mz_compress2(): */
/* Returns MZ_OK on success, or one of the error codes from mz_deflate() on failure. */
MINIZ_EXPORT int mz_compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len);
MINIZ_EXPORT int mz_compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, int level);

/* mz_compressBound() returns a (very) conservative upper bound on the amount of data that could be generated by calling mz_compress(). */
MINIZ_EXPORT mz_ulong mz_compressBound(mz_ulong source_len);

#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/

#ifndef MINIZ_NO_INFLATE_APIS

/* Initializes a decompressor. */
MINIZ_EXPORT int mz_inflateInit(mz_streamp pStream);

/* mz_inflateInit2() is like mz_inflateInit() with an additional option that controls the window size and whether or not the stream has been wrapped with a zlib header/footer: */
/* window_bits must be MZ_DEFAULT_WINDOW_BITS (to parse zlib header/footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate). */
MINIZ_EXPORT int mz_inflateInit2(mz_streamp pStream, int window_bits);

/* Quickly resets a compressor without having to reallocate anything. Same as calling mz_inflateEnd() followed by mz_inflateInit()/mz_inflateInit2(). */
MINIZ_EXPORT int mz_inflateReset(mz_streamp pStream);

/* Decompresses the input stream to the output, consuming only as much of the input as needed, and writing as much to the output as possible. */
/* Parameters: */
/*   pStream is the stream to read from and write to. You must initialize/update the next_in, avail_in, next_out, and avail_out members. */
/*   flush may be MZ_NO_FLUSH, MZ_SYNC_FLUSH, or MZ_FINISH. */
/*   On the first call, if flush is MZ_FINISH it's assumed the input and output buffers are both sized large enough to decompress the entire stream in a single call (this is slightly faster). */
/*   MZ_FINISH implies that there are no more source bytes available beside what's already in the input buffer, and that the output buffer is large enough to hold the rest of the decompressed data. */
/* Return values: */
/*   MZ_OK on success. Either more input is needed but not available, and/or there's more output to be written but the output buffer is full. */
/*   MZ_STREAM_END if all needed input has been consumed and all output bytes have been written. For zlib streams, the adler-32 of the decompressed data has also been verified. */
/*   MZ_STREAM_ERROR if the stream is bogus. */
/*   MZ_DATA_ERROR if the deflate stream is invalid. */
/*   MZ_PARAM_ERROR if one of the parameters is invalid. */
/*   MZ_BUF_ERROR if no forward progress is possible because the input buffer is empty but the inflater needs more input to continue, or if the output buffer is not large enough. Call mz_inflate() again */
/*   with more input data, or with more room in the output buffer (except when using single call decompression, described above). */
MINIZ_EXPORT int mz_inflate(mz_streamp pStream, int flush);

/* Deinitializes a decompressor. */
MINIZ_EXPORT int mz_inflateEnd(mz_streamp pStream);

/* Single-call decompression. */
/* Returns MZ_OK on success, or one of the error codes from mz_inflate() on failure. */
MINIZ_EXPORT int mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len);
MINIZ_EXPORT int mz_uncompress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong *pSource_len);
#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/

/* Returns a string description of the specified error code, or NULL if the error code is invalid. */
MINIZ_EXPORT const char *mz_error(int err);

/* Redefine zlib-compatible names to miniz equivalents, so miniz.c can be used as a drop-in replacement for the subset of zlib that miniz.c supports. */
/* Define MINIZ_NO_ZLIB_COMPATIBLE_NAMES to disable zlib-compatibility if you use zlib in the same project. */
#ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES
typedef unsigned char Byte;
typedef unsigned int uInt;
typedef mz_ulong uLong;
typedef Byte Bytef;
typedef uInt uIntf;
typedef char charf;
typedef int intf;
typedef void *voidpf;
typedef uLong uLongf;
typedef void *voidp;
typedef void *const voidpc;
#define Z_NULL 0
#define Z_NO_FLUSH MZ_NO_FLUSH
#define Z_PARTIAL_FLUSH MZ_PARTIAL_FLUSH
#define Z_SYNC_FLUSH MZ_SYNC_FLUSH
#define Z_FULL_FLUSH MZ_FULL_FLUSH
#define Z_FINISH MZ_FINISH
#define Z_BLOCK MZ_BLOCK
#define Z_OK MZ_OK
#define Z_STREAM_END MZ_STREAM_END
#define Z_NEED_DICT MZ_NEED_DICT
#define Z_ERRNO MZ_ERRNO
#define Z_STREAM_ERROR MZ_STREAM_ERROR
#define Z_DATA_ERROR MZ_DATA_ERROR
#define Z_MEM_ERROR MZ_MEM_ERROR
#define Z_BUF_ERROR MZ_BUF_ERROR
#define Z_VERSION_ERROR MZ_VERSION_ERROR
#define Z_PARAM_ERROR MZ_PARAM_ERROR
#define Z_NO_COMPRESSION MZ_NO_COMPRESSION
#define Z_BEST_SPEED MZ_BEST_SPEED
#define Z_BEST_COMPRESSION MZ_BEST_COMPRESSION
#define Z_DEFAULT_COMPRESSION MZ_DEFAULT_COMPRESSION
#define Z_DEFAULT_STRATEGY MZ_DEFAULT_STRATEGY
#define Z_FILTERED MZ_FILTERED
#define Z_HUFFMAN_ONLY MZ_HUFFMAN_ONLY
#define Z_RLE MZ_RLE
#define Z_FIXED MZ_FIXED
#define Z_DEFLATED MZ_DEFLATED
#define Z_DEFAULT_WINDOW_BITS MZ_DEFAULT_WINDOW_BITS
#define alloc_func mz_alloc_func
#define free_func mz_free_func
#define internal_state mz_internal_state
#define z_stream mz_stream

#ifndef MINIZ_NO_DEFLATE_APIS
#define deflateInit mz_deflateInit
#define deflateInit2 mz_deflateInit2
#define deflateReset mz_deflateReset
#define deflate mz_deflate
#define deflateEnd mz_deflateEnd
#define deflateBound mz_deflateBound
#define compress mz_compress
#define compress2 mz_compress2
#define compressBound mz_compressBound
#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/

#ifndef MINIZ_NO_INFLATE_APIS
#define inflateInit mz_inflateInit
#define inflateInit2 mz_inflateInit2
#define inflateReset mz_inflateReset
#define inflate mz_inflate
#define inflateEnd mz_inflateEnd
#define uncompress mz_uncompress
#define uncompress2 mz_uncompress2
#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/

#define crc32 mz_crc32
#define adler32 mz_adler32
#define MAX_WBITS 15
#define MAX_MEM_LEVEL 9
#define zError mz_error
#define ZLIB_VERSION MZ_VERSION
#define ZLIB_VERNUM MZ_VERNUM
#define ZLIB_VER_MAJOR MZ_VER_MAJOR
#define ZLIB_VER_MINOR MZ_VER_MINOR
#define ZLIB_VER_REVISION MZ_VER_REVISION
#define ZLIB_VER_SUBREVISION MZ_VER_SUBREVISION
#define zlibVersion mz_version
#define zlib_version mz_version()
#endif /* #ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES */

#endif /* MINIZ_NO_ZLIB_APIS */

#ifdef __cplusplus
}
#endif





//#pragma once
#include <assert.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>



/* ------------------- Types and macros */
typedef unsigned char mz_uint8;
typedef signed short mz_int16;
typedef unsigned short mz_uint16;
typedef unsigned int mz_uint32;
typedef unsigned int mz_uint;
typedef int64_t mz_int64;
typedef uint64_t mz_uint64;
typedef int mz_bool;

#define MZ_FALSE (0)
#define MZ_TRUE (1)

/* Works around MSVC's spammy "warning C4127: conditional expression is constant" message. */
#ifdef _MSC_VER
#define MZ_MACRO_END while (0, 0)
#else
#define MZ_MACRO_END while (0)
#endif

#ifdef MINIZ_NO_STDIO
#define MZ_FILE void *
#else
#include <stdio.h>
#define MZ_FILE FILE
#endif /* #ifdef MINIZ_NO_STDIO */

#ifdef MINIZ_NO_TIME
typedef struct mz_dummy_time_t_tag
{
    mz_uint32 m_dummy1;
    mz_uint32 m_dummy2;
} mz_dummy_time_t;
#define MZ_TIME_T mz_dummy_time_t
#else
#define MZ_TIME_T time_t
#endif

#define MZ_ASSERT(x) assert(x)

#ifdef MINIZ_NO_MALLOC
#define MZ_MALLOC(x) NULL
#define MZ_FREE(x) (void)x, ((void)0)
#define MZ_REALLOC(p, x) NULL
#else
#define MZ_MALLOC(x) malloc(x)
#define MZ_FREE(x) free(x)
#define MZ_REALLOC(p, x) realloc(p, x)
#endif

#define MZ_MAX(a, b) (((a) > (b)) ? (a) : (b))
#define MZ_MIN(a, b) (((a) < (b)) ? (a) : (b))
#define MZ_CLEAR_OBJ(obj) memset(&(obj), 0, sizeof(obj))
#define MZ_CLEAR_ARR(obj) memset((obj), 0, sizeof(obj))
#define MZ_CLEAR_PTR(obj) memset((obj), 0, sizeof(*obj))

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
#define MZ_READ_LE16(p) *((const mz_uint16 *)(p))
#define MZ_READ_LE32(p) *((const mz_uint32 *)(p))
#else
#define MZ_READ_LE16(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U))
#define MZ_READ_LE32(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U) | ((mz_uint32)(((const mz_uint8 *)(p))[2]) << 16U) | ((mz_uint32)(((const mz_uint8 *)(p))[3]) << 24U))
#endif

#define MZ_READ_LE64(p) (((mz_uint64)MZ_READ_LE32(p)) | (((mz_uint64)MZ_READ_LE32((const mz_uint8 *)(p) + sizeof(mz_uint32))) << 32U))

#ifdef _MSC_VER
#define MZ_FORCEINLINE __forceinline
#elif defined(__GNUC__)
#define MZ_FORCEINLINE __inline__ __attribute__((__always_inline__))
#else
#define MZ_FORCEINLINE inline
#endif

#ifdef __cplusplus
extern "C" {
#endif

extern MINIZ_EXPORT void *miniz_def_alloc_func(void *opaque, size_t items, size_t size);
extern MINIZ_EXPORT void miniz_def_free_func(void *opaque, void *address);
extern MINIZ_EXPORT void *miniz_def_realloc_func(void *opaque, void *address, size_t old_items, size_t old_size, size_t items, size_t size);

#define MZ_UINT16_MAX (0xFFFFU)
#define MZ_UINT32_MAX (0xFFFFFFFFU)

#ifdef __cplusplus
}
#endif
//#pragma once


#ifndef MINIZ_NO_DEFLATE_APIS

#ifdef __cplusplus
extern "C" {
#endif
/* ------------------- Low-level Compression API Definitions */

/* Set TDEFL_LESS_MEMORY to 1 to use less memory (compression will be slightly slower, and raw/dynamic blocks will be output more frequently). */
#define TDEFL_LESS_MEMORY 0

/* tdefl_init() compression flags logically OR'd together (low 12 bits contain the max. number of probes per dictionary search): */
/* TDEFL_DEFAULT_MAX_PROBES: The compressor defaults to 128 dictionary probes per dictionary search. 0=Huffman only, 1=Huffman+LZ (fastest/crap compression), 4095=Huffman+LZ (slowest/best compression). */
enum
{
    TDEFL_HUFFMAN_ONLY = 0,
    TDEFL_DEFAULT_MAX_PROBES = 128,
    TDEFL_MAX_PROBES_MASK = 0xFFF
};

/* TDEFL_WRITE_ZLIB_HEADER: If set, the compressor outputs a zlib header before the deflate data, and the Adler-32 of the source data at the end. Otherwise, you'll get raw deflate data. */
/* TDEFL_COMPUTE_ADLER32: Always compute the adler-32 of the input data (even when not writing zlib headers). */
/* TDEFL_GREEDY_PARSING_FLAG: Set to use faster greedy parsing, instead of more efficient lazy parsing. */
/* TDEFL_NONDETERMINISTIC_PARSING_FLAG: Enable to decrease the compressor's initialization time to the minimum, but the output may vary from run to run given the same input (depending on the contents of memory). */
/* TDEFL_RLE_MATCHES: Only look for RLE matches (matches with a distance of 1) */
/* TDEFL_FILTER_MATCHES: Discards matches <= 5 chars if enabled. */
/* TDEFL_FORCE_ALL_STATIC_BLOCKS: Disable usage of optimized Huffman tables. */
/* TDEFL_FORCE_ALL_RAW_BLOCKS: Only use raw (uncompressed) deflate blocks. */
/* The low 12 bits are reserved to control the max # of hash probes per dictionary lookup (see TDEFL_MAX_PROBES_MASK). */
enum
{
    TDEFL_WRITE_ZLIB_HEADER = 0x01000,
    TDEFL_COMPUTE_ADLER32 = 0x02000,
    TDEFL_GREEDY_PARSING_FLAG = 0x04000,
    TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,
    TDEFL_RLE_MATCHES = 0x10000,
    TDEFL_FILTER_MATCHES = 0x20000,
    TDEFL_FORCE_ALL_STATIC_BLOCKS = 0x40000,
    TDEFL_FORCE_ALL_RAW_BLOCKS = 0x80000
};

/* High level compression functions: */
/* tdefl_compress_mem_to_heap() compresses a block in memory to a heap block allocated via malloc(). */
/* On entry: */
/*  pSrc_buf, src_buf_len: Pointer and size of source block to compress. */
/*  flags: The max match finder probes (default is 128) logically OR'd against the above flags. Higher probes are slower but improve compression. */
/* On return: */
/*  Function returns a pointer to the compressed data, or NULL on failure. */
/*  *pOut_len will be set to the compressed data's size, which could be larger than src_buf_len on uncompressible data. */
/*  The caller must free() the returned block when it's no longer needed. */
MINIZ_EXPORT void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);

/* tdefl_compress_mem_to_mem() compresses a block in memory to another block in memory. */
/* Returns 0 on failure. */
MINIZ_EXPORT size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);

/* Compresses an image to a compressed PNG file in memory. */
/* On entry: */
/*  pImage, w, h, and num_chans describe the image to compress. num_chans may be 1, 2, 3, or 4. */
/*  The image pitch in bytes per scanline will be w*num_chans. The leftmost pixel on the top scanline is stored first in memory. */
/*  level may range from [0,10], use MZ_NO_COMPRESSION, MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc. or a decent default is MZ_DEFAULT_LEVEL */
/*  If flip is true, the image will be flipped on the Y axis (useful for OpenGL apps). */
/* On return: */
/*  Function returns a pointer to the compressed data, or NULL on failure. */
/*  *pLen_out will be set to the size of the PNG image file. */
/*  The caller must mz_free() the returned heap block (which will typically be larger than *pLen_out) when it's no longer needed. */
MINIZ_EXPORT void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip);
MINIZ_EXPORT void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h, int num_chans, size_t *pLen_out);

/* Output stream interface. The compressor uses this interface to write compressed data. It'll typically be called TDEFL_OUT_BUF_SIZE at a time. */
typedef mz_bool (*tdefl_put_buf_func_ptr)(const void *pBuf, int len, void *pUser);

/* tdefl_compress_mem_to_output() compresses a block to an output stream. The above helpers use this function internally. */
MINIZ_EXPORT mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

enum
{
    TDEFL_MAX_HUFF_TABLES = 3,
    TDEFL_MAX_HUFF_SYMBOLS_0 = 288,
    TDEFL_MAX_HUFF_SYMBOLS_1 = 32,
    TDEFL_MAX_HUFF_SYMBOLS_2 = 19,
    TDEFL_LZ_DICT_SIZE = 32768,
    TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1,
    TDEFL_MIN_MATCH_LEN = 3,
    TDEFL_MAX_MATCH_LEN = 258
};

/* TDEFL_OUT_BUF_SIZE MUST be large enough to hold a single entire compressed output block (using static/fixed Huffman codes). */
#if TDEFL_LESS_MEMORY
enum
{
    TDEFL_LZ_CODE_BUF_SIZE = 24 * 1024,
    TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
    TDEFL_MAX_HUFF_SYMBOLS = 288,
    TDEFL_LZ_HASH_BITS = 12,
    TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
    TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
    TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
};
#else
enum
{
    TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024,
    TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
    TDEFL_MAX_HUFF_SYMBOLS = 288,
    TDEFL_LZ_HASH_BITS = 15,
    TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
    TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
    TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
};
#endif

/* The low-level tdefl functions below may be used directly if the above helper functions aren't flexible enough. The low-level functions don't make any heap allocations, unlike the above helper functions. */
typedef enum {
    TDEFL_STATUS_BAD_PARAM = -2,
    TDEFL_STATUS_PUT_BUF_FAILED = -1,
    TDEFL_STATUS_OKAY = 0,
    TDEFL_STATUS_DONE = 1
} tdefl_status;

/* Must map to MZ_NO_FLUSH, MZ_SYNC_FLUSH, etc. enums */
typedef enum {
    TDEFL_NO_FLUSH = 0,
    TDEFL_SYNC_FLUSH = 2,
    TDEFL_FULL_FLUSH = 3,
    TDEFL_FINISH = 4
} tdefl_flush;

/* tdefl's compression state structure. */
typedef struct
{
    tdefl_put_buf_func_ptr m_pPut_buf_func;
    void *m_pPut_buf_user;
    mz_uint m_flags, m_max_probes[2];
    int m_greedy_parsing;
    mz_uint m_adler32, m_lookahead_pos, m_lookahead_size, m_dict_size;
    mz_uint8 *m_pLZ_code_buf, *m_pLZ_flags, *m_pOutput_buf, *m_pOutput_buf_end;
    mz_uint m_num_flags_left, m_total_lz_bytes, m_lz_code_buf_dict_pos, m_bits_in, m_bit_buffer;
    mz_uint m_saved_match_dist, m_saved_match_len, m_saved_lit, m_output_flush_ofs, m_output_flush_remaining, m_finished, m_block_index, m_wants_to_finish;
    tdefl_status m_prev_return_status;
    const void *m_pIn_buf;
    void *m_pOut_buf;
    size_t *m_pIn_buf_size, *m_pOut_buf_size;
    tdefl_flush m_flush;
    const mz_uint8 *m_pSrc;
    size_t m_src_buf_left, m_out_buf_ofs;
    mz_uint8 m_dict[TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN - 1];
    mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
    mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
    mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
    mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE];
    mz_uint16 m_next[TDEFL_LZ_DICT_SIZE];
    mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE];
    mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE];
} tdefl_compressor;

/* Initializes the compressor. */
/* There is no corresponding deinit() function because the tdefl API's do not dynamically allocate memory. */
/* pBut_buf_func: If NULL, output data will be supplied to the specified callback. In this case, the user should call the tdefl_compress_buffer() API for compression. */
/* If pBut_buf_func is NULL the user should always call the tdefl_compress() API. */
/* flags: See the above enums (TDEFL_HUFFMAN_ONLY, TDEFL_WRITE_ZLIB_HEADER, etc.) */
MINIZ_EXPORT tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

/* Compresses a block of data, consuming as much of the specified input buffer as possible, and writing as much compressed data to the specified output buffer as possible. */
MINIZ_EXPORT tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pIn_buf_size, void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush);

/* tdefl_compress_buffer() is only usable when the tdefl_init() is called with a non-NULL tdefl_put_buf_func_ptr. */
/* tdefl_compress_buffer() always consumes the entire input buffer. */
MINIZ_EXPORT tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush);

MINIZ_EXPORT tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d);
MINIZ_EXPORT mz_uint32 tdefl_get_adler32(tdefl_compressor *d);

/* Create tdefl_compress() flags given zlib-style compression parameters. */
/* level may range from [0,10] (where 10 is absolute max compression, but may be much slower on some files) */
/* window_bits may be -15 (raw deflate) or 15 (zlib) */
/* strategy may be either MZ_DEFAULT_STRATEGY, MZ_FILTERED, MZ_HUFFMAN_ONLY, MZ_RLE, or MZ_FIXED */
MINIZ_EXPORT mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy);

#ifndef MINIZ_NO_MALLOC
/* Allocate the tdefl_compressor structure in C so that */
/* non-C language bindings to tdefl_ API don't need to worry about */
/* structure size and allocation mechanism. */
MINIZ_EXPORT tdefl_compressor *tdefl_compressor_alloc(void);
MINIZ_EXPORT void tdefl_compressor_free(tdefl_compressor *pComp);
#endif

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/
//#pragma once

/* ------------------- Low-level Decompression API Definitions */

#ifndef MINIZ_NO_INFLATE_APIS

#ifdef __cplusplus
extern "C" {
#endif
/* Decompression flags used by tinfl_decompress(). */
/* TINFL_FLAG_PARSE_ZLIB_HEADER: If set, the input has a valid zlib header and ends with an adler32 checksum (it's a valid zlib stream). Otherwise, the input is a raw deflate stream. */
/* TINFL_FLAG_HAS_MORE_INPUT: If set, there are more input bytes available beyond the end of the supplied input buffer. If clear, the input buffer contains all remaining input. */
/* TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF: If set, the output buffer is large enough to hold the entire decompressed stream. If clear, the output buffer is at least the size of the dictionary (typically 32KB). */
/* TINFL_FLAG_COMPUTE_ADLER32: Force adler-32 checksum computation of the decompressed bytes. */
enum
{
    TINFL_FLAG_PARSE_ZLIB_HEADER = 1,
    TINFL_FLAG_HAS_MORE_INPUT = 2,
    TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,
    TINFL_FLAG_COMPUTE_ADLER32 = 8
};

/* High level decompression functions: */
/* tinfl_decompress_mem_to_heap() decompresses a block in memory to a heap block allocated via malloc(). */
/* On entry: */
/*  pSrc_buf, src_buf_len: Pointer and size of the Deflate or zlib source data to decompress. */
/* On return: */
/*  Function returns a pointer to the decompressed data, or NULL on failure. */
/*  *pOut_len will be set to the decompressed data's size, which could be larger than src_buf_len on uncompressible data. */
/*  The caller must call mz_free() on the returned block when it's no longer needed. */
MINIZ_EXPORT void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);

/* tinfl_decompress_mem_to_mem() decompresses a block in memory to another block in memory. */
/* Returns TINFL_DECOMPRESS_MEM_TO_MEM_FAILED on failure, or the number of bytes written on success. */
#define TINFL_DECOMPRESS_MEM_TO_MEM_FAILED ((size_t)(-1))
MINIZ_EXPORT size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);

/* tinfl_decompress_mem_to_callback() decompresses a block in memory to an internal 32KB buffer, and a user provided callback function will be called to flush the buffer. */
/* Returns 1 on success or 0 on failure. */
typedef int (*tinfl_put_buf_func_ptr)(const void *pBuf, int len, void *pUser);
MINIZ_EXPORT int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);

struct tinfl_decompressor_tag;
typedef struct tinfl_decompressor_tag tinfl_decompressor;

#ifndef MINIZ_NO_MALLOC
/* Allocate the tinfl_decompressor structure in C so that */
/* non-C language bindings to tinfl_ API don't need to worry about */
/* structure size and allocation mechanism. */
MINIZ_EXPORT tinfl_decompressor *tinfl_decompressor_alloc(void);
MINIZ_EXPORT void tinfl_decompressor_free(tinfl_decompressor *pDecomp);
#endif

/* Max size of LZ dictionary. */
#define TINFL_LZ_DICT_SIZE 32768

/* Return status. */
typedef enum {
    /* This flags indicates the inflator needs 1 or more input bytes to make forward progress, but the caller is indicating that no more are available. The compressed data */
    /* is probably corrupted. If you call the inflator again with more bytes it'll try to continue processing the input but this is a BAD sign (either the data is corrupted or you called it incorrectly). */
    /* If you call it again with no input you'll just get TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS again. */
    TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS = -4,

    /* This flag indicates that one or more of the input parameters was obviously bogus. (You can try calling it again, but if you get this error the calling code is wrong.) */
    TINFL_STATUS_BAD_PARAM = -3,

    /* This flags indicate the inflator is finished but the adler32 check of the uncompressed data didn't match. If you call it again it'll return TINFL_STATUS_DONE. */
    TINFL_STATUS_ADLER32_MISMATCH = -2,

    /* This flags indicate the inflator has somehow failed (bad code, corrupted input, etc.). If you call it again without resetting via tinfl_init() it it'll just keep on returning the same status failure code. */
    TINFL_STATUS_FAILED = -1,

    /* Any status code less than TINFL_STATUS_DONE must indicate a failure. */

    /* This flag indicates the inflator has returned every byte of uncompressed data that it can, has consumed every byte that it needed, has successfully reached the end of the deflate stream, and */
    /* if zlib headers and adler32 checking enabled that it has successfully checked the uncompressed data's adler32. If you call it again you'll just get TINFL_STATUS_DONE over and over again. */
    TINFL_STATUS_DONE = 0,

    /* This flag indicates the inflator MUST have more input data (even 1 byte) before it can make any more forward progress, or you need to clear the TINFL_FLAG_HAS_MORE_INPUT */
    /* flag on the next call if you don't have any more source data. If the source data was somehow corrupted it's also possible (but unlikely) for the inflator to keep on demanding input to */
    /* proceed, so be sure to properly set the TINFL_FLAG_HAS_MORE_INPUT flag. */
    TINFL_STATUS_NEEDS_MORE_INPUT = 1,

    /* This flag indicates the inflator definitely has 1 or more bytes of uncompressed data available, but it cannot write this data into the output buffer. */
    /* Note if the source compressed data was corrupted it's possible for the inflator to return a lot of uncompressed data to the caller. I've been assuming you know how much uncompressed data to expect */
    /* (either exact or worst case) and will stop calling the inflator and fail after receiving too much. In pure streaming scenarios where you have no idea how many bytes to expect this may not be possible */
    /* so I may need to add some code to address this. */
    TINFL_STATUS_HAS_MORE_OUTPUT = 2
} tinfl_status;

/* Initializes the decompressor to its initial state. */
#define tinfl_init(r)     \
    do                    \
    {                     \
        (r)->m_state = 0; \
    }                     \
    MZ_MACRO_END
#define tinfl_get_adler32(r) (r)->m_check_adler32

/* Main low-level decompressor coroutine function. This is the only function actually needed for decompression. All the other functions are just high-level helpers for improved usability. */
/* This is a universal API, i.e. it can be used as a building block to build any desired higher level decompression API. In the limit case, it can be called once per every byte input or output. */
MINIZ_EXPORT tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags);

/* Internal/private bits follow. */
enum
{
    TINFL_MAX_HUFF_TABLES = 3,
    TINFL_MAX_HUFF_SYMBOLS_0 = 288,
    TINFL_MAX_HUFF_SYMBOLS_1 = 32,
    TINFL_MAX_HUFF_SYMBOLS_2 = 19,
    TINFL_FAST_LOOKUP_BITS = 10,
    TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS
};

#if MINIZ_HAS_64BIT_REGISTERS
#define TINFL_USE_64BIT_BITBUF 1
#else
#define TINFL_USE_64BIT_BITBUF 0
#endif

#if TINFL_USE_64BIT_BITBUF
typedef mz_uint64 tinfl_bit_buf_t;
#define TINFL_BITBUF_SIZE (64)
#else
typedef mz_uint32 tinfl_bit_buf_t;
#define TINFL_BITBUF_SIZE (32)
#endif

struct tinfl_decompressor_tag
{
    mz_uint32 m_state, m_num_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];
    tinfl_bit_buf_t m_bit_buf;
    size_t m_dist_from_out_buf_start;
    mz_int16 m_look_up[TINFL_MAX_HUFF_TABLES][TINFL_FAST_LOOKUP_SIZE];
    mz_int16 m_tree_0[TINFL_MAX_HUFF_SYMBOLS_0 * 2];
    mz_int16 m_tree_1[TINFL_MAX_HUFF_SYMBOLS_1 * 2];
    mz_int16 m_tree_2[TINFL_MAX_HUFF_SYMBOLS_2 * 2];
    mz_uint8 m_code_size_0[TINFL_MAX_HUFF_SYMBOLS_0];
    mz_uint8 m_code_size_1[TINFL_MAX_HUFF_SYMBOLS_1];
    mz_uint8 m_code_size_2[TINFL_MAX_HUFF_SYMBOLS_2];
    mz_uint8 m_raw_header[4], m_len_codes[TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 137];
};

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/

//#pragma once


/* ------------------- ZIP archive reading/writing */

#ifndef MINIZ_NO_ARCHIVE_APIS

#ifdef __cplusplus
extern "C" {
#endif

enum
{
    /* Note: These enums can be reduced as needed to save memory or stack space - they are pretty conservative. */
    MZ_ZIP_MAX_IO_BUF_SIZE = 64 * 1024,
    MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE = 512,
    MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE = 512
};

typedef struct
{
    /* Central directory file index. */
    mz_uint32 m_file_index;

    /* Byte offset of this entry in the archive's central directory. Note we currently only support up to UINT_MAX or less bytes in the central dir. */
    mz_uint64 m_central_dir_ofs;

    /* These fields are copied directly from the zip's central dir. */
    mz_uint16 m_version_made_by;
    mz_uint16 m_version_needed;
    mz_uint16 m_bit_flag;
    mz_uint16 m_method;

    /* CRC-32 of uncompressed data. */
    mz_uint32 m_crc32;

    /* File's compressed size. */
    mz_uint64 m_comp_size;

    /* File's uncompressed size. Note, I've seen some old archives where directory entries had 512 bytes for their uncompressed sizes, but when you try to unpack them you actually get 0 bytes. */
    mz_uint64 m_uncomp_size;

    /* Zip internal and external file attributes. */
    mz_uint16 m_internal_attr;
    mz_uint32 m_external_attr;

    /* Entry's local header file offset in bytes. */
    mz_uint64 m_local_header_ofs;

    /* Size of comment in bytes. */
    mz_uint32 m_comment_size;

    /* MZ_TRUE if the entry appears to be a directory. */
    mz_bool m_is_directory;

    /* MZ_TRUE if the entry uses encryption/strong encryption (which miniz_zip doesn't support) */
    mz_bool m_is_encrypted;

    /* MZ_TRUE if the file is not encrypted, a patch file, and if it uses a compression method we support. */
    mz_bool m_is_supported;

    /* Filename. If string ends in '/' it's a subdirectory entry. */
    /* Guaranteed to be zero terminated, may be truncated to fit. */
    char m_filename[MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE];

    /* Comment field. */
    /* Guaranteed to be zero terminated, may be truncated to fit. */
    char m_comment[MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE];

#ifdef MINIZ_NO_TIME
    MZ_TIME_T m_padding;
#else
    MZ_TIME_T m_time;
#endif
} mz_zip_archive_file_stat;

typedef size_t (*mz_file_read_func)(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n);
typedef size_t (*mz_file_write_func)(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n);
typedef mz_bool (*mz_file_needs_keepalive)(void *pOpaque);

struct mz_zip_internal_state_tag;
typedef struct mz_zip_internal_state_tag mz_zip_internal_state;

typedef enum {
    MZ_ZIP_MODE_INVALID = 0,
    MZ_ZIP_MODE_READING = 1,
    MZ_ZIP_MODE_WRITING = 2,
    MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED = 3
} mz_zip_mode;

typedef enum {
    MZ_ZIP_FLAG_CASE_SENSITIVE = 0x0100,
    MZ_ZIP_FLAG_IGNORE_PATH = 0x0200,
    MZ_ZIP_FLAG_COMPRESSED_DATA = 0x0400,
    MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY = 0x0800,
    MZ_ZIP_FLAG_VALIDATE_LOCATE_FILE_FLAG = 0x1000, /* if enabled, mz_zip_reader_locate_file() will be called on each file as its validated to ensure the func finds the file in the central dir (intended for testing) */
    MZ_ZIP_FLAG_VALIDATE_HEADERS_ONLY = 0x2000,     /* validate the local headers, but don't decompress the entire file and check the crc32 */
    MZ_ZIP_FLAG_WRITE_ZIP64 = 0x4000,               /* always use the zip64 file format, instead of the original zip file format with automatic switch to zip64. Use as flags parameter with mz_zip_writer_init*_v2 */
    MZ_ZIP_FLAG_WRITE_ALLOW_READING = 0x8000,
    MZ_ZIP_FLAG_ASCII_FILENAME = 0x10000,
    /*After adding a compressed file, seek back
    to local file header and set the correct sizes*/
    MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE = 0x20000
} mz_zip_flags;

typedef enum {
    MZ_ZIP_TYPE_INVALID = 0,
    MZ_ZIP_TYPE_USER,
    MZ_ZIP_TYPE_MEMORY,
    MZ_ZIP_TYPE_HEAP,
    MZ_ZIP_TYPE_FILE,
    MZ_ZIP_TYPE_CFILE,
    MZ_ZIP_TOTAL_TYPES
} mz_zip_type;

/* miniz error codes. Be sure to update mz_zip_get_error_string() if you add or modify this enum. */
typedef enum {
    MZ_ZIP_NO_ERROR = 0,
    MZ_ZIP_UNDEFINED_ERROR,
    MZ_ZIP_TOO_MANY_FILES,
    MZ_ZIP_FILE_TOO_LARGE,
    MZ_ZIP_UNSUPPORTED_METHOD,
    MZ_ZIP_UNSUPPORTED_ENCRYPTION,
    MZ_ZIP_UNSUPPORTED_FEATURE,
    MZ_ZIP_FAILED_FINDING_CENTRAL_DIR,
    MZ_ZIP_NOT_AN_ARCHIVE,
    MZ_ZIP_INVALID_HEADER_OR_CORRUPTED,
    MZ_ZIP_UNSUPPORTED_MULTIDISK,
    MZ_ZIP_DECOMPRESSION_FAILED,
    MZ_ZIP_COMPRESSION_FAILED,
    MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE,
    MZ_ZIP_CRC_CHECK_FAILED,
    MZ_ZIP_UNSUPPORTED_CDIR_SIZE,
    MZ_ZIP_ALLOC_FAILED,
    MZ_ZIP_FILE_OPEN_FAILED,
    MZ_ZIP_FILE_CREATE_FAILED,
    MZ_ZIP_FILE_WRITE_FAILED,
    MZ_ZIP_FILE_READ_FAILED,
    MZ_ZIP_FILE_CLOSE_FAILED,
    MZ_ZIP_FILE_SEEK_FAILED,
    MZ_ZIP_FILE_STAT_FAILED,
    MZ_ZIP_INVALID_PARAMETER,
    MZ_ZIP_INVALID_FILENAME,
    MZ_ZIP_BUF_TOO_SMALL,
    MZ_ZIP_INTERNAL_ERROR,
    MZ_ZIP_FILE_NOT_FOUND,
    MZ_ZIP_ARCHIVE_TOO_LARGE,
    MZ_ZIP_VALIDATION_FAILED,
    MZ_ZIP_WRITE_CALLBACK_FAILED,
    MZ_ZIP_TOTAL_ERRORS
} mz_zip_error;

typedef struct
{
    mz_uint64 m_archive_size;
    mz_uint64 m_central_directory_file_ofs;

    /* We only support up to UINT32_MAX files in zip64 mode. */
    mz_uint32 m_total_files;
    mz_zip_mode m_zip_mode;
    mz_zip_type m_zip_type;
    mz_zip_error m_last_error;

    mz_uint64 m_file_offset_alignment;

    mz_alloc_func m_pAlloc;
    mz_free_func m_pFree;
    mz_realloc_func m_pRealloc;
    void *m_pAlloc_opaque;

    mz_file_read_func m_pRead;
    mz_file_write_func m_pWrite;
    mz_file_needs_keepalive m_pNeeds_keepalive;
    void *m_pIO_opaque;

    mz_zip_internal_state *m_pState;

} mz_zip_archive;

typedef struct
{
    mz_zip_archive *pZip;
    mz_uint flags;

    int status;

    mz_uint64 read_buf_size, read_buf_ofs, read_buf_avail, comp_remaining, out_buf_ofs, cur_file_ofs;
    mz_zip_archive_file_stat file_stat;
    void *pRead_buf;
    void *pWrite_buf;

    size_t out_blk_remain;

    tinfl_decompressor inflator;

#ifdef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
    mz_uint padding;
#else
    mz_uint file_crc32;
#endif

} mz_zip_reader_extract_iter_state;

/* -------- ZIP reading */

/* Inits a ZIP archive reader. */
/* These functions read and validate the archive's central directory. */
MINIZ_EXPORT mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint flags);

MINIZ_EXPORT mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint flags);

#ifndef MINIZ_NO_STDIO
/* Read a archive from a disk file. */
/* file_start_ofs is the file offset where the archive actually begins, or 0. */
/* actual_archive_size is the true total size of the archive, which may be smaller than the file's actual size on disk. If zero the entire file is treated as the archive. */
MINIZ_EXPORT mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags);
MINIZ_EXPORT mz_bool mz_zip_reader_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags, mz_uint64 file_start_ofs, mz_uint64 archive_size);

/* Read an archive from an already opened FILE, beginning at the current file position. */
/* The archive is assumed to be archive_size bytes long. If archive_size is 0, then the entire rest of the file is assumed to contain the archive. */
/* The FILE will NOT be closed when mz_zip_reader_end() is called. */
MINIZ_EXPORT mz_bool mz_zip_reader_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint64 archive_size, mz_uint flags);
#endif

/* Ends archive reading, freeing all allocations, and closing the input archive file if mz_zip_reader_init_file() was used. */
MINIZ_EXPORT mz_bool mz_zip_reader_end(mz_zip_archive *pZip);

/* -------- ZIP reading or writing */

/* Clears a mz_zip_archive struct to all zeros. */
/* Important: This must be done before passing the struct to any mz_zip functions. */
MINIZ_EXPORT void mz_zip_zero_struct(mz_zip_archive *pZip);

MINIZ_EXPORT mz_zip_mode mz_zip_get_mode(mz_zip_archive *pZip);
MINIZ_EXPORT mz_zip_type mz_zip_get_type(mz_zip_archive *pZip);

/* Returns the total number of files in the archive. */
MINIZ_EXPORT mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip);

MINIZ_EXPORT mz_uint64 mz_zip_get_archive_size(mz_zip_archive *pZip);
MINIZ_EXPORT mz_uint64 mz_zip_get_archive_file_start_offset(mz_zip_archive *pZip);
MINIZ_EXPORT MZ_FILE *mz_zip_get_cfile(mz_zip_archive *pZip);

/* Reads n bytes of raw archive data, starting at file offset file_ofs, to pBuf. */
MINIZ_EXPORT size_t mz_zip_read_archive_data(mz_zip_archive *pZip, mz_uint64 file_ofs, void *pBuf, size_t n);

/* All mz_zip funcs set the m_last_error field in the mz_zip_archive struct. These functions retrieve/manipulate this field. */
/* Note that the m_last_error functionality is not thread safe. */
MINIZ_EXPORT mz_zip_error mz_zip_set_last_error(mz_zip_archive *pZip, mz_zip_error err_num);
MINIZ_EXPORT mz_zip_error mz_zip_peek_last_error(mz_zip_archive *pZip);
MINIZ_EXPORT mz_zip_error mz_zip_clear_last_error(mz_zip_archive *pZip);
MINIZ_EXPORT mz_zip_error mz_zip_get_last_error(mz_zip_archive *pZip);
MINIZ_EXPORT const char *mz_zip_get_error_string(mz_zip_error mz_err);

/* MZ_TRUE if the archive file entry is a directory entry. */
MINIZ_EXPORT mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index);

/* MZ_TRUE if the file is encrypted/strong encrypted. */
MINIZ_EXPORT mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index);

/* MZ_TRUE if the compression method is supported, and the file is not encrypted, and the file is not a compressed patch file. */
MINIZ_EXPORT mz_bool mz_zip_reader_is_file_supported(mz_zip_archive *pZip, mz_uint file_index);

/* Retrieves the filename of an archive file entry. */
/* Returns the number of bytes written to pFilename, or if filename_buf_size is 0 this function returns the number of bytes needed to fully store the filename. */
MINIZ_EXPORT mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size);

/* Attempts to locates a file in the archive's central directory. */
/* Valid flags: MZ_ZIP_FLAG_CASE_SENSITIVE, MZ_ZIP_FLAG_IGNORE_PATH */
/* Returns -1 if the file cannot be found. */
MINIZ_EXPORT int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_reader_locate_file_v2(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags, mz_uint32 *file_index);

/* Returns detailed information about an archive file entry. */
MINIZ_EXPORT mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat);

/* MZ_TRUE if the file is in zip64 format. */
/* A file is considered zip64 if it contained a zip64 end of central directory marker, or if it contained any zip64 extended file information fields in the central directory. */
MINIZ_EXPORT mz_bool mz_zip_is_zip64(mz_zip_archive *pZip);

/* Returns the total central directory size in bytes. */
/* The current max supported size is <= MZ_UINT32_MAX. */
MINIZ_EXPORT size_t mz_zip_get_central_dir_size(mz_zip_archive *pZip);

/* Extracts a archive file to a memory buffer using no memory allocation. */
/* There must be at least enough room on the stack to store the inflator's state (~34KB or so). */
MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);

/* Extracts a archive file to a memory buffer. */
MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags);

/* Extracts a archive file to a dynamically allocated heap buffer. */
/* The memory will be allocated via the mz_zip_archive's alloc/realloc functions. */
/* Returns NULL and sets the last error on failure. */
MINIZ_EXPORT void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags);
MINIZ_EXPORT void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags);

/* Extracts a archive file using a callback function to output the file's data. */
MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags);

/* Extract a file iteratively */
MINIZ_EXPORT mz_zip_reader_extract_iter_state* mz_zip_reader_extract_iter_new(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags);
MINIZ_EXPORT mz_zip_reader_extract_iter_state* mz_zip_reader_extract_file_iter_new(mz_zip_archive *pZip, const char *pFilename, mz_uint flags);
MINIZ_EXPORT size_t mz_zip_reader_extract_iter_read(mz_zip_reader_extract_iter_state* pState, void* pvBuf, size_t buf_size);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_iter_free(mz_zip_reader_extract_iter_state* pState);

#ifndef MINIZ_NO_STDIO
/* Extracts a archive file to a disk file and sets its last accessed and modified times. */
/* This function only extracts files, not archive directory records. */
MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags);

/* Extracts a archive file starting at the current position in the destination FILE stream. */
MINIZ_EXPORT mz_bool mz_zip_reader_extract_to_cfile(mz_zip_archive *pZip, mz_uint file_index, MZ_FILE *File, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_reader_extract_file_to_cfile(mz_zip_archive *pZip, const char *pArchive_filename, MZ_FILE *pFile, mz_uint flags);
#endif

#if 0
/* TODO */
	typedef void *mz_zip_streaming_extract_state_ptr;
	mz_zip_streaming_extract_state_ptr mz_zip_streaming_extract_begin(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags);
	mz_uint64 mz_zip_streaming_extract_get_size(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState);
	mz_uint64 mz_zip_streaming_extract_get_cur_ofs(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState);
	mz_bool mz_zip_streaming_extract_seek(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState, mz_uint64 new_ofs);
	size_t mz_zip_streaming_extract_read(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState, void *pBuf, size_t buf_size);
	mz_bool mz_zip_streaming_extract_end(mz_zip_archive *pZip, mz_zip_streaming_extract_state_ptr pState);
#endif

/* This function compares the archive's local headers, the optional local zip64 extended information block, and the optional descriptor following the compressed data vs. the data in the central directory. */
/* It also validates that each file can be successfully uncompressed unless the MZ_ZIP_FLAG_VALIDATE_HEADERS_ONLY is specified. */
MINIZ_EXPORT mz_bool mz_zip_validate_file(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags);

/* Validates an entire archive by calling mz_zip_validate_file() on each file. */
MINIZ_EXPORT mz_bool mz_zip_validate_archive(mz_zip_archive *pZip, mz_uint flags);

/* Misc utils/helpers, valid for ZIP reading or writing */
MINIZ_EXPORT mz_bool mz_zip_validate_mem_archive(const void *pMem, size_t size, mz_uint flags, mz_zip_error *pErr);
#ifndef MINIZ_NO_STDIO
MINIZ_EXPORT mz_bool mz_zip_validate_file_archive(const char *pFilename, mz_uint flags, mz_zip_error *pErr);
#endif

/* Universal end function - calls either mz_zip_reader_end() or mz_zip_writer_end(). */
MINIZ_EXPORT mz_bool mz_zip_end(mz_zip_archive *pZip);

/* -------- ZIP writing */

#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

/* Inits a ZIP archive writer. */
/*Set pZip->m_pWrite (and pZip->m_pIO_opaque) before calling mz_zip_writer_init or mz_zip_writer_init_v2*/
/*The output is streamable, i.e. file_ofs in mz_file_write_func always increases only by n*/
MINIZ_EXPORT mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size);
MINIZ_EXPORT mz_bool mz_zip_writer_init_v2(mz_zip_archive *pZip, mz_uint64 existing_size, mz_uint flags);

MINIZ_EXPORT mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size);
MINIZ_EXPORT mz_bool mz_zip_writer_init_heap_v2(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size, mz_uint flags);

#ifndef MINIZ_NO_STDIO
MINIZ_EXPORT mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning);
MINIZ_EXPORT mz_bool mz_zip_writer_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning, mz_uint flags);
MINIZ_EXPORT mz_bool mz_zip_writer_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint flags);
#endif

/* Converts a ZIP archive reader object into a writer object, to allow efficient in-place file appends to occur on an existing archive. */
/* For archives opened using mz_zip_reader_init_file, pFilename must be the archive's filename so it can be reopened for writing. If the file can't be reopened, mz_zip_reader_end() will be called. */
/* For archives opened using mz_zip_reader_init_mem, the memory block must be growable using the realloc callback (which defaults to realloc unless you've overridden it). */
/* Finally, for archives opened using mz_zip_reader_init, the mz_zip_archive's user provided m_pWrite function cannot be NULL. */
/* Note: In-place archive modification is not recommended unless you know what you're doing, because if execution stops or something goes wrong before */
/* the archive is finalized the file's central directory will be hosed. */
MINIZ_EXPORT mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename);
MINIZ_EXPORT mz_bool mz_zip_writer_init_from_reader_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags);

/* Adds the contents of a memory buffer to an archive. These functions record the current local time into the archive. */
/* To add a directory entry, call this method with an archive name ending in a forwardslash with an empty buffer. */
/* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */
MINIZ_EXPORT mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags);

/* Like mz_zip_writer_add_mem(), except you can specify a file comment field, and optionally supply the function with already compressed data. */
/* uncomp_size/uncomp_crc32 are only used if the MZ_ZIP_FLAG_COMPRESSED_DATA flag is specified. */
MINIZ_EXPORT mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
                                              mz_uint64 uncomp_size, mz_uint32 uncomp_crc32);

MINIZ_EXPORT mz_bool mz_zip_writer_add_mem_ex_v2(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
                                                 mz_uint64 uncomp_size, mz_uint32 uncomp_crc32, MZ_TIME_T *last_modified, const char *user_extra_data_local, mz_uint user_extra_data_local_len,
                                                 const char *user_extra_data_central, mz_uint user_extra_data_central_len);

/* Adds the contents of a file to an archive. This function also records the disk file's modified time into the archive. */
/* File data is supplied via a read callback function. User mz_zip_writer_add_(c)file to add a file directly.*/
MINIZ_EXPORT mz_bool mz_zip_writer_add_read_buf_callback(mz_zip_archive *pZip, const char *pArchive_name, mz_file_read_func read_callback, void* callback_opaque, mz_uint64 max_size,
	const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, const char *user_extra_data_local, mz_uint user_extra_data_local_len,
	const char *user_extra_data_central, mz_uint user_extra_data_central_len);


#ifndef MINIZ_NO_STDIO
/* Adds the contents of a disk file to an archive. This function also records the disk file's modified time into the archive. */
/* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */
MINIZ_EXPORT mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);

/* Like mz_zip_writer_add_file(), except the file data is read from the specified FILE stream. */
MINIZ_EXPORT mz_bool mz_zip_writer_add_cfile(mz_zip_archive *pZip, const char *pArchive_name, MZ_FILE *pSrc_file, mz_uint64 max_size,
                                const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, const char *user_extra_data_local, mz_uint user_extra_data_local_len,
                                const char *user_extra_data_central, mz_uint user_extra_data_central_len);
#endif

/* Adds a file to an archive by fully cloning the data from another archive. */
/* This function fully clones the source file's compressed data (no recompression), along with its full filename, extra data (it may add or modify the zip64 local header extra data field), and the optional descriptor following the compressed data. */
MINIZ_EXPORT mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint src_file_index);

/* Finalizes the archive by writing the central directory records followed by the end of central directory record. */
/* After an archive is finalized, the only valid call on the mz_zip_archive struct is mz_zip_writer_end(). */
/* An archive must be manually finalized by calling this function for it to be valid. */
MINIZ_EXPORT mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip);

/* Finalizes a heap archive, returning a pointer to the heap block and its size. */
/* The heap block will be allocated using the mz_zip_archive's alloc/realloc callbacks. */
MINIZ_EXPORT mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **ppBuf, size_t *pSize);

/* Ends archive writing, freeing all allocations, and closing the output file if mz_zip_writer_init_file() was used. */
/* Note for the archive to be valid, it *must* have been finalized before ending (this function will not do it for you). */
MINIZ_EXPORT mz_bool mz_zip_writer_end(mz_zip_archive *pZip);

/* -------- Misc. high-level helper functions: */

/* mz_zip_add_mem_to_archive_file_in_place() efficiently (but not atomically) appends a memory blob to a ZIP archive. */
/* Note this is NOT a fully safe operation. If it crashes or dies in some way your archive can be left in a screwed up state (without a central directory). */
/* level_and_flags - compression level (0-10, see MZ_BEST_SPEED, MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or just set to MZ_DEFAULT_COMPRESSION. */
/* TODO: Perhaps add an option to leave the existing central dir in place in case the add dies? We could then truncate the file (so the old central dir would be at the end) if something goes wrong. */
MINIZ_EXPORT mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags);
MINIZ_EXPORT mz_bool mz_zip_add_mem_to_archive_file_in_place_v2(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_zip_error *pErr);

#ifndef MINIZ_NO_STDIO
/* Reads a single file from an archive into a heap block. */
/* If pComment is not NULL, only the file with the specified comment will be extracted. */
/* Returns NULL on failure. */
MINIZ_EXPORT void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint flags);
MINIZ_EXPORT void *mz_zip_extract_archive_file_to_heap_v2(const char *pZip_filename, const char *pArchive_name, const char *pComment, size_t *pSize, mz_uint flags, mz_zip_error *pErr);
#endif

#endif /* #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS */

#ifdef __cplusplus
}
#endif

#endif /* MINIZ_NO_ARCHIVE_APIS */
#endif


// #include "miniz.h"
/**************************************************************************
 *
 * Copyright 2013-2014 RAD Game Tools and Valve Software
 * Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 **************************************************************************/



typedef unsigned char mz_validate_uint16[sizeof(mz_uint16) == 2 ? 1 : -1];
typedef unsigned char mz_validate_uint32[sizeof(mz_uint32) == 4 ? 1 : -1];
typedef unsigned char mz_validate_uint64[sizeof(mz_uint64) == 8 ? 1 : -1];

#ifdef __cplusplus
extern "C" {
#endif

/* ------------------- zlib-style API's */

mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len)
{
    mz_uint32 i, s1 = (mz_uint32)(adler & 0xffff), s2 = (mz_uint32)(adler >> 16);
    size_t block_len = buf_len % 5552;
    if (!ptr)
        return MZ_ADLER32_INIT;
    while (buf_len)
    {
        for (i = 0; i + 7 < block_len; i += 8, ptr += 8)
        {
            s1 += ptr[0], s2 += s1;
            s1 += ptr[1], s2 += s1;
            s1 += ptr[2], s2 += s1;
            s1 += ptr[3], s2 += s1;
            s1 += ptr[4], s2 += s1;
            s1 += ptr[5], s2 += s1;
            s1 += ptr[6], s2 += s1;
            s1 += ptr[7], s2 += s1;
        }
        for (; i < block_len; ++i)
            s1 += *ptr++, s2 += s1;
        s1 %= 65521U, s2 %= 65521U;
        buf_len -= block_len;
        block_len = 5552;
    }
    return (s2 << 16) + s1;
}

/* Karl Malbrain's compact CRC-32. See "A compact CCITT crc16 and crc32 C implementation that balances processor cache usage against speed": http://www.geocities.com/malbrain/ */
#if 0
    mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len)
    {
        static const mz_uint32 s_crc32[16] = { 0, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
                                               0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c };
        mz_uint32 crcu32 = (mz_uint32)crc;
        if (!ptr)
            return MZ_CRC32_INIT;
        crcu32 = ~crcu32;
        while (buf_len--)
        {
            mz_uint8 b = *ptr++;
            crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)];
            crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)];
        }
        return ~crcu32;
    }
#elif defined(USE_EXTERNAL_MZCRC)
/* If USE_EXTERNAL_CRC is defined, an external module will export the
 * mz_crc32() symbol for us to use, e.g. an SSE-accelerated version.
 * Depending on the impl, it may be necessary to ~ the input/output crc values.
 */
mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len);
#else
/* Faster, but larger CPU cache footprint.
 */
mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len)
{
    static const mz_uint32 s_crc_table[256] =
        {
          0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535,
          0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD,
          0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D,
          0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
          0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4,
          0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
          0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC,
          0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
          0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB,
          0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F,
          0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB,
          0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
          0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA,
          0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE,
          0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A,
          0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
          0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409,
          0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
          0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739,
          0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
          0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268,
          0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0,
          0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8,
          0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
          0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF,
          0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703,
          0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7,
          0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
          0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE,
          0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
          0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6,
          0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
          0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D,
          0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5,
          0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605,
          0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
          0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
        };

    mz_uint32 crc32 = (mz_uint32)crc ^ 0xFFFFFFFF;
    const mz_uint8 *pByte_buf = (const mz_uint8 *)ptr;

    while (buf_len >= 4)
    {
        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[0]) & 0xFF];
        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[1]) & 0xFF];
        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[2]) & 0xFF];
        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[3]) & 0xFF];
        pByte_buf += 4;
        buf_len -= 4;
    }

    while (buf_len)
    {
        crc32 = (crc32 >> 8) ^ s_crc_table[(crc32 ^ pByte_buf[0]) & 0xFF];
        ++pByte_buf;
        --buf_len;
    }

    return ~crc32;
}
#endif

void mz_free(void *p)
{
    MZ_FREE(p);
}

MINIZ_EXPORT void *miniz_def_alloc_func(void *opaque, size_t items, size_t size)
{
    (void)opaque, (void)items, (void)size;
    return MZ_MALLOC(items * size);
}
MINIZ_EXPORT void miniz_def_free_func(void *opaque, void *address)
{
    (void)opaque, (void)address;
    MZ_FREE(address);
}
MINIZ_EXPORT void *miniz_def_realloc_func(void *opaque, void *address, size_t old_items, size_t old_size, size_t items, size_t size)
{
    (void)opaque, (void)address,  (void)old_items, (void)old_size, (void)items, (void)size;
    return MZ_REALLOC(address, items * size);
}

const char *mz_version(void)
{
    return MZ_VERSION;
}

#ifndef MINIZ_NO_ZLIB_APIS

#ifndef MINIZ_NO_DEFLATE_APIS

int mz_deflateInit(mz_streamp pStream, int level)
{
    return mz_deflateInit2(pStream, level, MZ_DEFLATED, MZ_DEFAULT_WINDOW_BITS, 9, MZ_DEFAULT_STRATEGY);
}

int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits, int mem_level, int strategy)
{
    tdefl_compressor *pComp;
    mz_uint comp_flags = TDEFL_COMPUTE_ADLER32 | tdefl_create_comp_flags_from_zip_params(level, window_bits, strategy);

    if (!pStream)
        return MZ_STREAM_ERROR;
    if ((method != MZ_DEFLATED) || ((mem_level < 1) || (mem_level > 9)) || ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS)))
        return MZ_PARAM_ERROR;

    pStream->data_type = 0;
    pStream->adler = MZ_ADLER32_INIT;
    pStream->msg = NULL;
    pStream->reserved = 0;
    pStream->total_in = 0;
    pStream->total_out = 0;
    if (!pStream->zalloc)
        pStream->zalloc = miniz_def_alloc_func;
    if (!pStream->zfree)
        pStream->zfree = miniz_def_free_func;

    pComp = (tdefl_compressor *)pStream->zalloc(pStream->opaque, 1, sizeof(tdefl_compressor));
    if (!pComp)
        return MZ_MEM_ERROR;

    pStream->state = (struct mz_internal_state *)pComp;

    if (tdefl_init(pComp, NULL, NULL, comp_flags) != TDEFL_STATUS_OKAY)
    {
        mz_deflateEnd(pStream);
        return MZ_PARAM_ERROR;
    }

    return MZ_OK;
}

int mz_deflateReset(mz_streamp pStream)
{
    if ((!pStream) || (!pStream->state) || (!pStream->zalloc) || (!pStream->zfree))
        return MZ_STREAM_ERROR;
    pStream->total_in = pStream->total_out = 0;
    tdefl_init((tdefl_compressor *)pStream->state, NULL, NULL, ((tdefl_compressor *)pStream->state)->m_flags);
    return MZ_OK;
}

int mz_deflate(mz_streamp pStream, int flush)
{
    size_t in_bytes, out_bytes;
    mz_ulong orig_total_in, orig_total_out;
    int mz_status = MZ_OK;

    if ((!pStream) || (!pStream->state) || (flush < 0) || (flush > MZ_FINISH) || (!pStream->next_out))
        return MZ_STREAM_ERROR;
    if (!pStream->avail_out)
        return MZ_BUF_ERROR;

    if (flush == MZ_PARTIAL_FLUSH)
        flush = MZ_SYNC_FLUSH;

    if (((tdefl_compressor *)pStream->state)->m_prev_return_status == TDEFL_STATUS_DONE)
        return (flush == MZ_FINISH) ? MZ_STREAM_END : MZ_BUF_ERROR;

    orig_total_in = pStream->total_in;
    orig_total_out = pStream->total_out;
    for (;;)
    {
        tdefl_status defl_status;
        in_bytes = pStream->avail_in;
        out_bytes = pStream->avail_out;

        defl_status = tdefl_compress((tdefl_compressor *)pStream->state, pStream->next_in, &in_bytes, pStream->next_out, &out_bytes, (tdefl_flush)flush);
        pStream->next_in += (mz_uint)in_bytes;
        pStream->avail_in -= (mz_uint)in_bytes;
        pStream->total_in += (mz_uint)in_bytes;
        pStream->adler = tdefl_get_adler32((tdefl_compressor *)pStream->state);

        pStream->next_out += (mz_uint)out_bytes;
        pStream->avail_out -= (mz_uint)out_bytes;
        pStream->total_out += (mz_uint)out_bytes;

        if (defl_status < 0)
        {
            mz_status = MZ_STREAM_ERROR;
            break;
        }
        else if (defl_status == TDEFL_STATUS_DONE)
        {
            mz_status = MZ_STREAM_END;
            break;
        }
        else if (!pStream->avail_out)
            break;
        else if ((!pStream->avail_in) && (flush != MZ_FINISH))
        {
            if ((flush) || (pStream->total_in != orig_total_in) || (pStream->total_out != orig_total_out))
                break;
            return MZ_BUF_ERROR; /* Can't make forward progress without some input.
 */
        }
    }
    return mz_status;
}

int mz_deflateEnd(mz_streamp pStream)
{
    if (!pStream)
        return MZ_STREAM_ERROR;
    if (pStream->state)
    {
        pStream->zfree(pStream->opaque, pStream->state);
        pStream->state = NULL;
    }
    return MZ_OK;
}

mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len)
{
    (void)pStream;
    /* This is really over conservative. (And lame, but it's actually pretty tricky to compute a true upper bound given the way tdefl's blocking works.) */
    return MZ_MAX(128 + (source_len * 110) / 100, 128 + source_len + ((source_len / (31 * 1024)) + 1) * 5);
}

int mz_compress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len, int level)
{
    int status;
    mz_stream stream;
    memset(&stream, 0, sizeof(stream));

    /* In case mz_ulong is 64-bits (argh I hate longs). */
    if ((mz_uint64)(source_len | *pDest_len) > 0xFFFFFFFFU)
        return MZ_PARAM_ERROR;

    stream.next_in = pSource;
    stream.avail_in = (mz_uint32)source_len;
    stream.next_out = pDest;
    stream.avail_out = (mz_uint32)*pDest_len;

    status = mz_deflateInit(&stream, level);
    if (status != MZ_OK)
        return status;

    status = mz_deflate(&stream, MZ_FINISH);
    if (status != MZ_STREAM_END)
    {
        mz_deflateEnd(&stream);
        return (status == MZ_OK) ? MZ_BUF_ERROR : status;
    }

    *pDest_len = stream.total_out;
    return mz_deflateEnd(&stream);
}

int mz_compress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len)
{
    return mz_compress2(pDest, pDest_len, pSource, source_len, MZ_DEFAULT_COMPRESSION);
}

mz_ulong mz_compressBound(mz_ulong source_len)
{
    return mz_deflateBound(NULL, source_len);
}

#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/

#ifndef MINIZ_NO_INFLATE_APIS

typedef struct
{
    tinfl_decompressor m_decomp;
    mz_uint m_dict_ofs, m_dict_avail, m_first_call, m_has_flushed;
    int m_window_bits;
    mz_uint8 m_dict[TINFL_LZ_DICT_SIZE];
    tinfl_status m_last_status;
} inflate_state;

int mz_inflateInit2(mz_streamp pStream, int window_bits)
{
    inflate_state *pDecomp;
    if (!pStream)
        return MZ_STREAM_ERROR;
    if ((window_bits != MZ_DEFAULT_WINDOW_BITS) && (-window_bits != MZ_DEFAULT_WINDOW_BITS))
        return MZ_PARAM_ERROR;

    pStream->data_type = 0;
    pStream->adler = 0;
    pStream->msg = NULL;
    pStream->total_in = 0;
    pStream->total_out = 0;
    pStream->reserved = 0;
    if (!pStream->zalloc)
        pStream->zalloc = miniz_def_alloc_func;
    if (!pStream->zfree)
        pStream->zfree = miniz_def_free_func;

    pDecomp = (inflate_state *)pStream->zalloc(pStream->opaque, 1, sizeof(inflate_state));
    if (!pDecomp)
        return MZ_MEM_ERROR;

    pStream->state = (struct mz_internal_state *)pDecomp;

    tinfl_init(&pDecomp->m_decomp);
    pDecomp->m_dict_ofs = 0;
    pDecomp->m_dict_avail = 0;
    pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
    pDecomp->m_first_call = 1;
    pDecomp->m_has_flushed = 0;
    pDecomp->m_window_bits = window_bits;

    return MZ_OK;
}

int mz_inflateInit(mz_streamp pStream)
{
    return mz_inflateInit2(pStream, MZ_DEFAULT_WINDOW_BITS);
}

int mz_inflateReset(mz_streamp pStream)
{
    inflate_state *pDecomp;
    if (!pStream)
        return MZ_STREAM_ERROR;

    pStream->data_type = 0;
    pStream->adler = 0;
    pStream->msg = NULL;
    pStream->total_in = 0;
    pStream->total_out = 0;
    pStream->reserved = 0;

    pDecomp = (inflate_state *)pStream->state;

    tinfl_init(&pDecomp->m_decomp);
    pDecomp->m_dict_ofs = 0;
    pDecomp->m_dict_avail = 0;
    pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
    pDecomp->m_first_call = 1;
    pDecomp->m_has_flushed = 0;
    /* pDecomp->m_window_bits = window_bits */;

    return MZ_OK;
}

int mz_inflate(mz_streamp pStream, int flush)
{
    inflate_state *pState;
    mz_uint n, first_call, decomp_flags = TINFL_FLAG_COMPUTE_ADLER32;
    size_t in_bytes, out_bytes, orig_avail_in;
    tinfl_status status;

    if ((!pStream) || (!pStream->state))
        return MZ_STREAM_ERROR;
    if (flush == MZ_PARTIAL_FLUSH)
        flush = MZ_SYNC_FLUSH;
    if ((flush) && (flush != MZ_SYNC_FLUSH) && (flush != MZ_FINISH))
        return MZ_STREAM_ERROR;

    pState = (inflate_state *)pStream->state;
    if (pState->m_window_bits > 0)
        decomp_flags |= TINFL_FLAG_PARSE_ZLIB_HEADER;
    orig_avail_in = pStream->avail_in;

    first_call = pState->m_first_call;
    pState->m_first_call = 0;
    if (pState->m_last_status < 0)
        return MZ_DATA_ERROR;

    if (pState->m_has_flushed && (flush != MZ_FINISH))
        return MZ_STREAM_ERROR;
    pState->m_has_flushed |= (flush == MZ_FINISH);

    if ((flush == MZ_FINISH) && (first_call))
    {
        /* MZ_FINISH on the first call implies that the input and output buffers are large enough to hold the entire compressed/decompressed file. */
        decomp_flags |= TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
        in_bytes = pStream->avail_in;
        out_bytes = pStream->avail_out;
        status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pStream->next_out, pStream->next_out, &out_bytes, decomp_flags);
        pState->m_last_status = status;
        pStream->next_in += (mz_uint)in_bytes;
        pStream->avail_in -= (mz_uint)in_bytes;
        pStream->total_in += (mz_uint)in_bytes;
        pStream->adler = tinfl_get_adler32(&pState->m_decomp);
        pStream->next_out += (mz_uint)out_bytes;
        pStream->avail_out -= (mz_uint)out_bytes;
        pStream->total_out += (mz_uint)out_bytes;

        if (status < 0)
            return MZ_DATA_ERROR;
        else if (status != TINFL_STATUS_DONE)
        {
            pState->m_last_status = TINFL_STATUS_FAILED;
            return MZ_BUF_ERROR;
        }
        return MZ_STREAM_END;
    }
    /* flush != MZ_FINISH then we must assume there's more input. */
    if (flush != MZ_FINISH)
        decomp_flags |= TINFL_FLAG_HAS_MORE_INPUT;

    if (pState->m_dict_avail)
    {
        n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
        memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
        pStream->next_out += n;
        pStream->avail_out -= n;
        pStream->total_out += n;
        pState->m_dict_avail -= n;
        pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);
        return ((pState->m_last_status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
    }

    for (;;)
    {
        in_bytes = pStream->avail_in;
        out_bytes = TINFL_LZ_DICT_SIZE - pState->m_dict_ofs;

        status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes, pState->m_dict, pState->m_dict + pState->m_dict_ofs, &out_bytes, decomp_flags);
        pState->m_last_status = status;

        pStream->next_in += (mz_uint)in_bytes;
        pStream->avail_in -= (mz_uint)in_bytes;
        pStream->total_in += (mz_uint)in_bytes;
        pStream->adler = tinfl_get_adler32(&pState->m_decomp);

        pState->m_dict_avail = (mz_uint)out_bytes;

        n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
        memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
        pStream->next_out += n;
        pStream->avail_out -= n;
        pStream->total_out += n;
        pState->m_dict_avail -= n;
        pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);

        if (status < 0)
            return MZ_DATA_ERROR; /* Stream is corrupted (there could be some uncompressed data left in the output dictionary - oh well). */
        else if ((status == TINFL_STATUS_NEEDS_MORE_INPUT) && (!orig_avail_in))
            return MZ_BUF_ERROR; /* Signal caller that we can't make forward progress without supplying more input or by setting flush to MZ_FINISH. */
        else if (flush == MZ_FINISH)
        {
            /* The output buffer MUST be large to hold the remaining uncompressed data when flush==MZ_FINISH. */
            if (status == TINFL_STATUS_DONE)
                return pState->m_dict_avail ? MZ_BUF_ERROR : MZ_STREAM_END;
            /* status here must be TINFL_STATUS_HAS_MORE_OUTPUT, which means there's at least 1 more byte on the way. If there's no more room left in the output buffer then something is wrong. */
            else if (!pStream->avail_out)
                return MZ_BUF_ERROR;
        }
        else if ((status == TINFL_STATUS_DONE) || (!pStream->avail_in) || (!pStream->avail_out) || (pState->m_dict_avail))
            break;
    }

    return ((status == TINFL_STATUS_DONE) && (!pState->m_dict_avail)) ? MZ_STREAM_END : MZ_OK;
}

int mz_inflateEnd(mz_streamp pStream)
{
    if (!pStream)
        return MZ_STREAM_ERROR;
    if (pStream->state)
    {
        pStream->zfree(pStream->opaque, pStream->state);
        pStream->state = NULL;
    }
    return MZ_OK;
}
int mz_uncompress2(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong *pSource_len)
{
    mz_stream stream;
    int status;
    memset(&stream, 0, sizeof(stream));

    /* In case mz_ulong is 64-bits (argh I hate longs). */
    if ((mz_uint64)(*pSource_len | *pDest_len) > 0xFFFFFFFFU)
        return MZ_PARAM_ERROR;

    stream.next_in = pSource;
    stream.avail_in = (mz_uint32)*pSource_len;
    stream.next_out = pDest;
    stream.avail_out = (mz_uint32)*pDest_len;

    status = mz_inflateInit(&stream);
    if (status != MZ_OK)
        return status;

    status = mz_inflate(&stream, MZ_FINISH);
    *pSource_len = *pSource_len - stream.avail_in;
    if (status != MZ_STREAM_END)
    {
        mz_inflateEnd(&stream);
        return ((status == MZ_BUF_ERROR) && (!stream.avail_in)) ? MZ_DATA_ERROR : status;
    }
    *pDest_len = stream.total_out;

    return mz_inflateEnd(&stream);
}

int mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len, const unsigned char *pSource, mz_ulong source_len)
{
    return mz_uncompress2(pDest, pDest_len, pSource, &source_len);
}

#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/

const char *mz_error(int err)
{
    static struct
    {
        int m_err;
        const char *m_pDesc;
    } s_error_descs[] =
        {
          { MZ_OK, "" }, { MZ_STREAM_END, "stream end" }, { MZ_NEED_DICT, "need dictionary" }, { MZ_ERRNO, "file error" }, { MZ_STREAM_ERROR, "stream error" }, { MZ_DATA_ERROR, "data error" }, { MZ_MEM_ERROR, "out of memory" }, { MZ_BUF_ERROR, "buf error" }, { MZ_VERSION_ERROR, "version error" }, { MZ_PARAM_ERROR, "parameter error" }
        };
    mz_uint i;
    for (i = 0; i < sizeof(s_error_descs) / sizeof(s_error_descs[0]); ++i)
        if (s_error_descs[i].m_err == err)
            return s_error_descs[i].m_pDesc;
    return NULL;
}

#endif /*MINIZ_NO_ZLIB_APIS */

#ifdef __cplusplus
}
#endif

/*
  This is free and unencumbered software released into the public domain.

  Anyone is free to copy, modify, publish, use, compile, sell, or
  distribute this software, either in source code form or as a compiled
  binary, for any purpose, commercial or non-commercial, and by any
  means.

  In jurisdictions that recognize copyright laws, the author or authors
  of this software dedicate any and all copyright interest in the
  software to the public domain. We make this dedication for the benefit
  of the public at large and to the detriment of our heirs and
  successors. We intend this dedication to be an overt act of
  relinquishment in perpetuity of all present and future rights to this
  software under copyright law.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.

  For more information, please refer to <http://unlicense.org/>
*/
/**************************************************************************
 *
 * Copyright 2013-2014 RAD Game Tools and Valve Software
 * Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 **************************************************************************/



#ifndef MINIZ_NO_DEFLATE_APIS

#ifdef __cplusplus
extern "C" {
#endif

/* ------------------- Low-level Compression (independent from all decompression API's) */

/* Purposely making these tables static for faster init and thread safety. */
static const mz_uint16 s_tdefl_len_sym[256] =
    {
      257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268, 268, 269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272, 272, 272, 272,
      273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274, 274, 274, 274, 275, 275, 275, 275, 275, 275, 275, 275, 276, 276, 276, 276, 276, 276, 276, 276,
      277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,
      279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280,
      281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,
      282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
      283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,
      284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 285
    };

static const mz_uint8 s_tdefl_len_extra[256] =
    {
      0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
      5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0
    };

static const mz_uint8 s_tdefl_small_dist_sym[512] =
    {
      0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11,
      11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13,
      13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
      14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
      14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
      15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
      16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
      16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
      16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
      17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
      17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
      17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17
    };

static const mz_uint8 s_tdefl_small_dist_extra[512] =
    {
      0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
      5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
      6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
      6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
      7, 7, 7, 7, 7, 7, 7, 7
    };

static const mz_uint8 s_tdefl_large_dist_sym[128] =
    {
      0, 0, 18, 19, 20, 20, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
      26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
      28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
    };

static const mz_uint8 s_tdefl_large_dist_extra[128] =
    {
      0, 0, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
      12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
      13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13
    };

/* Radix sorts tdefl_sym_freq[] array by 16-bit key m_key. Returns ptr to sorted values. */
typedef struct
{
    mz_uint16 m_key, m_sym_index;
} tdefl_sym_freq;
static tdefl_sym_freq *tdefl_radix_sort_syms(mz_uint num_syms, tdefl_sym_freq *pSyms0, tdefl_sym_freq *pSyms1)
{
    mz_uint32 total_passes = 2, pass_shift, pass, i, hist[256 * 2];
    tdefl_sym_freq *pCur_syms = pSyms0, *pNew_syms = pSyms1;
    MZ_CLEAR_ARR(hist);
    for (i = 0; i < num_syms; i++)
    {
        mz_uint freq = pSyms0[i].m_key;
        hist[freq & 0xFF]++;
        hist[256 + ((freq >> 8) & 0xFF)]++;
    }
    while ((total_passes > 1) && (num_syms == hist[(total_passes - 1) * 256]))
        total_passes--;
    for (pass_shift = 0, pass = 0; pass < total_passes; pass++, pass_shift += 8)
    {
        const mz_uint32 *pHist = &hist[pass << 8];
        mz_uint offsets[256], cur_ofs = 0;
        for (i = 0; i < 256; i++)
        {
            offsets[i] = cur_ofs;
            cur_ofs += pHist[i];
        }
        for (i = 0; i < num_syms; i++)
            pNew_syms[offsets[(pCur_syms[i].m_key >> pass_shift) & 0xFF]++] = pCur_syms[i];
        {
            tdefl_sym_freq *t = pCur_syms;
            pCur_syms = pNew_syms;
            pNew_syms = t;
        }
    }
    return pCur_syms;
}

/* tdefl_calculate_minimum_redundancy() originally written by: Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996. */
static void tdefl_calculate_minimum_redundancy(tdefl_sym_freq *A, int n)
{
    int root, leaf, next, avbl, used, dpth;
    if (n == 0)
        return;
    else if (n == 1)
    {
        A[0].m_key = 1;
        return;
    }
    A[0].m_key += A[1].m_key;
    root = 0;
    leaf = 2;
    for (next = 1; next < n - 1; next++)
    {
        if (leaf >= n || A[root].m_key < A[leaf].m_key)
        {
            A[next].m_key = A[root].m_key;
            A[root++].m_key = (mz_uint16)next;
        }
        else
            A[next].m_key = A[leaf++].m_key;
        if (leaf >= n || (root < next && A[root].m_key < A[leaf].m_key))
        {
            A[next].m_key = (mz_uint16)(A[next].m_key + A[root].m_key);
            A[root++].m_key = (mz_uint16)next;
        }
        else
            A[next].m_key = (mz_uint16)(A[next].m_key + A[leaf++].m_key);
    }
    A[n - 2].m_key = 0;
    for (next = n - 3; next >= 0; next--)
        A[next].m_key = A[A[next].m_key].m_key + 1;
    avbl = 1;
    used = dpth = 0;
    root = n - 2;
    next = n - 1;
    while (avbl > 0)
    {
        while (root >= 0 && (int)A[root].m_key == dpth)
        {
            used++;
            root--;
        }
        while (avbl > used)
        {
            A[next--].m_key = (mz_uint16)(dpth);
            avbl--;
        }
        avbl = 2 * used;
        dpth++;
        used = 0;
    }
}

/* Limits canonical Huffman code table's max code size. */
enum
{
    TDEFL_MAX_SUPPORTED_HUFF_CODESIZE = 32
};
static void tdefl_huffman_enforce_max_code_size(int *pNum_codes, int code_list_len, int max_code_size)
{
    int i;
    mz_uint32 total = 0;
    if (code_list_len <= 1)
        return;
    for (i = max_code_size + 1; i <= TDEFL_MAX_SUPPORTED_HUFF_CODESIZE; i++)
        pNum_codes[max_code_size] += pNum_codes[i];
    for (i = max_code_size; i > 0; i--)
        total += (((mz_uint32)pNum_codes[i]) << (max_code_size - i));
    while (total != (1UL << max_code_size))
    {
        pNum_codes[max_code_size]--;
        for (i = max_code_size - 1; i > 0; i--)
            if (pNum_codes[i])
            {
                pNum_codes[i]--;
                pNum_codes[i + 1] += 2;
                break;
            }
        total--;
    }
}

static void tdefl_optimize_huffman_table(tdefl_compressor *d, int table_num, int table_len, int code_size_limit, int static_table)
{
    int i, j, l, num_codes[1 + TDEFL_MAX_SUPPORTED_HUFF_CODESIZE];
    mz_uint next_code[TDEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1];
    MZ_CLEAR_ARR(num_codes);
    if (static_table)
    {
        for (i = 0; i < table_len; i++)
            num_codes[d->m_huff_code_sizes[table_num][i]]++;
    }
    else
    {
        tdefl_sym_freq syms0[TDEFL_MAX_HUFF_SYMBOLS], syms1[TDEFL_MAX_HUFF_SYMBOLS], *pSyms;
        int num_used_syms = 0;
        const mz_uint16 *pSym_count = &d->m_huff_count[table_num][0];
        for (i = 0; i < table_len; i++)
            if (pSym_count[i])
            {
                syms0[num_used_syms].m_key = (mz_uint16)pSym_count[i];
                syms0[num_used_syms++].m_sym_index = (mz_uint16)i;
            }

        pSyms = tdefl_radix_sort_syms(num_used_syms, syms0, syms1);
        tdefl_calculate_minimum_redundancy(pSyms, num_used_syms);

        for (i = 0; i < num_used_syms; i++)
            num_codes[pSyms[i].m_key]++;

        tdefl_huffman_enforce_max_code_size(num_codes, num_used_syms, code_size_limit);

        MZ_CLEAR_ARR(d->m_huff_code_sizes[table_num]);
        MZ_CLEAR_ARR(d->m_huff_codes[table_num]);
        for (i = 1, j = num_used_syms; i <= code_size_limit; i++)
            for (l = num_codes[i]; l > 0; l--)
                d->m_huff_code_sizes[table_num][pSyms[--j].m_sym_index] = (mz_uint8)(i);
    }

    next_code[1] = 0;
    for (j = 0, i = 2; i <= code_size_limit; i++)
        next_code[i] = j = ((j + num_codes[i - 1]) << 1);

    for (i = 0; i < table_len; i++)
    {
        mz_uint rev_code = 0, code, code_size;
        if ((code_size = d->m_huff_code_sizes[table_num][i]) == 0)
            continue;
        code = next_code[code_size]++;
        for (l = code_size; l > 0; l--, code >>= 1)
            rev_code = (rev_code << 1) | (code & 1);
        d->m_huff_codes[table_num][i] = (mz_uint16)rev_code;
    }
}

#define TDEFL_PUT_BITS(b, l)                                       \
    do                                                             \
    {                                                              \
        mz_uint bits = b;                                          \
        mz_uint len = l;                                           \
        MZ_ASSERT(bits <= ((1U << len) - 1U));                     \
        d->m_bit_buffer |= (bits << d->m_bits_in);                 \
        d->m_bits_in += len;                                       \
        while (d->m_bits_in >= 8)                                  \
        {                                                          \
            if (d->m_pOutput_buf < d->m_pOutput_buf_end)           \
                *d->m_pOutput_buf++ = (mz_uint8)(d->m_bit_buffer); \
            d->m_bit_buffer >>= 8;                                 \
            d->m_bits_in -= 8;                                     \
        }                                                          \
    }                                                              \
    MZ_MACRO_END

#define TDEFL_RLE_PREV_CODE_SIZE()                                                                                       \
    {                                                                                                                    \
        if (rle_repeat_count)                                                                                            \
        {                                                                                                                \
            if (rle_repeat_count < 3)                                                                                    \
            {                                                                                                            \
                d->m_huff_count[2][prev_code_size] = (mz_uint16)(d->m_huff_count[2][prev_code_size] + rle_repeat_count); \
                while (rle_repeat_count--)                                                                               \
                    packed_code_sizes[num_packed_code_sizes++] = prev_code_size;                                         \
            }                                                                                                            \
            else                                                                                                         \
            {                                                                                                            \
                d->m_huff_count[2][16] = (mz_uint16)(d->m_huff_count[2][16] + 1);                                        \
                packed_code_sizes[num_packed_code_sizes++] = 16;                                                         \
                packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_repeat_count - 3);                           \
            }                                                                                                            \
            rle_repeat_count = 0;                                                                                        \
        }                                                                                                                \
    }

#define TDEFL_RLE_ZERO_CODE_SIZE()                                                         \
    {                                                                                      \
        if (rle_z_count)                                                                   \
        {                                                                                  \
            if (rle_z_count < 3)                                                           \
            {                                                                              \
                d->m_huff_count[2][0] = (mz_uint16)(d->m_huff_count[2][0] + rle_z_count);  \
                while (rle_z_count--)                                                      \
                    packed_code_sizes[num_packed_code_sizes++] = 0;                        \
            }                                                                              \
            else if (rle_z_count <= 10)                                                    \
            {                                                                              \
                d->m_huff_count[2][17] = (mz_uint16)(d->m_huff_count[2][17] + 1);          \
                packed_code_sizes[num_packed_code_sizes++] = 17;                           \
                packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 3);  \
            }                                                                              \
            else                                                                           \
            {                                                                              \
                d->m_huff_count[2][18] = (mz_uint16)(d->m_huff_count[2][18] + 1);          \
                packed_code_sizes[num_packed_code_sizes++] = 18;                           \
                packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 11); \
            }                                                                              \
            rle_z_count = 0;                                                               \
        }                                                                                  \
    }

static const mz_uint8 s_tdefl_packed_code_size_syms_swizzle[] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };

static void tdefl_start_dynamic_block(tdefl_compressor *d)
{
    int num_lit_codes, num_dist_codes, num_bit_lengths;
    mz_uint i, total_code_sizes_to_pack, num_packed_code_sizes, rle_z_count, rle_repeat_count, packed_code_sizes_index;
    mz_uint8 code_sizes_to_pack[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], packed_code_sizes[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], prev_code_size = 0xFF;

    d->m_huff_count[0][256] = 1;

    tdefl_optimize_huffman_table(d, 0, TDEFL_MAX_HUFF_SYMBOLS_0, 15, MZ_FALSE);
    tdefl_optimize_huffman_table(d, 1, TDEFL_MAX_HUFF_SYMBOLS_1, 15, MZ_FALSE);

    for (num_lit_codes = 286; num_lit_codes > 257; num_lit_codes--)
        if (d->m_huff_code_sizes[0][num_lit_codes - 1])
            break;
    for (num_dist_codes = 30; num_dist_codes > 1; num_dist_codes--)
        if (d->m_huff_code_sizes[1][num_dist_codes - 1])
            break;

    memcpy(code_sizes_to_pack, &d->m_huff_code_sizes[0][0], num_lit_codes);
    memcpy(code_sizes_to_pack + num_lit_codes, &d->m_huff_code_sizes[1][0], num_dist_codes);
    total_code_sizes_to_pack = num_lit_codes + num_dist_codes;
    num_packed_code_sizes = 0;
    rle_z_count = 0;
    rle_repeat_count = 0;

    memset(&d->m_huff_count[2][0], 0, sizeof(d->m_huff_count[2][0]) * TDEFL_MAX_HUFF_SYMBOLS_2);
    for (i = 0; i < total_code_sizes_to_pack; i++)
    {
        mz_uint8 code_size = code_sizes_to_pack[i];
        if (!code_size)
        {
            TDEFL_RLE_PREV_CODE_SIZE();
            if (++rle_z_count == 138)
            {
                TDEFL_RLE_ZERO_CODE_SIZE();
            }
        }
        else
        {
            TDEFL_RLE_ZERO_CODE_SIZE();
            if (code_size != prev_code_size)
            {
                TDEFL_RLE_PREV_CODE_SIZE();
                d->m_huff_count[2][code_size] = (mz_uint16)(d->m_huff_count[2][code_size] + 1);
                packed_code_sizes[num_packed_code_sizes++] = code_size;
            }
            else if (++rle_repeat_count == 6)
            {
                TDEFL_RLE_PREV_CODE_SIZE();
            }
        }
        prev_code_size = code_size;
    }
    if (rle_repeat_count)
    {
        TDEFL_RLE_PREV_CODE_SIZE();
    }
    else
    {
        TDEFL_RLE_ZERO_CODE_SIZE();
    }

    tdefl_optimize_huffman_table(d, 2, TDEFL_MAX_HUFF_SYMBOLS_2, 7, MZ_FALSE);

    TDEFL_PUT_BITS(2, 2);

    TDEFL_PUT_BITS(num_lit_codes - 257, 5);
    TDEFL_PUT_BITS(num_dist_codes - 1, 5);

    for (num_bit_lengths = 18; num_bit_lengths >= 0; num_bit_lengths--)
        if (d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[num_bit_lengths]])
            break;
    num_bit_lengths = MZ_MAX(4, (num_bit_lengths + 1));
    TDEFL_PUT_BITS(num_bit_lengths - 4, 4);
    for (i = 0; (int)i < num_bit_lengths; i++)
        TDEFL_PUT_BITS(d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[i]], 3);

    for (packed_code_sizes_index = 0; packed_code_sizes_index < num_packed_code_sizes;)
    {
        mz_uint code = packed_code_sizes[packed_code_sizes_index++];
        MZ_ASSERT(code < TDEFL_MAX_HUFF_SYMBOLS_2);
        TDEFL_PUT_BITS(d->m_huff_codes[2][code], d->m_huff_code_sizes[2][code]);
        if (code >= 16)
            TDEFL_PUT_BITS(packed_code_sizes[packed_code_sizes_index++], "\02\03\07"[code - 16]);
    }
}

static void tdefl_start_static_block(tdefl_compressor *d)
{
    mz_uint i;
    mz_uint8 *p = &d->m_huff_code_sizes[0][0];

    for (i = 0; i <= 143; ++i)
        *p++ = 8;
    for (; i <= 255; ++i)
        *p++ = 9;
    for (; i <= 279; ++i)
        *p++ = 7;
    for (; i <= 287; ++i)
        *p++ = 8;

    memset(d->m_huff_code_sizes[1], 5, 32);

    tdefl_optimize_huffman_table(d, 0, 288, 15, MZ_TRUE);
    tdefl_optimize_huffman_table(d, 1, 32, 15, MZ_TRUE);

    TDEFL_PUT_BITS(1, 2);
}

static const mz_uint mz_bitmasks[17] = { 0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF };

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS
static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)
{
    mz_uint flags;
    mz_uint8 *pLZ_codes;
    mz_uint8 *pOutput_buf = d->m_pOutput_buf;
    mz_uint8 *pLZ_code_buf_end = d->m_pLZ_code_buf;
    mz_uint64 bit_buffer = d->m_bit_buffer;
    mz_uint bits_in = d->m_bits_in;

#define TDEFL_PUT_BITS_FAST(b, l)                    \
    {                                                \
        bit_buffer |= (((mz_uint64)(b)) << bits_in); \
        bits_in += (l);                              \
    }

    flags = 1;
    for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < pLZ_code_buf_end; flags >>= 1)
    {
        if (flags == 1)
            flags = *pLZ_codes++ | 0x100;

        if (flags & 1)
        {
            mz_uint s0, s1, n0, n1, sym, num_extra_bits;
            mz_uint match_len = pLZ_codes[0];
            mz_uint match_dist = (pLZ_codes[1] | (pLZ_codes[2] << 8));
            pLZ_codes += 3;

            MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
            TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
            TDEFL_PUT_BITS_FAST(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);

            /* This sequence coaxes MSVC into using cmov's vs. jmp's. */
            s0 = s_tdefl_small_dist_sym[match_dist & 511];
            n0 = s_tdefl_small_dist_extra[match_dist & 511];
            s1 = s_tdefl_large_dist_sym[match_dist >> 8];
            n1 = s_tdefl_large_dist_extra[match_dist >> 8];
            sym = (match_dist < 512) ? s0 : s1;
            num_extra_bits = (match_dist < 512) ? n0 : n1;

            MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
            TDEFL_PUT_BITS_FAST(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);
            TDEFL_PUT_BITS_FAST(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);
        }
        else
        {
            mz_uint lit = *pLZ_codes++;
            MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
            TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);

            if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end))
            {
                flags >>= 1;
                lit = *pLZ_codes++;
                MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
                TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);

                if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end))
                {
                    flags >>= 1;
                    lit = *pLZ_codes++;
                    MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
                    TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
                }
            }
        }

        if (pOutput_buf >= d->m_pOutput_buf_end)
            return MZ_FALSE;

        memcpy(pOutput_buf, &bit_buffer, sizeof(mz_uint64));
        pOutput_buf += (bits_in >> 3);
        bit_buffer >>= (bits_in & ~7);
        bits_in &= 7;
    }

#undef TDEFL_PUT_BITS_FAST

    d->m_pOutput_buf = pOutput_buf;
    d->m_bits_in = 0;
    d->m_bit_buffer = 0;

    while (bits_in)
    {
        mz_uint32 n = MZ_MIN(bits_in, 16);
        TDEFL_PUT_BITS((mz_uint)bit_buffer & mz_bitmasks[n], n);
        bit_buffer >>= n;
        bits_in -= n;
    }

    TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);

    return (d->m_pOutput_buf < d->m_pOutput_buf_end);
}
#else
static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)
{
    mz_uint flags;
    mz_uint8 *pLZ_codes;

    flags = 1;
    for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < d->m_pLZ_code_buf; flags >>= 1)
    {
        if (flags == 1)
            flags = *pLZ_codes++ | 0x100;
        if (flags & 1)
        {
            mz_uint sym, num_extra_bits;
            mz_uint match_len = pLZ_codes[0], match_dist = (pLZ_codes[1] | (pLZ_codes[2] << 8));
            pLZ_codes += 3;

            MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
            TDEFL_PUT_BITS(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
            TDEFL_PUT_BITS(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);

            if (match_dist < 512)
            {
                sym = s_tdefl_small_dist_sym[match_dist];
                num_extra_bits = s_tdefl_small_dist_extra[match_dist];
            }
            else
            {
                sym = s_tdefl_large_dist_sym[match_dist >> 8];
                num_extra_bits = s_tdefl_large_dist_extra[match_dist >> 8];
            }
            MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
            TDEFL_PUT_BITS(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);
            TDEFL_PUT_BITS(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);
        }
        else
        {
            mz_uint lit = *pLZ_codes++;
            MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
            TDEFL_PUT_BITS(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
        }
    }

    TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);

    return (d->m_pOutput_buf < d->m_pOutput_buf_end);
}
#endif /* MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS */

static mz_bool tdefl_compress_block(tdefl_compressor *d, mz_bool static_block)
{
    if (static_block)
        tdefl_start_static_block(d);
    else
        tdefl_start_dynamic_block(d);
    return tdefl_compress_lz_codes(d);
}

static const mz_uint s_tdefl_num_probes[11];

static int tdefl_flush_block(tdefl_compressor *d, int flush)
{
    mz_uint saved_bit_buf, saved_bits_in;
    mz_uint8 *pSaved_output_buf;
    mz_bool comp_block_succeeded = MZ_FALSE;
    int n, use_raw_block = ((d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS) != 0) && (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size;
    mz_uint8 *pOutput_buf_start = ((d->m_pPut_buf_func == NULL) && ((*d->m_pOut_buf_size - d->m_out_buf_ofs) >= TDEFL_OUT_BUF_SIZE)) ? ((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs) : d->m_output_buf;

    d->m_pOutput_buf = pOutput_buf_start;
    d->m_pOutput_buf_end = d->m_pOutput_buf + TDEFL_OUT_BUF_SIZE - 16;

    MZ_ASSERT(!d->m_output_flush_remaining);
    d->m_output_flush_ofs = 0;
    d->m_output_flush_remaining = 0;

    *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> d->m_num_flags_left);
    d->m_pLZ_code_buf -= (d->m_num_flags_left == 8);

    if ((d->m_flags & TDEFL_WRITE_ZLIB_HEADER) && (!d->m_block_index))
    {
        const mz_uint8 cmf = 0x78;
        mz_uint8 flg, flevel = 3;
        mz_uint header, i, mz_un = sizeof(s_tdefl_num_probes) / sizeof(mz_uint);

        /* Determine compression level by reversing the process in tdefl_create_comp_flags_from_zip_params() */
        for (i = 0; i < mz_un; i++)
            if (s_tdefl_num_probes[i] == (d->m_flags & 0xFFF)) break;

        if (i < 2)
            flevel = 0;
        else if (i < 6)
            flevel = 1;
        else if (i == 6)
            flevel = 2;

        header = cmf << 8 | (flevel << 6);
        header += 31 - (header % 31);
        flg = header & 0xFF;

        TDEFL_PUT_BITS(cmf, 8);
        TDEFL_PUT_BITS(flg, 8);
    }

    TDEFL_PUT_BITS(flush == TDEFL_FINISH, 1);

    pSaved_output_buf = d->m_pOutput_buf;
    saved_bit_buf = d->m_bit_buffer;
    saved_bits_in = d->m_bits_in;

    if (!use_raw_block)
        comp_block_succeeded = tdefl_compress_block(d, (d->m_flags & TDEFL_FORCE_ALL_STATIC_BLOCKS) || (d->m_total_lz_bytes < 48));

    /* If the block gets expanded, forget the current contents of the output buffer and send a raw block instead. */
    if (((use_raw_block) || ((d->m_total_lz_bytes) && ((d->m_pOutput_buf - pSaved_output_buf + 1U) >= d->m_total_lz_bytes))) &&
        ((d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size))
    {
        mz_uint i;
        d->m_pOutput_buf = pSaved_output_buf;
        d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
        TDEFL_PUT_BITS(0, 2);
        if (d->m_bits_in)
        {
            TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
        }
        for (i = 2; i; --i, d->m_total_lz_bytes ^= 0xFFFF)
        {
            TDEFL_PUT_BITS(d->m_total_lz_bytes & 0xFFFF, 16);
        }
        for (i = 0; i < d->m_total_lz_bytes; ++i)
        {
            TDEFL_PUT_BITS(d->m_dict[(d->m_lz_code_buf_dict_pos + i) & TDEFL_LZ_DICT_SIZE_MASK], 8);
        }
    }
    /* Check for the extremely unlikely (if not impossible) case of the compressed block not fitting into the output buffer when using dynamic codes. */
    else if (!comp_block_succeeded)
    {
        d->m_pOutput_buf = pSaved_output_buf;
        d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
        tdefl_compress_block(d, MZ_TRUE);
    }

    if (flush)
    {
        if (flush == TDEFL_FINISH)
        {
            if (d->m_bits_in)
            {
                TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
            }
            if (d->m_flags & TDEFL_WRITE_ZLIB_HEADER)
            {
                mz_uint i, a = d->m_adler32;
                for (i = 0; i < 4; i++)
                {
                    TDEFL_PUT_BITS((a >> 24) & 0xFF, 8);
                    a <<= 8;
                }
            }
        }
        else
        {
            mz_uint i, z = 0;
            TDEFL_PUT_BITS(0, 3);
            if (d->m_bits_in)
            {
                TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
            }
            for (i = 2; i; --i, z ^= 0xFFFF)
            {
                TDEFL_PUT_BITS(z & 0xFFFF, 16);
            }
        }
    }

    MZ_ASSERT(d->m_pOutput_buf < d->m_pOutput_buf_end);

    memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
    memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);

    d->m_pLZ_code_buf = d->m_lz_code_buf + 1;
    d->m_pLZ_flags = d->m_lz_code_buf;
    d->m_num_flags_left = 8;
    d->m_lz_code_buf_dict_pos += d->m_total_lz_bytes;
    d->m_total_lz_bytes = 0;
    d->m_block_index++;

    if ((n = (int)(d->m_pOutput_buf - pOutput_buf_start)) != 0)
    {
        if (d->m_pPut_buf_func)
        {
            *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;
            if (!(*d->m_pPut_buf_func)(d->m_output_buf, n, d->m_pPut_buf_user))
                return (d->m_prev_return_status = TDEFL_STATUS_PUT_BUF_FAILED);
        }
        else if (pOutput_buf_start == d->m_output_buf)
        {
            int bytes_to_copy = (int)MZ_MIN((size_t)n, (size_t)(*d->m_pOut_buf_size - d->m_out_buf_ofs));
            memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf, bytes_to_copy);
            d->m_out_buf_ofs += bytes_to_copy;
            if ((n -= bytes_to_copy) != 0)
            {
                d->m_output_flush_ofs = bytes_to_copy;
                d->m_output_flush_remaining = n;
            }
        }
        else
        {
            d->m_out_buf_ofs += n;
        }
    }

    return d->m_output_flush_remaining;
}

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
#ifdef MINIZ_UNALIGNED_USE_MEMCPY
static mz_uint16 TDEFL_READ_UNALIGNED_WORD(const mz_uint8* p)
{
	mz_uint16 ret;
	memcpy(&ret, p, sizeof(mz_uint16));
	return ret;
}
static mz_uint16 TDEFL_READ_UNALIGNED_WORD2(const mz_uint16* p)
{
	mz_uint16 ret;
	memcpy(&ret, p, sizeof(mz_uint16));
	return ret;
}
#else
#define TDEFL_READ_UNALIGNED_WORD(p) *(const mz_uint16 *)(p)
#define TDEFL_READ_UNALIGNED_WORD2(p) *(const mz_uint16 *)(p)
#endif
static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)
{
    mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;
    mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
    const mz_uint16 *s = (const mz_uint16 *)(d->m_dict + pos), *p, *q;
    mz_uint16 c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]), s01 = TDEFL_READ_UNALIGNED_WORD2(s);
    MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN);
    if (max_match_len <= match_len)
        return;
    for (;;)
    {
        for (;;)
        {
            if (--num_probes_left == 0)
                return;
#define TDEFL_PROBE                                                                             \
    next_probe_pos = d->m_next[probe_pos];                                                      \
    if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist)) \
        return;                                                                                 \
    probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK;                                       \
    if (TDEFL_READ_UNALIGNED_WORD(&d->m_dict[probe_pos + match_len - 1]) == c01)                \
        break;
            TDEFL_PROBE;
            TDEFL_PROBE;
            TDEFL_PROBE;
        }
        if (!dist)
            break;
        q = (const mz_uint16 *)(d->m_dict + probe_pos);
        if (TDEFL_READ_UNALIGNED_WORD2(q) != s01)
            continue;
        p = s;
        probe_len = 32;
        do
        {
        } while ((TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) &&
                 (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (--probe_len > 0));
        if (!probe_len)
        {
            *pMatch_dist = dist;
            *pMatch_len = MZ_MIN(max_match_len, (mz_uint)TDEFL_MAX_MATCH_LEN);
            break;
        }
        else if ((probe_len = ((mz_uint)(p - s) * 2) + (mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q)) > match_len)
        {
            *pMatch_dist = dist;
            if ((*pMatch_len = match_len = MZ_MIN(max_match_len, probe_len)) == max_match_len)
                break;
            c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]);
        }
    }
}
#else
static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)
{
    mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;
    mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
    const mz_uint8 *s = d->m_dict + pos, *p, *q;
    mz_uint8 c0 = d->m_dict[pos + match_len], c1 = d->m_dict[pos + match_len - 1];
    MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN);
    if (max_match_len <= match_len)
        return;
    for (;;)
    {
        for (;;)
        {
            if (--num_probes_left == 0)
                return;
#define TDEFL_PROBE                                                                               \
    next_probe_pos = d->m_next[probe_pos];                                                        \
    if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist))   \
        return;                                                                                   \
    probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK;                                         \
    if ((d->m_dict[probe_pos + match_len] == c0) && (d->m_dict[probe_pos + match_len - 1] == c1)) \
        break;
            TDEFL_PROBE;
            TDEFL_PROBE;
            TDEFL_PROBE;
        }
        if (!dist)
            break;
        p = s;
        q = d->m_dict + probe_pos;
        for (probe_len = 0; probe_len < max_match_len; probe_len++)
            if (*p++ != *q++)
                break;
        if (probe_len > match_len)
        {
            *pMatch_dist = dist;
            if ((*pMatch_len = match_len = probe_len) == max_match_len)
                return;
            c0 = d->m_dict[pos + match_len];
            c1 = d->m_dict[pos + match_len - 1];
        }
    }
}
#endif /* #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES */

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
#ifdef MINIZ_UNALIGNED_USE_MEMCPY
static mz_uint32 TDEFL_READ_UNALIGNED_WORD32(const mz_uint8* p)
{
	mz_uint32 ret;
	memcpy(&ret, p, sizeof(mz_uint32));
	return ret;
}
#else
#define TDEFL_READ_UNALIGNED_WORD32(p) *(const mz_uint32 *)(p)
#endif
static mz_bool tdefl_compress_fast(tdefl_compressor *d)
{
    /* Faster, minimally featured LZRW1-style match+parse loop with better register utilization. Intended for applications where raw throughput is valued more highly than ratio. */
    mz_uint lookahead_pos = d->m_lookahead_pos, lookahead_size = d->m_lookahead_size, dict_size = d->m_dict_size, total_lz_bytes = d->m_total_lz_bytes, num_flags_left = d->m_num_flags_left;
    mz_uint8 *pLZ_code_buf = d->m_pLZ_code_buf, *pLZ_flags = d->m_pLZ_flags;
    mz_uint cur_pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;

    while ((d->m_src_buf_left) || ((d->m_flush) && (lookahead_size)))
    {
        const mz_uint TDEFL_COMP_FAST_LOOKAHEAD_SIZE = 4096;
        mz_uint dst_pos = (lookahead_pos + lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
        mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(d->m_src_buf_left, TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);
        d->m_src_buf_left -= num_bytes_to_process;
        lookahead_size += num_bytes_to_process;

        while (num_bytes_to_process)
        {
            mz_uint32 n = MZ_MIN(TDEFL_LZ_DICT_SIZE - dst_pos, num_bytes_to_process);
            memcpy(d->m_dict + dst_pos, d->m_pSrc, n);
            if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
                memcpy(d->m_dict + TDEFL_LZ_DICT_SIZE + dst_pos, d->m_pSrc, MZ_MIN(n, (TDEFL_MAX_MATCH_LEN - 1) - dst_pos));
            d->m_pSrc += n;
            dst_pos = (dst_pos + n) & TDEFL_LZ_DICT_SIZE_MASK;
            num_bytes_to_process -= n;
        }

        dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - lookahead_size, dict_size);
        if ((!d->m_flush) && (lookahead_size < TDEFL_COMP_FAST_LOOKAHEAD_SIZE))
            break;

        while (lookahead_size >= 4)
        {
            mz_uint cur_match_dist, cur_match_len = 1;
            mz_uint8 *pCur_dict = d->m_dict + cur_pos;
            mz_uint first_trigram = TDEFL_READ_UNALIGNED_WORD32(pCur_dict) & 0xFFFFFF;
            mz_uint hash = (first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8)))) & TDEFL_LEVEL1_HASH_SIZE_MASK;
            mz_uint probe_pos = d->m_hash[hash];
            d->m_hash[hash] = (mz_uint16)lookahead_pos;

            if (((cur_match_dist = (mz_uint16)(lookahead_pos - probe_pos)) <= dict_size) && ((TDEFL_READ_UNALIGNED_WORD32(d->m_dict + (probe_pos &= TDEFL_LZ_DICT_SIZE_MASK)) & 0xFFFFFF) == first_trigram))
            {
                const mz_uint16 *p = (const mz_uint16 *)pCur_dict;
                const mz_uint16 *q = (const mz_uint16 *)(d->m_dict + probe_pos);
                mz_uint32 probe_len = 32;
                do
                {
                } while ((TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) &&
                         (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (TDEFL_READ_UNALIGNED_WORD2(++p) == TDEFL_READ_UNALIGNED_WORD2(++q)) && (--probe_len > 0));
                cur_match_len = ((mz_uint)(p - (const mz_uint16 *)pCur_dict) * 2) + (mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q);
                if (!probe_len)
                    cur_match_len = cur_match_dist ? TDEFL_MAX_MATCH_LEN : 0;

                if ((cur_match_len < TDEFL_MIN_MATCH_LEN) || ((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U * 1024U)))
                {
                    cur_match_len = 1;
                    *pLZ_code_buf++ = (mz_uint8)first_trigram;
                    *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
                    d->m_huff_count[0][(mz_uint8)first_trigram]++;
                }
                else
                {
                    mz_uint32 s0, s1;
                    cur_match_len = MZ_MIN(cur_match_len, lookahead_size);

                    MZ_ASSERT((cur_match_len >= TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 1) && (cur_match_dist <= TDEFL_LZ_DICT_SIZE));

                    cur_match_dist--;

                    pLZ_code_buf[0] = (mz_uint8)(cur_match_len - TDEFL_MIN_MATCH_LEN);
#ifdef MINIZ_UNALIGNED_USE_MEMCPY
					memcpy(&pLZ_code_buf[1], &cur_match_dist, sizeof(cur_match_dist));
#else
                    *(mz_uint16 *)(&pLZ_code_buf[1]) = (mz_uint16)cur_match_dist;
#endif
                    pLZ_code_buf += 3;
                    *pLZ_flags = (mz_uint8)((*pLZ_flags >> 1) | 0x80);

                    s0 = s_tdefl_small_dist_sym[cur_match_dist & 511];
                    s1 = s_tdefl_large_dist_sym[cur_match_dist >> 8];
                    d->m_huff_count[1][(cur_match_dist < 512) ? s0 : s1]++;

                    d->m_huff_count[0][s_tdefl_len_sym[cur_match_len - TDEFL_MIN_MATCH_LEN]]++;
                }
            }
            else
            {
                *pLZ_code_buf++ = (mz_uint8)first_trigram;
                *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
                d->m_huff_count[0][(mz_uint8)first_trigram]++;
            }

            if (--num_flags_left == 0)
            {
                num_flags_left = 8;
                pLZ_flags = pLZ_code_buf++;
            }

            total_lz_bytes += cur_match_len;
            lookahead_pos += cur_match_len;
            dict_size = MZ_MIN(dict_size + cur_match_len, (mz_uint)TDEFL_LZ_DICT_SIZE);
            cur_pos = (cur_pos + cur_match_len) & TDEFL_LZ_DICT_SIZE_MASK;
            MZ_ASSERT(lookahead_size >= cur_match_len);
            lookahead_size -= cur_match_len;

            if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])
            {
                int n;
                d->m_lookahead_pos = lookahead_pos;
                d->m_lookahead_size = lookahead_size;
                d->m_dict_size = dict_size;
                d->m_total_lz_bytes = total_lz_bytes;
                d->m_pLZ_code_buf = pLZ_code_buf;
                d->m_pLZ_flags = pLZ_flags;
                d->m_num_flags_left = num_flags_left;
                if ((n = tdefl_flush_block(d, 0)) != 0)
                    return (n < 0) ? MZ_FALSE : MZ_TRUE;
                total_lz_bytes = d->m_total_lz_bytes;
                pLZ_code_buf = d->m_pLZ_code_buf;
                pLZ_flags = d->m_pLZ_flags;
                num_flags_left = d->m_num_flags_left;
            }
        }

        while (lookahead_size)
        {
            mz_uint8 lit = d->m_dict[cur_pos];

            total_lz_bytes++;
            *pLZ_code_buf++ = lit;
            *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
            if (--num_flags_left == 0)
            {
                num_flags_left = 8;
                pLZ_flags = pLZ_code_buf++;
            }

            d->m_huff_count[0][lit]++;

            lookahead_pos++;
            dict_size = MZ_MIN(dict_size + 1, (mz_uint)TDEFL_LZ_DICT_SIZE);
            cur_pos = (cur_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
            lookahead_size--;

            if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])
            {
                int n;
                d->m_lookahead_pos = lookahead_pos;
                d->m_lookahead_size = lookahead_size;
                d->m_dict_size = dict_size;
                d->m_total_lz_bytes = total_lz_bytes;
                d->m_pLZ_code_buf = pLZ_code_buf;
                d->m_pLZ_flags = pLZ_flags;
                d->m_num_flags_left = num_flags_left;
                if ((n = tdefl_flush_block(d, 0)) != 0)
                    return (n < 0) ? MZ_FALSE : MZ_TRUE;
                total_lz_bytes = d->m_total_lz_bytes;
                pLZ_code_buf = d->m_pLZ_code_buf;
                pLZ_flags = d->m_pLZ_flags;
                num_flags_left = d->m_num_flags_left;
            }
        }
    }

    d->m_lookahead_pos = lookahead_pos;
    d->m_lookahead_size = lookahead_size;
    d->m_dict_size = dict_size;
    d->m_total_lz_bytes = total_lz_bytes;
    d->m_pLZ_code_buf = pLZ_code_buf;
    d->m_pLZ_flags = pLZ_flags;
    d->m_num_flags_left = num_flags_left;
    return MZ_TRUE;
}
#endif /* MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN */

static MZ_FORCEINLINE void tdefl_record_literal(tdefl_compressor *d, mz_uint8 lit)
{
    d->m_total_lz_bytes++;
    *d->m_pLZ_code_buf++ = lit;
    *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> 1);
    if (--d->m_num_flags_left == 0)
    {
        d->m_num_flags_left = 8;
        d->m_pLZ_flags = d->m_pLZ_code_buf++;
    }
    d->m_huff_count[0][lit]++;
}

static MZ_FORCEINLINE void tdefl_record_match(tdefl_compressor *d, mz_uint match_len, mz_uint match_dist)
{
    mz_uint32 s0, s1;

    MZ_ASSERT((match_len >= TDEFL_MIN_MATCH_LEN) && (match_dist >= 1) && (match_dist <= TDEFL_LZ_DICT_SIZE));

    d->m_total_lz_bytes += match_len;

    d->m_pLZ_code_buf[0] = (mz_uint8)(match_len - TDEFL_MIN_MATCH_LEN);

    match_dist -= 1;
    d->m_pLZ_code_buf[1] = (mz_uint8)(match_dist & 0xFF);
    d->m_pLZ_code_buf[2] = (mz_uint8)(match_dist >> 8);
    d->m_pLZ_code_buf += 3;

    *d->m_pLZ_flags = (mz_uint8)((*d->m_pLZ_flags >> 1) | 0x80);
    if (--d->m_num_flags_left == 0)
    {
        d->m_num_flags_left = 8;
        d->m_pLZ_flags = d->m_pLZ_code_buf++;
    }

    s0 = s_tdefl_small_dist_sym[match_dist & 511];
    s1 = s_tdefl_large_dist_sym[(match_dist >> 8) & 127];
    d->m_huff_count[1][(match_dist < 512) ? s0 : s1]++;
    d->m_huff_count[0][s_tdefl_len_sym[match_len - TDEFL_MIN_MATCH_LEN]]++;
}

static mz_bool tdefl_compress_normal(tdefl_compressor *d)
{
    const mz_uint8 *pSrc = d->m_pSrc;
    size_t src_buf_left = d->m_src_buf_left;
    tdefl_flush flush = d->m_flush;

    while ((src_buf_left) || ((flush) && (d->m_lookahead_size)))
    {
        mz_uint len_to_move, cur_match_dist, cur_match_len, cur_pos;
        /* Update dictionary and hash chains. Keeps the lookahead size equal to TDEFL_MAX_MATCH_LEN. */
        if ((d->m_lookahead_size + d->m_dict_size) >= (TDEFL_MIN_MATCH_LEN - 1))
        {
            mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK, ins_pos = d->m_lookahead_pos + d->m_lookahead_size - 2;
            mz_uint hash = (d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK];
            mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(src_buf_left, TDEFL_MAX_MATCH_LEN - d->m_lookahead_size);
            const mz_uint8 *pSrc_end = pSrc ? pSrc + num_bytes_to_process : NULL;
            src_buf_left -= num_bytes_to_process;
            d->m_lookahead_size += num_bytes_to_process;
            while (pSrc != pSrc_end)
            {
                mz_uint8 c = *pSrc++;
                d->m_dict[dst_pos] = c;
                if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
                    d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
                hash = ((hash << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);
                d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];
                d->m_hash[hash] = (mz_uint16)(ins_pos);
                dst_pos = (dst_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
                ins_pos++;
            }
        }
        else
        {
            while ((src_buf_left) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))
            {
                mz_uint8 c = *pSrc++;
                mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
                src_buf_left--;
                d->m_dict[dst_pos] = c;
                if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
                    d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
                if ((++d->m_lookahead_size + d->m_dict_size) >= TDEFL_MIN_MATCH_LEN)
                {
                    mz_uint ins_pos = d->m_lookahead_pos + (d->m_lookahead_size - 1) - 2;
                    mz_uint hash = ((d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << (TDEFL_LZ_HASH_SHIFT * 2)) ^ (d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);
                    d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];
                    d->m_hash[hash] = (mz_uint16)(ins_pos);
                }
            }
        }
        d->m_dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - d->m_lookahead_size, d->m_dict_size);
        if ((!flush) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))
            break;

        /* Simple lazy/greedy parsing state machine. */
        len_to_move = 1;
        cur_match_dist = 0;
        cur_match_len = d->m_saved_match_len ? d->m_saved_match_len : (TDEFL_MIN_MATCH_LEN - 1);
        cur_pos = d->m_lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;
        if (d->m_flags & (TDEFL_RLE_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS))
        {
            if ((d->m_dict_size) && (!(d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS)))
            {
                mz_uint8 c = d->m_dict[(cur_pos - 1) & TDEFL_LZ_DICT_SIZE_MASK];
                cur_match_len = 0;
                while (cur_match_len < d->m_lookahead_size)
                {
                    if (d->m_dict[cur_pos + cur_match_len] != c)
                        break;
                    cur_match_len++;
                }
                if (cur_match_len < TDEFL_MIN_MATCH_LEN)
                    cur_match_len = 0;
                else
                    cur_match_dist = 1;
            }
        }
        else
        {
            tdefl_find_match(d, d->m_lookahead_pos, d->m_dict_size, d->m_lookahead_size, &cur_match_dist, &cur_match_len);
        }
        if (((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U * 1024U)) || (cur_pos == cur_match_dist) || ((d->m_flags & TDEFL_FILTER_MATCHES) && (cur_match_len <= 5)))
        {
            cur_match_dist = cur_match_len = 0;
        }
        if (d->m_saved_match_len)
        {
            if (cur_match_len > d->m_saved_match_len)
            {
                tdefl_record_literal(d, (mz_uint8)d->m_saved_lit);
                if (cur_match_len >= 128)
                {
                    tdefl_record_match(d, cur_match_len, cur_match_dist);
                    d->m_saved_match_len = 0;
                    len_to_move = cur_match_len;
                }
                else
                {
                    d->m_saved_lit = d->m_dict[cur_pos];
                    d->m_saved_match_dist = cur_match_dist;
                    d->m_saved_match_len = cur_match_len;
                }
            }
            else
            {
                tdefl_record_match(d, d->m_saved_match_len, d->m_saved_match_dist);
                len_to_move = d->m_saved_match_len - 1;
                d->m_saved_match_len = 0;
            }
        }
        else if (!cur_match_dist)
            tdefl_record_literal(d, d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)]);
        else if ((d->m_greedy_parsing) || (d->m_flags & TDEFL_RLE_MATCHES) || (cur_match_len >= 128))
        {
            tdefl_record_match(d, cur_match_len, cur_match_dist);
            len_to_move = cur_match_len;
        }
        else
        {
            d->m_saved_lit = d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)];
            d->m_saved_match_dist = cur_match_dist;
            d->m_saved_match_len = cur_match_len;
        }
        /* Move the lookahead forward by len_to_move bytes. */
        d->m_lookahead_pos += len_to_move;
        MZ_ASSERT(d->m_lookahead_size >= len_to_move);
        d->m_lookahead_size -= len_to_move;
        d->m_dict_size = MZ_MIN(d->m_dict_size + len_to_move, (mz_uint)TDEFL_LZ_DICT_SIZE);
        /* Check if it's time to flush the current LZ codes to the internal output buffer. */
        if ((d->m_pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) ||
            ((d->m_total_lz_bytes > 31 * 1024) && (((((mz_uint)(d->m_pLZ_code_buf - d->m_lz_code_buf) * 115) >> 7) >= d->m_total_lz_bytes) || (d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS))))
        {
            int n;
            d->m_pSrc = pSrc;
            d->m_src_buf_left = src_buf_left;
            if ((n = tdefl_flush_block(d, 0)) != 0)
                return (n < 0) ? MZ_FALSE : MZ_TRUE;
        }
    }

    d->m_pSrc = pSrc;
    d->m_src_buf_left = src_buf_left;
    return MZ_TRUE;
}

static tdefl_status tdefl_flush_output_buffer(tdefl_compressor *d)
{
    if (d->m_pIn_buf_size)
    {
        *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;
    }

    if (d->m_pOut_buf_size)
    {
        size_t n = MZ_MIN(*d->m_pOut_buf_size - d->m_out_buf_ofs, d->m_output_flush_remaining);
        memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf + d->m_output_flush_ofs, n);
        d->m_output_flush_ofs += (mz_uint)n;
        d->m_output_flush_remaining -= (mz_uint)n;
        d->m_out_buf_ofs += n;

        *d->m_pOut_buf_size = d->m_out_buf_ofs;
    }

    return (d->m_finished && !d->m_output_flush_remaining) ? TDEFL_STATUS_DONE : TDEFL_STATUS_OKAY;
}

tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pIn_buf_size, void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush)
{
    if (!d)
    {
        if (pIn_buf_size)
            *pIn_buf_size = 0;
        if (pOut_buf_size)
            *pOut_buf_size = 0;
        return TDEFL_STATUS_BAD_PARAM;
    }

    d->m_pIn_buf = pIn_buf;
    d->m_pIn_buf_size = pIn_buf_size;
    d->m_pOut_buf = pOut_buf;
    d->m_pOut_buf_size = pOut_buf_size;
    d->m_pSrc = (const mz_uint8 *)(pIn_buf);
    d->m_src_buf_left = pIn_buf_size ? *pIn_buf_size : 0;
    d->m_out_buf_ofs = 0;
    d->m_flush = flush;

    if (((d->m_pPut_buf_func != NULL) == ((pOut_buf != NULL) || (pOut_buf_size != NULL))) || (d->m_prev_return_status != TDEFL_STATUS_OKAY) ||
        (d->m_wants_to_finish && (flush != TDEFL_FINISH)) || (pIn_buf_size && *pIn_buf_size && !pIn_buf) || (pOut_buf_size && *pOut_buf_size && !pOut_buf))
    {
        if (pIn_buf_size)
            *pIn_buf_size = 0;
        if (pOut_buf_size)
            *pOut_buf_size = 0;
        return (d->m_prev_return_status = TDEFL_STATUS_BAD_PARAM);
    }
    d->m_wants_to_finish |= (flush == TDEFL_FINISH);

    if ((d->m_output_flush_remaining) || (d->m_finished))
        return (d->m_prev_return_status = tdefl_flush_output_buffer(d));

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
    if (((d->m_flags & TDEFL_MAX_PROBES_MASK) == 1) &&
        ((d->m_flags & TDEFL_GREEDY_PARSING_FLAG) != 0) &&
        ((d->m_flags & (TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS | TDEFL_RLE_MATCHES)) == 0))
    {
        if (!tdefl_compress_fast(d))
            return d->m_prev_return_status;
    }
    else
#endif /* #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN */
    {
        if (!tdefl_compress_normal(d))
            return d->m_prev_return_status;
    }

    if ((d->m_flags & (TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32)) && (pIn_buf))
        d->m_adler32 = (mz_uint32)mz_adler32(d->m_adler32, (const mz_uint8 *)pIn_buf, d->m_pSrc - (const mz_uint8 *)pIn_buf);

    if ((flush) && (!d->m_lookahead_size) && (!d->m_src_buf_left) && (!d->m_output_flush_remaining))
    {
        if (tdefl_flush_block(d, flush) < 0)
            return d->m_prev_return_status;
        d->m_finished = (flush == TDEFL_FINISH);
        if (flush == TDEFL_FULL_FLUSH)
        {
            MZ_CLEAR_ARR(d->m_hash);
            MZ_CLEAR_ARR(d->m_next);
            d->m_dict_size = 0;
        }
    }

    return (d->m_prev_return_status = tdefl_flush_output_buffer(d));
}

tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush)
{
    MZ_ASSERT(d->m_pPut_buf_func);
    return tdefl_compress(d, pIn_buf, &in_buf_size, NULL, NULL, flush);
}

tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
{
    d->m_pPut_buf_func = pPut_buf_func;
    d->m_pPut_buf_user = pPut_buf_user;
    d->m_flags = (mz_uint)(flags);
    d->m_max_probes[0] = 1 + ((flags & 0xFFF) + 2) / 3;
    d->m_greedy_parsing = (flags & TDEFL_GREEDY_PARSING_FLAG) != 0;
    d->m_max_probes[1] = 1 + (((flags & 0xFFF) >> 2) + 2) / 3;
    if (!(flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG))
        MZ_CLEAR_ARR(d->m_hash);
    d->m_lookahead_pos = d->m_lookahead_size = d->m_dict_size = d->m_total_lz_bytes = d->m_lz_code_buf_dict_pos = d->m_bits_in = 0;
    d->m_output_flush_ofs = d->m_output_flush_remaining = d->m_finished = d->m_block_index = d->m_bit_buffer = d->m_wants_to_finish = 0;
    d->m_pLZ_code_buf = d->m_lz_code_buf + 1;
    d->m_pLZ_flags = d->m_lz_code_buf;
    *d->m_pLZ_flags = 0;
    d->m_num_flags_left = 8;
    d->m_pOutput_buf = d->m_output_buf;
    d->m_pOutput_buf_end = d->m_output_buf;
    d->m_prev_return_status = TDEFL_STATUS_OKAY;
    d->m_saved_match_dist = d->m_saved_match_len = d->m_saved_lit = 0;
    d->m_adler32 = 1;
    d->m_pIn_buf = NULL;
    d->m_pOut_buf = NULL;
    d->m_pIn_buf_size = NULL;
    d->m_pOut_buf_size = NULL;
    d->m_flush = TDEFL_NO_FLUSH;
    d->m_pSrc = NULL;
    d->m_src_buf_left = 0;
    d->m_out_buf_ofs = 0;
    if (!(flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG))
        MZ_CLEAR_ARR(d->m_dict);
    memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
    memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);
    return TDEFL_STATUS_OKAY;
}

tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d)
{
    return d->m_prev_return_status;
}

mz_uint32 tdefl_get_adler32(tdefl_compressor *d)
{
    return d->m_adler32;
}

mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
{
    tdefl_compressor *pComp;
    mz_bool succeeded;
    if (((buf_len) && (!pBuf)) || (!pPut_buf_func))
        return MZ_FALSE;
    pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
    if (!pComp)
        return MZ_FALSE;
    succeeded = (tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags) == TDEFL_STATUS_OKAY);
    succeeded = succeeded && (tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH) == TDEFL_STATUS_DONE);
    MZ_FREE(pComp);
    return succeeded;
}

typedef struct
{
    size_t m_size, m_capacity;
    mz_uint8 *m_pBuf;
    mz_bool m_expandable;
} tdefl_output_buffer;

static mz_bool tdefl_output_buffer_putter(const void *pBuf, int len, void *pUser)
{
    tdefl_output_buffer *p = (tdefl_output_buffer *)pUser;
    size_t new_size = p->m_size + len;
    if (new_size > p->m_capacity)
    {
        size_t new_capacity = p->m_capacity;
        mz_uint8 *pNew_buf;
        if (!p->m_expandable)
            return MZ_FALSE;
        do
        {
            new_capacity = MZ_MAX(128U, new_capacity << 1U);
        } while (new_size > new_capacity);
        pNew_buf = (mz_uint8 *)MZ_REALLOC(p->m_pBuf, new_capacity);
        if (!pNew_buf)
            return MZ_FALSE;
        p->m_pBuf = pNew_buf;
        p->m_capacity = new_capacity;
    }
    memcpy((mz_uint8 *)p->m_pBuf + p->m_size, pBuf, len);
    p->m_size = new_size;
    return MZ_TRUE;
}

void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
{
    tdefl_output_buffer out_buf;
    MZ_CLEAR_OBJ(out_buf);
    if (!pOut_len)
        return MZ_FALSE;
    else
        *pOut_len = 0;
    out_buf.m_expandable = MZ_TRUE;
    if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))
        return NULL;
    *pOut_len = out_buf.m_size;
    return out_buf.m_pBuf;
}

size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)
{
    tdefl_output_buffer out_buf;
    MZ_CLEAR_OBJ(out_buf);
    if (!pOut_buf)
        return 0;
    out_buf.m_pBuf = (mz_uint8 *)pOut_buf;
    out_buf.m_capacity = out_buf_len;
    if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))
        return 0;
    return out_buf.m_size;
}

static const mz_uint s_tdefl_num_probes[11] = { 0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500 };

/* level may actually range from [0,10] (10 is a "hidden" max level, where we want a bit more compression and it's fine if throughput to fall off a cliff on some files). */
mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits, int strategy)
{
    mz_uint comp_flags = s_tdefl_num_probes[(level >= 0) ? MZ_MIN(10, level) : MZ_DEFAULT_LEVEL] | ((level <= 3) ? TDEFL_GREEDY_PARSING_FLAG : 0);
    if (window_bits > 0)
        comp_flags |= TDEFL_WRITE_ZLIB_HEADER;

    if (!level)
        comp_flags |= TDEFL_FORCE_ALL_RAW_BLOCKS;
    else if (strategy == MZ_FILTERED)
        comp_flags |= TDEFL_FILTER_MATCHES;
    else if (strategy == MZ_HUFFMAN_ONLY)
        comp_flags &= ~TDEFL_MAX_PROBES_MASK;
    else if (strategy == MZ_FIXED)
        comp_flags |= TDEFL_FORCE_ALL_STATIC_BLOCKS;
    else if (strategy == MZ_RLE)
        comp_flags |= TDEFL_RLE_MATCHES;

    return comp_flags;
}

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4204) /* nonstandard extension used : non-constant aggregate initializer (also supported by GNU C and C99, so no big deal) */
#endif

/* Simple PNG writer function by Alex Evans, 2011. Released into the public domain: https://gist.github.com/908299, more context at
 http://altdevblogaday.org/2011/04/06/a-smaller-jpg-encoder/.
 This is actually a modification of Alex's original code so PNG files generated by this function pass pngcheck. */
void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w, int h, int num_chans, size_t *pLen_out, mz_uint level, mz_bool flip)
{
    /* Using a local copy of this array here in case MINIZ_NO_ZLIB_APIS was defined. */
    static const mz_uint s_tdefl_png_num_probes[11] = { 0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500 };
    tdefl_compressor *pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
    tdefl_output_buffer out_buf;
    int i, bpl = w * num_chans, y, z;
    mz_uint32 c;
    *pLen_out = 0;
    if (!pComp)
        return NULL;
    MZ_CLEAR_OBJ(out_buf);
    out_buf.m_expandable = MZ_TRUE;
    out_buf.m_capacity = 57 + MZ_MAX(64, (1 + bpl) * h);
    if (NULL == (out_buf.m_pBuf = (mz_uint8 *)MZ_MALLOC(out_buf.m_capacity)))
    {
        MZ_FREE(pComp);
        return NULL;
    }
    /* write dummy header */
    for (z = 41; z; --z)
        tdefl_output_buffer_putter(&z, 1, &out_buf);
    /* compress image data */
    tdefl_init(pComp, tdefl_output_buffer_putter, &out_buf, s_tdefl_png_num_probes[MZ_MIN(10, level)] | TDEFL_WRITE_ZLIB_HEADER);
    for (y = 0; y < h; ++y)
    {
        tdefl_compress_buffer(pComp, &z, 1, TDEFL_NO_FLUSH);
        tdefl_compress_buffer(pComp, (mz_uint8 *)pImage + (flip ? (h - 1 - y) : y) * bpl, bpl, TDEFL_NO_FLUSH);
    }
    if (tdefl_compress_buffer(pComp, NULL, 0, TDEFL_FINISH) != TDEFL_STATUS_DONE)
    {
        MZ_FREE(pComp);
        MZ_FREE(out_buf.m_pBuf);
        return NULL;
    }
    /* write real header */
    *pLen_out = out_buf.m_size - 41;
    {
        static const mz_uint8 chans[] = { 0x00, 0x00, 0x04, 0x02, 0x06 };
        mz_uint8 pnghdr[41] = { 0x89, 0x50, 0x4e, 0x47, 0x0d,
                                0x0a, 0x1a, 0x0a, 0x00, 0x00,
                                0x00, 0x0d, 0x49, 0x48, 0x44,
                                0x52, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x08,
                                0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x49, 0x44, 0x41,
                                0x54 };
        pnghdr[18] = (mz_uint8)(w >> 8);
        pnghdr[19] = (mz_uint8)w;
        pnghdr[22] = (mz_uint8)(h >> 8);
        pnghdr[23] = (mz_uint8)h;
        pnghdr[25] = chans[num_chans];
        pnghdr[33] = (mz_uint8)(*pLen_out >> 24);
        pnghdr[34] = (mz_uint8)(*pLen_out >> 16);
        pnghdr[35] = (mz_uint8)(*pLen_out >> 8);
        pnghdr[36] = (mz_uint8)*pLen_out;
        c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, pnghdr + 12, 17);
        for (i = 0; i < 4; ++i, c <<= 8)
            ((mz_uint8 *)(pnghdr + 29))[i] = (mz_uint8)(c >> 24);
        memcpy(out_buf.m_pBuf, pnghdr, 41);
    }
    /* write footer (IDAT CRC-32, followed by IEND chunk) */
    if (!tdefl_output_buffer_putter("\0\0\0\0\0\0\0\0\x49\x45\x4e\x44\xae\x42\x60\x82", 16, &out_buf))
    {
        *pLen_out = 0;
        MZ_FREE(pComp);
        MZ_FREE(out_buf.m_pBuf);
        return NULL;
    }
    c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, out_buf.m_pBuf + 41 - 4, *pLen_out + 4);
    for (i = 0; i < 4; ++i, c <<= 8)
        (out_buf.m_pBuf + out_buf.m_size - 16)[i] = (mz_uint8)(c >> 24);
    /* compute final size of file, grab compressed data buffer and return */
    *pLen_out += 57;
    MZ_FREE(pComp);
    return out_buf.m_pBuf;
}
void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h, int num_chans, size_t *pLen_out)
{
    /* Level 6 corresponds to TDEFL_DEFAULT_MAX_PROBES or MZ_DEFAULT_LEVEL (but we can't depend on MZ_DEFAULT_LEVEL being available in case the zlib API's where #defined out) */
    return tdefl_write_image_to_png_file_in_memory_ex(pImage, w, h, num_chans, pLen_out, 6, MZ_FALSE);
}

#ifndef MINIZ_NO_MALLOC
/* Allocate the tdefl_compressor and tinfl_decompressor structures in C so that */
/* non-C language bindings to tdefL_ and tinfl_ API don't need to worry about */
/* structure size and allocation mechanism. */
tdefl_compressor *tdefl_compressor_alloc(void)
{
    return (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
}

void tdefl_compressor_free(tdefl_compressor *pComp)
{
    MZ_FREE(pComp);
}
#endif

#ifdef _MSC_VER
#pragma warning(pop)
#endif

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_DEFLATE_APIS*/
 /**************************************************************************
 *
 * Copyright 2013-2014 RAD Game Tools and Valve Software
 * Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 **************************************************************************/



#ifndef MINIZ_NO_INFLATE_APIS

#ifdef __cplusplus
extern "C" {
#endif

/* ------------------- Low-level Decompression (completely independent from all compression API's) */

#define TINFL_MEMCPY(d, s, l) memcpy(d, s, l)
#define TINFL_MEMSET(p, c, l) memset(p, c, l)

#define TINFL_CR_BEGIN  \
    switch (r->m_state) \
    {                   \
        case 0:
#define TINFL_CR_RETURN(state_index, result) \
    do                                       \
    {                                        \
        status = result;                     \
        r->m_state = state_index;            \
        goto common_exit;                    \
        case state_index:;                   \
    }                                        \
    MZ_MACRO_END
#define TINFL_CR_RETURN_FOREVER(state_index, result) \
    do                                               \
    {                                                \
        for (;;)                                     \
        {                                            \
            TINFL_CR_RETURN(state_index, result);    \
        }                                            \
    }                                                \
    MZ_MACRO_END
#define TINFL_CR_FINISH }

#define TINFL_GET_BYTE(state_index, c)                                                                                                                           \
    do                                                                                                                                                           \
    {                                                                                                                                                            \
        while (pIn_buf_cur >= pIn_buf_end)                                                                                                                       \
        {                                                                                                                                                        \
            TINFL_CR_RETURN(state_index, (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) ? TINFL_STATUS_NEEDS_MORE_INPUT : TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS); \
        }                                                                                                                                                        \
        c = *pIn_buf_cur++;                                                                                                                                      \
    }                                                                                                                                                            \
    MZ_MACRO_END

#define TINFL_NEED_BITS(state_index, n)                \
    do                                                 \
    {                                                  \
        mz_uint c;                                     \
        TINFL_GET_BYTE(state_index, c);                \
        bit_buf |= (((tinfl_bit_buf_t)c) << num_bits); \
        num_bits += 8;                                 \
    } while (num_bits < (mz_uint)(n))
#define TINFL_SKIP_BITS(state_index, n)      \
    do                                       \
    {                                        \
        if (num_bits < (mz_uint)(n))         \
        {                                    \
            TINFL_NEED_BITS(state_index, n); \
        }                                    \
        bit_buf >>= (n);                     \
        num_bits -= (n);                     \
    }                                        \
    MZ_MACRO_END
#define TINFL_GET_BITS(state_index, b, n)    \
    do                                       \
    {                                        \
        if (num_bits < (mz_uint)(n))         \
        {                                    \
            TINFL_NEED_BITS(state_index, n); \
        }                                    \
        b = bit_buf & ((1 << (n)) - 1);      \
        bit_buf >>= (n);                     \
        num_bits -= (n);                     \
    }                                        \
    MZ_MACRO_END

/* TINFL_HUFF_BITBUF_FILL() is only used rarely, when the number of bytes remaining in the input buffer falls below 2. */
/* It reads just enough bytes from the input stream that are needed to decode the next Huffman code (and absolutely no more). It works by trying to fully decode a */
/* Huffman code by using whatever bits are currently present in the bit buffer. If this fails, it reads another byte, and tries again until it succeeds or until the */
/* bit buffer contains >=15 bits (deflate's max. Huffman code size). */
#define TINFL_HUFF_BITBUF_FILL(state_index, pLookUp, pTree)                    \
    do                                                                         \
    {                                                                          \
        temp = pLookUp[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)];                \
        if (temp >= 0)                                                         \
        {                                                                      \
            code_len = temp >> 9;                                              \
            if ((code_len) && (num_bits >= code_len))                          \
                break;                                                         \
        }                                                                      \
        else if (num_bits > TINFL_FAST_LOOKUP_BITS)                            \
        {                                                                      \
            code_len = TINFL_FAST_LOOKUP_BITS;                                 \
            do                                                                 \
            {                                                                  \
                temp = pTree[~temp + ((bit_buf >> code_len++) & 1)];           \
            } while ((temp < 0) && (num_bits >= (code_len + 1)));              \
            if (temp >= 0)                                                     \
                break;                                                         \
        }                                                                      \
        TINFL_GET_BYTE(state_index, c);                                        \
        bit_buf |= (((tinfl_bit_buf_t)c) << num_bits);                         \
        num_bits += 8;                                                         \
    } while (num_bits < 15);

/* TINFL_HUFF_DECODE() decodes the next Huffman coded symbol. It's more complex than you would initially expect because the zlib API expects the decompressor to never read */
/* beyond the final byte of the deflate stream. (In other words, when this macro wants to read another byte from the input, it REALLY needs another byte in order to fully */
/* decode the next Huffman code.) Handling this properly is particularly important on raw deflate (non-zlib) streams, which aren't followed by a byte aligned adler-32. */
/* The slow path is only executed at the very end of the input buffer. */
/* v1.16: The original macro handled the case at the very end of the passed-in input buffer, but we also need to handle the case where the user passes in 1+zillion bytes */
/* following the deflate data and our non-conservative read-ahead path won't kick in here on this code. This is much trickier. */
#define TINFL_HUFF_DECODE(state_index, sym, pLookUp, pTree)                                                                         \
    do                                                                                                                              \
    {                                                                                                                               \
        int temp;                                                                                                                   \
        mz_uint code_len, c;                                                                                                        \
        if (num_bits < 15)                                                                                                          \
        {                                                                                                                           \
            if ((pIn_buf_end - pIn_buf_cur) < 2)                                                                                    \
            {                                                                                                                       \
                TINFL_HUFF_BITBUF_FILL(state_index, pLookUp, pTree);                                                                \
            }                                                                                                                       \
            else                                                                                                                    \
            {                                                                                                                       \
                bit_buf |= (((tinfl_bit_buf_t)pIn_buf_cur[0]) << num_bits) | (((tinfl_bit_buf_t)pIn_buf_cur[1]) << (num_bits + 8)); \
                pIn_buf_cur += 2;                                                                                                   \
                num_bits += 16;                                                                                                     \
            }                                                                                                                       \
        }                                                                                                                           \
        if ((temp = pLookUp[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)                                                          \
            code_len = temp >> 9, temp &= 511;                                                                                      \
        else                                                                                                                        \
        {                                                                                                                           \
            code_len = TINFL_FAST_LOOKUP_BITS;                                                                                      \
            do                                                                                                                      \
            {                                                                                                                       \
                temp = pTree[~temp + ((bit_buf >> code_len++) & 1)];                                                                \
            } while (temp < 0);                                                                                                     \
        }                                                                                                                           \
        sym = temp;                                                                                                                 \
        bit_buf >>= code_len;                                                                                                       \
        num_bits -= code_len;                                                                                                       \
    }                                                                                                                               \
    MZ_MACRO_END

static void tinfl_clear_tree(tinfl_decompressor *r)
{
    if (r->m_type == 0)
        MZ_CLEAR_ARR(r->m_tree_0);
    else if (r->m_type == 1)
        MZ_CLEAR_ARR(r->m_tree_1);
    else
        MZ_CLEAR_ARR(r->m_tree_2);
}

tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags)
{
    static const mz_uint16 s_length_base[31] = { 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 };
    static const mz_uint8 s_length_extra[31] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0 };
    static const mz_uint16 s_dist_base[32] = { 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0 };
    static const mz_uint8 s_dist_extra[32] = { 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 };
    static const mz_uint8 s_length_dezigzag[19] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };
    static const mz_uint16 s_min_table_sizes[3] = { 257, 1, 4 };

    mz_int16 *pTrees[3];
    mz_uint8 *pCode_sizes[3];

    tinfl_status status = TINFL_STATUS_FAILED;
    mz_uint32 num_bits, dist, counter, num_extra;
    tinfl_bit_buf_t bit_buf;
    const mz_uint8 *pIn_buf_cur = pIn_buf_next, *const pIn_buf_end = pIn_buf_next + *pIn_buf_size;
    mz_uint8 *pOut_buf_cur = pOut_buf_next, *const pOut_buf_end = pOut_buf_next ? pOut_buf_next + *pOut_buf_size : NULL;
    size_t out_buf_size_mask = (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF) ? (size_t)-1 : ((pOut_buf_next - pOut_buf_start) + *pOut_buf_size) - 1, dist_from_out_buf_start;

    /* Ensure the output buffer's size is a power of 2, unless the output buffer is large enough to hold the entire output file (in which case it doesn't matter). */
    if (((out_buf_size_mask + 1) & out_buf_size_mask) || (pOut_buf_next < pOut_buf_start))
    {
        *pIn_buf_size = *pOut_buf_size = 0;
        return TINFL_STATUS_BAD_PARAM;
    }

    pTrees[0] = r->m_tree_0;
    pTrees[1] = r->m_tree_1;
    pTrees[2] = r->m_tree_2;
    pCode_sizes[0] = r->m_code_size_0;
    pCode_sizes[1] = r->m_code_size_1;
    pCode_sizes[2] = r->m_code_size_2;

    num_bits = r->m_num_bits;
    bit_buf = r->m_bit_buf;
    dist = r->m_dist;
    counter = r->m_counter;
    num_extra = r->m_num_extra;
    dist_from_out_buf_start = r->m_dist_from_out_buf_start;
    TINFL_CR_BEGIN

    bit_buf = num_bits = dist = counter = num_extra = r->m_zhdr0 = r->m_zhdr1 = 0;
    r->m_z_adler32 = r->m_check_adler32 = 1;
    if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER)
    {
        TINFL_GET_BYTE(1, r->m_zhdr0);
        TINFL_GET_BYTE(2, r->m_zhdr1);
        counter = (((r->m_zhdr0 * 256 + r->m_zhdr1) % 31 != 0) || (r->m_zhdr1 & 32) || ((r->m_zhdr0 & 15) != 8));
        if (!(decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))
            counter |= (((1U << (8U + (r->m_zhdr0 >> 4))) > 32768U) || ((out_buf_size_mask + 1) < (size_t)((size_t)1 << (8U + (r->m_zhdr0 >> 4)))));
        if (counter)
        {
            TINFL_CR_RETURN_FOREVER(36, TINFL_STATUS_FAILED);
        }
    }

    do
    {
        TINFL_GET_BITS(3, r->m_final, 3);
        r->m_type = r->m_final >> 1;
        if (r->m_type == 0)
        {
            TINFL_SKIP_BITS(5, num_bits & 7);
            for (counter = 0; counter < 4; ++counter)
            {
                if (num_bits)
                    TINFL_GET_BITS(6, r->m_raw_header[counter], 8);
                else
                    TINFL_GET_BYTE(7, r->m_raw_header[counter]);
            }
            if ((counter = (r->m_raw_header[0] | (r->m_raw_header[1] << 8))) != (mz_uint)(0xFFFF ^ (r->m_raw_header[2] | (r->m_raw_header[3] << 8))))
            {
                TINFL_CR_RETURN_FOREVER(39, TINFL_STATUS_FAILED);
            }
            while ((counter) && (num_bits))
            {
                TINFL_GET_BITS(51, dist, 8);
                while (pOut_buf_cur >= pOut_buf_end)
                {
                    TINFL_CR_RETURN(52, TINFL_STATUS_HAS_MORE_OUTPUT);
                }
                *pOut_buf_cur++ = (mz_uint8)dist;
                counter--;
            }
            while (counter)
            {
                size_t n;
                while (pOut_buf_cur >= pOut_buf_end)
                {
                    TINFL_CR_RETURN(9, TINFL_STATUS_HAS_MORE_OUTPUT);
                }
                while (pIn_buf_cur >= pIn_buf_end)
                {
                    TINFL_CR_RETURN(38, (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) ? TINFL_STATUS_NEEDS_MORE_INPUT : TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS);
                }
                n = MZ_MIN(MZ_MIN((size_t)(pOut_buf_end - pOut_buf_cur), (size_t)(pIn_buf_end - pIn_buf_cur)), counter);
                TINFL_MEMCPY(pOut_buf_cur, pIn_buf_cur, n);
                pIn_buf_cur += n;
                pOut_buf_cur += n;
                counter -= (mz_uint)n;
            }
        }
        else if (r->m_type == 3)
        {
            TINFL_CR_RETURN_FOREVER(10, TINFL_STATUS_FAILED);
        }
        else
        {
            if (r->m_type == 1)
            {
                mz_uint8 *p = r->m_code_size_0;
                mz_uint i;
                r->m_table_sizes[0] = 288;
                r->m_table_sizes[1] = 32;
                TINFL_MEMSET(r->m_code_size_1, 5, 32);
                for (i = 0; i <= 143; ++i)
                    *p++ = 8;
                for (; i <= 255; ++i)
                    *p++ = 9;
                for (; i <= 279; ++i)
                    *p++ = 7;
                for (; i <= 287; ++i)
                    *p++ = 8;
            }
            else
            {
                for (counter = 0; counter < 3; counter++)
                {
                    TINFL_GET_BITS(11, r->m_table_sizes[counter], "\05\05\04"[counter]);
                    r->m_table_sizes[counter] += s_min_table_sizes[counter];
                }
                MZ_CLEAR_ARR(r->m_code_size_2);
                for (counter = 0; counter < r->m_table_sizes[2]; counter++)
                {
                    mz_uint s;
                    TINFL_GET_BITS(14, s, 3);
                    r->m_code_size_2[s_length_dezigzag[counter]] = (mz_uint8)s;
                }
                r->m_table_sizes[2] = 19;
            }
            for (; (int)r->m_type >= 0; r->m_type--)
            {
                int tree_next, tree_cur;
                mz_int16 *pLookUp;
                mz_int16 *pTree;
                mz_uint8 *pCode_size;
                mz_uint i, j, used_syms, total, sym_index, next_code[17], total_syms[16];
                pLookUp = r->m_look_up[r->m_type];
                pTree = pTrees[r->m_type];
                pCode_size = pCode_sizes[r->m_type];
                MZ_CLEAR_ARR(total_syms);
                TINFL_MEMSET(pLookUp, 0, sizeof(r->m_look_up[0]));
                tinfl_clear_tree(r);
                for (i = 0; i < r->m_table_sizes[r->m_type]; ++i)
                    total_syms[pCode_size[i]]++;
                used_syms = 0, total = 0;
                next_code[0] = next_code[1] = 0;
                for (i = 1; i <= 15; ++i)
                {
                    used_syms += total_syms[i];
                    next_code[i + 1] = (total = ((total + total_syms[i]) << 1));
                }
                if ((65536 != total) && (used_syms > 1))
                {
                    TINFL_CR_RETURN_FOREVER(35, TINFL_STATUS_FAILED);
                }
                for (tree_next = -1, sym_index = 0; sym_index < r->m_table_sizes[r->m_type]; ++sym_index)
                {
                    mz_uint rev_code = 0, l, cur_code, code_size = pCode_size[sym_index];
                    if (!code_size)
                        continue;
                    cur_code = next_code[code_size]++;
                    for (l = code_size; l > 0; l--, cur_code >>= 1)
                        rev_code = (rev_code << 1) | (cur_code & 1);
                    if (code_size <= TINFL_FAST_LOOKUP_BITS)
                    {
                        mz_int16 k = (mz_int16)((code_size << 9) | sym_index);
                        while (rev_code < TINFL_FAST_LOOKUP_SIZE)
                        {
                            pLookUp[rev_code] = k;
                            rev_code += (1 << code_size);
                        }
                        continue;
                    }
                    if (0 == (tree_cur = pLookUp[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)]))
                    {
                        pLookUp[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)] = (mz_int16)tree_next;
                        tree_cur = tree_next;
                        tree_next -= 2;
                    }
                    rev_code >>= (TINFL_FAST_LOOKUP_BITS - 1);
                    for (j = code_size; j > (TINFL_FAST_LOOKUP_BITS + 1); j--)
                    {
                        tree_cur -= ((rev_code >>= 1) & 1);
                        if (!pTree[-tree_cur - 1])
                        {
                            pTree[-tree_cur - 1] = (mz_int16)tree_next;
                            tree_cur = tree_next;
                            tree_next -= 2;
                        }
                        else
                            tree_cur = pTree[-tree_cur - 1];
                    }
                    tree_cur -= ((rev_code >>= 1) & 1);
                    pTree[-tree_cur - 1] = (mz_int16)sym_index;
                }
                if (r->m_type == 2)
                {
                    for (counter = 0; counter < (r->m_table_sizes[0] + r->m_table_sizes[1]);)
                    {
                        mz_uint s;
                        TINFL_HUFF_DECODE(16, dist, r->m_look_up[2], r->m_tree_2);
                        if (dist < 16)
                        {
                            r->m_len_codes[counter++] = (mz_uint8)dist;
                            continue;
                        }
                        if ((dist == 16) && (!counter))
                        {
                            TINFL_CR_RETURN_FOREVER(17, TINFL_STATUS_FAILED);
                        }
                        num_extra = "\02\03\07"[dist - 16];
                        TINFL_GET_BITS(18, s, num_extra);
                        s += "\03\03\013"[dist - 16];
                        TINFL_MEMSET(r->m_len_codes + counter, (dist == 16) ? r->m_len_codes[counter - 1] : 0, s);
                        counter += s;
                    }
                    if ((r->m_table_sizes[0] + r->m_table_sizes[1]) != counter)
                    {
                        TINFL_CR_RETURN_FOREVER(21, TINFL_STATUS_FAILED);
                    }
                    TINFL_MEMCPY(r->m_code_size_0, r->m_len_codes, r->m_table_sizes[0]);
                    TINFL_MEMCPY(r->m_code_size_1, r->m_len_codes + r->m_table_sizes[0], r->m_table_sizes[1]);
                }
            }
            for (;;)
            {
                mz_uint8 *pSrc;
                for (;;)
                {
                    if (((pIn_buf_end - pIn_buf_cur) < 4) || ((pOut_buf_end - pOut_buf_cur) < 2))
                    {
                        TINFL_HUFF_DECODE(23, counter, r->m_look_up[0], r->m_tree_0);
                        if (counter >= 256)
                            break;
                        while (pOut_buf_cur >= pOut_buf_end)
                        {
                            TINFL_CR_RETURN(24, TINFL_STATUS_HAS_MORE_OUTPUT);
                        }
                        *pOut_buf_cur++ = (mz_uint8)counter;
                    }
                    else
                    {
                        int sym2;
                        mz_uint code_len;
#if TINFL_USE_64BIT_BITBUF
                        if (num_bits < 30)
                        {
                            bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE32(pIn_buf_cur)) << num_bits);
                            pIn_buf_cur += 4;
                            num_bits += 32;
                        }
#else
                        if (num_bits < 15)
                        {
                            bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits);
                            pIn_buf_cur += 2;
                            num_bits += 16;
                        }
#endif
                        if ((sym2 = r->m_look_up[0][bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)
                            code_len = sym2 >> 9;
                        else
                        {
                            code_len = TINFL_FAST_LOOKUP_BITS;
                            do
                            {
                                sym2 = r->m_tree_0[~sym2 + ((bit_buf >> code_len++) & 1)];
                            } while (sym2 < 0);
                        }
                        counter = sym2;
                        bit_buf >>= code_len;
                        num_bits -= code_len;
                        if (counter & 256)
                            break;

#if !TINFL_USE_64BIT_BITBUF
                        if (num_bits < 15)
                        {
                            bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits);
                            pIn_buf_cur += 2;
                            num_bits += 16;
                        }
#endif
                        if ((sym2 = r->m_look_up[0][bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)
                            code_len = sym2 >> 9;
                        else
                        {
                            code_len = TINFL_FAST_LOOKUP_BITS;
                            do
                            {
                                sym2 = r->m_tree_0[~sym2 + ((bit_buf >> code_len++) & 1)];
                            } while (sym2 < 0);
                        }
                        bit_buf >>= code_len;
                        num_bits -= code_len;

                        pOut_buf_cur[0] = (mz_uint8)counter;
                        if (sym2 & 256)
                        {
                            pOut_buf_cur++;
                            counter = sym2;
                            break;
                        }
                        pOut_buf_cur[1] = (mz_uint8)sym2;
                        pOut_buf_cur += 2;
                    }
                }
                if ((counter &= 511) == 256)
                    break;

                num_extra = s_length_extra[counter - 257];
                counter = s_length_base[counter - 257];
                if (num_extra)
                {
                    mz_uint extra_bits;
                    TINFL_GET_BITS(25, extra_bits, num_extra);
                    counter += extra_bits;
                }

                TINFL_HUFF_DECODE(26, dist, r->m_look_up[1], r->m_tree_1);
                num_extra = s_dist_extra[dist];
                dist = s_dist_base[dist];
                if (num_extra)
                {
                    mz_uint extra_bits;
                    TINFL_GET_BITS(27, extra_bits, num_extra);
                    dist += extra_bits;
                }

                dist_from_out_buf_start = pOut_buf_cur - pOut_buf_start;
                if ((dist == 0 || dist > dist_from_out_buf_start || dist_from_out_buf_start == 0) && (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))
                {
                    TINFL_CR_RETURN_FOREVER(37, TINFL_STATUS_FAILED);
                }

                pSrc = pOut_buf_start + ((dist_from_out_buf_start - dist) & out_buf_size_mask);

                if ((MZ_MAX(pOut_buf_cur, pSrc) + counter) > pOut_buf_end)
                {
                    while (counter--)
                    {
                        while (pOut_buf_cur >= pOut_buf_end)
                        {
                            TINFL_CR_RETURN(53, TINFL_STATUS_HAS_MORE_OUTPUT);
                        }
                        *pOut_buf_cur++ = pOut_buf_start[(dist_from_out_buf_start++ - dist) & out_buf_size_mask];
                    }
                    continue;
                }
#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
                else if ((counter >= 9) && (counter <= dist))
                {
                    const mz_uint8 *pSrc_end = pSrc + (counter & ~7);
                    do
                    {
#ifdef MINIZ_UNALIGNED_USE_MEMCPY
						memcpy(pOut_buf_cur, pSrc, sizeof(mz_uint32)*2);
#else
                        ((mz_uint32 *)pOut_buf_cur)[0] = ((const mz_uint32 *)pSrc)[0];
                        ((mz_uint32 *)pOut_buf_cur)[1] = ((const mz_uint32 *)pSrc)[1];
#endif
                        pOut_buf_cur += 8;
                    } while ((pSrc += 8) < pSrc_end);
                    if ((counter &= 7) < 3)
                    {
                        if (counter)
                        {
                            pOut_buf_cur[0] = pSrc[0];
                            if (counter > 1)
                                pOut_buf_cur[1] = pSrc[1];
                            pOut_buf_cur += counter;
                        }
                        continue;
                    }
                }
#endif
                while(counter>2)
                {
                    pOut_buf_cur[0] = pSrc[0];
                    pOut_buf_cur[1] = pSrc[1];
                    pOut_buf_cur[2] = pSrc[2];
                    pOut_buf_cur += 3;
                    pSrc += 3;
					counter -= 3;
                }
                if (counter > 0)
                {
                    pOut_buf_cur[0] = pSrc[0];
                    if (counter > 1)
                        pOut_buf_cur[1] = pSrc[1];
                    pOut_buf_cur += counter;
                }
            }
        }
    } while (!(r->m_final & 1));

    /* Ensure byte alignment and put back any bytes from the bitbuf if we've looked ahead too far on gzip, or other Deflate streams followed by arbitrary data. */
    /* I'm being super conservative here. A number of simplifications can be made to the byte alignment part, and the Adler32 check shouldn't ever need to worry about reading from the bitbuf now. */
    TINFL_SKIP_BITS(32, num_bits & 7);
    while ((pIn_buf_cur > pIn_buf_next) && (num_bits >= 8))
    {
        --pIn_buf_cur;
        num_bits -= 8;
    }
    bit_buf &= ~(~(tinfl_bit_buf_t)0 << num_bits);
    MZ_ASSERT(!num_bits); /* if this assert fires then we've read beyond the end of non-deflate/zlib streams with following data (such as gzip streams). */

    if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER)
    {
        for (counter = 0; counter < 4; ++counter)
        {
            mz_uint s;
            if (num_bits)
                TINFL_GET_BITS(41, s, 8);
            else
                TINFL_GET_BYTE(42, s);
            r->m_z_adler32 = (r->m_z_adler32 << 8) | s;
        }
    }
    TINFL_CR_RETURN_FOREVER(34, TINFL_STATUS_DONE);

    TINFL_CR_FINISH

common_exit:
    /* As long as we aren't telling the caller that we NEED more input to make forward progress: */
    /* Put back any bytes from the bitbuf in case we've looked ahead too far on gzip, or other Deflate streams followed by arbitrary data. */
    /* We need to be very careful here to NOT push back any bytes we definitely know we need to make forward progress, though, or we'll lock the caller up into an inf loop. */
    if ((status != TINFL_STATUS_NEEDS_MORE_INPUT) && (status != TINFL_STATUS_FAILED_CANNOT_MAKE_PROGRESS))
    {
        while ((pIn_buf_cur > pIn_buf_next) && (num_bits >= 8))
        {
            --pIn_buf_cur;
            num_bits -= 8;
        }
    }
    r->m_num_bits = num_bits;
    r->m_bit_buf = bit_buf & ~(~(tinfl_bit_buf_t)0 << num_bits);
    r->m_dist = dist;
    r->m_counter = counter;
    r->m_num_extra = num_extra;
    r->m_dist_from_out_buf_start = dist_from_out_buf_start;
    *pIn_buf_size = pIn_buf_cur - pIn_buf_next;
    *pOut_buf_size = pOut_buf_cur - pOut_buf_next;
    if ((decomp_flags & (TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32)) && (status >= 0))
    {
        const mz_uint8 *ptr = pOut_buf_next;
        size_t buf_len = *pOut_buf_size;
        mz_uint32 i, s1 = r->m_check_adler32 & 0xffff, s2 = r->m_check_adler32 >> 16;
        size_t block_len = buf_len % 5552;
        while (buf_len)
        {
            for (i = 0; i + 7 < block_len; i += 8, ptr += 8)
            {
                s1 += ptr[0], s2 += s1;
                s1 += ptr[1], s2 += s1;
                s1 += ptr[2], s2 += s1;
                s1 += ptr[3], s2 += s1;
                s1 += ptr[4], s2 += s1;
                s1 += ptr[5], s2 += s1;
                s1 += ptr[6], s2 += s1;
                s1 += ptr[7], s2 += s1;
            }
            for (; i < block_len; ++i)
                s1 += *ptr++, s2 += s1;
            s1 %= 65521U, s2 %= 65521U;
            buf_len -= block_len;
            block_len = 5552;
        }
        r->m_check_adler32 = (s2 << 16) + s1;
        if ((status == TINFL_STATUS_DONE) && (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) && (r->m_check_adler32 != r->m_z_adler32))
            status = TINFL_STATUS_ADLER32_MISMATCH;
    }
    return status;
}

/* Higher level helper functions. */
void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)
{
    tinfl_decompressor decomp;
    void *pBuf = NULL, *pNew_buf;
    size_t src_buf_ofs = 0, out_buf_capacity = 0;
    *pOut_len = 0;
    tinfl_init(&decomp);
    for (;;)
    {
        size_t src_buf_size = src_buf_len - src_buf_ofs, dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity;
        tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8 *)pSrc_buf + src_buf_ofs, &src_buf_size, (mz_uint8 *)pBuf, pBuf ? (mz_uint8 *)pBuf + *pOut_len : NULL, &dst_buf_size,
                                               (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
        if ((status < 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT))
        {
            MZ_FREE(pBuf);
            *pOut_len = 0;
            return NULL;
        }
        src_buf_ofs += src_buf_size;
        *pOut_len += dst_buf_size;
        if (status == TINFL_STATUS_DONE)
            break;
        new_out_buf_capacity = out_buf_capacity * 2;
        if (new_out_buf_capacity < 128)
            new_out_buf_capacity = 128;
        pNew_buf = MZ_REALLOC(pBuf, new_out_buf_capacity);
        if (!pNew_buf)
        {
            MZ_FREE(pBuf);
            *pOut_len = 0;
            return NULL;
        }
        pBuf = pNew_buf;
        out_buf_capacity = new_out_buf_capacity;
    }
    return pBuf;
}

size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)
{
    tinfl_decompressor decomp;
    tinfl_status status;
    tinfl_init(&decomp);
    status = tinfl_decompress(&decomp, (const mz_uint8 *)pSrc_buf, &src_buf_len, (mz_uint8 *)pOut_buf, (mz_uint8 *)pOut_buf, &out_buf_len, (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
    return (status != TINFL_STATUS_DONE) ? TINFL_DECOMPRESS_MEM_TO_MEM_FAILED : out_buf_len;
}

int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)
{
    int result = 0;
    tinfl_decompressor decomp;
    mz_uint8 *pDict = (mz_uint8 *)MZ_MALLOC(TINFL_LZ_DICT_SIZE);
    size_t in_buf_ofs = 0, dict_ofs = 0;
    if (!pDict)
        return TINFL_STATUS_FAILED;
    memset(pDict,0,TINFL_LZ_DICT_SIZE);
    tinfl_init(&decomp);
    for (;;)
    {
        size_t in_buf_size = *pIn_buf_size - in_buf_ofs, dst_buf_size = TINFL_LZ_DICT_SIZE - dict_ofs;
        tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8 *)pIn_buf + in_buf_ofs, &in_buf_size, pDict, pDict + dict_ofs, &dst_buf_size,
                                               (flags & ~(TINFL_FLAG_HAS_MORE_INPUT | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));
        in_buf_ofs += in_buf_size;
        if ((dst_buf_size) && (!(*pPut_buf_func)(pDict + dict_ofs, (int)dst_buf_size, pPut_buf_user)))
            break;
        if (status != TINFL_STATUS_HAS_MORE_OUTPUT)
        {
            result = (status == TINFL_STATUS_DONE);
            break;
        }
        dict_ofs = (dict_ofs + dst_buf_size) & (TINFL_LZ_DICT_SIZE - 1);
    }
    MZ_FREE(pDict);
    *pIn_buf_size = in_buf_ofs;
    return result;
}

#ifndef MINIZ_NO_MALLOC
tinfl_decompressor *tinfl_decompressor_alloc(void)
{
    tinfl_decompressor *pDecomp = (tinfl_decompressor *)MZ_MALLOC(sizeof(tinfl_decompressor));
    if (pDecomp)
        tinfl_init(pDecomp);
    return pDecomp;
}

void tinfl_decompressor_free(tinfl_decompressor *pDecomp)
{
    MZ_FREE(pDecomp);
}
#endif

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_INFLATE_APIS*/
 /**************************************************************************
 *
 * Copyright 2013-2014 RAD Game Tools and Valve Software
 * Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
 * Copyright 2016 Martin Raiber
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 **************************************************************************/


#ifndef MINIZ_NO_ARCHIVE_APIS

#ifdef __cplusplus
extern "C" {
#endif

/* ------------------- .ZIP archive reading */

#ifdef MINIZ_NO_STDIO
#define MZ_FILE void *
#else
#include <sys/stat.h>

#if defined(_MSC_VER) || defined(__MINGW64__)

#define WIN32_LEAN_AND_MEAN
#include <windows.h>

static WCHAR* mz_utf8z_to_widechar(const char* str)
{
  int reqChars = MultiByteToWideChar(CP_UTF8, 0, str, -1, NULL, 0);
  WCHAR* wStr = (WCHAR*)malloc(reqChars * sizeof(WCHAR));
  MultiByteToWideChar(CP_UTF8, 0, str, -1, wStr, sizeof(WCHAR) * reqChars);
  return wStr;
}

static FILE *mz_fopen(const char *pFilename, const char *pMode)
{
  WCHAR* wFilename = mz_utf8z_to_widechar(pFilename);
  WCHAR* wMode = mz_utf8z_to_widechar(pMode);
  FILE* pFile = NULL;
  errno_t err = _wfopen_s(&pFile, wFilename, wMode);
  free(wFilename);
  free(wMode);
  return err ? NULL : pFile;
}

static FILE *mz_freopen(const char *pPath, const char *pMode, FILE *pStream)
{
  WCHAR* wPath = mz_utf8z_to_widechar(pPath);
  WCHAR* wMode = mz_utf8z_to_widechar(pMode);
  FILE* pFile = NULL;
  errno_t err = _wfreopen_s(&pFile, wPath, wMode, pStream);
  free(wPath);
  free(wMode);
  return err ? NULL : pFile;
}

static int mz_stat64(const char *path, struct __stat64 *buffer)
{
  WCHAR* wPath = mz_utf8z_to_widechar(path);
  int res = _wstat64(wPath, buffer);
  free(wPath);
  return res;
}

#ifndef MINIZ_NO_TIME
#include <sys/utime.h>
#endif
#define MZ_FOPEN mz_fopen
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 _ftelli64
#define MZ_FSEEK64 _fseeki64
#define MZ_FILE_STAT_STRUCT _stat64
#define MZ_FILE_STAT mz_stat64
#define MZ_FFLUSH fflush
#define MZ_FREOPEN mz_freopen
#define MZ_DELETE_FILE remove

#elif defined(__MINGW32__) || defined(__WATCOMC__)
#ifndef MINIZ_NO_TIME
#include <sys/utime.h>
#endif
#define MZ_FOPEN(f, m) fopen(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 _ftelli64
#define MZ_FSEEK64 _fseeki64
#define MZ_FILE_STAT_STRUCT stat
#define MZ_FILE_STAT stat
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
#define MZ_DELETE_FILE remove

#elif defined(__TINYC__)
#ifndef MINIZ_NO_TIME
#include <sys/utime.h>
#endif
#define MZ_FOPEN(f, m) fopen(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 ftell
#define MZ_FSEEK64 fseek
#define MZ_FILE_STAT_STRUCT stat
#define MZ_FILE_STAT stat
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
#define MZ_DELETE_FILE remove

#elif defined(__USE_LARGEFILE64) /* gcc, clang */
#ifndef MINIZ_NO_TIME
#include <utime.h>
#endif
#define MZ_FOPEN(f, m) fopen64(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 ftello64
#define MZ_FSEEK64 fseeko64
#define MZ_FILE_STAT_STRUCT stat64
#define MZ_FILE_STAT stat64
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(p, m, s) freopen64(p, m, s)
#define MZ_DELETE_FILE remove

#elif defined(__APPLE__) || defined(__FreeBSD__)
#ifndef MINIZ_NO_TIME
#include <utime.h>
#endif
#define MZ_FOPEN(f, m) fopen(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 ftello
#define MZ_FSEEK64 fseeko
#define MZ_FILE_STAT_STRUCT stat
#define MZ_FILE_STAT stat
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(p, m, s) freopen(p, m, s)
#define MZ_DELETE_FILE remove

#else
// #pragma message("Using fopen, ftello, fseeko, stat() etc. path for file I/O - this path may not support large files.")
#ifndef MINIZ_NO_TIME
#include <utime.h>
#endif
#define MZ_FOPEN(f, m) fopen(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#ifdef __STRICT_ANSI__
#define MZ_FTELL64 ftell
#define MZ_FSEEK64 fseek
#else
#define MZ_FTELL64 ftello
#define MZ_FSEEK64 fseeko
#endif
#define MZ_FILE_STAT_STRUCT stat
#define MZ_FILE_STAT stat
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
#define MZ_DELETE_FILE remove
#endif /* #ifdef _MSC_VER */
#endif /* #ifdef MINIZ_NO_STDIO */

#define MZ_TOLOWER(c) ((((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c))

/* Various ZIP archive enums. To completely avoid cross platform compiler alignment and platform endian issues, miniz.c doesn't use structs for any of this stuff. */
enum
{
    /* ZIP archive identifiers and record sizes */
    MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06054b50,
    MZ_ZIP_CENTRAL_DIR_HEADER_SIG = 0x02014b50,
    MZ_ZIP_LOCAL_DIR_HEADER_SIG = 0x04034b50,
    MZ_ZIP_LOCAL_DIR_HEADER_SIZE = 30,
    MZ_ZIP_CENTRAL_DIR_HEADER_SIZE = 46,
    MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE = 22,

    /* ZIP64 archive identifier and record sizes */
    MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06064b50,
    MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG = 0x07064b50,
    MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE = 56,
    MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE = 20,
    MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID = 0x0001,
    MZ_ZIP_DATA_DESCRIPTOR_ID = 0x08074b50,
    MZ_ZIP_DATA_DESCRIPTER_SIZE64 = 24,
    MZ_ZIP_DATA_DESCRIPTER_SIZE32 = 16,

    /* Central directory header record offsets */
    MZ_ZIP_CDH_SIG_OFS = 0,
    MZ_ZIP_CDH_VERSION_MADE_BY_OFS = 4,
    MZ_ZIP_CDH_VERSION_NEEDED_OFS = 6,
    MZ_ZIP_CDH_BIT_FLAG_OFS = 8,
    MZ_ZIP_CDH_METHOD_OFS = 10,
    MZ_ZIP_CDH_FILE_TIME_OFS = 12,
    MZ_ZIP_CDH_FILE_DATE_OFS = 14,
    MZ_ZIP_CDH_CRC32_OFS = 16,
    MZ_ZIP_CDH_COMPRESSED_SIZE_OFS = 20,
    MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS = 24,
    MZ_ZIP_CDH_FILENAME_LEN_OFS = 28,
    MZ_ZIP_CDH_EXTRA_LEN_OFS = 30,
    MZ_ZIP_CDH_COMMENT_LEN_OFS = 32,
    MZ_ZIP_CDH_DISK_START_OFS = 34,
    MZ_ZIP_CDH_INTERNAL_ATTR_OFS = 36,
    MZ_ZIP_CDH_EXTERNAL_ATTR_OFS = 38,
    MZ_ZIP_CDH_LOCAL_HEADER_OFS = 42,

    /* Local directory header offsets */
    MZ_ZIP_LDH_SIG_OFS = 0,
    MZ_ZIP_LDH_VERSION_NEEDED_OFS = 4,
    MZ_ZIP_LDH_BIT_FLAG_OFS = 6,
    MZ_ZIP_LDH_METHOD_OFS = 8,
    MZ_ZIP_LDH_FILE_TIME_OFS = 10,
    MZ_ZIP_LDH_FILE_DATE_OFS = 12,
    MZ_ZIP_LDH_CRC32_OFS = 14,
    MZ_ZIP_LDH_COMPRESSED_SIZE_OFS = 18,
    MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS = 22,
    MZ_ZIP_LDH_FILENAME_LEN_OFS = 26,
    MZ_ZIP_LDH_EXTRA_LEN_OFS = 28,
    MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR = 1 << 3,

    /* End of central directory offsets */
    MZ_ZIP_ECDH_SIG_OFS = 0,
    MZ_ZIP_ECDH_NUM_THIS_DISK_OFS = 4,
    MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS = 6,
    MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 8,
    MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS = 10,
    MZ_ZIP_ECDH_CDIR_SIZE_OFS = 12,
    MZ_ZIP_ECDH_CDIR_OFS_OFS = 16,
    MZ_ZIP_ECDH_COMMENT_SIZE_OFS = 20,

    /* ZIP64 End of central directory locator offsets */
    MZ_ZIP64_ECDL_SIG_OFS = 0,                    /* 4 bytes */
    MZ_ZIP64_ECDL_NUM_DISK_CDIR_OFS = 4,          /* 4 bytes */
    MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS = 8,  /* 8 bytes */
    MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS = 16, /* 4 bytes */

    /* ZIP64 End of central directory header offsets */
    MZ_ZIP64_ECDH_SIG_OFS = 0,                       /* 4 bytes */
    MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS = 4,            /* 8 bytes */
    MZ_ZIP64_ECDH_VERSION_MADE_BY_OFS = 12,          /* 2 bytes */
    MZ_ZIP64_ECDH_VERSION_NEEDED_OFS = 14,           /* 2 bytes */
    MZ_ZIP64_ECDH_NUM_THIS_DISK_OFS = 16,            /* 4 bytes */
    MZ_ZIP64_ECDH_NUM_DISK_CDIR_OFS = 20,            /* 4 bytes */
    MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 24, /* 8 bytes */
    MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS = 32,       /* 8 bytes */
    MZ_ZIP64_ECDH_CDIR_SIZE_OFS = 40,                /* 8 bytes */
    MZ_ZIP64_ECDH_CDIR_OFS_OFS = 48,                 /* 8 bytes */
    MZ_ZIP_VERSION_MADE_BY_DOS_FILESYSTEM_ID = 0,
    MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG = 0x10,
    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED = 1,
    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG = 32,
    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION = 64,
    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_LOCAL_DIR_IS_MASKED = 8192,
    MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8 = 1 << 11
};

typedef struct
{
    void *m_p;
    size_t m_size, m_capacity;
    mz_uint m_element_size;
} mz_zip_array;

struct mz_zip_internal_state_tag
{
    mz_zip_array m_central_dir;
    mz_zip_array m_central_dir_offsets;
    mz_zip_array m_sorted_central_dir_offsets;

    /* The flags passed in when the archive is initially opened. */
    mz_uint32 m_init_flags;

    /* MZ_TRUE if the archive has a zip64 end of central directory headers, etc. */
    mz_bool m_zip64;

    /* MZ_TRUE if we found zip64 extended info in the central directory (m_zip64 will also be slammed to true too, even if we didn't find a zip64 end of central dir header, etc.) */
    mz_bool m_zip64_has_extended_info_fields;

    /* These fields are used by the file, FILE, memory, and memory/heap read/write helpers. */
    MZ_FILE *m_pFile;
    mz_uint64 m_file_archive_start_ofs;

    void *m_pMem;
    size_t m_mem_size;
    size_t m_mem_capacity;
};

#define MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(array_ptr, element_size) (array_ptr)->m_element_size = element_size

#if defined(DEBUG) || defined(_DEBUG)
static MZ_FORCEINLINE mz_uint mz_zip_array_range_check(const mz_zip_array *pArray, mz_uint index)
{
    MZ_ASSERT(index < pArray->m_size);
    return index;
}
#define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) ((element_type *)((array_ptr)->m_p))[mz_zip_array_range_check(array_ptr, index)]
#else
#define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index) ((element_type *)((array_ptr)->m_p))[index]
#endif

static MZ_FORCEINLINE void mz_zip_array_init(mz_zip_array *pArray, mz_uint32 element_size)
{
    memset(pArray, 0, sizeof(mz_zip_array));
    pArray->m_element_size = element_size;
}

static MZ_FORCEINLINE void mz_zip_array_clear(mz_zip_archive *pZip, mz_zip_array *pArray)
{
    pZip->m_pFree(pZip->m_pAlloc_opaque, pArray->m_p);
    memset(pArray, 0, sizeof(mz_zip_array));
}

static mz_bool mz_zip_array_ensure_capacity(mz_zip_archive *pZip, mz_zip_array *pArray, size_t min_new_capacity, mz_uint growing)
{
    void *pNew_p;
    size_t new_capacity = min_new_capacity;
    MZ_ASSERT(pArray->m_element_size);
    if (pArray->m_capacity >= min_new_capacity)
        return MZ_TRUE;
    if (growing)
    {
        new_capacity = MZ_MAX(1, pArray->m_capacity);
        while (new_capacity < min_new_capacity)
            new_capacity *= 2;
    }
    if (NULL == (pNew_p = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pArray->m_p, pArray->m_element_size, pArray->m_capacity, pArray->m_element_size, new_capacity)))
        return MZ_FALSE;
    pArray->m_p = pNew_p;
    pArray->m_capacity = new_capacity;
    return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_array_reserve(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_capacity, mz_uint growing)
{
    if (new_capacity > pArray->m_capacity)
    {
        if (!mz_zip_array_ensure_capacity(pZip, pArray, new_capacity, growing))
            return MZ_FALSE;
    }
    return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_array_resize(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_size, mz_uint growing)
{
    if (new_size > pArray->m_capacity)
    {
        if (!mz_zip_array_ensure_capacity(pZip, pArray, new_size, growing))
            return MZ_FALSE;
    }
    pArray->m_size = new_size;
    return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_array_ensure_room(mz_zip_archive *pZip, mz_zip_array *pArray, size_t n)
{
    return mz_zip_array_reserve(pZip, pArray, pArray->m_size + n, MZ_TRUE);
}

static MZ_FORCEINLINE mz_bool mz_zip_array_push_back(mz_zip_archive *pZip, mz_zip_array *pArray, const void *pElements, size_t n)
{
    size_t orig_size = pArray->m_size;
    if (!mz_zip_array_resize(pZip, pArray, orig_size + n, MZ_TRUE))
        return MZ_FALSE;
    if (n > 0)
        memcpy((mz_uint8 *)pArray->m_p + orig_size * pArray->m_element_size, pElements, n * pArray->m_element_size);
    return MZ_TRUE;
}

#ifndef MINIZ_NO_TIME
static MZ_TIME_T mz_zip_dos_to_time_t(int dos_time, int dos_date)
{
    struct tm tm;
    memset(&tm, 0, sizeof(tm));
    tm.tm_isdst = -1;
    tm.tm_year = ((dos_date >> 9) & 127) + 1980 - 1900;
    tm.tm_mon = ((dos_date >> 5) & 15) - 1;
    tm.tm_mday = dos_date & 31;
    tm.tm_hour = (dos_time >> 11) & 31;
    tm.tm_min = (dos_time >> 5) & 63;
    tm.tm_sec = (dos_time << 1) & 62;
    return mktime(&tm);
}

#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
static void mz_zip_time_t_to_dos_time(MZ_TIME_T time, mz_uint16 *pDOS_time, mz_uint16 *pDOS_date)
{
#ifdef _MSC_VER
    struct tm tm_struct;
    struct tm *tm = &tm_struct;
    errno_t err = localtime_s(tm, &time);
    if (err)
    {
        *pDOS_date = 0;
        *pDOS_time = 0;
        return;
    }
#else
    struct tm *tm = localtime(&time);
#endif /* #ifdef _MSC_VER */

    *pDOS_time = (mz_uint16)(((tm->tm_hour) << 11) + ((tm->tm_min) << 5) + ((tm->tm_sec) >> 1));
    *pDOS_date = (mz_uint16)(((tm->tm_year + 1900 - 1980) << 9) + ((tm->tm_mon + 1) << 5) + tm->tm_mday);
}
#endif /* MINIZ_NO_ARCHIVE_WRITING_APIS */

#ifndef MINIZ_NO_STDIO
#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
static mz_bool mz_zip_get_file_modified_time(const char *pFilename, MZ_TIME_T *pTime)
{
    struct MZ_FILE_STAT_STRUCT file_stat;

    /* On Linux with x86 glibc, this call will fail on large files (I think >= 0x80000000 bytes) unless you compiled with _LARGEFILE64_SOURCE. Argh. */
    if (MZ_FILE_STAT(pFilename, &file_stat) != 0)
        return MZ_FALSE;

    *pTime = file_stat.st_mtime;

    return MZ_TRUE;
}
#endif /* #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS*/

static mz_bool mz_zip_set_file_times(const char *pFilename, MZ_TIME_T access_time, MZ_TIME_T modified_time)
{
    struct utimbuf t;

    memset(&t, 0, sizeof(t));
    t.actime = access_time;
    t.modtime = modified_time;

    return !utime(pFilename, &t);
}
#endif /* #ifndef MINIZ_NO_STDIO */
#endif /* #ifndef MINIZ_NO_TIME */

static MZ_FORCEINLINE mz_bool mz_zip_set_error(mz_zip_archive *pZip, mz_zip_error err_num)
{
    if (pZip)
        pZip->m_last_error = err_num;
    return MZ_FALSE;
}

static mz_bool mz_zip_reader_init_internal(mz_zip_archive *pZip, mz_uint flags)
{
    (void)flags;
    if ((!pZip) || (pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (!pZip->m_pAlloc)
        pZip->m_pAlloc = miniz_def_alloc_func;
    if (!pZip->m_pFree)
        pZip->m_pFree = miniz_def_free_func;
    if (!pZip->m_pRealloc)
        pZip->m_pRealloc = miniz_def_realloc_func;

    pZip->m_archive_size = 0;
    pZip->m_central_directory_file_ofs = 0;
    pZip->m_total_files = 0;
    pZip->m_last_error = MZ_ZIP_NO_ERROR;

    if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

    memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));
    pZip->m_pState->m_init_flags = flags;
    pZip->m_pState->m_zip64 = MZ_FALSE;
    pZip->m_pState->m_zip64_has_extended_info_fields = MZ_FALSE;

    pZip->m_zip_mode = MZ_ZIP_MODE_READING;

    return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_reader_filename_less(const mz_zip_array *pCentral_dir_array, const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, mz_uint r_index)
{
    const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
    const mz_uint8 *pR = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, r_index));
    mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS), r_len = MZ_READ_LE16(pR + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    mz_uint8 l = 0, r = 0;
    pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
    pR += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
    pE = pL + MZ_MIN(l_len, r_len);
    while (pL < pE)
    {
        if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
            break;
        pL++;
        pR++;
    }
    return (pL == pE) ? (l_len < r_len) : (l < r);
}

#define MZ_SWAP_UINT32(a, b) \
    do                       \
    {                        \
        mz_uint32 t = a;     \
        a = b;               \
        b = t;               \
    }                        \
    MZ_MACRO_END

/* Heap sort of lowercased filenames, used to help accelerate plain central directory searches by mz_zip_reader_locate_file(). (Could also use qsort(), but it could allocate memory.) */
static void mz_zip_reader_sort_central_dir_offsets_by_filename(mz_zip_archive *pZip)
{
    mz_zip_internal_state *pState = pZip->m_pState;
    const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
    const mz_zip_array *pCentral_dir = &pState->m_central_dir;
    mz_uint32 *pIndices;
    mz_uint32 start, end;
    const mz_uint32 size = pZip->m_total_files;

    if (size <= 1U)
        return;

    pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);

    start = (size - 2U) >> 1U;
    for (;;)
    {
        mz_uint64 child, root = start;
        for (;;)
        {
            if ((child = (root << 1U) + 1U) >= size)
                break;
            child += (((child + 1U) < size) && (mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1U])));
            if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child]))
                break;
            MZ_SWAP_UINT32(pIndices[root], pIndices[child]);
            root = child;
        }
        if (!start)
            break;
        start--;
    }

    end = size - 1;
    while (end > 0)
    {
        mz_uint64 child, root = 0;
        MZ_SWAP_UINT32(pIndices[end], pIndices[0]);
        for (;;)
        {
            if ((child = (root << 1U) + 1U) >= end)
                break;
            child += (((child + 1U) < end) && mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[child], pIndices[child + 1U]));
            if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets, pIndices[root], pIndices[child]))
                break;
            MZ_SWAP_UINT32(pIndices[root], pIndices[child]);
            root = child;
        }
        end--;
    }
}

static mz_bool mz_zip_reader_locate_header_sig(mz_zip_archive *pZip, mz_uint32 record_sig, mz_uint32 record_size, mz_int64 *pOfs)
{
    mz_int64 cur_file_ofs;
    mz_uint32 buf_u32[4096 / sizeof(mz_uint32)];
    mz_uint8 *pBuf = (mz_uint8 *)buf_u32;

    /* Basic sanity checks - reject files which are too small */
    if (pZip->m_archive_size < record_size)
        return MZ_FALSE;

    /* Find the record by scanning the file from the end towards the beginning. */
    cur_file_ofs = MZ_MAX((mz_int64)pZip->m_archive_size - (mz_int64)sizeof(buf_u32), 0);
    for (;;)
    {
        int i, n = (int)MZ_MIN(sizeof(buf_u32), pZip->m_archive_size - cur_file_ofs);

        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, n) != (mz_uint)n)
            return MZ_FALSE;

        for (i = n - 4; i >= 0; --i)
        {
            mz_uint s = MZ_READ_LE32(pBuf + i);
            if (s == record_sig)
            {
                if ((pZip->m_archive_size - (cur_file_ofs + i)) >= record_size)
                    break;
            }
        }

        if (i >= 0)
        {
            cur_file_ofs += i;
            break;
        }

        /* Give up if we've searched the entire file, or we've gone back "too far" (~64kb) */
        if ((!cur_file_ofs) || ((pZip->m_archive_size - cur_file_ofs) >= (MZ_UINT16_MAX + record_size)))
            return MZ_FALSE;

        cur_file_ofs = MZ_MAX(cur_file_ofs - (sizeof(buf_u32) - 3), 0);
    }

    *pOfs = cur_file_ofs;
    return MZ_TRUE;
}

static mz_bool mz_zip_reader_read_central_dir(mz_zip_archive *pZip, mz_uint flags)
{
    mz_uint cdir_size = 0, cdir_entries_on_this_disk = 0, num_this_disk = 0, cdir_disk_index = 0;
    mz_uint64 cdir_ofs = 0;
    mz_int64 cur_file_ofs = 0;
    const mz_uint8 *p;

    mz_uint32 buf_u32[4096 / sizeof(mz_uint32)];
    mz_uint8 *pBuf = (mz_uint8 *)buf_u32;
    mz_bool sort_central_dir = ((flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0);
    mz_uint32 zip64_end_of_central_dir_locator_u32[(MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pZip64_locator = (mz_uint8 *)zip64_end_of_central_dir_locator_u32;

    mz_uint32 zip64_end_of_central_dir_header_u32[(MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pZip64_end_of_central_dir = (mz_uint8 *)zip64_end_of_central_dir_header_u32;

    mz_uint64 zip64_end_of_central_dir_ofs = 0;

    /* Basic sanity checks - reject files which are too small, and check the first 4 bytes of the file to make sure a local header is there. */
    if (pZip->m_archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);

    if (!mz_zip_reader_locate_header_sig(pZip, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE, &cur_file_ofs))
        return mz_zip_set_error(pZip, MZ_ZIP_FAILED_FINDING_CENTRAL_DIR);

    /* Read and verify the end of central directory record. */
    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

    if (MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_SIG_OFS) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG)
        return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);

    if (cur_file_ofs >= (MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE + MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE))
    {
        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs - MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE, pZip64_locator, MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE) == MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE)
        {
            if (MZ_READ_LE32(pZip64_locator + MZ_ZIP64_ECDL_SIG_OFS) == MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG)
            {
                zip64_end_of_central_dir_ofs = MZ_READ_LE64(pZip64_locator + MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS);
                if (zip64_end_of_central_dir_ofs > (pZip->m_archive_size - MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE))
                    return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);

                if (pZip->m_pRead(pZip->m_pIO_opaque, zip64_end_of_central_dir_ofs, pZip64_end_of_central_dir, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE) == MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE)
                {
                    if (MZ_READ_LE32(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_SIG_OFS) == MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG)
                    {
                        pZip->m_pState->m_zip64 = MZ_TRUE;
                    }
                }
            }
        }
    }

    pZip->m_total_files = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS);
    cdir_entries_on_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS);
    num_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_THIS_DISK_OFS);
    cdir_disk_index = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS);
    cdir_size = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_SIZE_OFS);
    cdir_ofs = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_OFS_OFS);

    if (pZip->m_pState->m_zip64)
    {
        mz_uint32 zip64_total_num_of_disks = MZ_READ_LE32(pZip64_locator + MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS);
        mz_uint64 zip64_cdir_total_entries = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS);
        mz_uint64 zip64_cdir_total_entries_on_this_disk = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS);
        mz_uint64 zip64_size_of_end_of_central_dir_record = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS);
        mz_uint64 zip64_size_of_central_directory = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_SIZE_OFS);

        if (zip64_size_of_end_of_central_dir_record < (MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE - 12))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

        if (zip64_total_num_of_disks != 1U)
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);

        /* Check for miniz's practical limits */
        if (zip64_cdir_total_entries > MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);

        pZip->m_total_files = (mz_uint32)zip64_cdir_total_entries;

        if (zip64_cdir_total_entries_on_this_disk > MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);

        cdir_entries_on_this_disk = (mz_uint32)zip64_cdir_total_entries_on_this_disk;

        /* Check for miniz's current practical limits (sorry, this should be enough for millions of files) */
        if (zip64_size_of_central_directory > MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);

        cdir_size = (mz_uint32)zip64_size_of_central_directory;

        num_this_disk = MZ_READ_LE32(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_NUM_THIS_DISK_OFS);

        cdir_disk_index = MZ_READ_LE32(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_NUM_DISK_CDIR_OFS);

        cdir_ofs = MZ_READ_LE64(pZip64_end_of_central_dir + MZ_ZIP64_ECDH_CDIR_OFS_OFS);
    }

    if (pZip->m_total_files != cdir_entries_on_this_disk)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);

    if (((num_this_disk | cdir_disk_index) != 0) && ((num_this_disk != 1) || (cdir_disk_index != 1)))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);

    if (cdir_size < (mz_uint64)pZip->m_total_files * MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    if ((cdir_ofs + (mz_uint64)cdir_size) > pZip->m_archive_size)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    pZip->m_central_directory_file_ofs = cdir_ofs;

    if (pZip->m_total_files)
    {
        mz_uint i, n;
        /* Read the entire central directory into a heap block, and allocate another heap block to hold the unsorted central dir file record offsets, and possibly another to hold the sorted indices. */
        if ((!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir, cdir_size, MZ_FALSE)) ||
            (!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir_offsets, pZip->m_total_files, MZ_FALSE)))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

        if (sort_central_dir)
        {
            if (!mz_zip_array_resize(pZip, &pZip->m_pState->m_sorted_central_dir_offsets, pZip->m_total_files, MZ_FALSE))
                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        if (pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs, pZip->m_pState->m_central_dir.m_p, cdir_size) != cdir_size)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

        /* Now create an index into the central directory file records, do some basic sanity checking on each record */
        p = (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p;
        for (n = cdir_size, i = 0; i < pZip->m_total_files; ++i)
        {
            mz_uint total_header_size, disk_index, bit_flags, filename_size, ext_data_size;
            mz_uint64 comp_size, decomp_size, local_header_ofs;

            if ((n < MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) || (MZ_READ_LE32(p) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG))
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

            MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, i) = (mz_uint32)(p - (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p);

            if (sort_central_dir)
                MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_sorted_central_dir_offsets, mz_uint32, i) = i;

            comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
            decomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
            local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
            filename_size = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
            ext_data_size = MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS);

            if ((!pZip->m_pState->m_zip64_has_extended_info_fields) &&
                (ext_data_size) &&
                (MZ_MAX(MZ_MAX(comp_size, decomp_size), local_header_ofs) == MZ_UINT32_MAX))
            {
                /* Attempt to find zip64 extended information field in the entry's extra data */
                mz_uint32 extra_size_remaining = ext_data_size;

                if (extra_size_remaining)
                {
					const mz_uint8 *pExtra_data;
					void* buf = NULL;

					if (MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + ext_data_size > n)
					{
						buf = MZ_MALLOC(ext_data_size);
						if(buf==NULL)
							return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

						if (pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size, buf, ext_data_size) != ext_data_size)
						{
							MZ_FREE(buf);
							return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
						}

						pExtra_data = (mz_uint8*)buf;
					}
					else
					{
						pExtra_data = p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size;
					}

                    do
                    {
                        mz_uint32 field_id;
                        mz_uint32 field_data_size;

						if (extra_size_remaining < (sizeof(mz_uint16) * 2))
						{
							MZ_FREE(buf);
							return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
						}

                        field_id = MZ_READ_LE16(pExtra_data);
                        field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));

						if ((field_data_size + sizeof(mz_uint16) * 2) > extra_size_remaining)
						{
							MZ_FREE(buf);
							return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
						}

                        if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
                        {
                            /* Ok, the archive didn't have any zip64 headers but it uses a zip64 extended information field so mark it as zip64 anyway (this can occur with infozip's zip util when it reads compresses files from stdin). */
                            pZip->m_pState->m_zip64 = MZ_TRUE;
                            pZip->m_pState->m_zip64_has_extended_info_fields = MZ_TRUE;
                            break;
                        }

                        pExtra_data += sizeof(mz_uint16) * 2 + field_data_size;
                        extra_size_remaining = extra_size_remaining - sizeof(mz_uint16) * 2 - field_data_size;
                    } while (extra_size_remaining);

					MZ_FREE(buf);
                }
            }

            /* I've seen archives that aren't marked as zip64 that uses zip64 ext data, argh */
            if ((comp_size != MZ_UINT32_MAX) && (decomp_size != MZ_UINT32_MAX))
            {
                if (((!MZ_READ_LE32(p + MZ_ZIP_CDH_METHOD_OFS)) && (decomp_size != comp_size)) || (decomp_size && !comp_size))
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
            }

            disk_index = MZ_READ_LE16(p + MZ_ZIP_CDH_DISK_START_OFS);
            if ((disk_index == MZ_UINT16_MAX) || ((disk_index != num_this_disk) && (disk_index != 1)))
                return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_MULTIDISK);

            if (comp_size != MZ_UINT32_MAX)
            {
                if (((mz_uint64)MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS) + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + comp_size) > pZip->m_archive_size)
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
            }

            bit_flags = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
            if (bit_flags & MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_LOCAL_DIR_IS_MASKED)
                return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);

            if ((total_header_size = MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS)) > n)
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

            n -= total_header_size;
            p += total_header_size;
        }
    }

    if (sort_central_dir)
        mz_zip_reader_sort_central_dir_offsets_by_filename(pZip);

    return MZ_TRUE;
}

void mz_zip_zero_struct(mz_zip_archive *pZip)
{
    if (pZip)
        MZ_CLEAR_PTR(pZip);
}

static mz_bool mz_zip_reader_end_internal(mz_zip_archive *pZip, mz_bool set_last_error)
{
    mz_bool status = MZ_TRUE;

    if (!pZip)
        return MZ_FALSE;

    if ((!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
    {
        if (set_last_error)
            pZip->m_last_error = MZ_ZIP_INVALID_PARAMETER;

        return MZ_FALSE;
    }

    if (pZip->m_pState)
    {
        mz_zip_internal_state *pState = pZip->m_pState;
        pZip->m_pState = NULL;

        mz_zip_array_clear(pZip, &pState->m_central_dir);
        mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
        mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);

#ifndef MINIZ_NO_STDIO
        if (pState->m_pFile)
        {
            if (pZip->m_zip_type == MZ_ZIP_TYPE_FILE)
            {
                if (MZ_FCLOSE(pState->m_pFile) == EOF)
                {
                    if (set_last_error)
                        pZip->m_last_error = MZ_ZIP_FILE_CLOSE_FAILED;
                    status = MZ_FALSE;
                }
            }
            pState->m_pFile = NULL;
        }
#endif /* #ifndef MINIZ_NO_STDIO */

        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
    }
    pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;

    return status;
}

mz_bool mz_zip_reader_end(mz_zip_archive *pZip)
{
    return mz_zip_reader_end_internal(pZip, MZ_TRUE);
}
mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size, mz_uint flags)
{
    if ((!pZip) || (!pZip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (!mz_zip_reader_init_internal(pZip, flags))
        return MZ_FALSE;

    pZip->m_zip_type = MZ_ZIP_TYPE_USER;
    pZip->m_archive_size = size;

    if (!mz_zip_reader_read_central_dir(pZip, flags))
    {
        mz_zip_reader_end_internal(pZip, MZ_FALSE);
        return MZ_FALSE;
    }

    return MZ_TRUE;
}

static size_t mz_zip_mem_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
{
    mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
    size_t s = (file_ofs >= pZip->m_archive_size) ? 0 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n);
    memcpy(pBuf, (const mz_uint8 *)pZip->m_pState->m_pMem + file_ofs, s);
    return s;
}

mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem, size_t size, mz_uint flags)
{
    if (!pMem)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);

    if (!mz_zip_reader_init_internal(pZip, flags))
        return MZ_FALSE;

    pZip->m_zip_type = MZ_ZIP_TYPE_MEMORY;
    pZip->m_archive_size = size;
    pZip->m_pRead = mz_zip_mem_read_func;
    pZip->m_pIO_opaque = pZip;
    pZip->m_pNeeds_keepalive = NULL;

#ifdef __cplusplus
    pZip->m_pState->m_pMem = const_cast<void *>(pMem);
#else
    pZip->m_pState->m_pMem = (void *)pMem;
#endif

    pZip->m_pState->m_mem_size = size;

    if (!mz_zip_reader_read_central_dir(pZip, flags))
    {
        mz_zip_reader_end_internal(pZip, MZ_FALSE);
        return MZ_FALSE;
    }

    return MZ_TRUE;
}

#ifndef MINIZ_NO_STDIO
static size_t mz_zip_file_read_func(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
{
    mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
    mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);

    file_ofs += pZip->m_pState->m_file_archive_start_ofs;

    if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
        return 0;

    return MZ_FREAD(pBuf, 1, n, pZip->m_pState->m_pFile);
}

mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint32 flags)
{
    return mz_zip_reader_init_file_v2(pZip, pFilename, flags, 0, 0);
}

mz_bool mz_zip_reader_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags, mz_uint64 file_start_ofs, mz_uint64 archive_size)
{
    mz_uint64 file_size;
    MZ_FILE *pFile;

    if ((!pZip) || (!pFilename) || ((archive_size) && (archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pFile = MZ_FOPEN(pFilename, "rb");
    if (!pFile)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);

    file_size = archive_size;
    if (!file_size)
    {
        if (MZ_FSEEK64(pFile, 0, SEEK_END))
        {
            MZ_FCLOSE(pFile);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_SEEK_FAILED);
        }

        file_size = MZ_FTELL64(pFile);
    }

    /* TODO: Better sanity check archive_size and the # of actual remaining bytes */

    if (file_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
    {
	MZ_FCLOSE(pFile);
        return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
    }

    if (!mz_zip_reader_init_internal(pZip, flags))
    {
        MZ_FCLOSE(pFile);
        return MZ_FALSE;
    }

    pZip->m_zip_type = MZ_ZIP_TYPE_FILE;
    pZip->m_pRead = mz_zip_file_read_func;
    pZip->m_pIO_opaque = pZip;
    pZip->m_pState->m_pFile = pFile;
    pZip->m_archive_size = file_size;
    pZip->m_pState->m_file_archive_start_ofs = file_start_ofs;

    if (!mz_zip_reader_read_central_dir(pZip, flags))
    {
        mz_zip_reader_end_internal(pZip, MZ_FALSE);
        return MZ_FALSE;
    }

    return MZ_TRUE;
}

mz_bool mz_zip_reader_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint64 archive_size, mz_uint flags)
{
    mz_uint64 cur_file_ofs;

    if ((!pZip) || (!pFile))
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);

    cur_file_ofs = MZ_FTELL64(pFile);

    if (!archive_size)
    {
        if (MZ_FSEEK64(pFile, 0, SEEK_END))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_SEEK_FAILED);

        archive_size = MZ_FTELL64(pFile) - cur_file_ofs;

        if (archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
            return mz_zip_set_error(pZip, MZ_ZIP_NOT_AN_ARCHIVE);
    }

    if (!mz_zip_reader_init_internal(pZip, flags))
        return MZ_FALSE;

    pZip->m_zip_type = MZ_ZIP_TYPE_CFILE;
    pZip->m_pRead = mz_zip_file_read_func;

    pZip->m_pIO_opaque = pZip;
    pZip->m_pState->m_pFile = pFile;
    pZip->m_archive_size = archive_size;
    pZip->m_pState->m_file_archive_start_ofs = cur_file_ofs;

    if (!mz_zip_reader_read_central_dir(pZip, flags))
    {
        mz_zip_reader_end_internal(pZip, MZ_FALSE);
        return MZ_FALSE;
    }

    return MZ_TRUE;
}

#endif /* #ifndef MINIZ_NO_STDIO */

static MZ_FORCEINLINE const mz_uint8 *mz_zip_get_cdh(mz_zip_archive *pZip, mz_uint file_index)
{
    if ((!pZip) || (!pZip->m_pState) || (file_index >= pZip->m_total_files))
        return NULL;
    return &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
}

mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip, mz_uint file_index)
{
    mz_uint m_bit_flag;
    const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
    if (!p)
    {
        mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        return MZ_FALSE;
    }

    m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
    return (m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION)) != 0;
}

mz_bool mz_zip_reader_is_file_supported(mz_zip_archive *pZip, mz_uint file_index)
{
    mz_uint bit_flag;
    mz_uint method;

    const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
    if (!p)
    {
        mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        return MZ_FALSE;
    }

    method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);
    bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);

    if ((method != 0) && (method != MZ_DEFLATED))
    {
        mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);
        return MZ_FALSE;
    }

    if (bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION))
    {
        mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);
        return MZ_FALSE;
    }

    if (bit_flag & MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG)
    {
        mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);
        return MZ_FALSE;
    }

    return MZ_TRUE;
}

mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip, mz_uint file_index)
{
    mz_uint filename_len, attribute_mapping_id, external_attr;
    const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
    if (!p)
    {
        mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        return MZ_FALSE;
    }

    filename_len = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    if (filename_len)
    {
        if (*(p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_len - 1) == '/')
            return MZ_TRUE;
    }

    /* Bugfix: This code was also checking if the internal attribute was non-zero, which wasn't correct. */
    /* Most/all zip writers (hopefully) set DOS file/directory attributes in the low 16-bits, so check for the DOS directory flag and ignore the source OS ID in the created by field. */
    /* FIXME: Remove this check? Is it necessary - we already check the filename. */
    attribute_mapping_id = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS) >> 8;
    (void)attribute_mapping_id;

    external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
    if ((external_attr & MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG) != 0)
    {
        return MZ_TRUE;
    }

    return MZ_FALSE;
}

static mz_bool mz_zip_file_stat_internal(mz_zip_archive *pZip, mz_uint file_index, const mz_uint8 *pCentral_dir_header, mz_zip_archive_file_stat *pStat, mz_bool *pFound_zip64_extra_data)
{
    mz_uint n;
    const mz_uint8 *p = pCentral_dir_header;

    if (pFound_zip64_extra_data)
        *pFound_zip64_extra_data = MZ_FALSE;

    if ((!p) || (!pStat))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    /* Extract fields from the central directory record. */
    pStat->m_file_index = file_index;
    pStat->m_central_dir_ofs = MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index);
    pStat->m_version_made_by = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS);
    pStat->m_version_needed = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_NEEDED_OFS);
    pStat->m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
    pStat->m_method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);
#ifndef MINIZ_NO_TIME
    pStat->m_time = mz_zip_dos_to_time_t(MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_TIME_OFS), MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_DATE_OFS));
#endif
    pStat->m_crc32 = MZ_READ_LE32(p + MZ_ZIP_CDH_CRC32_OFS);
    pStat->m_comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
    pStat->m_uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
    pStat->m_internal_attr = MZ_READ_LE16(p + MZ_ZIP_CDH_INTERNAL_ATTR_OFS);
    pStat->m_external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
    pStat->m_local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);

    /* Copy as much of the filename and comment as possible. */
    n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1);
    memcpy(pStat->m_filename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
    pStat->m_filename[n] = '\0';

    n = MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS);
    n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE - 1);
    pStat->m_comment_size = n;
    memcpy(pStat->m_comment, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) + MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS), n);
    pStat->m_comment[n] = '\0';

    /* Set some flags for convienance */
    pStat->m_is_directory = mz_zip_reader_is_file_a_directory(pZip, file_index);
    pStat->m_is_encrypted = mz_zip_reader_is_file_encrypted(pZip, file_index);
    pStat->m_is_supported = mz_zip_reader_is_file_supported(pZip, file_index);

    /* See if we need to read any zip64 extended information fields. */
    /* Confusingly, these zip64 fields can be present even on non-zip64 archives (Debian zip on a huge files from stdin piped to stdout creates them). */
    if (MZ_MAX(MZ_MAX(pStat->m_comp_size, pStat->m_uncomp_size), pStat->m_local_header_ofs) == MZ_UINT32_MAX)
    {
        /* Attempt to find zip64 extended information field in the entry's extra data */
        mz_uint32 extra_size_remaining = MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS);

        if (extra_size_remaining)
        {
            const mz_uint8 *pExtra_data = p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);

            do
            {
                mz_uint32 field_id;
                mz_uint32 field_data_size;

                if (extra_size_remaining < (sizeof(mz_uint16) * 2))
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                field_id = MZ_READ_LE16(pExtra_data);
                field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));

                if ((field_data_size + sizeof(mz_uint16) * 2) > extra_size_remaining)
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
                {
                    const mz_uint8 *pField_data = pExtra_data + sizeof(mz_uint16) * 2;
                    mz_uint32 field_data_remaining = field_data_size;

                    if (pFound_zip64_extra_data)
                        *pFound_zip64_extra_data = MZ_TRUE;

                    if (pStat->m_uncomp_size == MZ_UINT32_MAX)
                    {
                        if (field_data_remaining < sizeof(mz_uint64))
                            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                        pStat->m_uncomp_size = MZ_READ_LE64(pField_data);
                        pField_data += sizeof(mz_uint64);
                        field_data_remaining -= sizeof(mz_uint64);
                    }

                    if (pStat->m_comp_size == MZ_UINT32_MAX)
                    {
                        if (field_data_remaining < sizeof(mz_uint64))
                            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                        pStat->m_comp_size = MZ_READ_LE64(pField_data);
                        pField_data += sizeof(mz_uint64);
                        field_data_remaining -= sizeof(mz_uint64);
                    }

                    if (pStat->m_local_header_ofs == MZ_UINT32_MAX)
                    {
                        if (field_data_remaining < sizeof(mz_uint64))
                            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

                        pStat->m_local_header_ofs = MZ_READ_LE64(pField_data);
                        pField_data += sizeof(mz_uint64);
                        field_data_remaining -= sizeof(mz_uint64);
                    }

                    break;
                }

                pExtra_data += sizeof(mz_uint16) * 2 + field_data_size;
                extra_size_remaining = extra_size_remaining - sizeof(mz_uint16) * 2 - field_data_size;
            } while (extra_size_remaining);
        }
    }

    return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool mz_zip_string_equal(const char *pA, const char *pB, mz_uint len, mz_uint flags)
{
    mz_uint i;
    if (flags & MZ_ZIP_FLAG_CASE_SENSITIVE)
        return 0 == memcmp(pA, pB, len);
    for (i = 0; i < len; ++i)
        if (MZ_TOLOWER(pA[i]) != MZ_TOLOWER(pB[i]))
            return MZ_FALSE;
    return MZ_TRUE;
}

static MZ_FORCEINLINE int mz_zip_filename_compare(const mz_zip_array *pCentral_dir_array, const mz_zip_array *pCentral_dir_offsets, mz_uint l_index, const char *pR, mz_uint r_len)
{
    const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_array, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, l_index)), *pE;
    mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    mz_uint8 l = 0, r = 0;
    pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
    pE = pL + MZ_MIN(l_len, r_len);
    while (pL < pE)
    {
        if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
            break;
        pL++;
        pR++;
    }
    return (pL == pE) ? (int)(l_len - r_len) : (l - r);
}

static mz_bool mz_zip_locate_file_binary_search(mz_zip_archive *pZip, const char *pFilename, mz_uint32 *pIndex)
{
    mz_zip_internal_state *pState = pZip->m_pState;
    const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
    const mz_zip_array *pCentral_dir = &pState->m_central_dir;
    mz_uint32 *pIndices = &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32, 0);
    const mz_uint32 size = pZip->m_total_files;
    const mz_uint filename_len = (mz_uint)strlen(pFilename);

    if (pIndex)
        *pIndex = 0;

    if (size)
    {
        /* yes I could use uint32_t's, but then we would have to add some special case checks in the loop, argh, and */
        /* honestly the major expense here on 32-bit CPU's will still be the filename compare */
        mz_int64 l = 0, h = (mz_int64)size - 1;

        while (l <= h)
        {
            mz_int64 m = l + ((h - l) >> 1);
            mz_uint32 file_index = pIndices[(mz_uint32)m];

            int comp = mz_zip_filename_compare(pCentral_dir, pCentral_dir_offsets, file_index, pFilename, filename_len);
            if (!comp)
            {
                if (pIndex)
                    *pIndex = file_index;
                return MZ_TRUE;
            }
            else if (comp < 0)
                l = m + 1;
            else
                h = m - 1;
        }
    }

    return mz_zip_set_error(pZip, MZ_ZIP_FILE_NOT_FOUND);
}

int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags)
{
    mz_uint32 index;
    if (!mz_zip_reader_locate_file_v2(pZip, pName, pComment, flags, &index))
        return -1;
    else
        return (int)index;
}

mz_bool mz_zip_reader_locate_file_v2(mz_zip_archive *pZip, const char *pName, const char *pComment, mz_uint flags, mz_uint32 *pIndex)
{
    mz_uint file_index;
    size_t name_len, comment_len;

    if (pIndex)
        *pIndex = 0;

    if ((!pZip) || (!pZip->m_pState) || (!pName))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    /* See if we can use a binary search */
    if (((pZip->m_pState->m_init_flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0) &&
        (pZip->m_zip_mode == MZ_ZIP_MODE_READING) &&
        ((flags & (MZ_ZIP_FLAG_IGNORE_PATH | MZ_ZIP_FLAG_CASE_SENSITIVE)) == 0) && (!pComment) && (pZip->m_pState->m_sorted_central_dir_offsets.m_size))
    {
        return mz_zip_locate_file_binary_search(pZip, pName, pIndex);
    }

    /* Locate the entry by scanning the entire central directory */
    name_len = strlen(pName);
    if (name_len > MZ_UINT16_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    comment_len = pComment ? strlen(pComment) : 0;
    if (comment_len > MZ_UINT16_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    for (file_index = 0; file_index < pZip->m_total_files; file_index++)
    {
        const mz_uint8 *pHeader = &MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir, mz_uint8, MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index));
        mz_uint filename_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_FILENAME_LEN_OFS);
        const char *pFilename = (const char *)pHeader + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
        if (filename_len < name_len)
            continue;
        if (comment_len)
        {
            mz_uint file_extra_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_EXTRA_LEN_OFS), file_comment_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_COMMENT_LEN_OFS);
            const char *pFile_comment = pFilename + filename_len + file_extra_len;
            if ((file_comment_len != comment_len) || (!mz_zip_string_equal(pComment, pFile_comment, file_comment_len, flags)))
                continue;
        }
        if ((flags & MZ_ZIP_FLAG_IGNORE_PATH) && (filename_len))
        {
            int ofs = filename_len - 1;
            do
            {
                if ((pFilename[ofs] == '/') || (pFilename[ofs] == '\\') || (pFilename[ofs] == ':'))
                    break;
            } while (--ofs >= 0);
            ofs++;
            pFilename += ofs;
            filename_len -= ofs;
        }
        if ((filename_len == name_len) && (mz_zip_string_equal(pName, pFilename, filename_len, flags)))
        {
            if (pIndex)
                *pIndex = file_index;
            return MZ_TRUE;
        }
    }

    return mz_zip_set_error(pZip, MZ_ZIP_FILE_NOT_FOUND);
}

static
mz_bool mz_zip_reader_extract_to_mem_no_alloc1(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size, const mz_zip_archive_file_stat *st)
{
    int status = TINFL_STATUS_DONE;
    mz_uint64 needed_size, cur_file_ofs, comp_remaining, out_buf_ofs = 0, read_buf_size, read_buf_ofs = 0, read_buf_avail;
    mz_zip_archive_file_stat file_stat;
    void *pRead_buf;
    mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
    tinfl_decompressor inflator;

    if ((!pZip) || (!pZip->m_pState) || ((buf_size) && (!pBuf)) || ((user_read_buf_size) && (!pUser_read_buf)) || (!pZip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (st) {
        file_stat = *st;
    } else
    if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
        return MZ_FALSE;

    /* A directory or zero length file */
    if ((file_stat.m_is_directory) || (!file_stat.m_comp_size))
        return MZ_TRUE;

    /* Encryption and patch files are not supported. */
    if (file_stat.m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);

    /* This function only supports decompressing stored and deflate. */
    if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);

    /* Ensure supplied output buffer is large enough. */
    needed_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? file_stat.m_comp_size : file_stat.m_uncomp_size;
    if (buf_size < needed_size)
        return mz_zip_set_error(pZip, MZ_ZIP_BUF_TOO_SMALL);

    /* Read and parse the local directory entry. */
    cur_file_ofs = file_stat.m_local_header_ofs;
    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

    if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
    if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))
    {
        /* The file is stored or the caller has requested the compressed data. */
        if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, (size_t)needed_size) != needed_size)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
        if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) == 0)
        {
            if (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32)
                return mz_zip_set_error(pZip, MZ_ZIP_CRC_CHECK_FAILED);
        }
#endif

        return MZ_TRUE;
    }

    /* Decompress the file either directly from memory or from a file input buffer. */
    tinfl_init(&inflator);

    if (pZip->m_pState->m_pMem)
    {
        /* Read directly from the archive in memory. */
        pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
        read_buf_size = read_buf_avail = file_stat.m_comp_size;
        comp_remaining = 0;
    }
    else if (pUser_read_buf)
    {
        /* Use a user provided read buffer. */
        if (!user_read_buf_size)
            return MZ_FALSE;
        pRead_buf = (mz_uint8 *)pUser_read_buf;
        read_buf_size = user_read_buf_size;
        read_buf_avail = 0;
        comp_remaining = file_stat.m_comp_size;
    }
    else
    {
        /* Temporarily allocate a read buffer. */
        read_buf_size = MZ_MIN(file_stat.m_comp_size, (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE);
        if (((sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))
            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

        if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size)))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

        read_buf_avail = 0;
        comp_remaining = file_stat.m_comp_size;
    }

    do
    {
        /* The size_t cast here should be OK because we've verified that the output buffer is >= file_stat.m_uncomp_size above */
        size_t in_buf_size, out_buf_size = (size_t)(file_stat.m_uncomp_size - out_buf_ofs);
        if ((!read_buf_avail) && (!pZip->m_pState->m_pMem))
        {
            read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
            if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
            {
                status = TINFL_STATUS_FAILED;
                mz_zip_set_error(pZip, MZ_ZIP_DECOMPRESSION_FAILED);
                break;
            }
            cur_file_ofs += read_buf_avail;
            comp_remaining -= read_buf_avail;
            read_buf_ofs = 0;
        }
        in_buf_size = (size_t)read_buf_avail;
        status = tinfl_decompress(&inflator, (mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pBuf, (mz_uint8 *)pBuf + out_buf_ofs, &out_buf_size, TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF | (comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0));
        read_buf_avail -= in_buf_size;
        read_buf_ofs += in_buf_size;
        out_buf_ofs += out_buf_size;
    } while (status == TINFL_STATUS_NEEDS_MORE_INPUT);

    if (status == TINFL_STATUS_DONE)
    {
        /* Make sure the entire file was decompressed, and check its CRC. */
        if (out_buf_ofs != file_stat.m_uncomp_size)
        {
            mz_zip_set_error(pZip, MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
            status = TINFL_STATUS_FAILED;
        }
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
        else if (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32)
        {
            mz_zip_set_error(pZip, MZ_ZIP_CRC_CHECK_FAILED);
            status = TINFL_STATUS_FAILED;
        }
#endif
    }

    if ((!pZip->m_pState->m_pMem) && (!pUser_read_buf))
        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);

    return status == TINFL_STATUS_DONE;
}

mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)
{
    return mz_zip_reader_extract_to_mem_no_alloc1(pZip, file_index, pBuf, buf_size, flags, pUser_read_buf, user_read_buf_size, NULL);
}

mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size)
{
    mz_uint32 file_index;
    if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
        return MZ_FALSE;
    return mz_zip_reader_extract_to_mem_no_alloc1(pZip, file_index, pBuf, buf_size, flags, pUser_read_buf, user_read_buf_size, NULL);
}

mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index, void *pBuf, size_t buf_size, mz_uint flags)
{
    return mz_zip_reader_extract_to_mem_no_alloc1(pZip, file_index, pBuf, buf_size, flags, NULL, 0, NULL);
}

mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size, mz_uint flags)
{
    return mz_zip_reader_extract_file_to_mem_no_alloc(pZip, pFilename, pBuf, buf_size, flags, NULL, 0);
}

void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index, size_t *pSize, mz_uint flags)
{
    mz_zip_archive_file_stat file_stat;
    mz_uint64 alloc_size;
    void *pBuf;

    if (pSize)
        *pSize = 0;

    if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
        return NULL;

    alloc_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? file_stat.m_comp_size : file_stat.m_uncomp_size;
    if (((sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))
    {
        mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
        return NULL;
    }

    if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)alloc_size)))
    {
        mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        return NULL;
    }

    if (!mz_zip_reader_extract_to_mem_no_alloc1(pZip, file_index, pBuf, (size_t)alloc_size, flags, NULL, 0, &file_stat))
    {
        pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
        return NULL;
    }

    if (pSize)
        *pSize = (size_t)alloc_size;
    return pBuf;
}

void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip, const char *pFilename, size_t *pSize, mz_uint flags)
{
    mz_uint32 file_index;
    if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
    {
        if (pSize)
            *pSize = 0;
        return MZ_FALSE;
    }
    return mz_zip_reader_extract_to_heap(pZip, file_index, pSize, flags);
}

mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip, mz_uint file_index, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)
{
    int status = TINFL_STATUS_DONE;
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
    mz_uint file_crc32 = MZ_CRC32_INIT;
#endif
    mz_uint64 read_buf_size, read_buf_ofs = 0, read_buf_avail, comp_remaining, out_buf_ofs = 0, cur_file_ofs;
    mz_zip_archive_file_stat file_stat;
    void *pRead_buf = NULL;
    void *pWrite_buf = NULL;
    mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;

    if ((!pZip) || (!pZip->m_pState) || (!pCallback) || (!pZip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
        return MZ_FALSE;

    /* A directory or zero length file */
    if ((file_stat.m_is_directory) || (!file_stat.m_comp_size))
        return MZ_TRUE;

    /* Encryption and patch files are not supported. */
    if (file_stat.m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);

    /* This function only supports decompressing stored and deflate. */
    if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);

    /* Read and do some minimal validation of the local directory entry (this doesn't crack the zip64 stuff, which we already have from the central dir) */
    cur_file_ofs = file_stat.m_local_header_ofs;
    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

    if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
    if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    /* Decompress the file either directly from memory or from a file input buffer. */
    if (pZip->m_pState->m_pMem)
    {
        pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
        read_buf_size = read_buf_avail = file_stat.m_comp_size;
        comp_remaining = 0;
    }
    else
    {
        read_buf_size = MZ_MIN(file_stat.m_comp_size, (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE);
        if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)read_buf_size)))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

        read_buf_avail = 0;
        comp_remaining = file_stat.m_comp_size;
    }

    if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method))
    {
        /* The file is stored or the caller has requested the compressed data. */
        if (pZip->m_pState->m_pMem)
        {
            if (((sizeof(size_t) == sizeof(mz_uint32))) && (file_stat.m_comp_size > MZ_UINT32_MAX))
                return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

            if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)file_stat.m_comp_size) != file_stat.m_comp_size)
            {
                mz_zip_set_error(pZip, MZ_ZIP_WRITE_CALLBACK_FAILED);
                status = TINFL_STATUS_FAILED;
            }
            else if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
            {
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
                file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf, (size_t)file_stat.m_comp_size);
#endif
            }

            cur_file_ofs += file_stat.m_comp_size;
            out_buf_ofs += file_stat.m_comp_size;
            comp_remaining = 0;
        }
        else
        {
            while (comp_remaining)
            {
                read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
                if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
                {
                    mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                    status = TINFL_STATUS_FAILED;
                    break;
                }

#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
                if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
                {
                    file_crc32 = (mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf, (size_t)read_buf_avail);
                }
#endif

                if (pCallback(pOpaque, out_buf_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
                {
                    mz_zip_set_error(pZip, MZ_ZIP_WRITE_CALLBACK_FAILED);
                    status = TINFL_STATUS_FAILED;
                    break;
                }

                cur_file_ofs += read_buf_avail;
                out_buf_ofs += read_buf_avail;
                comp_remaining -= read_buf_avail;
            }
        }
    }
    else
    {
        tinfl_decompressor inflator;
        tinfl_init(&inflator);

        if (NULL == (pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, TINFL_LZ_DICT_SIZE)))
        {
            mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            status = TINFL_STATUS_FAILED;
        }
        else
        {
            do
            {
                mz_uint8 *pWrite_buf_cur = (mz_uint8 *)pWrite_buf + (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
                size_t in_buf_size, out_buf_size = TINFL_LZ_DICT_SIZE - (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
                if ((!read_buf_avail) && (!pZip->m_pState->m_pMem))
                {
                    read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
                    if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf, (size_t)read_buf_avail) != read_buf_avail)
                    {
                        mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                        status = TINFL_STATUS_FAILED;
                        break;
                    }
                    cur_file_ofs += read_buf_avail;
                    comp_remaining -= read_buf_avail;
                    read_buf_ofs = 0;
                }

                in_buf_size = (size_t)read_buf_avail;
                status = tinfl_decompress(&inflator, (const mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size, (mz_uint8 *)pWrite_buf, pWrite_buf_cur, &out_buf_size, comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);
                read_buf_avail -= in_buf_size;
                read_buf_ofs += in_buf_size;

                if (out_buf_size)
                {
                    if (pCallback(pOpaque, out_buf_ofs, pWrite_buf_cur, out_buf_size) != out_buf_size)
                    {
                        mz_zip_set_error(pZip, MZ_ZIP_WRITE_CALLBACK_FAILED);
                        status = TINFL_STATUS_FAILED;
                        break;
                    }

#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
                    file_crc32 = (mz_uint32)mz_crc32(file_crc32, pWrite_buf_cur, out_buf_size);
#endif
                    if ((out_buf_ofs += out_buf_size) > file_stat.m_uncomp_size)
                    {
                        mz_zip_set_error(pZip, MZ_ZIP_DECOMPRESSION_FAILED);
                        status = TINFL_STATUS_FAILED;
                        break;
                    }
                }
            } while ((status == TINFL_STATUS_NEEDS_MORE_INPUT) || (status == TINFL_STATUS_HAS_MORE_OUTPUT));
        }
    }

    if ((status == TINFL_STATUS_DONE) && (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
    {
        /* Make sure the entire file was decompressed, and check its CRC. */
        if (out_buf_ofs != file_stat.m_uncomp_size)
        {
            mz_zip_set_error(pZip, MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
            status = TINFL_STATUS_FAILED;
        }
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
        else if (file_crc32 != file_stat.m_crc32)
        {
            mz_zip_set_error(pZip, MZ_ZIP_DECOMPRESSION_FAILED);
            status = TINFL_STATUS_FAILED;
        }
#endif
    }

    if (!pZip->m_pState->m_pMem)
        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);

    if (pWrite_buf)
        pZip->m_pFree(pZip->m_pAlloc_opaque, pWrite_buf);

    return status == TINFL_STATUS_DONE;
}

mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip, const char *pFilename, mz_file_write_func pCallback, void *pOpaque, mz_uint flags)
{
    mz_uint32 file_index;
    if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
        return MZ_FALSE;

    return mz_zip_reader_extract_to_callback(pZip, file_index, pCallback, pOpaque, flags);
}

mz_zip_reader_extract_iter_state* mz_zip_reader_extract_iter_new(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags)
{
    mz_zip_reader_extract_iter_state *pState;
    mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;

    /* Argument sanity check */
    if ((!pZip) || (!pZip->m_pState))
        return NULL;

    /* Allocate an iterator status structure */
    pState = (mz_zip_reader_extract_iter_state*)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_reader_extract_iter_state));
    if (!pState)
    {
        mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        return NULL;
    }

    /* Fetch file details */
    if (!mz_zip_reader_file_stat(pZip, file_index, &pState->file_stat))
    {
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        return NULL;
    }

    /* Encryption and patch files are not supported. */
    if (pState->file_stat.m_bit_flag & (MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_IS_ENCRYPTED | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_USES_STRONG_ENCRYPTION | MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_COMPRESSED_PATCH_FLAG))
    {
        mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        return NULL;
    }

    /* This function only supports decompressing stored and deflate. */
    if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (pState->file_stat.m_method != 0) && (pState->file_stat.m_method != MZ_DEFLATED))
    {
        mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        return NULL;
    }

    /* Init state - save args */
    pState->pZip = pZip;
    pState->flags = flags;

    /* Init state - reset variables to defaults */
    pState->status = TINFL_STATUS_DONE;
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
    pState->file_crc32 = MZ_CRC32_INIT;
#endif
    pState->read_buf_ofs = 0;
    pState->out_buf_ofs = 0;
    pState->pRead_buf = NULL;
    pState->pWrite_buf = NULL;
    pState->out_blk_remain = 0;

    /* Read and parse the local directory entry. */
    pState->cur_file_ofs = pState->file_stat.m_local_header_ofs;
    if (pZip->m_pRead(pZip->m_pIO_opaque, pState->cur_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
    {
        mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        return NULL;
    }

    if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
    {
        mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        return NULL;
    }

    pState->cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) + MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
    if ((pState->cur_file_ofs + pState->file_stat.m_comp_size) > pZip->m_archive_size)
    {
        mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
        return NULL;
    }

    /* Decompress the file either directly from memory or from a file input buffer. */
    if (pZip->m_pState->m_pMem)
    {
        pState->pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + pState->cur_file_ofs;
        pState->read_buf_size = pState->read_buf_avail = pState->file_stat.m_comp_size;
        pState->comp_remaining = pState->file_stat.m_comp_size;
    }
    else
    {
        if (!((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!pState->file_stat.m_method)))
        {
            /* Decompression required, therefore intermediate read buffer required */
            pState->read_buf_size = MZ_MIN(pState->file_stat.m_comp_size, (mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE);
            if (NULL == (pState->pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)pState->read_buf_size)))
            {
                mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
                pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
                return NULL;
            }
        }
        else
        {
            /* Decompression not required - we will be reading directly into user buffer, no temp buf required */
            pState->read_buf_size = 0;
        }
        pState->read_buf_avail = 0;
        pState->comp_remaining = pState->file_stat.m_comp_size;
    }

    if (!((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!pState->file_stat.m_method)))
    {
        /* Decompression required, init decompressor */
        tinfl_init( &pState->inflator );

        /* Allocate write buffer */
        if (NULL == (pState->pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, TINFL_LZ_DICT_SIZE)))
        {
            mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            if (pState->pRead_buf)
                pZip->m_pFree(pZip->m_pAlloc_opaque, pState->pRead_buf);
            pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
            return NULL;
        }
    }

    return pState;
}

mz_zip_reader_extract_iter_state* mz_zip_reader_extract_file_iter_new(mz_zip_archive *pZip, const char *pFilename, mz_uint flags)
{
    mz_uint32 file_index;

    /* Locate file index by name */
    if (!mz_zip_reader_locate_file_v2(pZip, pFilename, NULL, flags, &file_index))
        return NULL;

    /* Construct iterator */
    return mz_zip_reader_extract_iter_new(pZip, file_index, flags);
}

size_t mz_zip_reader_extract_iter_read(mz_zip_reader_extract_iter_state* pState, void* pvBuf, size_t buf_size)
{
    size_t copied_to_caller = 0;

    /* Argument sanity check */
    if ((!pState) || (!pState->pZip) || (!pState->pZip->m_pState) || (!pvBuf))
        return 0;

    if ((pState->flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!pState->file_stat.m_method))
    {
        /* The file is stored or the caller has requested the compressed data, calc amount to return. */
        copied_to_caller = (size_t)MZ_MIN( buf_size, pState->comp_remaining );

        /* Zip is in memory....or requires reading from a file? */
        if (pState->pZip->m_pState->m_pMem)
        {
            /* Copy data to caller's buffer */
            memcpy( pvBuf, pState->pRead_buf, copied_to_caller );
            pState->pRead_buf = ((mz_uint8*)pState->pRead_buf) + copied_to_caller;
        }
        else
        {
            /* Read directly into caller's buffer */
            if (pState->pZip->m_pRead(pState->pZip->m_pIO_opaque, pState->cur_file_ofs, pvBuf, copied_to_caller) != copied_to_caller)
            {
                /* Failed to read all that was asked for, flag failure and alert user */
                mz_zip_set_error(pState->pZip, MZ_ZIP_FILE_READ_FAILED);
                pState->status = TINFL_STATUS_FAILED;
                copied_to_caller = 0;
            }
        }

#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
        /* Compute CRC if not returning compressed data only */
        if (!(pState->flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
            pState->file_crc32 = (mz_uint32)mz_crc32(pState->file_crc32, (const mz_uint8 *)pvBuf, copied_to_caller);
#endif

        /* Advance offsets, dec counters */
        pState->cur_file_ofs += copied_to_caller;
        pState->out_buf_ofs += copied_to_caller;
        pState->comp_remaining -= copied_to_caller;
    }
    else
    {
        do
        {
            /* Calc ptr to write buffer - given current output pos and block size */
            mz_uint8 *pWrite_buf_cur = (mz_uint8 *)pState->pWrite_buf + (pState->out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));

            /* Calc max output size - given current output pos and block size */
            size_t in_buf_size, out_buf_size = TINFL_LZ_DICT_SIZE - (pState->out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));

            if (!pState->out_blk_remain)
            {
                /* Read more data from file if none available (and reading from file) */
                if ((!pState->read_buf_avail) && (!pState->pZip->m_pState->m_pMem))
                {
                    /* Calc read size */
                    pState->read_buf_avail = MZ_MIN(pState->read_buf_size, pState->comp_remaining);
                    if (pState->pZip->m_pRead(pState->pZip->m_pIO_opaque, pState->cur_file_ofs, pState->pRead_buf, (size_t)pState->read_buf_avail) != pState->read_buf_avail)
                    {
                        mz_zip_set_error(pState->pZip, MZ_ZIP_FILE_READ_FAILED);
                        pState->status = TINFL_STATUS_FAILED;
                        break;
                    }

                    /* Advance offsets, dec counters */
                    pState->cur_file_ofs += pState->read_buf_avail;
                    pState->comp_remaining -= pState->read_buf_avail;
                    pState->read_buf_ofs = 0;
                }

                /* Perform decompression */
                in_buf_size = (size_t)pState->read_buf_avail;
                pState->status = tinfl_decompress(&pState->inflator, (const mz_uint8 *)pState->pRead_buf + pState->read_buf_ofs, &in_buf_size, (mz_uint8 *)pState->pWrite_buf, pWrite_buf_cur, &out_buf_size, pState->comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);
                pState->read_buf_avail -= in_buf_size;
                pState->read_buf_ofs += in_buf_size;

                /* Update current output block size remaining */
                pState->out_blk_remain = out_buf_size;
            }

            if (pState->out_blk_remain)
            {
                /* Calc amount to return. */
                size_t to_copy = MZ_MIN( (buf_size - copied_to_caller), pState->out_blk_remain );

                /* Copy data to caller's buffer */
                memcpy( (mz_uint8*)pvBuf + copied_to_caller, pWrite_buf_cur, to_copy );

#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
                /* Perform CRC */
                pState->file_crc32 = (mz_uint32)mz_crc32(pState->file_crc32, pWrite_buf_cur, to_copy);
#endif

                /* Decrement data consumed from block */
                pState->out_blk_remain -= to_copy;

                /* Inc output offset, while performing sanity check */
                if ((pState->out_buf_ofs += to_copy) > pState->file_stat.m_uncomp_size)
                {
                    mz_zip_set_error(pState->pZip, MZ_ZIP_DECOMPRESSION_FAILED);
                    pState->status = TINFL_STATUS_FAILED;
                    break;
                }

                /* Increment counter of data copied to caller */
                copied_to_caller += to_copy;
            }
        } while ( (copied_to_caller < buf_size) && ((pState->status == TINFL_STATUS_NEEDS_MORE_INPUT) || (pState->status == TINFL_STATUS_HAS_MORE_OUTPUT)) );
    }

    /* Return how many bytes were copied into user buffer */
    return copied_to_caller;
}

mz_bool mz_zip_reader_extract_iter_free(mz_zip_reader_extract_iter_state* pState)
{
    int status;

    /* Argument sanity check */
    if ((!pState) || (!pState->pZip) || (!pState->pZip->m_pState))
        return MZ_FALSE;

    /* Was decompression completed and requested? */
    if ((pState->status == TINFL_STATUS_DONE) && (!(pState->flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
    {
        /* Make sure the entire file was decompressed, and check its CRC. */
        if (pState->out_buf_ofs != pState->file_stat.m_uncomp_size)
        {
            mz_zip_set_error(pState->pZip, MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE);
            pState->status = TINFL_STATUS_FAILED;
        }
#ifndef MINIZ_DISABLE_ZIP_READER_CRC32_CHECKS
        else if (pState->file_crc32 != pState->file_stat.m_crc32)
        {
            mz_zip_set_error(pState->pZip, MZ_ZIP_DECOMPRESSION_FAILED);
            pState->status = TINFL_STATUS_FAILED;
        }
#endif
    }

    /* Free buffers */
    if (!pState->pZip->m_pState->m_pMem)
        pState->pZip->m_pFree(pState->pZip->m_pAlloc_opaque, pState->pRead_buf);
    if (pState->pWrite_buf)
        pState->pZip->m_pFree(pState->pZip->m_pAlloc_opaque, pState->pWrite_buf);

    /* Save status */
    status = pState->status;

    /* Free context */
    pState->pZip->m_pFree(pState->pZip->m_pAlloc_opaque, pState);

    return status == TINFL_STATUS_DONE;
}

#ifndef MINIZ_NO_STDIO
static size_t mz_zip_file_write_callback(void *pOpaque, mz_uint64 ofs, const void *pBuf, size_t n)
{
    (void)ofs;

    return MZ_FWRITE(pBuf, 1, n, (MZ_FILE *)pOpaque);
}

mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index, const char *pDst_filename, mz_uint flags)
{
    mz_bool status;
    mz_zip_archive_file_stat file_stat;
    MZ_FILE *pFile;

    if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
        return MZ_FALSE;

    if ((file_stat.m_is_directory) || (!file_stat.m_is_supported))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);

    pFile = MZ_FOPEN(pDst_filename, "wb");
    if (!pFile)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);

    status = mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_file_write_callback, pFile, flags);

    if (MZ_FCLOSE(pFile) == EOF)
    {
        if (status)
            mz_zip_set_error(pZip, MZ_ZIP_FILE_CLOSE_FAILED);

        status = MZ_FALSE;
    }

#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_STDIO)
    if (status)
        mz_zip_set_file_times(pDst_filename, file_stat.m_time, file_stat.m_time);
#endif

    return status;
}

mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip, const char *pArchive_filename, const char *pDst_filename, mz_uint flags)
{
    mz_uint32 file_index;
    if (!mz_zip_reader_locate_file_v2(pZip, pArchive_filename, NULL, flags, &file_index))
        return MZ_FALSE;

    return mz_zip_reader_extract_to_file(pZip, file_index, pDst_filename, flags);
}

mz_bool mz_zip_reader_extract_to_cfile(mz_zip_archive *pZip, mz_uint file_index, MZ_FILE *pFile, mz_uint flags)
{
    mz_zip_archive_file_stat file_stat;

    if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
        return MZ_FALSE;

    if ((file_stat.m_is_directory) || (!file_stat.m_is_supported))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);

    return mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_file_write_callback, pFile, flags);
}

mz_bool mz_zip_reader_extract_file_to_cfile(mz_zip_archive *pZip, const char *pArchive_filename, MZ_FILE *pFile, mz_uint flags)
{
    mz_uint32 file_index;
    if (!mz_zip_reader_locate_file_v2(pZip, pArchive_filename, NULL, flags, &file_index))
        return MZ_FALSE;

    return mz_zip_reader_extract_to_cfile(pZip, file_index, pFile, flags);
}
#endif /* #ifndef MINIZ_NO_STDIO */

static size_t mz_zip_compute_crc32_callback(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
{
    mz_uint32 *p = (mz_uint32 *)pOpaque;
    (void)file_ofs;
    *p = (mz_uint32)mz_crc32(*p, (const mz_uint8 *)pBuf, n);
    return n;
}

mz_bool mz_zip_validate_file(mz_zip_archive *pZip, mz_uint file_index, mz_uint flags)
{
    mz_zip_archive_file_stat file_stat;
    mz_zip_internal_state *pState;
    const mz_uint8 *pCentral_dir_header;
    mz_bool found_zip64_ext_data_in_cdir = MZ_FALSE;
    mz_bool found_zip64_ext_data_in_ldir = MZ_FALSE;
    mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
    mz_uint64 local_header_ofs = 0;
    mz_uint32 local_header_filename_len, local_header_extra_len, local_header_crc32;
    mz_uint64 local_header_comp_size, local_header_uncomp_size;
    mz_uint32 uncomp_crc32 = MZ_CRC32_INIT;
    mz_bool has_data_descriptor;
    mz_uint32 local_header_bit_flags;

    mz_zip_array file_data_array;
    mz_zip_array_init(&file_data_array, 1);

    if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || (!pZip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (file_index > pZip->m_total_files)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pState = pZip->m_pState;

    pCentral_dir_header = mz_zip_get_cdh(pZip, file_index);

    if (!mz_zip_file_stat_internal(pZip, file_index, pCentral_dir_header, &file_stat, &found_zip64_ext_data_in_cdir))
        return MZ_FALSE;

    /* A directory or zero length file */
    if ((file_stat.m_is_directory) || (!file_stat.m_uncomp_size))
        return MZ_TRUE;

    /* Encryption and patch files are not supported. */
    if (file_stat.m_is_encrypted)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_ENCRYPTION);

    /* This function only supports stored and deflate. */
    if ((file_stat.m_method != 0) && (file_stat.m_method != MZ_DEFLATED))
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_METHOD);

    if (!file_stat.m_is_supported)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_FEATURE);

    /* Read and parse the local directory entry. */
    local_header_ofs = file_stat.m_local_header_ofs;
    if (pZip->m_pRead(pZip->m_pIO_opaque, local_header_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

    if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    local_header_filename_len = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS);
    local_header_extra_len = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
    local_header_comp_size = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS);
    local_header_uncomp_size = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS);
    local_header_crc32 = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_CRC32_OFS);
    local_header_bit_flags = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS);
    has_data_descriptor = (local_header_bit_flags & 8) != 0;

    if (local_header_filename_len != strlen(file_stat.m_filename))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    if ((local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + local_header_filename_len + local_header_extra_len + file_stat.m_comp_size) > pZip->m_archive_size)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    if (!mz_zip_array_resize(pZip, &file_data_array, MZ_MAX(local_header_filename_len, local_header_extra_len), MZ_FALSE))
    {
        mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        goto handle_failure;
    }

    if (local_header_filename_len)
    {
        if (pZip->m_pRead(pZip->m_pIO_opaque, local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE, file_data_array.m_p, local_header_filename_len) != local_header_filename_len)
        {
            mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
            goto handle_failure;
        }

        /* I've seen 1 archive that had the same pathname, but used backslashes in the local dir and forward slashes in the central dir. Do we care about this? For now, this case will fail validation. */
        if (memcmp(file_stat.m_filename, file_data_array.m_p, local_header_filename_len) != 0)
        {
            mz_zip_set_error(pZip, MZ_ZIP_VALIDATION_FAILED);
            goto handle_failure;
        }
    }

    if ((local_header_extra_len) && ((local_header_comp_size == MZ_UINT32_MAX) || (local_header_uncomp_size == MZ_UINT32_MAX)))
    {
        mz_uint32 extra_size_remaining = local_header_extra_len;
        const mz_uint8 *pExtra_data = (const mz_uint8 *)file_data_array.m_p;

        if (pZip->m_pRead(pZip->m_pIO_opaque, local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + local_header_filename_len, file_data_array.m_p, local_header_extra_len) != local_header_extra_len)
        {
            mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
            goto handle_failure;
        }

        do
        {
            mz_uint32 field_id, field_data_size, field_total_size;

            if (extra_size_remaining < (sizeof(mz_uint16) * 2))
            {
                mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                goto handle_failure;
            }

            field_id = MZ_READ_LE16(pExtra_data);
            field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));
            field_total_size = field_data_size + sizeof(mz_uint16) * 2;

            if (field_total_size > extra_size_remaining)
            {
                mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                goto handle_failure;
            }

            if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
            {
                const mz_uint8 *pSrc_field_data = pExtra_data + sizeof(mz_uint32);

                if (field_data_size < sizeof(mz_uint64) * 2)
                {
                    mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                    goto handle_failure;
                }

                local_header_uncomp_size = MZ_READ_LE64(pSrc_field_data);
                local_header_comp_size = MZ_READ_LE64(pSrc_field_data + sizeof(mz_uint64));

                found_zip64_ext_data_in_ldir = MZ_TRUE;
                break;
            }

            pExtra_data += field_total_size;
            extra_size_remaining -= field_total_size;
        } while (extra_size_remaining);
    }

    /* TODO: parse local header extra data when local_header_comp_size is 0xFFFFFFFF! (big_descriptor.zip) */
    /* I've seen zips in the wild with the data descriptor bit set, but proper local header values and bogus data descriptors */
    if ((has_data_descriptor) && (!local_header_comp_size) && (!local_header_crc32))
    {
        mz_uint8 descriptor_buf[32];
        mz_bool has_id;
        const mz_uint8 *pSrc;
        mz_uint32 file_crc32;
        mz_uint64 comp_size = 0, uncomp_size = 0;

        mz_uint32 num_descriptor_uint32s = ((pState->m_zip64) || (found_zip64_ext_data_in_ldir)) ? 6 : 4;

        if (pZip->m_pRead(pZip->m_pIO_opaque, local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + local_header_filename_len + local_header_extra_len + file_stat.m_comp_size, descriptor_buf, sizeof(mz_uint32) * num_descriptor_uint32s) != (sizeof(mz_uint32) * num_descriptor_uint32s))
        {
            mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
            goto handle_failure;
        }

        has_id = (MZ_READ_LE32(descriptor_buf) == MZ_ZIP_DATA_DESCRIPTOR_ID);
        pSrc = has_id ? (descriptor_buf + sizeof(mz_uint32)) : descriptor_buf;

        file_crc32 = MZ_READ_LE32(pSrc);

        if ((pState->m_zip64) || (found_zip64_ext_data_in_ldir))
        {
            comp_size = MZ_READ_LE64(pSrc + sizeof(mz_uint32));
            uncomp_size = MZ_READ_LE64(pSrc + sizeof(mz_uint32) + sizeof(mz_uint64));
        }
        else
        {
            comp_size = MZ_READ_LE32(pSrc + sizeof(mz_uint32));
            uncomp_size = MZ_READ_LE32(pSrc + sizeof(mz_uint32) + sizeof(mz_uint32));
        }

        if ((file_crc32 != file_stat.m_crc32) || (comp_size != file_stat.m_comp_size) || (uncomp_size != file_stat.m_uncomp_size))
        {
            mz_zip_set_error(pZip, MZ_ZIP_VALIDATION_FAILED);
            goto handle_failure;
        }
    }
    else
    {
        if ((local_header_crc32 != file_stat.m_crc32) || (local_header_comp_size != file_stat.m_comp_size) || (local_header_uncomp_size != file_stat.m_uncomp_size))
        {
            mz_zip_set_error(pZip, MZ_ZIP_VALIDATION_FAILED);
            goto handle_failure;
        }
    }

    mz_zip_array_clear(pZip, &file_data_array);

    if ((flags & MZ_ZIP_FLAG_VALIDATE_HEADERS_ONLY) == 0)
    {
        if (!mz_zip_reader_extract_to_callback(pZip, file_index, mz_zip_compute_crc32_callback, &uncomp_crc32, 0))
            return MZ_FALSE;

        /* 1 more check to be sure, although the extract checks too. */
        if (uncomp_crc32 != file_stat.m_crc32)
        {
            mz_zip_set_error(pZip, MZ_ZIP_VALIDATION_FAILED);
            return MZ_FALSE;
        }
    }

    return MZ_TRUE;

handle_failure:
    mz_zip_array_clear(pZip, &file_data_array);
    return MZ_FALSE;
}

mz_bool mz_zip_validate_archive(mz_zip_archive *pZip, mz_uint flags)
{
    mz_zip_internal_state *pState;
    mz_uint32 i;

    if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || (!pZip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pState = pZip->m_pState;

    /* Basic sanity checks */
    if (!pState->m_zip64)
    {
        if (pZip->m_total_files > MZ_UINT16_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);

        if (pZip->m_archive_size > MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
    }
    else
    {
        if (pState->m_central_dir.m_size >= MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
    }

    for (i = 0; i < pZip->m_total_files; i++)
    {
        if (MZ_ZIP_FLAG_VALIDATE_LOCATE_FILE_FLAG & flags)
        {
            mz_uint32 found_index;
            mz_zip_archive_file_stat stat;

            if (!mz_zip_reader_file_stat(pZip, i, &stat))
                return MZ_FALSE;

            if (!mz_zip_reader_locate_file_v2(pZip, stat.m_filename, NULL, 0, &found_index))
                return MZ_FALSE;

            /* This check can fail if there are duplicate filenames in the archive (which we don't check for when writing - that's up to the user) */
            if (found_index != i)
                return mz_zip_set_error(pZip, MZ_ZIP_VALIDATION_FAILED);
        }

        if (!mz_zip_validate_file(pZip, i, flags))
            return MZ_FALSE;
    }

    return MZ_TRUE;
}

mz_bool mz_zip_validate_mem_archive(const void *pMem, size_t size, mz_uint flags, mz_zip_error *pErr)
{
    mz_bool success = MZ_TRUE;
    mz_zip_archive zip;
    mz_zip_error actual_err = MZ_ZIP_NO_ERROR;

    if ((!pMem) || (!size))
    {
        if (pErr)
            *pErr = MZ_ZIP_INVALID_PARAMETER;
        return MZ_FALSE;
    }

    mz_zip_zero_struct(&zip);

    if (!mz_zip_reader_init_mem(&zip, pMem, size, flags))
    {
        if (pErr)
            *pErr = zip.m_last_error;
        return MZ_FALSE;
    }

    if (!mz_zip_validate_archive(&zip, flags))
    {
        actual_err = zip.m_last_error;
        success = MZ_FALSE;
    }

    if (!mz_zip_reader_end_internal(&zip, success))
    {
        if (!actual_err)
            actual_err = zip.m_last_error;
        success = MZ_FALSE;
    }

    if (pErr)
        *pErr = actual_err;

    return success;
}

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_validate_file_archive(const char *pFilename, mz_uint flags, mz_zip_error *pErr)
{
    mz_bool success = MZ_TRUE;
    mz_zip_archive zip;
    mz_zip_error actual_err = MZ_ZIP_NO_ERROR;

    if (!pFilename)
    {
        if (pErr)
            *pErr = MZ_ZIP_INVALID_PARAMETER;
        return MZ_FALSE;
    }

    mz_zip_zero_struct(&zip);

    if (!mz_zip_reader_init_file_v2(&zip, pFilename, flags, 0, 0))
    {
        if (pErr)
            *pErr = zip.m_last_error;
        return MZ_FALSE;
    }

    if (!mz_zip_validate_archive(&zip, flags))
    {
        actual_err = zip.m_last_error;
        success = MZ_FALSE;
    }

    if (!mz_zip_reader_end_internal(&zip, success))
    {
        if (!actual_err)
            actual_err = zip.m_last_error;
        success = MZ_FALSE;
    }

    if (pErr)
        *pErr = actual_err;

    return success;
}
#endif /* #ifndef MINIZ_NO_STDIO */

/* ------------------- .ZIP archive writing */

#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

static MZ_FORCEINLINE void mz_write_le16(mz_uint8 *p, mz_uint16 v)
{
    p[0] = (mz_uint8)v;
    p[1] = (mz_uint8)(v >> 8);
}
static MZ_FORCEINLINE void mz_write_le32(mz_uint8 *p, mz_uint32 v)
{
    p[0] = (mz_uint8)v;
    p[1] = (mz_uint8)(v >> 8);
    p[2] = (mz_uint8)(v >> 16);
    p[3] = (mz_uint8)(v >> 24);
}
static MZ_FORCEINLINE void mz_write_le64(mz_uint8 *p, mz_uint64 v)
{
    mz_write_le32(p, (mz_uint32)v);
    mz_write_le32(p + sizeof(mz_uint32), (mz_uint32)(v >> 32));
}

#define MZ_WRITE_LE16(p, v) mz_write_le16((mz_uint8 *)(p), (mz_uint16)(v))
#define MZ_WRITE_LE32(p, v) mz_write_le32((mz_uint8 *)(p), (mz_uint32)(v))
#define MZ_WRITE_LE64(p, v) mz_write_le64((mz_uint8 *)(p), (mz_uint64)(v))

static size_t mz_zip_heap_write_func(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
{
    mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
    mz_zip_internal_state *pState = pZip->m_pState;
    mz_uint64 new_size = MZ_MAX(file_ofs + n, pState->m_mem_size);

    if (!n)
        return 0;

    /* An allocation this big is likely to just fail on 32-bit systems, so don't even go there. */
    if ((sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF))
    {
        mz_zip_set_error(pZip, MZ_ZIP_FILE_TOO_LARGE);
        return 0;
    }

    if (new_size > pState->m_mem_capacity)
    {
        void *pNew_block;
        size_t new_capacity = MZ_MAX(64, pState->m_mem_capacity);

        while (new_capacity < new_size)
            new_capacity *= 2;

        if (NULL == (pNew_block = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pState->m_pMem, 1, pState->m_mem_capacity, 1, new_capacity)))
        {
            mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            return 0;
        }

        pState->m_pMem = pNew_block;
        pState->m_mem_capacity = new_capacity;
    }
    memcpy((mz_uint8 *)pState->m_pMem + file_ofs, pBuf, n);
    pState->m_mem_size = (size_t)new_size;
    return n;
}

static mz_bool mz_zip_writer_end_internal(mz_zip_archive *pZip, mz_bool set_last_error)
{
    mz_zip_internal_state *pState;
    mz_bool status = MZ_TRUE;

    if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) || ((pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) && (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED)))
    {
        if (set_last_error)
            mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        return MZ_FALSE;
    }

    pState = pZip->m_pState;
    pZip->m_pState = NULL;
    mz_zip_array_clear(pZip, &pState->m_central_dir);
    mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
    mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);

#ifndef MINIZ_NO_STDIO
    if (pState->m_pFile)
    {
        if (pZip->m_zip_type == MZ_ZIP_TYPE_FILE)
        {
            if (MZ_FCLOSE(pState->m_pFile) == EOF)
            {
                if (set_last_error)
                    mz_zip_set_error(pZip, MZ_ZIP_FILE_CLOSE_FAILED);
                status = MZ_FALSE;
            }
        }

        pState->m_pFile = NULL;
    }
#endif /* #ifndef MINIZ_NO_STDIO */

    if ((pZip->m_pWrite == mz_zip_heap_write_func) && (pState->m_pMem))
    {
        pZip->m_pFree(pZip->m_pAlloc_opaque, pState->m_pMem);
        pState->m_pMem = NULL;
    }

    pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
    pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
    return status;
}

mz_bool mz_zip_writer_init_v2(mz_zip_archive *pZip, mz_uint64 existing_size, mz_uint flags)
{
    mz_bool zip64 = (flags & MZ_ZIP_FLAG_WRITE_ZIP64) != 0;

    if (!pZip) {
        printf("No zip\n");
    }

    if (pZip->m_pState) {
        printf("State Prsent\n");
    }

    if(!pZip->m_pWrite) {
        printf("No Write\n");
    }
    if (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID) {
        printf("Invalid Mode\n");
    }

    if ((!pZip) || (pZip->m_pState) || (!pZip->m_pWrite) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID)) {
        printf("State\n");
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
    }

    if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
    {
        if (!pZip->m_pRead) {
            printf("READ\n");
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        }
    }

    if (pZip->m_file_offset_alignment)
    {
        /* Ensure user specified file offset alignment is a power of 2. */
        if (pZip->m_file_offset_alignment & (pZip->m_file_offset_alignment - 1)) {
            printf("Alignment\n");
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        }
    }

    if (!pZip->m_pAlloc)
        pZip->m_pAlloc = miniz_def_alloc_func;
    if (!pZip->m_pFree)
        pZip->m_pFree = miniz_def_free_func;
    if (!pZip->m_pRealloc)
        pZip->m_pRealloc = miniz_def_realloc_func;

    pZip->m_archive_size = existing_size;
    pZip->m_central_directory_file_ofs = 0;
    pZip->m_total_files = 0;

    if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

    memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));

    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir, sizeof(mz_uint8));
    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets, sizeof(mz_uint32));
    MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets, sizeof(mz_uint32));

    pZip->m_pState->m_zip64 = zip64;
    pZip->m_pState->m_zip64_has_extended_info_fields = zip64;

    pZip->m_zip_type = MZ_ZIP_TYPE_USER;
    pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;

    return MZ_TRUE;
}

mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size)
{
    return mz_zip_writer_init_v2(pZip, existing_size, 0);
}

mz_bool mz_zip_writer_init_heap_v2(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size, mz_uint flags)
{
    pZip->m_pWrite = mz_zip_heap_write_func;
    pZip->m_pNeeds_keepalive = NULL;

    if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
        pZip->m_pRead = mz_zip_mem_read_func;

    pZip->m_pIO_opaque = pZip;

    if (!mz_zip_writer_init_v2(pZip, size_to_reserve_at_beginning, flags))
        return MZ_FALSE;

    pZip->m_zip_type = MZ_ZIP_TYPE_HEAP;

    if (0 != (initial_allocation_size = MZ_MAX(initial_allocation_size, size_to_reserve_at_beginning)))
    {
        if (NULL == (pZip->m_pState->m_pMem = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, initial_allocation_size)))
        {
            mz_zip_writer_end_internal(pZip, MZ_FALSE);
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }
        pZip->m_pState->m_mem_capacity = initial_allocation_size;
    }

    return MZ_TRUE;
}

mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip, size_t size_to_reserve_at_beginning, size_t initial_allocation_size)
{
    return mz_zip_writer_init_heap_v2(pZip, size_to_reserve_at_beginning, initial_allocation_size, 0);
}

#ifndef MINIZ_NO_STDIO
static size_t mz_zip_file_write_func(void *pOpaque, mz_uint64 file_ofs, const void *pBuf, size_t n)
{
    mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
    mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);

    file_ofs += pZip->m_pState->m_file_archive_start_ofs;

    if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
    {
        mz_zip_set_error(pZip, MZ_ZIP_FILE_SEEK_FAILED);
        return 0;
    }

    return MZ_FWRITE(pBuf, 1, n, pZip->m_pState->m_pFile);
}

mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning)
{
    return mz_zip_writer_init_file_v2(pZip, pFilename, size_to_reserve_at_beginning, 0);
}

mz_bool mz_zip_writer_init_file_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint64 size_to_reserve_at_beginning, mz_uint flags)
{
    MZ_FILE *pFile;

    pZip->m_pWrite = mz_zip_file_write_func;
    pZip->m_pNeeds_keepalive = NULL;

    if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
        pZip->m_pRead = mz_zip_file_read_func;

    pZip->m_pIO_opaque = pZip;

    if (!mz_zip_writer_init_v2(pZip, size_to_reserve_at_beginning, flags))
        return MZ_FALSE;

    if (NULL == (pFile = MZ_FOPEN(pFilename, (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING) ? "w+b" : "wb")))
    {
        mz_zip_writer_end(pZip);
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);
    }

    pZip->m_pState->m_pFile = pFile;
    pZip->m_zip_type = MZ_ZIP_TYPE_FILE;

    if (size_to_reserve_at_beginning)
    {
        mz_uint64 cur_ofs = 0;
        char buf[4096];

        MZ_CLEAR_ARR(buf);

        do
        {
            size_t n = (size_t)MZ_MIN(sizeof(buf), size_to_reserve_at_beginning);
            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_ofs, buf, n) != n)
            {
                mz_zip_writer_end(pZip);
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
            }
            cur_ofs += n;
            size_to_reserve_at_beginning -= n;
        } while (size_to_reserve_at_beginning);
    }

    return MZ_TRUE;
}

mz_bool mz_zip_writer_init_cfile(mz_zip_archive *pZip, MZ_FILE *pFile, mz_uint flags)
{
    pZip->m_pWrite = mz_zip_file_write_func;
    pZip->m_pNeeds_keepalive = NULL;

    if (flags & MZ_ZIP_FLAG_WRITE_ALLOW_READING)
        pZip->m_pRead = mz_zip_file_read_func;

    pZip->m_pIO_opaque = pZip;

    if (!mz_zip_writer_init_v2(pZip, 0, flags))
        return MZ_FALSE;

    pZip->m_pState->m_pFile = pFile;
    pZip->m_pState->m_file_archive_start_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
    pZip->m_zip_type = MZ_ZIP_TYPE_CFILE;

    return MZ_TRUE;
}
#endif /* #ifndef MINIZ_NO_STDIO */

mz_bool mz_zip_writer_init_from_reader_v2(mz_zip_archive *pZip, const char *pFilename, mz_uint flags)
{
    mz_zip_internal_state *pState;

    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (flags & MZ_ZIP_FLAG_WRITE_ZIP64)
    {
        /* We don't support converting a non-zip64 file to zip64 - this seems like more trouble than it's worth. (What about the existing 32-bit data descriptors that could follow the compressed data?) */
        if (!pZip->m_pState->m_zip64)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
    }

    /* No sense in trying to write to an archive that's already at the support max size */
    if (pZip->m_pState->m_zip64)
    {
        if (pZip->m_total_files == MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }
    else
    {
        if (pZip->m_total_files == MZ_UINT16_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);

        if ((pZip->m_archive_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + MZ_ZIP_LOCAL_DIR_HEADER_SIZE) > MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_TOO_LARGE);
    }

    pState = pZip->m_pState;

    if (pState->m_pFile)
    {
#ifdef MINIZ_NO_STDIO
        (void)pFilename;
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
#else
        if (pZip->m_pIO_opaque != pZip)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        if (pZip->m_zip_type == MZ_ZIP_TYPE_FILE)
        {
            if (!pFilename)
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

            /* Archive is being read from stdio and was originally opened only for reading. Try to reopen as writable. */
            if (NULL == (pState->m_pFile = MZ_FREOPEN(pFilename, "r+b", pState->m_pFile)))
            {
                /* The mz_zip_archive is now in a bogus state because pState->m_pFile is NULL, so just close it. */
                mz_zip_reader_end_internal(pZip, MZ_FALSE);
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);
            }
        }

        pZip->m_pWrite = mz_zip_file_write_func;
        pZip->m_pNeeds_keepalive = NULL;
#endif /* #ifdef MINIZ_NO_STDIO */
    }
    else if (pState->m_pMem)
    {
        /* Archive lives in a memory block. Assume it's from the heap that we can resize using the realloc callback. */
        if (pZip->m_pIO_opaque != pZip)
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

        pState->m_mem_capacity = pState->m_mem_size;
        pZip->m_pWrite = mz_zip_heap_write_func;
        pZip->m_pNeeds_keepalive = NULL;
    }
    /* Archive is being read via a user provided read function - make sure the user has specified a write function too. */
    else if (!pZip->m_pWrite)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    /* Start writing new files at the archive's current central directory location. */
    /* TODO: We could add a flag that lets the user start writing immediately AFTER the existing central dir - this would be safer. */
    pZip->m_archive_size = pZip->m_central_directory_file_ofs;
    pZip->m_central_directory_file_ofs = 0;

    /* Clear the sorted central dir offsets, they aren't useful or maintained now. */
    /* Even though we're now in write mode, files can still be extracted and verified, but file locates will be slow. */
    /* TODO: We could easily maintain the sorted central directory offsets. */
    mz_zip_array_clear(pZip, &pZip->m_pState->m_sorted_central_dir_offsets);

    pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;

    return MZ_TRUE;
}

mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip, const char *pFilename)
{
    return mz_zip_writer_init_from_reader_v2(pZip, pFilename, 0);
}

/* TODO: pArchive_name is a terrible name here! */
mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, mz_uint level_and_flags)
{
    return mz_zip_writer_add_mem_ex(pZip, pArchive_name, pBuf, buf_size, NULL, 0, level_and_flags, 0, 0);
}

typedef struct
{
    mz_zip_archive *m_pZip;
    mz_uint64 m_cur_archive_file_ofs;
    mz_uint64 m_comp_size;
} mz_zip_writer_add_state;

static mz_bool mz_zip_writer_add_put_buf_callback(const void *pBuf, int len, void *pUser)
{
    mz_zip_writer_add_state *pState = (mz_zip_writer_add_state *)pUser;
    if ((int)pState->m_pZip->m_pWrite(pState->m_pZip->m_pIO_opaque, pState->m_cur_archive_file_ofs, pBuf, len) != len)
        return MZ_FALSE;

    pState->m_cur_archive_file_ofs += len;
    pState->m_comp_size += len;
    return MZ_TRUE;
}

#define MZ_ZIP64_MAX_LOCAL_EXTRA_FIELD_SIZE (sizeof(mz_uint16) * 2 + sizeof(mz_uint64) * 2)
#define MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE (sizeof(mz_uint16) * 2 + sizeof(mz_uint64) * 3)
static mz_uint32 mz_zip_writer_create_zip64_extra_data(mz_uint8 *pBuf, mz_uint64 *pUncomp_size, mz_uint64 *pComp_size, mz_uint64 *pLocal_header_ofs)
{
    mz_uint8 *pDst = pBuf;
    mz_uint32 field_size = 0;

    MZ_WRITE_LE16(pDst + 0, MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID);
    MZ_WRITE_LE16(pDst + 2, 0);
    pDst += sizeof(mz_uint16) * 2;

    if (pUncomp_size)
    {
        MZ_WRITE_LE64(pDst, *pUncomp_size);
        pDst += sizeof(mz_uint64);
        field_size += sizeof(mz_uint64);
    }

    if (pComp_size)
    {
        MZ_WRITE_LE64(pDst, *pComp_size);
        pDst += sizeof(mz_uint64);
        field_size += sizeof(mz_uint64);
    }

    if (pLocal_header_ofs)
    {
        MZ_WRITE_LE64(pDst, *pLocal_header_ofs);
        pDst += sizeof(mz_uint64);
        field_size += sizeof(mz_uint64);
    }

    MZ_WRITE_LE16(pBuf + 2, field_size);

    return (mz_uint32)(pDst - pBuf);
}

static mz_bool mz_zip_writer_create_local_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size, mz_uint16 extra_size, mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date)
{
    (void)pZip;
    memset(pDst, 0, MZ_ZIP_LOCAL_DIR_HEADER_SIZE);
    MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_SIG_OFS, MZ_ZIP_LOCAL_DIR_HEADER_SIG);
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_VERSION_NEEDED_OFS, method ? 20 : 0);
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_BIT_FLAG_OFS, bit_flags);
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_METHOD_OFS, method);
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_TIME_OFS, dos_time);
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_DATE_OFS, dos_date);
    MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_CRC32_OFS, uncomp_crc32);
    MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS, MZ_MIN(comp_size, MZ_UINT32_MAX));
    MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS, MZ_MIN(uncomp_size, MZ_UINT32_MAX));
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILENAME_LEN_OFS, filename_size);
    MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_EXTRA_LEN_OFS, extra_size);
    return MZ_TRUE;
}

static mz_bool mz_zip_writer_create_central_dir_header(mz_zip_archive *pZip, mz_uint8 *pDst,
                                                       mz_uint16 filename_size, mz_uint16 extra_size, mz_uint16 comment_size,
                                                       mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32,
                                                       mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date,
                                                       mz_uint64 local_header_ofs, mz_uint32 ext_attributes)
{
    (void)pZip;
    memset(pDst, 0, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_SIG_OFS, MZ_ZIP_CENTRAL_DIR_HEADER_SIG);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_VERSION_NEEDED_OFS, method ? 20 : 0);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_BIT_FLAG_OFS, bit_flags);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_METHOD_OFS, method);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_TIME_OFS, dos_time);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_DATE_OFS, dos_date);
    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_CRC32_OFS, uncomp_crc32);
    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, MZ_MIN(comp_size, MZ_UINT32_MAX));
    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, MZ_MIN(uncomp_size, MZ_UINT32_MAX));
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILENAME_LEN_OFS, filename_size);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_EXTRA_LEN_OFS, extra_size);
    MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_COMMENT_LEN_OFS, comment_size);
    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS, ext_attributes);
    MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_LOCAL_HEADER_OFS, MZ_MIN(local_header_ofs, MZ_UINT32_MAX));
    return MZ_TRUE;
}

static mz_bool mz_zip_writer_add_to_central_dir(mz_zip_archive *pZip, const char *pFilename, mz_uint16 filename_size,
                                                const void *pExtra, mz_uint16 extra_size, const void *pComment, mz_uint16 comment_size,
                                                mz_uint64 uncomp_size, mz_uint64 comp_size, mz_uint32 uncomp_crc32,
                                                mz_uint16 method, mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date,
                                                mz_uint64 local_header_ofs, mz_uint32 ext_attributes,
                                                const char *user_extra_data, mz_uint user_extra_data_len)
{
    mz_zip_internal_state *pState = pZip->m_pState;
    mz_uint32 central_dir_ofs = (mz_uint32)pState->m_central_dir.m_size;
    size_t orig_central_dir_size = pState->m_central_dir.m_size;
    mz_uint8 central_dir_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];

    if (!pZip->m_pState->m_zip64)
    {
        if (local_header_ofs > 0xFFFFFFFF)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_TOO_LARGE);
    }

    /* miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet */
    if (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + extra_size + user_extra_data_len + comment_size) >= MZ_UINT32_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);

    if (!mz_zip_writer_create_central_dir_header(pZip, central_dir_header, filename_size, (mz_uint16)(extra_size + user_extra_data_len), comment_size, uncomp_size, comp_size, uncomp_crc32, method, bit_flags, dos_time, dos_date, local_header_ofs, ext_attributes))
        return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

    if ((!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_dir_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)) ||
        (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pFilename, filename_size)) ||
        (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pExtra, extra_size)) ||
        (!mz_zip_array_push_back(pZip, &pState->m_central_dir, user_extra_data, user_extra_data_len)) ||
        (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pComment, comment_size)) ||
        (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &central_dir_ofs, 1)))
    {
        /* Try to resize the central directory array back into its original state. */
        mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
    }

    return MZ_TRUE;
}

static mz_bool mz_zip_writer_validate_archive_name(const char *pArchive_name)
{
    /* Basic ZIP archive filename validity checks: Valid filenames cannot start with a forward slash, cannot contain a drive letter, and cannot use DOS-style backward slashes. */
    if (*pArchive_name == '/')
        return MZ_FALSE;

    /* Making sure the name does not contain drive letters or DOS style backward slashes is the responsibility of the program using miniz*/

    return MZ_TRUE;
}

static mz_uint mz_zip_writer_compute_padding_needed_for_file_alignment(mz_zip_archive *pZip)
{
    mz_uint32 n;
    if (!pZip->m_file_offset_alignment)
        return 0;
    n = (mz_uint32)(pZip->m_archive_size & (pZip->m_file_offset_alignment - 1));
    return (mz_uint)((pZip->m_file_offset_alignment - n) & (pZip->m_file_offset_alignment - 1));
}

static mz_bool mz_zip_writer_write_zeros(mz_zip_archive *pZip, mz_uint64 cur_file_ofs, mz_uint32 n)
{
    char buf[4096];
    memset(buf, 0, MZ_MIN(sizeof(buf), n));
    while (n)
    {
        mz_uint32 s = MZ_MIN(sizeof(buf), n);
        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_file_ofs, buf, s) != s)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_file_ofs += s;
        n -= s;
    }
    return MZ_TRUE;
}

mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
                                 mz_uint64 uncomp_size, mz_uint32 uncomp_crc32)
{
    return mz_zip_writer_add_mem_ex_v2(pZip, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, uncomp_size, uncomp_crc32, NULL, NULL, 0, NULL, 0);
}

mz_bool mz_zip_writer_add_mem_ex_v2(mz_zip_archive *pZip, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size,
                                    mz_uint level_and_flags, mz_uint64 uncomp_size, mz_uint32 uncomp_crc32, MZ_TIME_T *last_modified,
                                    const char *user_extra_data, mz_uint user_extra_data_len, const char *user_extra_data_central, mz_uint user_extra_data_central_len)
{
    mz_uint16 method = 0, dos_time = 0, dos_date = 0;
    mz_uint level, ext_attributes = 0, num_alignment_padding_bytes;
    mz_uint64 local_dir_header_ofs = pZip->m_archive_size, cur_archive_file_ofs = pZip->m_archive_size, comp_size = 0;
    size_t archive_name_size;
    mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
    tdefl_compressor *pComp = NULL;
    mz_bool store_data_uncompressed;
    mz_zip_internal_state *pState;
    mz_uint8 *pExtra_data = NULL;
    mz_uint32 extra_size = 0;
    mz_uint8 extra_data[MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE];
    mz_uint16 bit_flags = 0;

    if ((int)level_and_flags < 0)
        level_and_flags = MZ_DEFAULT_LEVEL;

    if (uncomp_size || (buf_size && !(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)))
        bit_flags |= MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR;

    if (!(level_and_flags & MZ_ZIP_FLAG_ASCII_FILENAME))
        bit_flags |= MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8;

    level = level_and_flags & 0xF;
    store_data_uncompressed = ((!level) || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA));

    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || ((buf_size) && (!pBuf)) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pState = pZip->m_pState;

    if (pState->m_zip64)
    {
        if (pZip->m_total_files == MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }
    else
    {
        if (pZip->m_total_files == MZ_UINT16_MAX)
        {
            pState->m_zip64 = MZ_TRUE;
            /*return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES); */
        }
        if (((mz_uint64)buf_size > 0xFFFFFFFF) || (uncomp_size > 0xFFFFFFFF))
        {
            pState->m_zip64 = MZ_TRUE;
            /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
        }
    }

    if ((!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (uncomp_size))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (!mz_zip_writer_validate_archive_name(pArchive_name))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);

#ifndef MINIZ_NO_TIME
    if (last_modified != NULL)
    {
        mz_zip_time_t_to_dos_time(*last_modified, &dos_time, &dos_date);
    }
    else
    {
        MZ_TIME_T cur_time;
        time(&cur_time);
        mz_zip_time_t_to_dos_time(cur_time, &dos_time, &dos_date);
    }
#endif /* #ifndef MINIZ_NO_TIME */

	if (!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
	{
		uncomp_crc32 = (mz_uint32)mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, buf_size);
		uncomp_size = buf_size;
		if (uncomp_size <= 3)
		{
			level = 0;
			store_data_uncompressed = MZ_TRUE;
		}
	}

    archive_name_size = strlen(pArchive_name);
    if (archive_name_size > MZ_UINT16_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);

    num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

    /* miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet */
    if (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE + comment_size) >= MZ_UINT32_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);

    if (!pState->m_zip64)
    {
        /* Bail early if the archive would obviously become too large */
        if ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + archive_name_size
			+ MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size + user_extra_data_len +
			pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE + user_extra_data_central_len
			+ MZ_ZIP_DATA_DESCRIPTER_SIZE32) > 0xFFFFFFFF)
        {
            pState->m_zip64 = MZ_TRUE;
            /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
        }
    }

    if ((archive_name_size) && (pArchive_name[archive_name_size - 1] == '/'))
    {
        /* Set DOS Subdirectory attribute bit. */
        ext_attributes |= MZ_ZIP_DOS_DIR_ATTRIBUTE_BITFLAG;

        /* Subdirectories cannot contain data. */
        if ((buf_size) || (uncomp_size))
            return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
    }

    /* Try to do any allocations before writing to the archive, so if an allocation fails the file remains unmodified. (A good idea if we're doing an in-place modification.) */
    if ((!mz_zip_array_ensure_room(pZip, &pState->m_central_dir, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + comment_size + (pState->m_zip64 ? MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE : 0))) || (!mz_zip_array_ensure_room(pZip, &pState->m_central_dir_offsets, 1)))
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

    if ((!store_data_uncompressed) && (buf_size))
    {
        if (NULL == (pComp = (tdefl_compressor *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor))))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
    }

    if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes))
    {
        pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
        return MZ_FALSE;
    }

    local_dir_header_ofs += num_alignment_padding_bytes;
    if (pZip->m_file_offset_alignment)
    {
        MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
    }
    cur_archive_file_ofs += num_alignment_padding_bytes;

    MZ_CLEAR_ARR(local_dir_header);

    if (!store_data_uncompressed || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
    {
        method = MZ_DEFLATED;
    }

    if (pState->m_zip64)
    {
        if (uncomp_size >= MZ_UINT32_MAX || local_dir_header_ofs >= MZ_UINT32_MAX)
        {
            pExtra_data = extra_data;
            extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (uncomp_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
                                                               (uncomp_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
        }

        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, (mz_uint16)(extra_size + user_extra_data_len), 0, 0, 0, method, bit_flags, dos_time, dos_date))
            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_archive_file_ofs += sizeof(local_dir_header);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }
        cur_archive_file_ofs += archive_name_size;

        if (pExtra_data != NULL)
        {
            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, extra_data, extra_size) != extra_size)
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

            cur_archive_file_ofs += extra_size;
        }
    }
    else
    {
        if ((comp_size > MZ_UINT32_MAX) || (cur_archive_file_ofs > MZ_UINT32_MAX))
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, (mz_uint16)user_extra_data_len, 0, 0, 0, method, bit_flags, dos_time, dos_date))
            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_archive_file_ofs += sizeof(local_dir_header);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }
        cur_archive_file_ofs += archive_name_size;
    }

	if (user_extra_data_len > 0)
	{
		if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, user_extra_data, user_extra_data_len) != user_extra_data_len)
			return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

		cur_archive_file_ofs += user_extra_data_len;
	}

    if (store_data_uncompressed)
    {
        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pBuf, buf_size) != buf_size)
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }

        cur_archive_file_ofs += buf_size;
        comp_size = buf_size;
    }
    else if (buf_size)
    {
        mz_zip_writer_add_state state;

        state.m_pZip = pZip;
        state.m_cur_archive_file_ofs = cur_archive_file_ofs;
        state.m_comp_size = 0;

        if ((tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY) ||
            (tdefl_compress_buffer(pComp, pBuf, buf_size, TDEFL_FINISH) != TDEFL_STATUS_DONE))
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
            return mz_zip_set_error(pZip, MZ_ZIP_COMPRESSION_FAILED);
        }

        comp_size = state.m_comp_size;
        cur_archive_file_ofs = state.m_cur_archive_file_ofs;
    }

    pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
    pComp = NULL;

    if (uncomp_size)
    {
        mz_uint8 local_dir_footer[MZ_ZIP_DATA_DESCRIPTER_SIZE64];
        mz_uint32 local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE32;

        MZ_ASSERT(bit_flags & MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR);

        MZ_WRITE_LE32(local_dir_footer + 0, MZ_ZIP_DATA_DESCRIPTOR_ID);
        MZ_WRITE_LE32(local_dir_footer + 4, uncomp_crc32);
        if (pExtra_data == NULL)
        {
            if (comp_size > MZ_UINT32_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);

            MZ_WRITE_LE32(local_dir_footer + 8, comp_size);
            MZ_WRITE_LE32(local_dir_footer + 12, uncomp_size);
        }
        else
        {
            MZ_WRITE_LE64(local_dir_footer + 8, comp_size);
            MZ_WRITE_LE64(local_dir_footer + 16, uncomp_size);
            local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE64;
        }

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_footer, local_dir_footer_size) != local_dir_footer_size)
            return MZ_FALSE;

        cur_archive_file_ofs += local_dir_footer_size;
    }

    if (pExtra_data != NULL)
    {
        extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (uncomp_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
                                                           (uncomp_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
    }

    if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, pExtra_data, (mz_uint16)extra_size, pComment,
                                          comment_size, uncomp_size, comp_size, uncomp_crc32, method, bit_flags, dos_time, dos_date, local_dir_header_ofs, ext_attributes,
                                          user_extra_data_central, user_extra_data_central_len))
        return MZ_FALSE;

    pZip->m_total_files++;
    pZip->m_archive_size = cur_archive_file_ofs;

    return MZ_TRUE;
}

mz_bool mz_zip_writer_add_read_buf_callback(mz_zip_archive *pZip, const char *pArchive_name, mz_file_read_func read_callback, void* callback_opaque, mz_uint64 max_size, const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
                                const char *user_extra_data, mz_uint user_extra_data_len, const char *user_extra_data_central, mz_uint user_extra_data_central_len)
{
    mz_uint16 gen_flags;
    mz_uint uncomp_crc32 = MZ_CRC32_INIT, level, num_alignment_padding_bytes;
    mz_uint16 method = 0, dos_time = 0, dos_date = 0, ext_attributes = 0;
    mz_uint64 local_dir_header_ofs, cur_archive_file_ofs = pZip->m_archive_size, uncomp_size = 0, comp_size = 0;
    size_t archive_name_size;
    mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
    mz_uint8 *pExtra_data = NULL;
    mz_uint32 extra_size = 0;
    mz_uint8 extra_data[MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE];
    mz_zip_internal_state *pState;
    mz_uint64 file_ofs = 0, cur_archive_header_file_ofs;

    if ((int)level_and_flags < 0)
        level_and_flags = MZ_DEFAULT_LEVEL;
    level = level_and_flags & 0xF;

    gen_flags = (level_and_flags & MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE) ? 0 : MZ_ZIP_LDH_BIT_FLAG_HAS_LOCATOR;

    if (!(level_and_flags & MZ_ZIP_FLAG_ASCII_FILENAME))
        gen_flags |= MZ_ZIP_GENERAL_PURPOSE_BIT_FLAG_UTF8;

    /* Sanity checks */
    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pArchive_name) || ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pState = pZip->m_pState;

    if ((!pState->m_zip64) && (max_size > MZ_UINT32_MAX))
    {
        /* Source file is too large for non-zip64 */
        /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
        pState->m_zip64 = MZ_TRUE;
    }

    /* We could support this, but why? */
    if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (!mz_zip_writer_validate_archive_name(pArchive_name))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);

    if (pState->m_zip64)
    {
        if (pZip->m_total_files == MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }
    else
    {
        if (pZip->m_total_files == MZ_UINT16_MAX)
        {
            pState->m_zip64 = MZ_TRUE;
            /*return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES); */
        }
    }

    archive_name_size = strlen(pArchive_name);
    if (archive_name_size > MZ_UINT16_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_FILENAME);

    num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

    /* miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet */
    if (((mz_uint64)pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + archive_name_size + MZ_ZIP64_MAX_CENTRAL_EXTRA_FIELD_SIZE + comment_size) >= MZ_UINT32_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);

    if (!pState->m_zip64)
    {
        /* Bail early if the archive would obviously become too large */
        if ((pZip->m_archive_size + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + archive_name_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE
			+ archive_name_size + comment_size + user_extra_data_len + pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE + 1024
			+ MZ_ZIP_DATA_DESCRIPTER_SIZE32 + user_extra_data_central_len) > 0xFFFFFFFF)
        {
            pState->m_zip64 = MZ_TRUE;
            /*return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); */
        }
    }

#ifndef MINIZ_NO_TIME
    if (pFile_time)
    {
        mz_zip_time_t_to_dos_time(*pFile_time, &dos_time, &dos_date);
    }
#endif

    if (max_size <= 3)
        level = 0;

    if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs, num_alignment_padding_bytes))
    {
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
    }

    cur_archive_file_ofs += num_alignment_padding_bytes;
    local_dir_header_ofs = cur_archive_file_ofs;

    if (pZip->m_file_offset_alignment)
    {
        MZ_ASSERT((cur_archive_file_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
    }

    if (max_size && level)
    {
        method = MZ_DEFLATED;
    }

    MZ_CLEAR_ARR(local_dir_header);
    if (pState->m_zip64)
    {
        if (max_size >= MZ_UINT32_MAX || local_dir_header_ofs >= MZ_UINT32_MAX)
        {
            pExtra_data = extra_data;
            if (level_and_flags & MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE)
                extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (max_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
                                                               (max_size >= MZ_UINT32_MAX) ? &comp_size : NULL,
                                                                (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
            else
                extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, NULL,
                                                                   NULL,
                                                                   (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
        }

        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, (mz_uint16)(extra_size + user_extra_data_len), 0, 0, 0, method, gen_flags, dos_time, dos_date))
            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_archive_file_ofs += sizeof(local_dir_header);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
        {
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }

        cur_archive_file_ofs += archive_name_size;

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, extra_data, extra_size) != extra_size)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_archive_file_ofs += extra_size;
    }
    else
    {
        if ((comp_size > MZ_UINT32_MAX) || (cur_archive_file_ofs > MZ_UINT32_MAX))
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header, (mz_uint16)archive_name_size, (mz_uint16)user_extra_data_len, 0, 0, 0, method, gen_flags, dos_time, dos_date))
            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_archive_file_ofs += sizeof(local_dir_header);

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
        {
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }

        cur_archive_file_ofs += archive_name_size;
    }

    if (user_extra_data_len > 0)
    {
        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, user_extra_data, user_extra_data_len) != user_extra_data_len)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        cur_archive_file_ofs += user_extra_data_len;
    }

    if (max_size)
    {
        void *pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, MZ_ZIP_MAX_IO_BUF_SIZE);
        if (!pRead_buf)
        {
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        if (!level)
        {
            while (1)
            {
                size_t n = read_callback(callback_opaque, file_ofs, pRead_buf, MZ_ZIP_MAX_IO_BUF_SIZE);
                if (n == 0)
                    break;

                if ((n > MZ_ZIP_MAX_IO_BUF_SIZE) || (file_ofs + n > max_size))
                {
                    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
                    return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                }
                if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pRead_buf, n) != n)
                {
                    pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
                    return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
                }
                file_ofs += n;
                uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, n);
                cur_archive_file_ofs += n;
            }
            uncomp_size = file_ofs;
            comp_size = uncomp_size;
        }
        else
        {
            mz_bool result = MZ_FALSE;
            mz_zip_writer_add_state state;
            tdefl_compressor *pComp = (tdefl_compressor *)pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor));
            if (!pComp)
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
                return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            }

            state.m_pZip = pZip;
            state.m_cur_archive_file_ofs = cur_archive_file_ofs;
            state.m_comp_size = 0;

            if (tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state, tdefl_create_comp_flags_from_zip_params(level, -15, MZ_DEFAULT_STRATEGY)) != TDEFL_STATUS_OKAY)
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
                pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
                return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);
            }

            for (;;)
            {
                tdefl_status status;
                tdefl_flush flush = TDEFL_NO_FLUSH;

                size_t n = read_callback(callback_opaque, file_ofs, pRead_buf, MZ_ZIP_MAX_IO_BUF_SIZE);
                if ((n > MZ_ZIP_MAX_IO_BUF_SIZE) || (file_ofs + n > max_size))
                {
                    mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
                    break;
                }

                file_ofs += n;
                uncomp_crc32 = (mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, n);

                if (pZip->m_pNeeds_keepalive != NULL && pZip->m_pNeeds_keepalive(pZip->m_pIO_opaque))
                    flush = TDEFL_FULL_FLUSH;

                if (n == 0)
                    flush = TDEFL_FINISH;

                status = tdefl_compress_buffer(pComp, pRead_buf, n, flush);
                if (status == TDEFL_STATUS_DONE)
                {
                    result = MZ_TRUE;
                    break;
                }
                else if (status != TDEFL_STATUS_OKAY)
                {
                    mz_zip_set_error(pZip, MZ_ZIP_COMPRESSION_FAILED);
                    break;
                }
            }

            pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);

            if (!result)
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
                return MZ_FALSE;
            }

            uncomp_size = file_ofs;
            comp_size = state.m_comp_size;
            cur_archive_file_ofs = state.m_cur_archive_file_ofs;
        }

        pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
    }

    if (!(level_and_flags & MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE))
    {
        mz_uint8 local_dir_footer[MZ_ZIP_DATA_DESCRIPTER_SIZE64];
        mz_uint32 local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE32;

        MZ_WRITE_LE32(local_dir_footer + 0, MZ_ZIP_DATA_DESCRIPTOR_ID);
        MZ_WRITE_LE32(local_dir_footer + 4, uncomp_crc32);
        if (pExtra_data == NULL)
        {
            if (comp_size > MZ_UINT32_MAX)
                return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);

            MZ_WRITE_LE32(local_dir_footer + 8, comp_size);
            MZ_WRITE_LE32(local_dir_footer + 12, uncomp_size);
        }
        else
        {
            MZ_WRITE_LE64(local_dir_footer + 8, comp_size);
            MZ_WRITE_LE64(local_dir_footer + 16, uncomp_size);
            local_dir_footer_size = MZ_ZIP_DATA_DESCRIPTER_SIZE64;
        }

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, local_dir_footer, local_dir_footer_size) != local_dir_footer_size)
            return MZ_FALSE;

        cur_archive_file_ofs += local_dir_footer_size;
    }

    if (level_and_flags & MZ_ZIP_FLAG_WRITE_HEADER_SET_SIZE)
    {
        if (pExtra_data != NULL)
        {
            extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (max_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
                                                               (max_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
        }

        if (!mz_zip_writer_create_local_dir_header(pZip, local_dir_header,
                                                   (mz_uint16)archive_name_size, (mz_uint16)(extra_size + user_extra_data_len),
                                                   (max_size >= MZ_UINT32_MAX) ? MZ_UINT32_MAX : uncomp_size,
                                                    (max_size >= MZ_UINT32_MAX) ? MZ_UINT32_MAX : comp_size,
                                                   uncomp_crc32, method, gen_flags, dos_time, dos_date))
            return mz_zip_set_error(pZip, MZ_ZIP_INTERNAL_ERROR);

        cur_archive_header_file_ofs = local_dir_header_ofs;

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_header_file_ofs, local_dir_header, sizeof(local_dir_header)) != sizeof(local_dir_header))
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        if (pExtra_data != NULL)
        {
            cur_archive_header_file_ofs += sizeof(local_dir_header);

            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_header_file_ofs, pArchive_name, archive_name_size) != archive_name_size)
            {
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
            }

            cur_archive_header_file_ofs += archive_name_size;

            if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_header_file_ofs, extra_data, extra_size) != extra_size)
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

            cur_archive_header_file_ofs += extra_size;
        }
    }

    if (pExtra_data != NULL)
    {
        extra_size = mz_zip_writer_create_zip64_extra_data(extra_data, (uncomp_size >= MZ_UINT32_MAX) ? &uncomp_size : NULL,
                                                           (uncomp_size >= MZ_UINT32_MAX) ? &comp_size : NULL, (local_dir_header_ofs >= MZ_UINT32_MAX) ? &local_dir_header_ofs : NULL);
    }

    if (!mz_zip_writer_add_to_central_dir(pZip, pArchive_name, (mz_uint16)archive_name_size, pExtra_data, (mz_uint16)extra_size, pComment, comment_size,
                                          uncomp_size, comp_size, uncomp_crc32, method, gen_flags, dos_time, dos_date, local_dir_header_ofs, ext_attributes,
                                          user_extra_data_central, user_extra_data_central_len))
        return MZ_FALSE;

    pZip->m_total_files++;
    pZip->m_archive_size = cur_archive_file_ofs;

    return MZ_TRUE;
}

#ifndef MINIZ_NO_STDIO

static size_t mz_file_read_func_stdio(void *pOpaque, mz_uint64 file_ofs, void *pBuf, size_t n)
{
	MZ_FILE *pSrc_file = (MZ_FILE *)pOpaque;
	mz_int64 cur_ofs = MZ_FTELL64(pSrc_file);

	if (((mz_int64)file_ofs < 0) || (((cur_ofs != (mz_int64)file_ofs)) && (MZ_FSEEK64(pSrc_file, (mz_int64)file_ofs, SEEK_SET))))
		return 0;

	return MZ_FREAD(pBuf, 1, n, pSrc_file);
}

mz_bool mz_zip_writer_add_cfile(mz_zip_archive *pZip, const char *pArchive_name, MZ_FILE *pSrc_file, mz_uint64 max_size, const MZ_TIME_T *pFile_time, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags,
	const char *user_extra_data, mz_uint user_extra_data_len, const char *user_extra_data_central, mz_uint user_extra_data_central_len)
{
	return mz_zip_writer_add_read_buf_callback(pZip, pArchive_name, mz_file_read_func_stdio, pSrc_file, max_size, pFile_time, pComment, comment_size, level_and_flags,
		user_extra_data, user_extra_data_len, user_extra_data_central, user_extra_data_central_len);
}

mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name, const char *pSrc_filename, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)
{
    MZ_FILE *pSrc_file = NULL;
    mz_uint64 uncomp_size = 0;
    MZ_TIME_T file_modified_time;
    MZ_TIME_T *pFile_time = NULL;
    mz_bool status;

    memset(&file_modified_time, 0, sizeof(file_modified_time));

#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_STDIO)
    pFile_time = &file_modified_time;
    if (!mz_zip_get_file_modified_time(pSrc_filename, &file_modified_time))
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_STAT_FAILED);
#endif

    pSrc_file = MZ_FOPEN(pSrc_filename, "rb");
    if (!pSrc_file)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_OPEN_FAILED);

    MZ_FSEEK64(pSrc_file, 0, SEEK_END);
    uncomp_size = MZ_FTELL64(pSrc_file);
    MZ_FSEEK64(pSrc_file, 0, SEEK_SET);

    status = mz_zip_writer_add_cfile(pZip, pArchive_name, pSrc_file, uncomp_size, pFile_time, pComment, comment_size, level_and_flags, NULL, 0, NULL, 0);

    MZ_FCLOSE(pSrc_file);

    return status;
}
#endif /* #ifndef MINIZ_NO_STDIO */

static mz_bool mz_zip_writer_update_zip64_extension_block(mz_zip_array *pNew_ext, mz_zip_archive *pZip, const mz_uint8 *pExt, mz_uint32 ext_len, mz_uint64 *pComp_size, mz_uint64 *pUncomp_size, mz_uint64 *pLocal_header_ofs, mz_uint32 *pDisk_start)
{
    /* + 64 should be enough for any new zip64 data */
    if (!mz_zip_array_reserve(pZip, pNew_ext, ext_len + 64, MZ_FALSE))
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

    mz_zip_array_resize(pZip, pNew_ext, 0, MZ_FALSE);

    if ((pUncomp_size) || (pComp_size) || (pLocal_header_ofs) || (pDisk_start))
    {
        mz_uint8 new_ext_block[64];
        mz_uint8 *pDst = new_ext_block;
        mz_write_le16(pDst, MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID);
        mz_write_le16(pDst + sizeof(mz_uint16), 0);
        pDst += sizeof(mz_uint16) * 2;

        if (pUncomp_size)
        {
            mz_write_le64(pDst, *pUncomp_size);
            pDst += sizeof(mz_uint64);
        }

        if (pComp_size)
        {
            mz_write_le64(pDst, *pComp_size);
            pDst += sizeof(mz_uint64);
        }

        if (pLocal_header_ofs)
        {
            mz_write_le64(pDst, *pLocal_header_ofs);
            pDst += sizeof(mz_uint64);
        }

        if (pDisk_start)
        {
            mz_write_le32(pDst, *pDisk_start);
            pDst += sizeof(mz_uint32);
        }

        mz_write_le16(new_ext_block + sizeof(mz_uint16), (mz_uint16)((pDst - new_ext_block) - sizeof(mz_uint16) * 2));

        if (!mz_zip_array_push_back(pZip, pNew_ext, new_ext_block, pDst - new_ext_block))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
    }

    if ((pExt) && (ext_len))
    {
        mz_uint32 extra_size_remaining = ext_len;
        const mz_uint8 *pExtra_data = pExt;

        do
        {
            mz_uint32 field_id, field_data_size, field_total_size;

            if (extra_size_remaining < (sizeof(mz_uint16) * 2))
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

            field_id = MZ_READ_LE16(pExtra_data);
            field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));
            field_total_size = field_data_size + sizeof(mz_uint16) * 2;

            if (field_total_size > extra_size_remaining)
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

            if (field_id != MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
            {
                if (!mz_zip_array_push_back(pZip, pNew_ext, pExtra_data, field_total_size))
                    return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
            }

            pExtra_data += field_total_size;
            extra_size_remaining -= field_total_size;
        } while (extra_size_remaining);
    }

    return MZ_TRUE;
}

/* TODO: This func is now pretty freakin complex due to zip64, split it up? */
mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip, mz_zip_archive *pSource_zip, mz_uint src_file_index)
{
    mz_uint n, bit_flags, num_alignment_padding_bytes, src_central_dir_following_data_size;
    mz_uint64 src_archive_bytes_remaining, local_dir_header_ofs;
    mz_uint64 cur_src_file_ofs, cur_dst_file_ofs;
    mz_uint32 local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) / sizeof(mz_uint32)];
    mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
    mz_uint8 new_central_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];
    size_t orig_central_dir_size;
    mz_zip_internal_state *pState;
    void *pBuf;
    const mz_uint8 *pSrc_central_header;
    mz_zip_archive_file_stat src_file_stat;
    mz_uint32 src_filename_len, src_comment_len, src_ext_len;
    mz_uint32 local_header_filename_size, local_header_extra_len;
    mz_uint64 local_header_comp_size, local_header_uncomp_size;
    mz_bool found_zip64_ext_data_in_ldir = MZ_FALSE;

    /* Sanity checks */
    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pSource_zip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pState = pZip->m_pState;

    /* Don't support copying files from zip64 archives to non-zip64, even though in some cases this is possible */
    if ((pSource_zip->m_pState->m_zip64) && (!pZip->m_pState->m_zip64))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    /* Get pointer to the source central dir header and crack it */
    if (NULL == (pSrc_central_header = mz_zip_get_cdh(pSource_zip, src_file_index)))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_SIG_OFS) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    src_filename_len = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    src_comment_len = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_COMMENT_LEN_OFS);
    src_ext_len = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS);
    src_central_dir_following_data_size = src_filename_len + src_ext_len + src_comment_len;

    /* TODO: We don't support central dir's >= MZ_UINT32_MAX bytes right now (+32 fudge factor in case we need to add more extra data) */
    if ((pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_central_dir_following_data_size + 32) >= MZ_UINT32_MAX)
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);

    num_alignment_padding_bytes = mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

    if (!pState->m_zip64)
    {
        if (pZip->m_total_files == MZ_UINT16_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }
    else
    {
        /* TODO: Our zip64 support still has some 32-bit limits that may not be worth fixing. */
        if (pZip->m_total_files == MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }

    if (!mz_zip_file_stat_internal(pSource_zip, src_file_index, pSrc_central_header, &src_file_stat, NULL))
        return MZ_FALSE;

    cur_src_file_ofs = src_file_stat.m_local_header_ofs;
    cur_dst_file_ofs = pZip->m_archive_size;

    /* Read the source archive's local dir header */
    if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);

    if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);

    cur_src_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;

    /* Compute the total size we need to copy (filename+extra data+compressed data) */
    local_header_filename_size = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS);
    local_header_extra_len = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
    local_header_comp_size = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS);
    local_header_uncomp_size = MZ_READ_LE32(pLocal_header + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS);
    src_archive_bytes_remaining = local_header_filename_size + local_header_extra_len + src_file_stat.m_comp_size;

    /* Try to find a zip64 extended information field */
    if ((local_header_extra_len) && ((local_header_comp_size == MZ_UINT32_MAX) || (local_header_uncomp_size == MZ_UINT32_MAX)))
    {
        mz_zip_array file_data_array;
        const mz_uint8 *pExtra_data;
        mz_uint32 extra_size_remaining = local_header_extra_len;

        mz_zip_array_init(&file_data_array, 1);
        if (!mz_zip_array_resize(pZip, &file_data_array, local_header_extra_len, MZ_FALSE))
        {
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, src_file_stat.m_local_header_ofs + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + local_header_filename_size, file_data_array.m_p, local_header_extra_len) != local_header_extra_len)
        {
            mz_zip_array_clear(pZip, &file_data_array);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
        }

        pExtra_data = (const mz_uint8 *)file_data_array.m_p;

        do
        {
            mz_uint32 field_id, field_data_size, field_total_size;

            if (extra_size_remaining < (sizeof(mz_uint16) * 2))
            {
                mz_zip_array_clear(pZip, &file_data_array);
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
            }

            field_id = MZ_READ_LE16(pExtra_data);
            field_data_size = MZ_READ_LE16(pExtra_data + sizeof(mz_uint16));
            field_total_size = field_data_size + sizeof(mz_uint16) * 2;

            if (field_total_size > extra_size_remaining)
            {
                mz_zip_array_clear(pZip, &file_data_array);
                return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
            }

            if (field_id == MZ_ZIP64_EXTENDED_INFORMATION_FIELD_HEADER_ID)
            {
                const mz_uint8 *pSrc_field_data = pExtra_data + sizeof(mz_uint32);

                if (field_data_size < sizeof(mz_uint64) * 2)
                {
                    mz_zip_array_clear(pZip, &file_data_array);
                    return mz_zip_set_error(pZip, MZ_ZIP_INVALID_HEADER_OR_CORRUPTED);
                }

                local_header_uncomp_size = MZ_READ_LE64(pSrc_field_data);
                local_header_comp_size = MZ_READ_LE64(pSrc_field_data + sizeof(mz_uint64)); /* may be 0 if there's a descriptor */

                found_zip64_ext_data_in_ldir = MZ_TRUE;
                break;
            }

            pExtra_data += field_total_size;
            extra_size_remaining -= field_total_size;
        } while (extra_size_remaining);

        mz_zip_array_clear(pZip, &file_data_array);
    }

    if (!pState->m_zip64)
    {
        /* Try to detect if the new archive will most likely wind up too big and bail early (+(sizeof(mz_uint32) * 4) is for the optional descriptor which could be present, +64 is a fudge factor). */
        /* We also check when the archive is finalized so this doesn't need to be perfect. */
        mz_uint64 approx_new_archive_size = cur_dst_file_ofs + num_alignment_padding_bytes + MZ_ZIP_LOCAL_DIR_HEADER_SIZE + src_archive_bytes_remaining + (sizeof(mz_uint32) * 4) +
                                            pState->m_central_dir.m_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_central_dir_following_data_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE + 64;

        if (approx_new_archive_size >= MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);
    }

    /* Write dest archive padding */
    if (!mz_zip_writer_write_zeros(pZip, cur_dst_file_ofs, num_alignment_padding_bytes))
        return MZ_FALSE;

    cur_dst_file_ofs += num_alignment_padding_bytes;

    local_dir_header_ofs = cur_dst_file_ofs;
    if (pZip->m_file_offset_alignment)
    {
        MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) == 0);
    }

    /* The original zip's local header+ext block doesn't change, even with zip64, so we can just copy it over to the dest zip */
    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) != MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

    cur_dst_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;

    /* Copy over the source archive bytes to the dest archive, also ensure we have enough buf space to handle optional data descriptor */
    if (NULL == (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)MZ_MAX(32U, MZ_MIN((mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE, src_archive_bytes_remaining)))))
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

    while (src_archive_bytes_remaining)
    {
        n = (mz_uint)MZ_MIN((mz_uint64)MZ_ZIP_MAX_IO_BUF_SIZE, src_archive_bytes_remaining);
        if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, n) != n)
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
        }
        cur_src_file_ofs += n;

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n)
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }
        cur_dst_file_ofs += n;

        src_archive_bytes_remaining -= n;
    }

    /* Now deal with the optional data descriptor */
    bit_flags = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS);
    if (bit_flags & 8)
    {
        /* Copy data descriptor */
        if ((pSource_zip->m_pState->m_zip64) || (found_zip64_ext_data_in_ldir))
        {
            /* src is zip64, dest must be zip64 */

            /* name			uint32_t's */
            /* id				1 (optional in zip64?) */
            /* crc			1 */
            /* comp_size	2 */
            /* uncomp_size 2 */
            if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, (sizeof(mz_uint32) * 6)) != (sizeof(mz_uint32) * 6))
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
            }

            n = sizeof(mz_uint32) * ((MZ_READ_LE32(pBuf) == MZ_ZIP_DATA_DESCRIPTOR_ID) ? 6 : 5);
        }
        else
        {
            /* src is NOT zip64 */
            mz_bool has_id;

            if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf, sizeof(mz_uint32) * 4) != sizeof(mz_uint32) * 4)
            {
                pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
                return mz_zip_set_error(pZip, MZ_ZIP_FILE_READ_FAILED);
            }

            has_id = (MZ_READ_LE32(pBuf) == MZ_ZIP_DATA_DESCRIPTOR_ID);

            if (pZip->m_pState->m_zip64)
            {
                /* dest is zip64, so upgrade the data descriptor */
                const mz_uint8 *pSrc_descriptor = (const mz_uint8 *)pBuf + (has_id ? sizeof(mz_uint32) : 0);
                const mz_uint32 src_crc32 = MZ_READ_LE32(pSrc_descriptor);
                const mz_uint64 src_comp_size = MZ_READ_LE32(pSrc_descriptor + sizeof(mz_uint32));
                const mz_uint64 src_uncomp_size = MZ_READ_LE32(pSrc_descriptor + 2*sizeof(mz_uint32));

                mz_write_le32((mz_uint8 *)pBuf, MZ_ZIP_DATA_DESCRIPTOR_ID);
                mz_write_le32((mz_uint8 *)pBuf + sizeof(mz_uint32) * 1, src_crc32);
                mz_write_le64((mz_uint8 *)pBuf + sizeof(mz_uint32) * 2, src_comp_size);
                mz_write_le64((mz_uint8 *)pBuf + sizeof(mz_uint32) * 4, src_uncomp_size);

                n = sizeof(mz_uint32) * 6;
            }
            else
            {
                /* dest is NOT zip64, just copy it as-is */
                n = sizeof(mz_uint32) * (has_id ? 4 : 3);
            }
        }

        if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n)
        {
            pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);
        }

        cur_src_file_ofs += n;
        cur_dst_file_ofs += n;
    }
    pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);

    /* Finally, add the new central dir header */
    orig_central_dir_size = pState->m_central_dir.m_size;

    memcpy(new_central_header, pSrc_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);

    if (pState->m_zip64)
    {
        /* This is the painful part: We need to write a new central dir header + ext block with updated zip64 fields, and ensure the old fields (if any) are not included. */
        const mz_uint8 *pSrc_ext = pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_filename_len;
        mz_zip_array new_ext_block;

        mz_zip_array_init(&new_ext_block, sizeof(mz_uint8));

        MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, MZ_UINT32_MAX);
        MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, MZ_UINT32_MAX);
        MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS, MZ_UINT32_MAX);

        if (!mz_zip_writer_update_zip64_extension_block(&new_ext_block, pZip, pSrc_ext, src_ext_len, &src_file_stat.m_comp_size, &src_file_stat.m_uncomp_size, &local_dir_header_ofs, NULL))
        {
            mz_zip_array_clear(pZip, &new_ext_block);
            return MZ_FALSE;
        }

        MZ_WRITE_LE16(new_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS, new_ext_block.m_size);

        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, new_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))
        {
            mz_zip_array_clear(pZip, &new_ext_block);
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, src_filename_len))
        {
            mz_zip_array_clear(pZip, &new_ext_block);
            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, new_ext_block.m_p, new_ext_block.m_size))
        {
            mz_zip_array_clear(pZip, &new_ext_block);
            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + src_filename_len + src_ext_len, src_comment_len))
        {
            mz_zip_array_clear(pZip, &new_ext_block);
            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }

        mz_zip_array_clear(pZip, &new_ext_block);
    }
    else
    {
        /* sanity checks */
        if (cur_dst_file_ofs > MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);

        if (local_dir_header_ofs >= MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE);

        MZ_WRITE_LE32(new_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_dir_header_ofs);

        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, new_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);

        if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, src_central_dir_following_data_size))
        {
            mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
            return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
        }
    }

    /* This shouldn't trigger unless we screwed up during the initial sanity checks */
    if (pState->m_central_dir.m_size >= MZ_UINT32_MAX)
    {
        /* TODO: Support central dirs >= 32-bits in size */
        mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
        return mz_zip_set_error(pZip, MZ_ZIP_UNSUPPORTED_CDIR_SIZE);
    }

    n = (mz_uint32)orig_central_dir_size;
    if (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &n, 1))
    {
        mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size, MZ_FALSE);
        return mz_zip_set_error(pZip, MZ_ZIP_ALLOC_FAILED);
    }

    pZip->m_total_files++;
    pZip->m_archive_size = cur_dst_file_ofs;

    return MZ_TRUE;
}

mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip)
{
    mz_zip_internal_state *pState;
    mz_uint64 central_dir_ofs, central_dir_size;
    mz_uint8 hdr[256];

    if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    pState = pZip->m_pState;

    if (pState->m_zip64)
    {
        if ((mz_uint64)pState->m_central_dir.m_size >= MZ_UINT32_MAX)
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }
    else
    {
        if ((pZip->m_total_files > MZ_UINT16_MAX) || ((pZip->m_archive_size + pState->m_central_dir.m_size + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) > MZ_UINT32_MAX))
            return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES);
    }

    central_dir_ofs = 0;
    central_dir_size = 0;
    if (pZip->m_total_files)
    {
        /* Write central directory */
        central_dir_ofs = pZip->m_archive_size;
        central_dir_size = pState->m_central_dir.m_size;
        pZip->m_central_directory_file_ofs = central_dir_ofs;
        if (pZip->m_pWrite(pZip->m_pIO_opaque, central_dir_ofs, pState->m_central_dir.m_p, (size_t)central_dir_size) != central_dir_size)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        pZip->m_archive_size += central_dir_size;
    }

    if (pState->m_zip64)
    {
        /* Write zip64 end of central directory header */
        mz_uint64 rel_ofs_to_zip64_ecdr = pZip->m_archive_size;

        MZ_CLEAR_ARR(hdr);
        MZ_WRITE_LE32(hdr + MZ_ZIP64_ECDH_SIG_OFS, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIG);
        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_SIZE_OF_RECORD_OFS, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE - sizeof(mz_uint32) - sizeof(mz_uint64));
        MZ_WRITE_LE16(hdr + MZ_ZIP64_ECDH_VERSION_MADE_BY_OFS, 0x031E); /* TODO: always Unix */
        MZ_WRITE_LE16(hdr + MZ_ZIP64_ECDH_VERSION_NEEDED_OFS, 0x002D);
        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS, pZip->m_total_files);
        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_TOTAL_ENTRIES_OFS, pZip->m_total_files);
        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_SIZE_OFS, central_dir_size);
        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDH_CDIR_OFS_OFS, central_dir_ofs);
        if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        pZip->m_archive_size += MZ_ZIP64_END_OF_CENTRAL_DIR_HEADER_SIZE;

        /* Write zip64 end of central directory locator */
        MZ_CLEAR_ARR(hdr);
        MZ_WRITE_LE32(hdr + MZ_ZIP64_ECDL_SIG_OFS, MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIG);
        MZ_WRITE_LE64(hdr + MZ_ZIP64_ECDL_REL_OFS_TO_ZIP64_ECDR_OFS, rel_ofs_to_zip64_ecdr);
        MZ_WRITE_LE32(hdr + MZ_ZIP64_ECDL_TOTAL_NUMBER_OF_DISKS_OFS, 1);
        if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE) != MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE)
            return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

        pZip->m_archive_size += MZ_ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIZE;
    }

    /* Write end of central directory record */
    MZ_CLEAR_ARR(hdr);
    MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_SIG_OFS, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG);
    MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS, MZ_MIN(MZ_UINT16_MAX, pZip->m_total_files));
    MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS, MZ_MIN(MZ_UINT16_MAX, pZip->m_total_files));
    MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_SIZE_OFS, MZ_MIN(MZ_UINT32_MAX, central_dir_size));
    MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_OFS_OFS, MZ_MIN(MZ_UINT32_MAX, central_dir_ofs));

    if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr, MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) != MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_WRITE_FAILED);

#ifndef MINIZ_NO_STDIO
    if ((pState->m_pFile) && (MZ_FFLUSH(pState->m_pFile) == EOF))
        return mz_zip_set_error(pZip, MZ_ZIP_FILE_CLOSE_FAILED);
#endif /* #ifndef MINIZ_NO_STDIO */

    pZip->m_archive_size += MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE;

    pZip->m_zip_mode = MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED;
    return MZ_TRUE;
}

mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **ppBuf, size_t *pSize)
{
    if ((!ppBuf) || (!pSize))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    *ppBuf = NULL;
    *pSize = 0;

    if ((!pZip) || (!pZip->m_pState))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (pZip->m_pWrite != mz_zip_heap_write_func)
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    if (!mz_zip_writer_finalize_archive(pZip))
        return MZ_FALSE;

    *ppBuf = pZip->m_pState->m_pMem;
    *pSize = pZip->m_pState->m_mem_size;
    pZip->m_pState->m_pMem = NULL;
    pZip->m_pState->m_mem_size = pZip->m_pState->m_mem_capacity = 0;

    return MZ_TRUE;
}

mz_bool mz_zip_writer_end(mz_zip_archive *pZip)
{
    return mz_zip_writer_end_internal(pZip, MZ_TRUE);
}

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags)
{
    return mz_zip_add_mem_to_archive_file_in_place_v2(pZip_filename, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, NULL);
}

mz_bool mz_zip_add_mem_to_archive_file_in_place_v2(const char *pZip_filename, const char *pArchive_name, const void *pBuf, size_t buf_size, const void *pComment, mz_uint16 comment_size, mz_uint level_and_flags, mz_zip_error *pErr)
{
    mz_bool status, created_new_archive = MZ_FALSE;
    mz_zip_archive zip_archive;
    struct MZ_FILE_STAT_STRUCT file_stat;
    mz_zip_error actual_err = MZ_ZIP_NO_ERROR;

    mz_zip_zero_struct(&zip_archive);
    if ((int)level_and_flags < 0)
        level_and_flags = MZ_DEFAULT_LEVEL;

    if ((!pZip_filename) || (!pArchive_name) || ((buf_size) && (!pBuf)) || ((comment_size) && (!pComment)) || ((level_and_flags & 0xF) > MZ_UBER_COMPRESSION))
    {
        if (pErr)
            *pErr = MZ_ZIP_INVALID_PARAMETER;
        return MZ_FALSE;
    }

    if (!mz_zip_writer_validate_archive_name(pArchive_name))
    {
        if (pErr)
            *pErr = MZ_ZIP_INVALID_FILENAME;
        return MZ_FALSE;
    }

    /* Important: The regular non-64 bit version of stat() can fail here if the file is very large, which could cause the archive to be overwritten. */
    /* So be sure to compile with _LARGEFILE64_SOURCE 1 */
    if (MZ_FILE_STAT(pZip_filename, &file_stat) != 0)
    {
        /* Create a new archive. */
        if (!mz_zip_writer_init_file_v2(&zip_archive, pZip_filename, 0, level_and_flags))
        {
            if (pErr)
                *pErr = zip_archive.m_last_error;
            return MZ_FALSE;
        }

        created_new_archive = MZ_TRUE;
    }
    else
    {
        /* Append to an existing archive. */
        if (!mz_zip_reader_init_file_v2(&zip_archive, pZip_filename, level_and_flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY, 0, 0))
        {
            if (pErr)
                *pErr = zip_archive.m_last_error;
            return MZ_FALSE;
        }

        if (!mz_zip_writer_init_from_reader_v2(&zip_archive, pZip_filename, level_and_flags))
        {
            if (pErr)
                *pErr = zip_archive.m_last_error;

            mz_zip_reader_end_internal(&zip_archive, MZ_FALSE);

            return MZ_FALSE;
        }
    }

    status = mz_zip_writer_add_mem_ex(&zip_archive, pArchive_name, pBuf, buf_size, pComment, comment_size, level_and_flags, 0, 0);
    actual_err = zip_archive.m_last_error;

    /* Always finalize, even if adding failed for some reason, so we have a valid central directory. (This may not always succeed, but we can try.) */
    if (!mz_zip_writer_finalize_archive(&zip_archive))
    {
        if (!actual_err)
            actual_err = zip_archive.m_last_error;

        status = MZ_FALSE;
    }

    if (!mz_zip_writer_end_internal(&zip_archive, status))
    {
        if (!actual_err)
            actual_err = zip_archive.m_last_error;

        status = MZ_FALSE;
    }

    if ((!status) && (created_new_archive))
    {
        /* It's a new archive and something went wrong, so just delete it. */
        int ignoredStatus = MZ_DELETE_FILE(pZip_filename);
        (void)ignoredStatus;
    }

    if (pErr)
        *pErr = actual_err;

    return status;
}

void *mz_zip_extract_archive_file_to_heap_v2(const char *pZip_filename, const char *pArchive_name, const char *pComment, size_t *pSize, mz_uint flags, mz_zip_error *pErr)
{
    mz_uint32 file_index;
    mz_zip_archive zip_archive;
    void *p = NULL;

    if (pSize)
        *pSize = 0;

    if ((!pZip_filename) || (!pArchive_name))
    {
        if (pErr)
            *pErr = MZ_ZIP_INVALID_PARAMETER;

        return NULL;
    }

    mz_zip_zero_struct(&zip_archive);
    if (!mz_zip_reader_init_file_v2(&zip_archive, pZip_filename, flags | MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY, 0, 0))
    {
        if (pErr)
            *pErr = zip_archive.m_last_error;

        return NULL;
    }

    if (mz_zip_reader_locate_file_v2(&zip_archive, pArchive_name, pComment, flags, &file_index))
    {
        p = mz_zip_reader_extract_to_heap(&zip_archive, file_index, pSize, flags);
    }

    mz_zip_reader_end_internal(&zip_archive, p != NULL);

    if (pErr)
        *pErr = zip_archive.m_last_error;

    return p;
}

void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const char *pArchive_name, size_t *pSize, mz_uint flags)
{
    return mz_zip_extract_archive_file_to_heap_v2(pZip_filename, pArchive_name, NULL, pSize, flags, NULL);
}

#endif /* #ifndef MINIZ_NO_STDIO */

#endif /* #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS */

/* ------------------- Misc utils */

mz_zip_mode mz_zip_get_mode(mz_zip_archive *pZip)
{
    return pZip ? pZip->m_zip_mode : MZ_ZIP_MODE_INVALID;
}

mz_zip_type mz_zip_get_type(mz_zip_archive *pZip)
{
    return pZip ? pZip->m_zip_type : MZ_ZIP_TYPE_INVALID;
}

mz_zip_error mz_zip_set_last_error(mz_zip_archive *pZip, mz_zip_error err_num)
{
    mz_zip_error prev_err;

    if (!pZip)
        return MZ_ZIP_INVALID_PARAMETER;

    prev_err = pZip->m_last_error;

    pZip->m_last_error = err_num;
    return prev_err;
}

mz_zip_error mz_zip_peek_last_error(mz_zip_archive *pZip)
{
    if (!pZip)
        return MZ_ZIP_INVALID_PARAMETER;

    return pZip->m_last_error;
}

mz_zip_error mz_zip_clear_last_error(mz_zip_archive *pZip)
{
    return mz_zip_set_last_error(pZip, MZ_ZIP_NO_ERROR);
}

mz_zip_error mz_zip_get_last_error(mz_zip_archive *pZip)
{
    mz_zip_error prev_err;

    if (!pZip)
        return MZ_ZIP_INVALID_PARAMETER;

    prev_err = pZip->m_last_error;

    pZip->m_last_error = MZ_ZIP_NO_ERROR;
    return prev_err;
}

const char *mz_zip_get_error_string(mz_zip_error mz_err)
{
    switch (mz_err)
    {
        case MZ_ZIP_NO_ERROR:
            return "no error";
        case MZ_ZIP_UNDEFINED_ERROR:
            return "undefined error";
        case MZ_ZIP_TOO_MANY_FILES:
            return "too many files";
        case MZ_ZIP_FILE_TOO_LARGE:
            return "file too large";
        case MZ_ZIP_UNSUPPORTED_METHOD:
            return "unsupported method";
        case MZ_ZIP_UNSUPPORTED_ENCRYPTION:
            return "unsupported encryption";
        case MZ_ZIP_UNSUPPORTED_FEATURE:
            return "unsupported feature";
        case MZ_ZIP_FAILED_FINDING_CENTRAL_DIR:
            return "failed finding central directory";
        case MZ_ZIP_NOT_AN_ARCHIVE:
            return "not a ZIP archive";
        case MZ_ZIP_INVALID_HEADER_OR_CORRUPTED:
            return "invalid header or archive is corrupted";
        case MZ_ZIP_UNSUPPORTED_MULTIDISK:
            return "unsupported multidisk archive";
        case MZ_ZIP_DECOMPRESSION_FAILED:
            return "decompression failed or archive is corrupted";
        case MZ_ZIP_COMPRESSION_FAILED:
            return "compression failed";
        case MZ_ZIP_UNEXPECTED_DECOMPRESSED_SIZE:
            return "unexpected decompressed size";
        case MZ_ZIP_CRC_CHECK_FAILED:
            return "CRC-32 check failed";
        case MZ_ZIP_UNSUPPORTED_CDIR_SIZE:
            return "unsupported central directory size";
        case MZ_ZIP_ALLOC_FAILED:
            return "allocation failed";
        case MZ_ZIP_FILE_OPEN_FAILED:
            return "file open failed";
        case MZ_ZIP_FILE_CREATE_FAILED:
            return "file create failed";
        case MZ_ZIP_FILE_WRITE_FAILED:
            return "file write failed";
        case MZ_ZIP_FILE_READ_FAILED:
            return "file read failed";
        case MZ_ZIP_FILE_CLOSE_FAILED:
            return "file close failed";
        case MZ_ZIP_FILE_SEEK_FAILED:
            return "file seek failed";
        case MZ_ZIP_FILE_STAT_FAILED:
            return "file stat failed";
        case MZ_ZIP_INVALID_PARAMETER:
            return "invalid parameter";
        case MZ_ZIP_INVALID_FILENAME:
            return "invalid filename";
        case MZ_ZIP_BUF_TOO_SMALL:
            return "buffer too small";
        case MZ_ZIP_INTERNAL_ERROR:
            return "internal error";
        case MZ_ZIP_FILE_NOT_FOUND:
            return "file not found";
        case MZ_ZIP_ARCHIVE_TOO_LARGE:
            return "archive is too large";
        case MZ_ZIP_VALIDATION_FAILED:
            return "validation failed";
        case MZ_ZIP_WRITE_CALLBACK_FAILED:
            return "write callback failed";
	case MZ_ZIP_TOTAL_ERRORS:
            return "total errors";
        default:
            break;
    }

    return "unknown error";
}

/* Note: Just because the archive is not zip64 doesn't necessarily mean it doesn't have Zip64 extended information extra field, argh. */
mz_bool mz_zip_is_zip64(mz_zip_archive *pZip)
{
    if ((!pZip) || (!pZip->m_pState))
        return MZ_FALSE;

    return pZip->m_pState->m_zip64;
}

size_t mz_zip_get_central_dir_size(mz_zip_archive *pZip)
{
    if ((!pZip) || (!pZip->m_pState))
        return 0;

    return pZip->m_pState->m_central_dir.m_size;
}

mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip)
{
    return pZip ? pZip->m_total_files : 0;
}

mz_uint64 mz_zip_get_archive_size(mz_zip_archive *pZip)
{
    if (!pZip)
        return 0;
    return pZip->m_archive_size;
}

mz_uint64 mz_zip_get_archive_file_start_offset(mz_zip_archive *pZip)
{
    if ((!pZip) || (!pZip->m_pState))
        return 0;
    return pZip->m_pState->m_file_archive_start_ofs;
}

MZ_FILE *mz_zip_get_cfile(mz_zip_archive *pZip)
{
    if ((!pZip) || (!pZip->m_pState))
        return 0;
    return pZip->m_pState->m_pFile;
}

size_t mz_zip_read_archive_data(mz_zip_archive *pZip, mz_uint64 file_ofs, void *pBuf, size_t n)
{
    if ((!pZip) || (!pZip->m_pState) || (!pBuf) || (!pZip->m_pRead))
        return mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);

    return pZip->m_pRead(pZip->m_pIO_opaque, file_ofs, pBuf, n);
}

mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index, char *pFilename, mz_uint filename_buf_size)
{
    mz_uint n;
    const mz_uint8 *p = mz_zip_get_cdh(pZip, file_index);
    if (!p)
    {
        if (filename_buf_size)
            pFilename[0] = '\0';
        mz_zip_set_error(pZip, MZ_ZIP_INVALID_PARAMETER);
        return 0;
    }
    n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
    if (filename_buf_size)
    {
        n = MZ_MIN(n, filename_buf_size - 1);
        memcpy(pFilename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
        pFilename[n] = '\0';
    }
    return n + 1;
}

mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index, mz_zip_archive_file_stat *pStat)
{
    return mz_zip_file_stat_internal(pZip, file_index, mz_zip_get_cdh(pZip, file_index), pStat, NULL);
}

mz_bool mz_zip_end(mz_zip_archive *pZip)
{
    if (!pZip)
        return MZ_FALSE;

    if (pZip->m_zip_mode == MZ_ZIP_MODE_READING)
        return mz_zip_reader_end(pZip);
#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS
    else if ((pZip->m_zip_mode == MZ_ZIP_MODE_WRITING) || (pZip->m_zip_mode == MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED))
        return mz_zip_writer_end(pZip);
#endif

    return MZ_FALSE;
}

#ifdef __cplusplus
}
#endif

#endif /*#ifndef MINIZ_NO_ARCHIVE_APIS*/




#define APE_AMALGAMATED

/*
SPDX-License-Identifier: MIT

ape
https://github.com/kgabis/ape
Copyright (c) 2023 Krzysztof Gabis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ape_h
#define ape_h

#ifdef __cplusplus
extern "C"
{
#endif
#if 0
} // unconfuse xcode
#endif

#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>

#ifdef _MSC_VER
#define __attribute__(x)
#endif

#define APE_VERSION_MAJOR 0
#define APE_VERSION_MINOR 15
#define APE_VERSION_PATCH 0

#define APE_VERSION_STRING "0.15.0"

typedef struct ape ape_t;
typedef struct ape_object { uint64_t _internal; } ape_object_t;
typedef struct ape_error ape_error_t;
typedef struct ape_program ape_program_t;
typedef struct ape_traceback ape_traceback_t;

typedef enum ape_error_type {
    APE_ERROR_NONE = 0,
    APE_ERROR_PARSING,
    APE_ERROR_COMPILATION,
    APE_ERROR_RUNTIME,
    APE_ERROR_TIMEOUT,
    APE_ERROR_ALLOCATION,
    APE_ERROR_USER, // from ape_add_error() or ape_add_errorf()
} ape_error_type_t;

typedef enum ape_object_type {
    APE_OBJECT_NONE            = 0,
    APE_OBJECT_ERROR           = 1 << 0,
    APE_OBJECT_NUMBER          = 1 << 1,
    APE_OBJECT_BOOL            = 1 << 2,
    APE_OBJECT_STRING          = 1 << 3,
    APE_OBJECT_NULL            = 1 << 4,
    APE_OBJECT_NATIVE_FUNCTION = 1 << 5,
    APE_OBJECT_ARRAY           = 1 << 6,
    APE_OBJECT_MAP             = 1 << 7,
    APE_OBJECT_FUNCTION        = 1 << 8,
    APE_OBJECT_EXTERNAL        = 1 << 9,
    APE_OBJECT_FREED           = 1 << 10,
    APE_OBJECT_ANY             = 0xffff, // for checking types with &
} ape_object_type_t;

typedef ape_object_t (*ape_native_fn)(ape_t *ape, void *data, int argc, ape_object_t *args);
typedef void*        (*ape_malloc_fn)(void *ctx, size_t size);
typedef void         (*ape_free_fn)(void *ctx, void *ptr);
typedef void         (*ape_data_destroy_fn)(void* data);
typedef void*        (*ape_data_copy_fn)(void* data);

typedef size_t (*ape_stdout_write_fn)(void* context, const void *data, size_t data_size);
typedef char*  (*ape_read_file_fn)(void* context, const char *path);
typedef size_t (*ape_write_file_fn)(void* context, const char *path, const char *string, size_t string_size);

//-----------------------------------------------------------------------------
// Ape API
//-----------------------------------------------------------------------------
ape_t* ape_make(void);
ape_t* ape_make_ex(ape_malloc_fn malloc_fn, ape_free_fn free_fn, void *ctx);
void   ape_destroy(ape_t *ape);

void   ape_free_allocated(ape_t *ape, void *ptr);

void ape_set_repl_mode(ape_t *ape, bool enabled);

// -1 to disable, returns false if it can't be set for current platform (otherwise true).
// If execution time exceeds given limit an APE_ERROR_TIMEOUT error is set.
// Precision is not guaranteed because time can't be checked every VM tick
// but expect it to be submilisecond.
bool ape_set_timeout(ape_t *ape, double max_execution_time_ms);

void ape_set_stdout_write_function(ape_t *ape, ape_stdout_write_fn stdout_write, void *context);
void ape_set_file_write_function(ape_t *ape, ape_write_file_fn file_write, void *context);
void ape_set_file_read_function(ape_t *ape, ape_read_file_fn file_read, void *context);

ape_program_t* ape_compile(ape_t *ape, const char *code);
ape_program_t* ape_compile_file(ape_t *ape, const char *path);
ape_object_t   ape_execute_program(ape_t *ape, const ape_program_t *program);
void           ape_program_destroy(ape_program_t *program);

ape_object_t  ape_execute(ape_t *ape, const char *code, size_t len);
ape_object_t  ape_execute_file(ape_t *ape, const char *path);

ape_object_t  ape_call(ape_t *ape, const char *function_name, int argc, ape_object_t *args);
#define APE_CALL(ape, function_name, ...) \
    ape_call(\
        (ape),\
        (function_name),\
        sizeof((ape_object_t[]){__VA_ARGS__}) / sizeof(ape_object_t),\
        (ape_object_t[]){__VA_ARGS__})

void ape_set_runtime_error(ape_t *ape, const char *message);
void ape_set_runtime_errorf(ape_t *ape, const char *format, ...) __attribute__ ((format (printf, 2, 3)));
bool ape_has_errors(const ape_t *ape);
int  ape_errors_count(const ape_t *ape);
void ape_clear_errors(ape_t *ape);
const ape_error_t* ape_get_error(const ape_t *ape, int index);

bool ape_set_native_function(ape_t *ape, const char *name, ape_native_fn fn, void *data);
bool ape_set_global_constant(ape_t *ape, const char *name, ape_object_t obj);
ape_object_t ape_get_object(ape_t *ape, const char *name);

bool ape_check_args(ape_t *ape, bool generate_error, int argc, ape_object_t *args, int expected_argc, int *expected_types);
#define APE_CHECK_ARGS(ape, generate_error, argc, args, ...)\
    ape_check_args(\
        (ape),\
        (generate_error),\
        (argc),\
        (args),\
        sizeof((int[]){__VA_ARGS__}) / sizeof(int),\
        (int[]){__VA_ARGS__})

//-----------------------------------------------------------------------------
// Ape object
//-----------------------------------------------------------------------------

ape_object_t ape_object_make_number(double val);
ape_object_t ape_object_make_bool(bool val);
ape_object_t ape_object_make_null(void);
ape_object_t ape_object_make_string(ape_t *ape, const char *str);
ape_object_t ape_object_make_stringf(ape_t *ape, const char *format, ...) __attribute__ ((format (printf, 2, 3)));
ape_object_t ape_object_make_array(ape_t *ape);
ape_object_t ape_object_make_map(ape_t *ape);
ape_object_t ape_object_make_native_function(ape_t *ape, ape_native_fn fn, void *data);
ape_object_t ape_object_make_error(ape_t *ape, const char *message);
ape_object_t ape_object_make_errorf(ape_t *ape, const char *format, ...) __attribute__ ((format (printf, 2, 3)));
ape_object_t ape_object_make_external(ape_t *ape, void *data);

char* ape_object_serialize(ape_t *ape, ape_object_t obj);

bool ape_object_disable_gc(ape_object_t obj);
void ape_object_enable_gc(ape_object_t obj);

bool ape_object_equals(ape_object_t a, ape_object_t b);

bool ape_object_is_null(ape_object_t obj);

ape_object_t ape_object_copy(ape_object_t obj);
ape_object_t ape_object_deep_copy(ape_object_t obj);

ape_object_type_t ape_object_get_type(ape_object_t obj);
const char*       ape_object_get_type_string(ape_object_t obj);
const char*       ape_object_get_type_name(ape_object_type_t type);

double       ape_object_get_number(ape_object_t obj);
bool         ape_object_get_bool(ape_object_t obj);
const char * ape_object_get_string(ape_object_t obj);
void*        ape_object_get_external(ape_object_t obj);

const char*            ape_object_get_error_message(ape_object_t obj);
const ape_traceback_t* ape_object_get_error_traceback(ape_object_t obj);

bool ape_object_set_external_destroy_function(ape_object_t object, ape_data_destroy_fn destroy_fn);
bool ape_object_set_external_copy_function(ape_object_t object, ape_data_copy_fn copy_fn);

//-----------------------------------------------------------------------------
// Ape object array
//-----------------------------------------------------------------------------

int ape_object_get_array_length(ape_object_t obj);

ape_object_t ape_object_get_array_value(ape_object_t object, int ix);
const char*  ape_object_get_array_string(ape_object_t object, int ix);
double       ape_object_get_array_number(ape_object_t object, int ix);
bool         ape_object_get_array_bool(ape_object_t object, int ix);

bool ape_object_set_array_value(ape_object_t object, int ix, ape_object_t value);
bool ape_object_set_array_string(ape_object_t object, int ix, const char *string);
bool ape_object_set_array_number(ape_object_t object, int ix, double number);
bool ape_object_set_array_bool(ape_object_t object, int ix, bool value);

bool ape_object_add_array_value(ape_object_t object, ape_object_t value);
bool ape_object_add_array_string(ape_object_t object, const char *string);
bool ape_object_add_array_number(ape_object_t object, double number);
bool ape_object_add_array_bool(ape_object_t object, bool value);

//-----------------------------------------------------------------------------
// Ape object map
//-----------------------------------------------------------------------------

int          ape_object_get_map_length(ape_object_t obj);
ape_object_t ape_object_get_map_key_at(ape_object_t object, int ix);
ape_object_t ape_object_get_map_value_at(ape_object_t object, int ix);
bool         ape_object_set_map_value_at(ape_object_t object, int ix, ape_object_t val);

bool ape_object_set_map_value_with_value_key(ape_object_t object, ape_object_t key, ape_object_t value);
bool ape_object_set_map_value(ape_object_t object, const char *key, ape_object_t value);
bool ape_object_set_map_string(ape_object_t object, const char *key, const char *string);
bool ape_object_set_map_number(ape_object_t object, const char *key, double number);
bool ape_object_set_map_bool(ape_object_t object, const char *key, bool value);

ape_object_t  ape_object_get_map_value_with_value_key(ape_object_t object, ape_object_t key);
ape_object_t  ape_object_get_map_value(ape_object_t object, const char *key);
const char*   ape_object_get_map_string(ape_object_t object, const char *key);
double        ape_object_get_map_number(ape_object_t object, const char *key);
bool          ape_object_get_map_bool(ape_object_t object, const char *key);

bool ape_object_map_has_key(ape_object_t object, const char *key);

//-----------------------------------------------------------------------------
// Ape error
//-----------------------------------------------------------------------------
const char*      ape_error_get_message(const ape_error_t *error);
const char*      ape_error_get_filepath(const ape_error_t *error);
const char*      ape_error_get_line(const ape_error_t *error);
int              ape_error_get_line_number(const ape_error_t *error);
int              ape_error_get_column_number(const ape_error_t *error);
ape_error_type_t ape_error_get_type(const ape_error_t *error);
const char*      ape_error_get_type_string(const ape_error_t *error);
const char*      ape_error_type_to_string(ape_error_type_t type);
char*            ape_error_serialize(ape_t *ape, const ape_error_t *error);
const ape_traceback_t* ape_error_get_traceback(const ape_error_t *error);

//-----------------------------------------------------------------------------
// Ape traceback
//-----------------------------------------------------------------------------
int         ape_traceback_get_depth(const ape_traceback_t *traceback);
const char* ape_traceback_get_filepath(const ape_traceback_t *traceback, int depth);
const char* ape_traceback_get_line(const ape_traceback_t *traceback, int depth);
int         ape_traceback_get_line_number(const ape_traceback_t *traceback, int depth);
int         ape_traceback_get_column_number(const ape_traceback_t *traceback, int depth);
const char* ape_traceback_get_function_name(const ape_traceback_t *traceback, int depth);

#ifdef __cplusplus
}
#endif

#endif /* ape_h */


/*
SPDX-License-Identifier: MIT

ape
https://github.com/kgabis/ape
Copyright (c) 2023 Krzysztof Gabis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#define APE_AMALGAMATED

#ifdef _MSC_VER
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif /* _CRT_SECURE_NO_WARNINGS */
#endif /* _MSC_VER */

// #include "ape.h"

//-----------------------------------------------------------------------------
// Headers
//-----------------------------------------------------------------------------
//FILE_START:common.h
#ifndef common_h
#define common_h

#include <assert.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <math.h>
#include <float.h>

#if defined(__linux__)
    #define APE_LINUX
    #define APE_POSIX
#elif defined(_WIN32)
    #define APE_WINDOWS
#elif (defined(__APPLE__) && defined(__MACH__))
    #define APE_APPLE
    #define APE_POSIX
#elif defined(__EMSCRIPTEN__)
    #define APE_EMSCRIPTEN
#endif

#if defined(__unix__)
#include <unistd.h>
#if defined(_POSIX_VERSION)
    #define APE_POSIX
#endif
#endif

#if defined(APE_POSIX)
#include <sys/time.h>
#elif defined(APE_WINDOWS)
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#elif defined(APE_EMSCRIPTEN)
#include <emscripten/emscripten.h>
#endif

#ifndef APE_AMALGAMATED
#include "ape.h"
#endif

#define APE_STREQ(a, b) (strcmp((a), (b)) == 0)
#define APE_STRNEQ(a, b, n) (strncmp((a), (b), (n)) == 0)
#define APE_ARRAY_LEN(array) ((int)(sizeof(array) / sizeof(array[0])))
#define APE_DBLEQ(a, b) (fabs((a) - (b)) < DBL_EPSILON)

#ifdef APE_DEBUG
    #define APE_ASSERT(x) assert((x))
    #define APE_FILENAME (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)
    #define APE_LOG(...) ape_log(APE_FILENAME, __LINE__, __VA_ARGS__)
#else
    #define APE_ASSERT(x) ((void)0)
    #define APE_LOG(...) ((void)0)
#endif

#ifdef APE_AMALGAMATED
    #define COLLECTIONS_AMALGAMATED
    #define APE_INTERNAL static
#else
    #define APE_INTERNAL
#endif

typedef struct compiled_file compiled_file_t;
typedef struct allocator allocator_t;

typedef struct src_pos {
    const compiled_file_t *file;
    int line;
    int column;
} src_pos_t;

typedef struct ape_config {
    struct {
        struct {
            ape_stdout_write_fn write;
            void *context;
        } write;
    } stdio;

    struct {
        struct {
            ape_read_file_fn read_file;
            void *context;
        } read_file;

        struct {
            ape_write_file_fn write_file;
            void *context;
        } write_file;
    } fileio;

    bool repl_mode; // allows redefinition of symbols

    double max_execution_time_ms;
    bool max_execution_time_set;
} ape_config_t;

typedef struct ape_timer {
#if defined(APE_POSIX)
    int64_t start_offset;
#elif defined(APE_WINDOWS)
    double pc_frequency;
#endif
    double start_time_ms;
} ape_timer_t;

#ifndef APE_AMALGAMATED
extern const src_pos_t src_pos_invalid;
extern const src_pos_t src_pos_zero;
#endif

APE_INTERNAL src_pos_t src_pos_make(const compiled_file_t *file, int line, int column);
APE_INTERNAL char *ape_stringf(allocator_t *alloc, const char *format, ...);
APE_INTERNAL void ape_log(const char *file, int line, const char *format, ...);
APE_INTERNAL char* ape_strndup(allocator_t *alloc, const char *string, size_t n);
APE_INTERNAL char* ape_strdup(allocator_t *alloc, const char *string);

APE_INTERNAL uint64_t ape_double_to_uint64(double val);
APE_INTERNAL double ape_uint64_to_double(uint64_t val);

APE_INTERNAL bool ape_timer_platform_supported(void);
APE_INTERNAL ape_timer_t ape_timer_start(void);
APE_INTERNAL double ape_timer_get_elapsed_ms(const ape_timer_t *timer);

#endif /* common_h */
//FILE_END
//FILE_START:collections.h
#ifndef collections_h
#define collections_h

#include <stdbool.h>
#include <stddef.h>

#ifdef COLLECTIONS_AMALGAMATED
#define COLLECTIONS_API static
#else
#define COLLECTIONS_API
#endif

//-----------------------------------------------------------------------------
// Collections
//-----------------------------------------------------------------------------

typedef unsigned long (*collections_hash_fn)(const void* val);
typedef bool (*collections_equals_fn)(const void *a, const void *b);

//-----------------------------------------------------------------------------
// Allocator
//-----------------------------------------------------------------------------

typedef void * (*allocator_malloc_fn)(void *ctx, size_t size);
typedef void (*allocator_free_fn)(void *ctx, void *ptr);

typedef struct allocator {
    allocator_malloc_fn malloc;
    allocator_free_fn free;
    void *ctx;
} allocator_t;

COLLECTIONS_API allocator_t allocator_make(allocator_malloc_fn malloc_fn, allocator_free_fn free_fn, void *ctx);
COLLECTIONS_API void* allocator_malloc(allocator_t *allocator, size_t size);
COLLECTIONS_API void  allocator_free(allocator_t *allocator, void *ptr);

//-----------------------------------------------------------------------------
// Dictionary
//-----------------------------------------------------------------------------

typedef struct dict_ dict_t_;

#define dict(TYPE) dict_t_

typedef void (*dict_item_destroy_fn)(void* item);
typedef void* (*dict_item_copy_fn)(void* item);

#define dict_make(alloc, copy_fn, destroy_fn) dict_make_(alloc, (dict_item_copy_fn)(copy_fn), (dict_item_destroy_fn)(destroy_fn))

COLLECTIONS_API dict_t_*     dict_make_(allocator_t *alloc, dict_item_copy_fn copy_fn, dict_item_destroy_fn destroy_fn);
COLLECTIONS_API void         dict_destroy(dict_t_ *dict);
COLLECTIONS_API void         dict_destroy_with_items(dict_t_ *dict);
COLLECTIONS_API dict_t_*     dict_copy_with_items(dict_t_ *dict);
COLLECTIONS_API bool         dict_set(dict_t_ *dict, const char *key, void *value);
COLLECTIONS_API void *       dict_get(const dict_t_ *dict, const char *key);
COLLECTIONS_API void *       dict_get_value_at(const dict_t_ *dict, unsigned int ix);
COLLECTIONS_API const char * dict_get_key_at(const dict_t_ *dict, unsigned int ix);
COLLECTIONS_API int          dict_count(const dict_t_ *dict);
COLLECTIONS_API bool         dict_remove(dict_t_ *dict, const char *key);

//-----------------------------------------------------------------------------
// Value dictionary
//-----------------------------------------------------------------------------

typedef struct valdict_ valdict_t_;

#define valdict(KEY_TYPE, VALUE_TYPE) valdict_t_

#define valdict_make(allocator, key_type, val_type) valdict_make_(allocator, sizeof(key_type), sizeof(val_type))

COLLECTIONS_API valdict_t_*  valdict_make_(allocator_t *alloc, size_t key_size, size_t val_size);
COLLECTIONS_API valdict_t_*  valdict_make_with_capacity(allocator_t *alloc, unsigned int min_capacity, size_t key_size, size_t val_size);
COLLECTIONS_API void         valdict_destroy(valdict_t_ *dict);
COLLECTIONS_API void         valdict_set_hash_function(valdict_t_ *dict, collections_hash_fn hash_fn);
COLLECTIONS_API void         valdict_set_equals_function(valdict_t_ *dict, collections_equals_fn equals_fn);
COLLECTIONS_API bool         valdict_set(valdict_t_ *dict, void *key, void *value);
COLLECTIONS_API void *       valdict_get(const valdict_t_ *dict, const void *key);
COLLECTIONS_API void *       valdict_get_key_at(const valdict_t_ *dict, unsigned int ix);
COLLECTIONS_API void *       valdict_get_value_at(const valdict_t_ *dict, unsigned int ix);
COLLECTIONS_API unsigned int valdict_get_capacity(const valdict_t_ *dict);
COLLECTIONS_API bool         valdict_set_value_at(const valdict_t_ *dict, unsigned int ix, const void *value);
COLLECTIONS_API int          valdict_count(const valdict_t_ *dict);
COLLECTIONS_API bool         valdict_remove(valdict_t_ *dict, void *key);
COLLECTIONS_API void         valdict_clear(valdict_t_ *dict);

//-----------------------------------------------------------------------------
// Pointer dictionary
//-----------------------------------------------------------------------------

typedef struct ptrdict_ ptrdict_t_;

#define ptrdict(KEY_TYPE, VALUE_TYPE) ptrdict_t_

COLLECTIONS_API ptrdict_t_* ptrdict_make(allocator_t *alloc);
COLLECTIONS_API void        ptrdict_destroy(ptrdict_t_ *dict);
COLLECTIONS_API void        ptrdict_set_hash_function(ptrdict_t_ *dict, collections_hash_fn hash_fn);
COLLECTIONS_API void        ptrdict_set_equals_function(ptrdict_t_ *dict, collections_equals_fn equals_fn);
COLLECTIONS_API bool        ptrdict_set(ptrdict_t_ *dict, void *key, void *value);
COLLECTIONS_API void *      ptrdict_get(const ptrdict_t_ *dict, const void *key);
COLLECTIONS_API void *      ptrdict_get_value_at(const ptrdict_t_ *dict, unsigned int ix);
COLLECTIONS_API void *      ptrdict_get_key_at(const ptrdict_t_ *dict, unsigned int ix);
COLLECTIONS_API int         ptrdict_count(const ptrdict_t_ *dict);
COLLECTIONS_API bool        ptrdict_remove(ptrdict_t_ *dict, void *key);

//-----------------------------------------------------------------------------
// Array
//-----------------------------------------------------------------------------

typedef struct array_ array_t_;

#define array(TYPE) array_t_

#define array_make(allocator, type) array_make_(allocator, sizeof(type))
typedef void (*array_item_deinit_fn)(void* item);
#define array_destroy_with_items(arr, fn) array_destroy_with_items_(arr, (array_item_deinit_fn)(fn))
#define array_clear_and_deinit_items(arr, fn) array_clear_and_deinit_items_(arr, (array_item_deinit_fn)(fn))

COLLECTIONS_API array_t_*    array_make_(allocator_t *alloc, size_t element_size);
COLLECTIONS_API array_t_*    array_make_with_capacity(allocator_t *alloc, unsigned int capacity, size_t element_size);
COLLECTIONS_API void         array_destroy(array_t_ *arr);
COLLECTIONS_API void         array_destroy_with_items_(array_t_ *arr, array_item_deinit_fn deinit_fn);
COLLECTIONS_API array_t_*    array_copy(const array_t_ *arr);
COLLECTIONS_API bool         array_add(array_t_ *arr, const void *value);
COLLECTIONS_API bool         array_addn(array_t_ *arr, const void *values, int n);
COLLECTIONS_API bool         array_add_array(array_t_ *dest, array_t_ *source);
COLLECTIONS_API bool         array_push(array_t_ *arr, const void *value);
COLLECTIONS_API bool         array_pop(array_t_ *arr, void *out_value);
COLLECTIONS_API void *       array_top(array_t_ *arr);
COLLECTIONS_API bool         array_set(array_t_ *arr, unsigned int ix, void *value);
COLLECTIONS_API bool         array_setn(array_t_ *arr, unsigned int ix, void *values, int n);
COLLECTIONS_API void *       array_get(array_t_ *arr, unsigned int ix);
COLLECTIONS_API const void * array_get_const(const array_t_ *arr, unsigned int ix);
COLLECTIONS_API void *       array_get_last(array_t_ *arr);
COLLECTIONS_API int          array_count(const array_t_ *arr);
COLLECTIONS_API unsigned int array_get_capacity(const array_t_ *arr);
COLLECTIONS_API bool         array_remove_at(array_t_ *arr, unsigned int ix);
COLLECTIONS_API bool         array_remove_item(array_t_ *arr, void *ptr);
COLLECTIONS_API void         array_clear(array_t_ *arr);
COLLECTIONS_API void         array_clear_and_deinit_items_(array_t_ *arr, array_item_deinit_fn deinit_fn);
COLLECTIONS_API void         array_lock_capacity(array_t_ *arr);
COLLECTIONS_API int          array_get_index(const array_t_ *arr, void *ptr);
COLLECTIONS_API bool         array_contains(const array_t_ *arr, void *ptr);
COLLECTIONS_API void*        array_data(array_t_ *arr); // might become invalidated by remove/add operations
COLLECTIONS_API const void*  array_const_data(const array_t_ *arr);
COLLECTIONS_API void         array_orphan_data(array_t_ *arr);
COLLECTIONS_API bool         array_reverse(array_t_ *arr);

//-----------------------------------------------------------------------------
// Pointer Array
//-----------------------------------------------------------------------------

typedef struct ptrarray_ ptrarray_t_;

#define ptrarray(TYPE) ptrarray_t_

typedef void (*ptrarray_item_destroy_fn)(void* item);
#define ptrarray_destroy_with_items(arr, fn) ptrarray_destroy_with_items_(arr, (ptrarray_item_destroy_fn)(fn))
#define ptrarray_clear_and_destroy_items(arr, fn) ptrarray_clear_and_destroy_items_(arr, (ptrarray_item_destroy_fn)(fn))

typedef void* (*ptrarray_item_copy_fn)(void* item);
#define ptrarray_copy_with_items(arr, copy_fn, destroy_fn) ptrarray_copy_with_items_(arr, (ptrarray_item_copy_fn)(copy_fn), (ptrarray_item_destroy_fn)(destroy_fn))

COLLECTIONS_API ptrarray_t_* ptrarray_make(allocator_t *alloc);
COLLECTIONS_API ptrarray_t_* ptrarray_make_with_capacity(allocator_t *alloc, unsigned int capacity);
COLLECTIONS_API void         ptrarray_destroy(ptrarray_t_ *arr);
COLLECTIONS_API void         ptrarray_destroy_with_items_(ptrarray_t_ *arr, ptrarray_item_destroy_fn destroy_fn);
COLLECTIONS_API ptrarray_t_* ptrarray_copy(ptrarray_t_ *arr);
COLLECTIONS_API ptrarray_t_* ptrarray_copy_with_items_(ptrarray_t_ *arr, ptrarray_item_copy_fn copy_fn, ptrarray_item_destroy_fn destroy_fn);
COLLECTIONS_API bool         ptrarray_add(ptrarray_t_ *arr, void *ptr);
COLLECTIONS_API bool         ptrarray_set(ptrarray_t_ *arr, unsigned int ix, void *ptr);
COLLECTIONS_API bool         ptrarray_add_array(ptrarray_t_ *dest, ptrarray_t_ *source);
COLLECTIONS_API void *       ptrarray_get(ptrarray_t_ *arr, unsigned int ix);
COLLECTIONS_API const void * ptrarray_get_const(const ptrarray_t_ *arr, unsigned int ix);
COLLECTIONS_API bool         ptrarray_push(ptrarray_t_ *arr, void *ptr);
COLLECTIONS_API void *       ptrarray_pop(ptrarray_t_ *arr);
COLLECTIONS_API void *       ptrarray_top(ptrarray_t_ *arr);
COLLECTIONS_API int          ptrarray_count(const ptrarray_t_ *arr);
COLLECTIONS_API bool         ptrarray_remove_at(ptrarray_t_ *arr, unsigned int ix);
COLLECTIONS_API bool         ptrarray_remove_item(ptrarray_t_ *arr, void *item);
COLLECTIONS_API void         ptrarray_clear(ptrarray_t_ *arr);
COLLECTIONS_API void         ptrarray_clear_and_destroy_items_(ptrarray_t_ *arr, ptrarray_item_destroy_fn destroy_fn);
COLLECTIONS_API void         ptrarray_lock_capacity(ptrarray_t_ *arr);
COLLECTIONS_API int          ptrarray_get_index(ptrarray_t_ *arr, void *ptr);
COLLECTIONS_API bool         ptrarray_contains(ptrarray_t_ *arr, void *ptr);
COLLECTIONS_API void *       ptrarray_get_addr(ptrarray_t_ *arr, unsigned int ix);
COLLECTIONS_API void*        ptrarray_data(ptrarray_t_ *arr); // might become invalidated by remove/add operations
COLLECTIONS_API void         ptrarray_reverse(ptrarray_t_ *arr);

//-----------------------------------------------------------------------------
// String buffer
//-----------------------------------------------------------------------------

typedef struct strbuf strbuf_t;

COLLECTIONS_API strbuf_t* strbuf_make(allocator_t *alloc);
COLLECTIONS_API strbuf_t* strbuf_make_with_capacity(allocator_t *alloc, unsigned int capacity);
COLLECTIONS_API void strbuf_destroy(strbuf_t *buf);
COLLECTIONS_API void strbuf_clear(strbuf_t *buf);
COLLECTIONS_API bool strbuf_append(strbuf_t *buf, const char *str);
COLLECTIONS_API bool strbuf_appendf(strbuf_t *buf, const char *fmt, ...)  __attribute__((format(printf, 2, 3)));
COLLECTIONS_API const char * strbuf_get_string(const strbuf_t *buf);
COLLECTIONS_API size_t strbuf_get_length(const strbuf_t *buf);
COLLECTIONS_API char * strbuf_get_string_and_destroy(strbuf_t *buf);
COLLECTIONS_API bool strbuf_failed(strbuf_t *buf);

//-----------------------------------------------------------------------------
// Utils
//-----------------------------------------------------------------------------

COLLECTIONS_API ptrarray(char)* kg_split_string(allocator_t *alloc, const char *str, const char *delimiter);
COLLECTIONS_API char* kg_join(allocator_t *alloc, ptrarray(char) *items, const char *with);
COLLECTIONS_API char* kg_canonicalise_path(allocator_t *alloc, const char *path);
COLLECTIONS_API bool  kg_is_path_absolute(const char *path);
COLLECTIONS_API bool  kg_streq(const char *a, const char *b);

#endif /* collections_h */
//FILE_END
//FILE_START:errors.h
#ifndef errors_h
#define errors_h

#ifndef APE_AMALGAMATED
#include "common.h"
#include "token.h"
#endif

#define ERRORS_MAX_COUNT 16
#define ERROR_MESSAGE_MAX_LENGTH 255

typedef struct traceback traceback_t;

typedef enum error_type {
    ERROR_NONE = 0,
    ERROR_PARSING,
    ERROR_COMPILATION,
    ERROR_RUNTIME,
    ERROR_TIME_OUT, // not ERROR_TIMEOUT to avoid name collision from windows.h
    ERROR_ALLOCATION,
    ERROR_USER,
} error_type_t;

typedef struct error {
    error_type_t type;
    char message[ERROR_MESSAGE_MAX_LENGTH];
    src_pos_t pos;
    traceback_t *traceback;
} error_t;

typedef struct errors {
    error_t errors[ERRORS_MAX_COUNT];
    int count;
} errors_t;

APE_INTERNAL void errors_init(errors_t *errors);
APE_INTERNAL void errors_deinit(errors_t *errors);

APE_INTERNAL void errors_add_error(errors_t *errors, error_type_t type, src_pos_t pos, const char *message);
APE_INTERNAL void errors_add_errorf(errors_t *errors, error_type_t type, src_pos_t pos, const char *format, ...) __attribute__ ((format (printf, 4, 5)));
APE_INTERNAL void errors_clear(errors_t *errors);
APE_INTERNAL int errors_get_count(const errors_t *errors);
APE_INTERNAL error_t *errors_get(errors_t *errors, int ix);
APE_INTERNAL const error_t *errors_getc(const errors_t *errors, int ix);
APE_INTERNAL const char *error_type_to_string(error_type_t type);
APE_INTERNAL error_t *errors_get_last_error(errors_t *errors);
APE_INTERNAL bool errors_has_errors(const errors_t *errors);

#endif /* errors_h */
//FILE_END
//FILE_START:token.h
#ifndef token_h
#define token_h

#ifndef APE_AMALGAMATED
#include "common.h"
#endif

typedef enum {
    TOKEN_INVALID = 0,
    TOKEN_EOF,

    // Operators
    TOKEN_ASSIGN,

    TOKEN_PLUS_ASSIGN,
    TOKEN_MINUS_ASSIGN,
    TOKEN_ASTERISK_ASSIGN,
    TOKEN_SLASH_ASSIGN,
    TOKEN_PERCENT_ASSIGN,
    TOKEN_BIT_AND_ASSIGN,
    TOKEN_BIT_OR_ASSIGN,
    TOKEN_BIT_XOR_ASSIGN,
    TOKEN_LSHIFT_ASSIGN,
    TOKEN_RSHIFT_ASSIGN,

    TOKEN_QUESTION,

    TOKEN_PLUS,
    TOKEN_PLUS_PLUS,
    TOKEN_MINUS,
    TOKEN_MINUS_MINUS,
    TOKEN_BANG,
    TOKEN_ASTERISK,
    TOKEN_SLASH,

    TOKEN_LT,
    TOKEN_LTE,
    TOKEN_GT,
    TOKEN_GTE,

    TOKEN_EQ,
    TOKEN_NOT_EQ,

    TOKEN_AND,
    TOKEN_OR,

    TOKEN_BIT_AND,
    TOKEN_BIT_OR,
    TOKEN_BIT_XOR,
    TOKEN_LSHIFT,
    TOKEN_RSHIFT,

    // Delimiters
    TOKEN_COMMA,
    TOKEN_SEMICOLON,
    TOKEN_COLON,
    TOKEN_LPAREN,
    TOKEN_RPAREN,
    TOKEN_LBRACE,
    TOKEN_RBRACE,
    TOKEN_LBRACKET,
    TOKEN_RBRACKET,
    TOKEN_DOT,
    TOKEN_PERCENT,

    // Keywords
    TOKEN_FUNCTION,
    TOKEN_CONST,
    TOKEN_VAR,
    TOKEN_TRUE,
    TOKEN_FALSE,
    TOKEN_IF,
    TOKEN_ELSE,
    TOKEN_RETURN,
    TOKEN_WHILE,
    TOKEN_BREAK,
    TOKEN_FOR,
    TOKEN_IN,
    TOKEN_CONTINUE,
    TOKEN_NULL,
    TOKEN_IMPORT,
    TOKEN_RECOVER,

    // Identifiers and literals
    TOKEN_IDENT,
    TOKEN_NUMBER,
    TOKEN_STRING,
    TOKEN_TEMPLATE_STRING,

    TOKEN_TYPE_MAX
} token_type_t;

typedef struct token {
    token_type_t type;
    const char *literal;
    int len;
    src_pos_t pos;
} token_t;

APE_INTERNAL void token_init(token_t *tok, token_type_t type, const char *literal, int len); // no need to destroy
APE_INTERNAL char *token_duplicate_literal(allocator_t *alloc, const token_t *tok);
APE_INTERNAL const char *token_type_to_string(token_type_t type);

#endif /* token_h */
//FILE_END
//FILE_START:compiled_file.h
#ifndef compiled_file_h
#define compiled_file_h

#ifndef APE_AMALGAMATED
#include "common.h"
#include "collections.h"
#endif

typedef struct compiled_file compiled_file_t;

typedef struct compiled_file {
    allocator_t *alloc;
    char *dir_path;
    char *path;
    ptrarray(char*) *lines;
} compiled_file_t;

APE_INTERNAL compiled_file_t* compiled_file_make(allocator_t *alloc, const char *path);
APE_INTERNAL void compiled_file_destroy(compiled_file_t *file);

#endif /* compiled_file_h */
//FILE_END
//FILE_START:lexer.h
#ifndef lexer_h
#define lexer_h

#include <stdbool.h>
#include <stddef.h>

#ifndef APE_AMALGAMATED
#include "common.h"
#include "token.h"
#include "collections.h"
#include "compiled_file.h"
#endif

typedef struct errors errors_t;

typedef struct lexer {
    allocator_t *alloc;
    errors_t *errors;
    const char *input;
    int input_len;
    int position;
    int next_position;
    char ch;
    int line;
    int column;
    compiled_file_t *file;
    bool failed;
    bool continue_template_string;
    struct {
        int position;
        int next_position;
        char ch;
        int line;
        int column;
    } prev_token_state;
    token_t prev_token;
    token_t cur_token;
    token_t peek_token;
} lexer_t;

APE_INTERNAL bool lexer_init(lexer_t *lex, allocator_t *alloc, errors_t *errs, const char *input, size_t len, compiled_file_t *file); // no need to deinit

APE_INTERNAL bool lexer_failed(lexer_t *lex);
APE_INTERNAL void lexer_continue_template_string(lexer_t *lex);
APE_INTERNAL bool lexer_cur_token_is(lexer_t *lex, token_type_t type);
APE_INTERNAL bool lexer_peek_token_is(lexer_t *lex, token_type_t type);
APE_INTERNAL bool lexer_next_token(lexer_t *lex);
APE_INTERNAL bool lexer_previous_token(lexer_t *lex);
APE_INTERNAL token_t lexer_next_token_internal(lexer_t *lex); // exposed here for tests
APE_INTERNAL bool lexer_expect_current(lexer_t *lex, token_type_t type);

#endif /* lexer_h */
//FILE_END
//FILE_START:ast.h
#ifndef ast_h
#define ast_h

#ifndef APE_AMALGAMATED
#include "common.h"
#include "collections.h"
#include "token.h"
#endif

typedef struct code_block {
    allocator_t *alloc;
    ptrarray(statement_t) *statements;
} code_block_t;

typedef struct expression expression_t;
typedef struct statement statement_t;

typedef struct map_literal {
    ptrarray(expression_t) *keys;
    ptrarray(expression_t) *values;
} map_literal_t;

typedef enum {
    OPERATOR_NONE,
    OPERATOR_ASSIGN,
    OPERATOR_PLUS,
    OPERATOR_MINUS,
    OPERATOR_BANG,
    OPERATOR_ASTERISK,
    OPERATOR_SLASH,
    OPERATOR_LT,
    OPERATOR_LTE,
    OPERATOR_GT,
    OPERATOR_GTE,
    OPERATOR_EQ,
    OPERATOR_NOT_EQ,
    OPERATOR_MODULUS,
    OPERATOR_LOGICAL_AND,
    OPERATOR_LOGICAL_OR,
    OPERATOR_BIT_AND,
    OPERATOR_BIT_OR,
    OPERATOR_BIT_XOR,
    OPERATOR_LSHIFT,
    OPERATOR_RSHIFT,
} operator_t;

typedef struct prefix {
    operator_t op;
    expression_t *right;
} prefix_expression_t;

typedef struct infix {
    operator_t op;
    expression_t *left;
    expression_t *right;
} infix_expression_t;

typedef struct if_case {
    allocator_t *alloc;
    expression_t *test;
    code_block_t *consequence;
} if_case_t;

typedef struct fn_literal {
    char *name;
    ptrarray(ident_t) *params;
    code_block_t *body;
} fn_literal_t;

typedef struct call_expression {
    expression_t *function;
    ptrarray(expression_t) *args;
} call_expression_t;

typedef struct index_expression {
    expression_t *left;
    expression_t *index;
} index_expression_t;

typedef struct assign_expression {
    expression_t *dest;
    expression_t *source;
    bool is_postfix;
} assign_expression_t;

typedef struct logical_expression {
    operator_t op;
    expression_t *left;
    expression_t *right;
} logical_expression_t;

typedef struct ternary_expression {
    expression_t *test;
    expression_t *if_true;
    expression_t *if_false;
} ternary_expression_t;

typedef enum expression_type {
    EXPRESSION_NONE,
    EXPRESSION_IDENT,
    EXPRESSION_NUMBER_LITERAL,
    EXPRESSION_BOOL_LITERAL,
    EXPRESSION_STRING_LITERAL,
    EXPRESSION_NULL_LITERAL,
    EXPRESSION_ARRAY_LITERAL,
    EXPRESSION_MAP_LITERAL,
    EXPRESSION_PREFIX,
    EXPRESSION_INFIX,
    EXPRESSION_FUNCTION_LITERAL,
    EXPRESSION_CALL,
    EXPRESSION_INDEX,
    EXPRESSION_ASSIGN,
    EXPRESSION_LOGICAL,
    EXPRESSION_TERNARY,
} expression_type_t;

typedef struct ident {
    allocator_t *alloc;
    char *value;
    src_pos_t pos;
} ident_t;

typedef struct expression {
    allocator_t *alloc;
    expression_type_t type;
    union {
        ident_t *ident;
        double number_literal;
        bool bool_literal;
        char *string_literal;
        ptrarray(expression_t) *array;
        map_literal_t map;
        prefix_expression_t prefix;
        infix_expression_t infix;
        fn_literal_t fn_literal;
        call_expression_t call_expr;
        index_expression_t index_expr;
        assign_expression_t assign;
        logical_expression_t logical;
        ternary_expression_t ternary;
    };
    src_pos_t pos;
} expression_t;

typedef enum statement_type {
    STATEMENT_NONE,
    STATEMENT_DEFINE,
    STATEMENT_IF,
    STATEMENT_RETURN_VALUE,
    STATEMENT_EXPRESSION,
    STATEMENT_WHILE_LOOP,
    STATEMENT_BREAK,
    STATEMENT_CONTINUE,
    STATEMENT_FOREACH,
    STATEMENT_FOR_LOOP,
    STATEMENT_BLOCK,
    STATEMENT_IMPORT,
    STATEMENT_RECOVER,
} statement_type_t;

typedef struct define_statement {
    ident_t *name;
    expression_t *value;
    bool assignable;
} define_statement_t;

typedef struct if_statement {
    ptrarray(if_case_t) *cases;
    code_block_t *alternative;
} if_statement_t;

typedef struct while_loop_statement {
    expression_t *test;
    code_block_t *body;
} while_loop_statement_t;

typedef struct foreach_statement {
    ident_t *iterator;
    expression_t *source;
    code_block_t *body;
} foreach_statement_t;

typedef struct for_loop_statement {
    statement_t *init;
    expression_t *test;
    expression_t *update;
    code_block_t *body;
} for_loop_statement_t;

typedef struct import_statement {
    char *path;
} import_statement_t;

typedef struct recover_statement {
    ident_t *error_ident;
    code_block_t *body;
} recover_statement_t;

typedef struct statement {
    allocator_t *alloc;
    statement_type_t type;
    union {
        define_statement_t define;
        if_statement_t if_statement;
        expression_t *return_value;
        expression_t *expression;
        while_loop_statement_t while_loop;
        foreach_statement_t foreach;
        for_loop_statement_t for_loop;
        code_block_t *block;
        import_statement_t import;
        recover_statement_t recover;
    };
    src_pos_t pos;
} statement_t;

APE_INTERNAL char* statements_to_string(allocator_t *alloc, ptrarray(statement_t) *statements);

APE_INTERNAL statement_t* statement_make_define(allocator_t *alloc, ident_t *name, expression_t *value, bool assignable);
APE_INTERNAL statement_t* statement_make_if(allocator_t *alloc, ptrarray(if_case_t) *cases, code_block_t *alternative);
APE_INTERNAL statement_t* statement_make_return(allocator_t *alloc, expression_t *value);
APE_INTERNAL statement_t* statement_make_expression(allocator_t *alloc, expression_t *value);
APE_INTERNAL statement_t* statement_make_while_loop(allocator_t *alloc, expression_t *test, code_block_t *body);
APE_INTERNAL statement_t* statement_make_break(allocator_t *alloc);
APE_INTERNAL statement_t* statement_make_foreach(allocator_t *alloc, ident_t *iterator, expression_t *source, code_block_t *body);
APE_INTERNAL statement_t* statement_make_for_loop(allocator_t *alloc, statement_t *init, expression_t *test, expression_t *update, code_block_t *body);
APE_INTERNAL statement_t* statement_make_continue(allocator_t *alloc);
APE_INTERNAL statement_t* statement_make_block(allocator_t *alloc, code_block_t *block);
APE_INTERNAL statement_t* statement_make_import(allocator_t *alloc, char *path);
APE_INTERNAL statement_t* statement_make_recover(allocator_t *alloc, ident_t *error_ident, code_block_t *body);

APE_INTERNAL void statement_destroy(void *stmt);

APE_INTERNAL statement_t* statement_copy(const statement_t *stmt);

APE_INTERNAL code_block_t* code_block_make(allocator_t *alloc, ptrarray(statement_t) *statements);
APE_INTERNAL void code_block_destroy(code_block_t *stmt);
APE_INTERNAL code_block_t* code_block_copy(code_block_t *block);

APE_INTERNAL expression_t* expression_make_ident(allocator_t *alloc, ident_t *ident);
APE_INTERNAL expression_t* expression_make_number_literal(allocator_t *alloc, double val);
APE_INTERNAL expression_t* expression_make_bool_literal(allocator_t *alloc, bool val);
APE_INTERNAL expression_t* expression_make_string_literal(allocator_t *alloc, char *value);
APE_INTERNAL expression_t* expression_make_null_literal(allocator_t *alloc);
APE_INTERNAL expression_t* expression_make_array_literal(allocator_t *alloc, ptrarray(expression_t) *values);
APE_INTERNAL expression_t* expression_make_map_literal(allocator_t *alloc, ptrarray(expression_t) *keys, ptrarray(expression_t) *values);
APE_INTERNAL expression_t* expression_make_prefix(allocator_t *alloc, operator_t op, expression_t *right);
APE_INTERNAL expression_t* expression_make_infix(allocator_t *alloc, operator_t op, expression_t *left, expression_t *right);
APE_INTERNAL expression_t* expression_make_fn_literal(allocator_t *alloc, ptrarray(ident_t) *params, code_block_t *body);
APE_INTERNAL expression_t* expression_make_call(allocator_t *alloc, expression_t *function, ptrarray(expression_t) *args);
APE_INTERNAL expression_t* expression_make_index(allocator_t *alloc, expression_t *left, expression_t *index);
APE_INTERNAL expression_t* expression_make_assign(allocator_t *alloc, expression_t *dest, expression_t *source, bool is_postfix);
APE_INTERNAL expression_t* expression_make_logical(allocator_t *alloc, operator_t op, expression_t *left, expression_t *right);
APE_INTERNAL expression_t* expression_make_ternary(allocator_t *alloc, expression_t *test, expression_t *if_true, expression_t *if_false);

APE_INTERNAL void expression_destroy(expression_t *expr);
APE_INTERNAL void expression_destroy_wrapper(void *expr);

APE_INTERNAL expression_t* expression_copy(expression_t *expr);

APE_INTERNAL void statement_to_string(const statement_t *stmt, strbuf_t *buf);
APE_INTERNAL void expression_to_string(expression_t *expr, strbuf_t *buf);

APE_INTERNAL void code_block_to_string(const code_block_t *stmt, strbuf_t *buf);
APE_INTERNAL const char* operator_to_string(operator_t op);

APE_INTERNAL const char *expression_type_to_string(expression_type_t type);

APE_INTERNAL ident_t* ident_make(allocator_t *alloc, token_t tok);
APE_INTERNAL ident_t* ident_copy(ident_t *ident);
APE_INTERNAL void ident_destroy(ident_t *ident);
APE_INTERNAL void ident_destroy_wrapper(void *ident);

APE_INTERNAL if_case_t *if_case_make(allocator_t *alloc, expression_t *test, code_block_t *consequence);
APE_INTERNAL void if_case_destroy(if_case_t *cond);
APE_INTERNAL if_case_t* if_case_copy(if_case_t *cond);

APE_INTERNAL void if_case_destroy_wrapper(void *cond);

#endif /* ast_h */
//FILE_END
//FILE_START:parser.h
#ifndef parser_h
#define parser_h

#ifndef APE_AMALGAMATED
#include "common.h"
#include "lexer.h"
#include "token.h"
#include "ast.h"
#include "collections.h"
#endif

typedef struct parser parser_t;
typedef struct errors errors_t;

typedef expression_t* (*right_assoc_parse_fn)(parser_t *p);
typedef expression_t* (*left_assoc_parse_fn)(parser_t *p, expression_t *expr);

typedef struct parser {
    allocator_t *alloc;
    const ape_config_t *config;
    lexer_t lexer;
    errors_t *errors;

    right_assoc_parse_fn right_assoc_parse_fns[TOKEN_TYPE_MAX];
    left_assoc_parse_fn left_assoc_parse_fns[TOKEN_TYPE_MAX];

    int depth;
} parser_t;

APE_INTERNAL parser_t* parser_make(allocator_t *alloc, const ape_config_t *config, errors_t *errors);
APE_INTERNAL void parser_destroy(parser_t *parser);

APE_INTERNAL ptrarray(statement_t)* parser_parse_all(parser_t *parser,  const char *input, size_t len, compiled_file_t *file);

#endif /* parser_h */
//FILE_END
//FILE_START:object.h
#ifndef object_h
#define object_h

#include <stdint.h>

#ifndef APE_AMALGAMATED
#include "common.h"
#include "collections.h"
#include "ast.h"
#endif

typedef struct compilation_result compilation_result_t;
typedef struct traceback traceback_t;
typedef struct vm vm_t;
typedef struct gcmem gcmem_t;

#define OBJECT_STRING_BUF_SIZE 24

typedef enum {
    OBJECT_NONE      = 0,
    OBJECT_ERROR     = 1 << 0,
    OBJECT_NUMBER    = 1 << 1,
    OBJECT_BOOL      = 1 << 2,
    OBJECT_STRING    = 1 << 3,
    OBJECT_NULL      = 1 << 4,
    OBJECT_NATIVE_FUNCTION = 1 << 5,
    OBJECT_ARRAY     = 1 << 6,
    OBJECT_MAP       = 1 << 7,
    OBJECT_FUNCTION  = 1 << 8,
    OBJECT_EXTERNAL  = 1 << 9,
    OBJECT_FREED     = 1 << 10,
    OBJECT_ANY       = 0xffff,
} object_type_t;

typedef struct object {
    union {
        uint64_t handle;
        double number;
    };
} object_t;

typedef struct function {
    union {
        object_t *free_vals_allocated;
        object_t free_vals_buf[2];
    };
    union {
        char *name;
        const char *const_name;
    };
    compilation_result_t *comp_result;
    int num_locals;
    int num_args;
    int free_vals_count;
    bool owns_data;
} function_t;

#define NATIVE_FN_MAX_DATA_LEN 24
typedef object_t (*native_fn)(vm_t *vm, void *data, int argc, object_t *args);

typedef struct native_function {
    char *name;
    native_fn fn;
    uint8_t data[NATIVE_FN_MAX_DATA_LEN];
    int data_len;
} native_function_t;

typedef void  (*external_data_destroy_fn)(void* data);
typedef void* (*external_data_copy_fn)(void* data);

typedef struct external_data {
    void *data;
    external_data_destroy_fn data_destroy_fn;
    external_data_copy_fn    data_copy_fn;
} external_data_t;

typedef struct object_error {
    char *message;
    traceback_t *traceback;
} object_error_t;

typedef struct object_string {
    union {
        char *value_allocated;
        char value_buf[OBJECT_STRING_BUF_SIZE];
    };
    unsigned long hash;
    bool is_allocated;
    int capacity;
    int length;
} object_string_t;

typedef struct object_data {
    gcmem_t *mem;
    union {
        object_string_t string;
        object_error_t error;
        array(object_t) *array;
        valdict(object_t, object_t) *map;
        function_t function;
        native_function_t native_function;
        external_data_t external;
    };
    bool gcmark;
    object_type_t type;
} object_data_t;

APE_INTERNAL object_t object_make_from_data(object_type_t type, object_data_t *data);
APE_INTERNAL object_t object_make_number(double val);
APE_INTERNAL object_t object_make_bool(bool val);
APE_INTERNAL object_t object_make_null(void);
APE_INTERNAL object_t object_make_string(gcmem_t *mem, const char *string);
APE_INTERNAL object_t object_make_string_with_capacity(gcmem_t *mem, int capacity);
APE_INTERNAL object_t object_make_native_function(gcmem_t *mem, const char *name, native_fn fn, void *data, int data_len);
APE_INTERNAL object_t object_make_array(gcmem_t *mem);
APE_INTERNAL object_t object_make_array_with_capacity(gcmem_t *mem, unsigned capacity);
APE_INTERNAL object_t object_make_map(gcmem_t *mem);
APE_INTERNAL object_t object_make_map_with_capacity(gcmem_t *mem, unsigned capacity);
APE_INTERNAL object_t object_make_error(gcmem_t *mem, const char *message);
APE_INTERNAL object_t object_make_error_no_copy(gcmem_t *mem, char *message);
APE_INTERNAL object_t object_make_errorf(gcmem_t *mem, const char *fmt, ...) __attribute__ ((format (printf, 2, 3)));
APE_INTERNAL object_t object_make_function(gcmem_t *mem, const char *name, compilation_result_t *comp_res,
                                           bool owns_data, int num_locals, int num_args,
                                           int free_vals_count);
APE_INTERNAL object_t object_make_external(gcmem_t *mem, void *data);

APE_INTERNAL void object_deinit(object_t obj);
APE_INTERNAL void object_data_deinit(object_data_t *obj);

APE_INTERNAL bool        object_is_allocated(object_t obj);
APE_INTERNAL gcmem_t*    object_get_mem(object_t obj);
APE_INTERNAL bool        object_is_hashable(object_t obj);
APE_INTERNAL void        object_to_string(object_t obj, strbuf_t *buf, bool quote_str);
APE_INTERNAL const char* object_get_type_name(const object_type_t type);
APE_INTERNAL char*       object_get_type_union_name(allocator_t *alloc, const object_type_t type);
APE_INTERNAL char*       object_serialize(allocator_t *alloc, object_t object);
APE_INTERNAL object_t    object_deep_copy(gcmem_t *mem, object_t object);
APE_INTERNAL object_t    object_copy(gcmem_t *mem, object_t obj);
APE_INTERNAL double      object_compare(object_t a, object_t b, bool *out_ok);
APE_INTERNAL bool        object_equals(object_t a, object_t b);

APE_INTERNAL object_data_t* object_get_allocated_data(object_t object);

APE_INTERNAL bool           object_get_bool(object_t obj);
APE_INTERNAL double         object_get_number(object_t obj);
APE_INTERNAL function_t*    object_get_function(object_t obj);
APE_INTERNAL const char*    object_get_string(object_t obj);
APE_INTERNAL int            object_get_string_length(object_t obj);
APE_INTERNAL void           object_set_string_length(object_t obj, int len);
APE_INTERNAL int            object_get_string_capacity(object_t obj);
APE_INTERNAL char*          object_get_mutable_string(object_t obj);
APE_INTERNAL bool           object_string_append(object_t obj, const char *src, int len);
APE_INTERNAL unsigned long  object_get_string_hash(object_t obj);
APE_INTERNAL native_function_t* object_get_native_function(object_t obj);
APE_INTERNAL object_type_t  object_get_type(object_t obj);

APE_INTERNAL bool object_is_numeric(object_t obj);
APE_INTERNAL bool object_is_null(object_t obj);
APE_INTERNAL bool object_is_callable(object_t obj);

APE_INTERNAL const char* object_get_function_name(object_t obj);
APE_INTERNAL object_t    object_get_function_free_val(object_t obj, int ix);
APE_INTERNAL void        object_set_function_free_val(object_t obj, int ix, object_t val);
APE_INTERNAL object_t*   object_get_function_free_vals(object_t obj);

APE_INTERNAL const char*  object_get_error_message(object_t obj);
APE_INTERNAL void         object_set_error_traceback(object_t obj, traceback_t *traceback);
APE_INTERNAL traceback_t* object_get_error_traceback(object_t obj);

APE_INTERNAL external_data_t* object_get_external_data(object_t object);
APE_INTERNAL bool object_set_external_destroy_function(object_t object, external_data_destroy_fn destroy_fn);
APE_INTERNAL bool object_set_external_data(object_t object, void *data);
APE_INTERNAL bool object_set_external_copy_function(object_t object, external_data_copy_fn copy_fn);

APE_INTERNAL object_t object_get_array_value_at(object_t array, int ix);
APE_INTERNAL bool     object_set_array_value_at(object_t obj, int ix, object_t val);
APE_INTERNAL bool     object_add_array_value(object_t array, object_t val);
APE_INTERNAL int      object_get_array_length(object_t array);
APE_INTERNAL bool     object_remove_array_value_at(object_t array, int ix);

APE_INTERNAL int      object_get_map_length(object_t obj);
APE_INTERNAL object_t object_get_map_key_at(object_t obj, int ix);
APE_INTERNAL object_t object_get_map_value_at(object_t obj, int ix);
APE_INTERNAL bool     object_set_map_value_at(object_t obj, int ix, object_t val);
APE_INTERNAL object_t object_get_kv_pair_at(gcmem_t *mem, object_t obj, int ix);
APE_INTERNAL bool     object_set_map_value(object_t obj, object_t key, object_t val);
APE_INTERNAL object_t object_get_map_value(object_t obj, object_t key);
APE_INTERNAL bool     object_map_has_key(object_t obj, object_t key);

#endif /* object_h */
//FILE_END
//FILE_START:global_store.h
#ifndef global_store_h
#define global_store_h

#ifndef APE_AMALGAMATED
#include "common.h"
#include "collections.h"
#include "object.h"
#endif

typedef struct symbol symbol_t;
typedef struct gcmem gcmem_t;
typedef struct global_store global_store_t;

APE_INTERNAL global_store_t *global_store_make(allocator_t *alloc, gcmem_t *mem);
APE_INTERNAL void global_store_destroy(global_store_t *store);
APE_INTERNAL const symbol_t* global_store_get_symbol(global_store_t *store, const char *name);
APE_INTERNAL object_t global_store_get_object(global_store_t *store, const char *name);
APE_INTERNAL bool global_store_set(global_store_t *store, const char *name, object_t object);
APE_INTERNAL object_t global_store_get_object_at(global_store_t *store, int ix, bool *out_ok);
APE_INTERNAL bool global_store_set_object_at(global_store_t *store, int ix, object_t object);
APE_INTERNAL object_t *global_store_get_object_data(global_store_t *store);
APE_INTERNAL int global_store_get_object_count(global_store_t *store);

#endif /* global_store_h */
//FILE_END
//FILE_START:symbol_table.h
#ifndef symbol_table_h
#define symbol_table_h

#ifndef APE_AMALGAMATED
#include "common.h"
#include "token.h"
#include "collections.h"
#endif

typedef struct global_store global_store_t;

typedef enum symbol_type {
    SYMBOL_NONE = 0,
    SYMBOL_MODULE_GLOBAL,
    SYMBOL_LOCAL,
    SYMBOL_APE_GLOBAL,
    SYMBOL_FREE,
    SYMBOL_FUNCTION,
    SYMBOL_THIS,
} symbol_type_t;

typedef struct symbol {
    allocator_t *alloc;
    symbol_type_t type;
    char *name;
    int index;
    bool assignable;
} symbol_t;

typedef struct block_scope {
    allocator_t *alloc;
    dict(symbol_t) *store;
    int offset;
    int num_definitions;
} block_scope_t;

typedef struct symbol_table {
    allocator_t *alloc;
    struct symbol_table *outer;
    global_store_t *global_store;
    ptrarray(block_scope_t) *block_scopes;
    ptrarray(symbol_t) *free_symbols;
    ptrarray(symbol_t) *module_global_symbols;
    int max_num_definitions;
    int module_global_offset;
} symbol_table_t;

APE_INTERNAL symbol_t *symbol_make(allocator_t *alloc, const char *name, symbol_type_t type, int index, bool assignable);
APE_INTERNAL void symbol_destroy(symbol_t *symbol);
APE_INTERNAL symbol_t* symbol_copy(symbol_t *symbol);

APE_INTERNAL void symbol_destroy_wrapper(void *symbol);
APE_INTERNAL void* symbol_copy_wrapper(void *symbol);

APE_INTERNAL symbol_table_t *symbol_table_make(allocator_t *alloc, symbol_table_t *outer, global_store_t *global_store, int module_global_offset);
APE_INTERNAL void symbol_table_destroy(symbol_table_t *st);
APE_INTERNAL symbol_table_t* symbol_table_copy(symbol_table_t *st);
APE_INTERNAL bool symbol_table_add_module_symbol(symbol_table_t *st, symbol_t *symbol);
APE_INTERNAL const symbol_t *symbol_table_define(symbol_table_t *st, const char *name, bool assignable);
APE_INTERNAL const symbol_t *symbol_table_define_free(symbol_table_t *st, const symbol_t *original);
APE_INTERNAL const symbol_t *symbol_table_define_function_name(symbol_table_t *st, const char *name, bool assignable);
APE_INTERNAL const symbol_t *symbol_table_define_this(symbol_table_t *st);

APE_INTERNAL const symbol_t *symbol_table_resolve(symbol_table_t *st, const char *name);

APE_INTERNAL bool symbol_table_symbol_is_defined(symbol_table_t *st, const char *name);
APE_INTERNAL bool symbol_table_push_block_scope(symbol_table_t *table);
APE_INTERNAL void symbol_table_pop_block_scope(symbol_table_t *table);
APE_INTERNAL block_scope_t* symbol_table_get_block_scope(symbol_table_t *table);

APE_INTERNAL bool symbol_table_is_module_global_scope(symbol_table_t *table);
APE_INTERNAL bool symbol_table_is_top_block_scope(symbol_table_t *table);
APE_INTERNAL bool symbol_table_is_top_global_scope(symbol_table_t *table);

APE_INTERNAL int symbol_table_get_module_global_symbol_count(const symbol_table_t *table);
APE_INTERNAL const symbol_t * symbol_table_get_module_global_symbol_at(const symbol_table_t *table, int ix);


#endif /* symbol_table_h */
//FILE_END
//FILE_START:code.h
#ifndef code_h
#define code_h

#include <stdint.h>

#ifndef APE_AMALGAMATED
#include "common.h"
#include "collections.h"
#endif

typedef uint8_t opcode_t;

typedef enum opcode_val {
    OPCODE_NONE = 0,
    OPCODE_CONSTANT,
    OPCODE_ADD,
    OPCODE_POP,
    OPCODE_SUB,
    OPCODE_MUL,
    OPCODE_DIV,
    OPCODE_MOD,
    OPCODE_TRUE,
    OPCODE_FALSE,
    OPCODE_COMPARE,
    OPCODE_COMPARE_EQ,
    OPCODE_EQUAL,
    OPCODE_NOT_EQUAL,
    OPCODE_GREATER_THAN,
    OPCODE_GREATER_THAN_EQUAL,
    OPCODE_MINUS,
    OPCODE_BANG,
    OPCODE_JUMP,
    OPCODE_JUMP_IF_FALSE,
    OPCODE_JUMP_IF_TRUE,
    OPCODE_NULL,
    OPCODE_GET_MODULE_GLOBAL,
    OPCODE_SET_MODULE_GLOBAL,
    OPCODE_DEFINE_MODULE_GLOBAL,
    OPCODE_ARRAY,
    OPCODE_MAP_START,
    OPCODE_MAP_END,
    OPCODE_GET_THIS,
    OPCODE_GET_INDEX,
    OPCODE_SET_INDEX,
    OPCODE_GET_VALUE_AT,
    OPCODE_CALL,
    OPCODE_RETURN_VALUE,
    OPCODE_RETURN,
    OPCODE_GET_LOCAL,
    OPCODE_DEFINE_LOCAL,
    OPCODE_SET_LOCAL,
    OPCODE_GET_APE_GLOBAL,
    OPCODE_FUNCTION,
    OPCODE_GET_FREE,
    OPCODE_SET_FREE,
    OPCODE_CURRENT_FUNCTION,
    OPCODE_DUP,
    OPCODE_NUMBER,
    OPCODE_LEN,
    OPCODE_SET_RECOVER,
    OPCODE_OR,
    OPCODE_XOR,
    OPCODE_AND,
    OPCODE_LSHIFT,
    OPCODE_RSHIFT,
    OPCODE_MAX,
} opcode_val_t;

typedef struct opcode_definition {
    const char *name;
    int num_operands;
    int operand_widths[2];
} opcode_definition_t;

APE_INTERNAL opcode_definition_t* opcode_lookup(opcode_t op);
APE_INTERNAL const char *opcode_get_name(opcode_t op);
APE_INTERNAL int code_make(opcode_t op, int operands_count, uint64_t *operands, array(uint8_t) *res);
APE_INTERNAL void code_to_string(uint8_t *code, src_pos_t *source_positions, size_t code_size, strbuf_t *res);
APE_INTERNAL bool code_read_operands(opcode_definition_t *def, uint8_t *instr, uint64_t out_operands[2]);

#endif /* code_h */
//FILE_END
//FILE_START:compilation_scope.h
#ifndef compilation_scope_h
#define compilation_scope_h

#ifndef APE_AMALGAMATED
#include "symbol_table.h"
#include "code.h"
#include "gc.h"
#endif

typedef struct compilation_result {
    allocator_t *alloc;
    uint8_t *bytecode;
    src_pos_t *src_positions;
    int count;
} compilation_result_t;

typedef struct compilation_scope {
    allocator_t *alloc;
    struct compilation_scope *outer;
    array(uint8_t) *bytecode;
    array(src_pos_t) *src_positions;
    array(int) *break_ip_stack;
    array(int) *continue_ip_stack;
    opcode_t last_opcode;
} compilation_scope_t;

APE_INTERNAL compilation_scope_t* compilation_scope_make(allocator_t *alloc, compilation_scope_t *outer);
APE_INTERNAL void compilation_scope_destroy(compilation_scope_t *scope);
APE_INTERNAL compilation_result_t *compilation_scope_orphan_result(compilation_scope_t *scope);

APE_INTERNAL compilation_result_t* compilation_result_make(allocator_t *alloc, uint8_t *bytecode, src_pos_t *src_positions, int count);
APE_INTERNAL void compilation_result_destroy(compilation_result_t* res);

#endif /* compilation_scope_h */
//FILE_END
//FILE_START:optimisation.h
#ifndef optimisation_h
#define optimisation_h


#ifndef APE_AMALGAMATED
#include "common.h"
#include "parser.h"
#endif

APE_INTERNAL expression_t* optimise_expression(expression_t* expr);

#endif /* optimisation_h */
//FILE_END
//FILE_START:compiler.h
#ifndef compiler_h
#define compiler_h

#ifndef APE_AMALGAMATED
#include "collections.h"
#include "common.h"
#include "errors.h"
#include "parser.h"
#include "code.h"
#include "token.h"
#include "compilation_scope.h"
#include "compiled_file.h"
#endif

typedef struct ape_config ape_config_t;
typedef struct gcmem gcmem_t;
typedef struct symbol_table symbol_table_t;

typedef struct compiler compiler_t;
typedef struct compilation_result compilation_result_t;
typedef struct compiled_file compiled_file_t;

APE_INTERNAL compiler_t *compiler_make(allocator_t *alloc,
                                       const ape_config_t *config,
                                       gcmem_t *mem, errors_t *errors,
                                       ptrarray(compiled_file_t) *files,
                                       global_store_t *global_store);
APE_INTERNAL void compiler_destroy(compiler_t *comp);
APE_INTERNAL compilation_result_t* compiler_compile(compiler_t *comp, const char *code, size_t len);
APE_INTERNAL compilation_result_t* compiler_compile_file(compiler_t *comp, const char *path);
APE_INTERNAL symbol_table_t* compiler_get_symbol_table(compiler_t *comp);
APE_INTERNAL void compiler_set_symbol_table(compiler_t *comp, symbol_table_t *table);
APE_INTERNAL array(object_t)* compiler_get_constants(const compiler_t *comp);

#endif /* compiler_h */
//FILE_END
//FILE_START:gc.h
#ifndef gc_h
#define gc_h

#ifndef APE_AMALGAMATED
#include "common.h"
#include "collections.h"
#include "object.h"
#endif

typedef struct object_data object_data_t;
typedef struct env env_t;

#define GCMEM_POOL_SIZE 2048
#define GCMEM_POOLS_NUM 3
#define GCMEM_SWEEP_INTERVAL 128

typedef struct object_data_pool {
    object_data_t *data[GCMEM_POOL_SIZE];
    int count;
} object_data_pool_t;

typedef struct gcmem {
    allocator_t *alloc;
    int allocations_since_sweep;

    ptrarray(object_data_t) *objects;
    ptrarray(object_data_t) *objects_back;

    array(object_t) *objects_not_gced;

    object_data_pool_t data_only_pool;
    object_data_pool_t pools[GCMEM_POOLS_NUM];
} gcmem_t;

APE_INTERNAL gcmem_t *gcmem_make(allocator_t *alloc);
APE_INTERNAL void gcmem_destroy(gcmem_t *mem);

APE_INTERNAL object_data_t* gcmem_alloc_object_data(gcmem_t *mem, object_type_t type);
APE_INTERNAL object_data_t* gcmem_get_object_data_from_pool(gcmem_t *mem, object_type_t type);

APE_INTERNAL void gc_unmark_all(gcmem_t *mem);
APE_INTERNAL void gc_mark_objects(object_t *objects, int count);
APE_INTERNAL void gc_mark_object(object_t object);
APE_INTERNAL void gc_sweep(gcmem_t *mem);

APE_INTERNAL bool gc_disable_on_object(object_t obj);
APE_INTERNAL void gc_enable_on_object(object_t obj);

APE_INTERNAL int gc_should_sweep(gcmem_t *mem);

#endif /* gc_h */
//FILE_END
//FILE_START:builtins.h
#ifndef builtins_h
#define builtins_h

#include <stdint.h>

#ifndef APE_AMALGAMATED
#include "common.h"
#include "object.h"
#endif

typedef struct vm vm_t;

APE_INTERNAL int builtins_count(void);
APE_INTERNAL native_fn builtins_get_fn(int ix);
APE_INTERNAL const char* builtins_get_name(int ix);

#endif /* builtins_h */
//FILE_END
//FILE_START:traceback.h
#ifndef traceback_h
#define traceback_h

#ifndef APE_AMALGAMATED
#include "common.h"
#include "collections.h"
#endif

typedef struct vm vm_t;

typedef struct traceback_item {
    char *function_name;
    src_pos_t pos;
} traceback_item_t;

typedef struct traceback {
    allocator_t *alloc;
    array(traceback_item_t)* items;
} traceback_t;

APE_INTERNAL traceback_t* traceback_make(allocator_t *alloc);
APE_INTERNAL void traceback_destroy(traceback_t *traceback);
APE_INTERNAL bool traceback_append(traceback_t *traceback, const char *function_name, src_pos_t pos);
APE_INTERNAL bool traceback_append_from_vm(traceback_t *traceback, vm_t *vm);
APE_INTERNAL bool traceback_to_string(const traceback_t *traceback, strbuf_t *buf);
APE_INTERNAL const char* traceback_item_get_line(traceback_item_t *item);
APE_INTERNAL const char* traceback_item_get_filepath(traceback_item_t *item);

#endif /* traceback_h */
//FILE_END
//FILE_START:frame.h
#ifndef frame_h
#define frame_h

#include <stdint.h>

#ifndef APE_AMALGAMATED
#include "common.h"
#include "object.h"
#include "collections.h"
#include "code.h"
#endif

typedef struct {
    object_t function;
    int ip;
    int base_pointer;
    const src_pos_t *src_positions;
    uint8_t *bytecode;
    int src_ip;
    int bytecode_size;
    int recover_ip;
    bool is_recovering;
} frame_t;

APE_INTERNAL bool frame_init(frame_t* frame, object_t function, int base_pointer);

APE_INTERNAL opcode_val_t frame_read_opcode(frame_t* frame);
APE_INTERNAL uint64_t frame_read_uint64(frame_t* frame);
APE_INTERNAL uint16_t frame_read_uint16(frame_t* frame);
APE_INTERNAL uint8_t frame_read_uint8(frame_t* frame);
APE_INTERNAL src_pos_t frame_src_position(const frame_t *frame);

#endif /* frame_h */
//FILE_END
//FILE_START:vm.h
#ifndef vm_h
#define vm_h

#ifndef APE_AMALGAMATED
#include "ape.h"
#include "common.h"
#include "ast.h"
#include "object.h"
#include "frame.h"
#include "errors.h"
#include "global_store.h"
#endif

#define VM_STACK_SIZE 2048
#define VM_MAX_GLOBALS 2048
#define VM_MAX_FRAMES 2048
#define VM_THIS_STACK_SIZE 2048

typedef struct ape_config ape_config_t;
typedef struct compilation_result compilation_result_t;

typedef struct vm {
    allocator_t *alloc;
    const ape_config_t *config;
    gcmem_t *mem;
    errors_t *errors;
    global_store_t *global_store;
    object_t globals[VM_MAX_GLOBALS];
    int globals_count;
    object_t stack[VM_STACK_SIZE];
    int sp;
    object_t this_stack[VM_THIS_STACK_SIZE];
    int this_sp;
    frame_t frames[VM_MAX_FRAMES];
    int frames_count;
    object_t last_popped;
    frame_t *current_frame;
    bool running;
    object_t operator_oveload_keys[OPCODE_MAX];
} vm_t;

APE_INTERNAL vm_t* vm_make(allocator_t *alloc, const ape_config_t *config, gcmem_t *mem, errors_t *errors, global_store_t *global_store); // config can be null (for internal testing purposes)
APE_INTERNAL void  vm_destroy(vm_t *vm);

APE_INTERNAL void vm_reset(vm_t *vm);

APE_INTERNAL bool vm_run(vm_t *vm, compilation_result_t *comp_res, array(object_t) *constants);
APE_INTERNAL object_t vm_call(vm_t *vm, array(object_t) *constants, object_t callee, int argc, object_t *args);
APE_INTERNAL bool vm_execute_function(vm_t *vm, object_t function, array(object_t) *constants);

APE_INTERNAL object_t vm_get_last_popped(vm_t *vm);
APE_INTERNAL bool vm_has_errors(vm_t *vm);

APE_INTERNAL bool vm_set_global(vm_t *vm, int ix, object_t val);
APE_INTERNAL object_t vm_get_global(vm_t *vm, int ix);

#endif /* vm_h */
//FILE_END

//-----------------------------------------------------------------------------
// C files
//-----------------------------------------------------------------------------
//FILE_START:common.c
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

#ifndef APE_AMALGAMATED
#include "common.h"
#include "collections.h"
#endif

APE_INTERNAL const src_pos_t src_pos_invalid = { NULL, -1, -1 };
APE_INTERNAL const src_pos_t src_pos_zero = { NULL, 0, 0 };

APE_INTERNAL src_pos_t src_pos_make(const compiled_file_t *file, int line, int column) {
    return (src_pos_t) {
        .file = file,
        .line = line,
        .column = column,
    };
}

char *ape_stringf(allocator_t *alloc, const char *format, ...) {
    va_list args;
    va_start(args, format);
    int to_write = vsnprintf(NULL, 0, format, args);
    va_end(args);
    va_start(args, format);
    char *res = (char*)allocator_malloc(alloc, to_write + 1);
    if (!res) {
        return NULL;
    }
    int written = vsprintf(res, format, args);
    (void)written;
    APE_ASSERT(written == to_write);
    va_end(args);
    return res;
}

void ape_log(const char *file, int line, const char *format, ...) {
    char msg[4096];
    int written = snprintf(msg, APE_ARRAY_LEN(msg) - 1, "%s:%d: ", file, line);
    (void)written;
    va_list args;
    va_start(args, format);
    int written_msg = vsnprintf(msg + written, APE_ARRAY_LEN(msg) - written - 1, format, args);
    (void)written_msg;
    va_end(args);

    APE_ASSERT(written_msg <= (APE_ARRAY_LEN(msg) - written));

    printf("%s", msg);
}

char* ape_strndup(allocator_t *alloc, const char *string, size_t n) {
    char *output_string = (char*)allocator_malloc(alloc, n + 1);
    if (!output_string) {
        return NULL;
    }
    output_string[n] = '\0';
    memcpy(output_string, string, n);
    return output_string;
}

char* ape_strdup(allocator_t *alloc, const char *string) {
    if (!string) {
        return NULL;
    }
    return ape_strndup(alloc, string, strlen(string));
}

uint64_t ape_double_to_uint64(double val) {
    union {
        uint64_t val_uint64;
        double val_double;
    } temp = {
        .val_double = val
    };
    return temp.val_uint64;
}

double ape_uint64_to_double(uint64_t val) {
    union {
        uint64_t val_uint64;
        double val_double;
    } temp = {
        .val_uint64 = val
    };
    return temp.val_double;
}

bool ape_timer_platform_supported() {
#if defined(APE_POSIX) || defined(APE_EMSCRIPTEN) || defined(APE_WINDOWS)
    return true;
#else
    return false;
#endif
}

ape_timer_t ape_timer_start() {
    ape_timer_t timer;
    memset(&timer, 0, sizeof(ape_timer_t));
#if defined(APE_POSIX)
    // At some point it should be replaced with more accurate per-platform timers
    struct timeval start_time;
    gettimeofday(&start_time, NULL);
    timer.start_offset = start_time.tv_sec;
    timer.start_time_ms = start_time.tv_usec / 1000.0;
#elif defined(APE_WINDOWS)
    LARGE_INTEGER li;
    QueryPerformanceFrequency(&li); // not sure what to do if it fails
    timer.pc_frequency = (double)(li.QuadPart) / 1000.0;
    QueryPerformanceCounter(&li);
    timer.start_time_ms = li.QuadPart / timer.pc_frequency;
#elif defined(APE_EMSCRIPTEN)
    timer.start_time_ms = emscripten_get_now();
#endif
    return timer;
}

double ape_timer_get_elapsed_ms(const ape_timer_t *timer) {
#if defined(APE_POSIX)
    struct timeval current_time;
    gettimeofday(&current_time, NULL);
    int time_s = (int)((int64_t)current_time.tv_sec - timer->start_offset);
    double current_time_ms = (time_s * 1000) + (current_time.tv_usec / 1000.0);
    return current_time_ms - timer->start_time_ms;
#elif defined(APE_WINDOWS)
    LARGE_INTEGER li;
    QueryPerformanceCounter(&li);
    double current_time_ms = li.QuadPart / timer->pc_frequency;
    return current_time_ms - timer->start_time_ms;
#elif defined(APE_EMSCRIPTEN)
    double current_time_ms = emscripten_get_now();
    return current_time_ms - timer->start_time_ms;
#else
    return 0;
#endif
}
//FILE_END
//FILE_START:collections.c
#ifndef COLLECTIONS_AMALGAMATED
#include "collections.h"
#endif

#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdint.h>

#ifdef COLLECTIONS_DEBUG
#include <assert.h>
#define COLLECTIONS_ASSERT(x) assert(x)
#else
#define COLLECTIONS_ASSERT(x)
#endif

//-----------------------------------------------------------------------------
// Collections
//-----------------------------------------------------------------------------
static char* collections_strndup(allocator_t *alloc, const char *string, size_t n);
static char* collections_strdup(allocator_t *alloc, const char *string);
static unsigned long collections_hash(const void *ptr, size_t len); /* djb2 */
static unsigned int upper_power_of_two(unsigned int v);

static char* collections_strndup(allocator_t *alloc, const char *string, size_t n) {
    char *output_string = (char*)allocator_malloc(alloc, n + 1);
    if (!output_string) {
        return NULL;
    }
    output_string[n] = '\0';
    memcpy(output_string, string, n);
    return output_string;
}

static char* collections_strdup(allocator_t *alloc, const char *string) {
    if (!string) {
        return NULL;
    }
    return collections_strndup(alloc, string, strlen(string));
}

static unsigned long collections_hash(const void *ptr, size_t len) { /* djb2 */
    const uint8_t *ptr_u8 = (const uint8_t*)ptr;
    unsigned long hash = 5381;
    for (size_t i = 0; i < len; i++) {
        uint8_t val = ptr_u8[i];
        hash = ((hash << 5) + hash) + val;
    }
    return hash;
}

static unsigned int upper_power_of_two(unsigned int v) {
    v--;
    v |= v >> 1;
    v |= v >> 2;
    v |= v >> 4;
    v |= v >> 8;
    v |= v >> 16;
    v++;
    return v;
}

//-----------------------------------------------------------------------------
// Allocator
//-----------------------------------------------------------------------------

allocator_t allocator_make(allocator_malloc_fn malloc_fn, allocator_free_fn free_fn, void *ctx) {
    allocator_t alloc;
    alloc.malloc = malloc_fn;
    alloc.free = free_fn;
    alloc.ctx = ctx;
    return alloc;
}

void* allocator_malloc(allocator_t *allocator, size_t size) {
    if (!allocator || !allocator->malloc) {
        return malloc(size);
    }
    return allocator->malloc(allocator->ctx, size);
}

void allocator_free(allocator_t *allocator, void *ptr) {
    if (!allocator || !allocator->free) {
        free(ptr);
        return;
    }
    allocator->free(allocator->ctx, ptr);
}

//-----------------------------------------------------------------------------
// Dictionary
//-----------------------------------------------------------------------------

#define DICT_INVALID_IX UINT_MAX
#define DICT_INITIAL_SIZE 32

typedef struct dict_ {
    allocator_t *alloc;
    unsigned int *cells;
    unsigned long *hashes;
    char **keys;
    void **values;
    unsigned int *cell_ixs;
    unsigned int count;
    unsigned int item_capacity;
    unsigned int cell_capacity;
    dict_item_copy_fn copy_fn;
    dict_item_destroy_fn destroy_fn;
} dict_t_;

// Private declarations
static bool dict_init(dict_t_ *dict, allocator_t *alloc, unsigned int initial_capacity, dict_item_copy_fn copy_fn, dict_item_destroy_fn destroy_fn);
static void dict_deinit(dict_t_ *dict, bool free_keys);
static unsigned int dict_get_cell_ix(const dict_t_ *dict,
                                     const char *key,
                                     unsigned long hash,
                                     bool *out_found);
static unsigned long hash_string(const char *str);
static bool dict_grow_and_rehash(dict_t_ *dict);
static bool dict_set_internal(dict_t_ *dict, const char *ckey, char *mkey, void *value);

// Public
dict_t_* dict_make_(allocator_t *alloc, dict_item_copy_fn copy_fn, dict_item_destroy_fn destroy_fn) {
    dict_t_ *dict = allocator_malloc(alloc, sizeof(dict_t_));
    if (dict == NULL) {
        return NULL;
    }
    bool ok = dict_init(dict, alloc, DICT_INITIAL_SIZE, copy_fn, destroy_fn);
    if (!ok) {
        allocator_free(alloc, dict);
        return NULL;
    }
    return dict;
}

void dict_destroy(dict_t_ *dict) {
    if (!dict) {
        return;
    }
    allocator_t *alloc = dict->alloc;
    dict_deinit(dict, true);
    allocator_free(alloc, dict);
}

void dict_destroy_with_items(dict_t_ *dict) {
    if (!dict) {
        return;
    }

    if (dict->destroy_fn) {
        for (unsigned int i = 0; i < dict->count; i++) {
            dict->destroy_fn(dict->values[i]);
        }
    }

    dict_destroy(dict);
}

dict_t_* dict_copy_with_items(dict_t_ *dict) {
    if (!dict->copy_fn || !dict->destroy_fn) {
        return false;
    }

    dict_t_ *dict_copy = dict_make_(dict->alloc, dict->copy_fn, dict->destroy_fn);
    if (!dict_copy) {
        return NULL;
    }
    for (int i = 0; i < dict_count(dict); i++) {
        const char *key = dict_get_key_at(dict, i);
        void *item = dict_get_value_at(dict, i);
        void *item_copy = dict_copy->copy_fn(item);
        if (item && !item_copy) {
            dict_destroy_with_items(dict_copy);
            return NULL;
        }
        bool ok = dict_set(dict_copy, key, item_copy);
        if (!ok) {
            dict_copy->destroy_fn(item_copy);
            dict_destroy_with_items(dict_copy);
            return NULL;
        }
    }
    return dict_copy;
}

bool dict_set(dict_t_ *dict, const char *key, void *value) {
    return dict_set_internal(dict, key, NULL, value);
}

void* dict_get(const dict_t_ *dict, const char *key) {
    unsigned long hash = hash_string(key);
    bool found = false;
    unsigned long cell_ix = dict_get_cell_ix(dict, key, hash, &found);
    if (found == false) {
        return NULL;
    }
    unsigned int item_ix = dict->cells[cell_ix];
    return dict->values[item_ix];
}

void *dict_get_value_at(const dict_t_ *dict, unsigned int ix) {
    if (ix >= dict->count) {
        return NULL;
    }
    return dict->values[ix];
}

const char *dict_get_key_at(const dict_t_ *dict, unsigned int ix) {
    if (ix >= dict->count) {
        return NULL;
    }
    return dict->keys[ix];
}

int dict_count(const dict_t_ *dict) {
    if (!dict) {
        return 0;
    }
    return dict->count;
}

bool dict_remove(dict_t_ *dict, const char *key) {
    unsigned long hash = hash_string(key);
    bool found = false;
    unsigned int cell = dict_get_cell_ix(dict, key, hash, &found);
    if (!found) {
        return false;
    }

    unsigned int item_ix = dict->cells[cell];
    allocator_free(dict->alloc, dict->keys[item_ix]);
    unsigned int last_item_ix = dict->count - 1;
    if (item_ix < last_item_ix) {
        dict->keys[item_ix] = dict->keys[last_item_ix];
        dict->values[item_ix] = dict->values[last_item_ix];
        dict->cell_ixs[item_ix] = dict->cell_ixs[last_item_ix];
        dict->hashes[item_ix] = dict->hashes[last_item_ix];
        dict->cells[dict->cell_ixs[item_ix]] = item_ix;
    }
    dict->count--;

    unsigned int i = cell;
    unsigned int j = i;
    for (unsigned int x = 0; x < (dict->cell_capacity - 1); x++) {
        j = (j + 1) & (dict->cell_capacity - 1);
        if (dict->cells[j] == DICT_INVALID_IX) {
            break;
        }
        unsigned int k = (unsigned int)(dict->hashes[dict->cells[j]]) & (dict->cell_capacity - 1);
        if ((j > i && (k <= i || k > j))
            || (j < i && (k <= i && k > j))) {
            dict->cell_ixs[dict->cells[j]] = i;
            dict->cells[i] = dict->cells[j];
            i = j;
        }
    }
    dict->cells[i] = DICT_INVALID_IX;
    return true;
}

// Private definitions
static bool dict_init(dict_t_ *dict, allocator_t *alloc, unsigned int initial_capacity, dict_item_copy_fn copy_fn, dict_item_destroy_fn destroy_fn) {
    dict->alloc = alloc;
    dict->cells = NULL;
    dict->keys = NULL;
    dict->values = NULL;
    dict->cell_ixs = NULL;
    dict->hashes = NULL;

    dict->count = 0;
    dict->cell_capacity = initial_capacity;
    dict->item_capacity = (unsigned int)(initial_capacity * 0.7f);
    dict->copy_fn = copy_fn;
    dict->destroy_fn = destroy_fn;

    dict->cells = allocator_malloc(alloc, dict->cell_capacity * sizeof(*dict->cells));
    dict->keys = allocator_malloc(alloc, dict->item_capacity * sizeof(*dict->keys));
    dict->values = allocator_malloc(alloc, dict->item_capacity * sizeof(*dict->values));
    dict->cell_ixs = allocator_malloc(alloc, dict->item_capacity * sizeof(*dict->cell_ixs));
    dict->hashes = allocator_malloc(alloc, dict->item_capacity * sizeof(*dict->hashes));
    if (dict->cells == NULL
     || dict->keys == NULL
     || dict->values == NULL
     || dict->cell_ixs == NULL
     || dict->hashes == NULL) {
        goto error;
    }
    for (unsigned int i = 0; i < dict->cell_capacity; i++) {
        dict->cells[i] = DICT_INVALID_IX;
    }
    return true;
error:
    allocator_free(dict->alloc, dict->cells);
    allocator_free(dict->alloc, dict->keys);
    allocator_free(dict->alloc, dict->values);
    allocator_free(dict->alloc, dict->cell_ixs);
    allocator_free(dict->alloc, dict->hashes);
    return false;
}

static void dict_deinit(dict_t_ *dict, bool free_keys) {
    if (free_keys) {
        for (unsigned int i = 0; i < dict->count; i++) {
            allocator_free(dict->alloc, dict->keys[i]);
        }
    }
    dict->count = 0;
    dict->item_capacity = 0;
    dict->cell_capacity = 0;

    allocator_free(dict->alloc, dict->cells);
    allocator_free(dict->alloc, dict->keys);
    allocator_free(dict->alloc, dict->values);
    allocator_free(dict->alloc, dict->cell_ixs);
    allocator_free(dict->alloc, dict->hashes);

    dict->cells = NULL;
    dict->keys = NULL;
    dict->values = NULL;
    dict->cell_ixs = NULL;
    dict->hashes = NULL;
}

static unsigned int dict_get_cell_ix(const dict_t_ *dict,
                                     const char *key,
                                     unsigned long hash,
                                     bool *out_found)
{
    *out_found = false;
    unsigned int cell_ix = (unsigned int)hash & (dict->cell_capacity - 1);
    for (unsigned int i = 0; i < dict->cell_capacity; i++) {
        unsigned int ix = (cell_ix + i) & (dict->cell_capacity - 1);
        unsigned int cell = dict->cells[ix];
        if (cell == DICT_INVALID_IX) {
            return ix;
        }
        unsigned long hash_to_check = dict->hashes[cell];
        if (hash != hash_to_check) {
            continue;
        }
        const char *key_to_check = dict->keys[cell];
        if (strcmp(key, key_to_check) == 0) {
            *out_found = true;
            return ix;
        }
    }
    return DICT_INVALID_IX;
}

static unsigned long hash_string(const char *str) { /* djb2 */
    unsigned long hash = 5381;
    uint8_t c;
    while ((c = *str++)) {
        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
    }
    return hash;
}

static bool dict_grow_and_rehash(dict_t_ *dict) {
    dict_t_ new_dict;
    bool ok = dict_init(&new_dict, dict->alloc, dict->cell_capacity * 2, dict->copy_fn, dict->destroy_fn);
    if (!ok) {
        return false;
    }
    for (unsigned int i = 0; i < dict->count; i++) {
        char *key = dict->keys[i];
        void *value = dict->values[i];
        ok = dict_set_internal(&new_dict, key, key, value);
        if (!ok) {
            dict_deinit(&new_dict, false);
            return false;
        }
    }
    dict_deinit(dict, false);
    *dict = new_dict;
    return true;
}

static bool dict_set_internal(dict_t_ *dict, const char *ckey, char *mkey, void *value) {
    unsigned long hash = hash_string(ckey);
    bool found = false;
    unsigned int cell_ix = dict_get_cell_ix(dict, ckey, hash, &found);
    if (found) {
        unsigned int item_ix = dict->cells[cell_ix];
        dict->values[item_ix] = value;
        return true;
    }
    if (dict->count >= dict->item_capacity) {
        bool ok = dict_grow_and_rehash(dict);
        if (!ok) {
            return false;
        }
        cell_ix = dict_get_cell_ix(dict, ckey, hash, &found);
    }

    if (mkey) {
        dict->keys[dict->count] = mkey;
    } else {
        char *key_copy = collections_strdup(dict->alloc, ckey);
        if (!key_copy) {
            return false;
        }
        dict->keys[dict->count] = key_copy;
    }
    dict->cells[cell_ix] = dict->count;
    dict->values[dict->count] = value;
    dict->cell_ixs[dict->count] = cell_ix;
    dict->hashes[dict->count] = hash;
    dict->count++;
    return true;
}

//-----------------------------------------------------------------------------
// Value dictionary
//-----------------------------------------------------------------------------
#define VALDICT_INVALID_IX UINT_MAX

typedef struct valdict_ {
    allocator_t *alloc;
    size_t key_size;
    size_t val_size;
    unsigned int *cells;
    unsigned long *hashes;
    void *keys;
    void *values;
    unsigned int *cell_ixs;
    unsigned int count;
    unsigned int item_capacity;
    unsigned int cell_capacity;
    collections_hash_fn _hash_key;
    collections_equals_fn _keys_equals;
} valdict_t_;

// Private declarations
static bool valdict_init(valdict_t_ *dict, allocator_t *alloc, size_t key_size, size_t val_size, unsigned int initial_capacity);
static void valdict_deinit(valdict_t_ *dict);
static unsigned int valdict_get_cell_ix(const valdict_t_ *dict,
                                        const void *key,
                                        unsigned long hash,
                                        bool *out_found);
static bool valdict_grow_and_rehash(valdict_t_ *dict);
static bool valdict_set_key_at(valdict_t_ *dict, unsigned int ix, void *key);
static bool valdict_keys_are_equal(const valdict_t_ *dict, const void *a, const void *b);
static unsigned long valdict_hash_key(const valdict_t_ *dict, const void *key);

// Public
valdict_t_* valdict_make_(allocator_t *alloc, size_t key_size, size_t val_size) {
    return valdict_make_with_capacity(alloc, DICT_INITIAL_SIZE, key_size, val_size);
}

valdict_t_* valdict_make_with_capacity(allocator_t *alloc, unsigned int min_capacity, size_t key_size, size_t val_size) {
    unsigned int capacity = upper_power_of_two(min_capacity * 2);

    valdict_t_ *dict = allocator_malloc(alloc, sizeof(valdict_t_));
    if (!dict) {
        return NULL;
    }
    bool ok = valdict_init(dict, alloc, key_size, val_size, capacity);
    if (!ok) {
        allocator_free(alloc, dict);
        return NULL;
    }
    return dict;
}

void valdict_destroy(valdict_t_ *dict) {
    if (!dict) {
        return;
    }
    allocator_t *alloc = dict->alloc;
    valdict_deinit(dict);
    allocator_free(alloc, dict);
}

void  valdict_set_hash_function(valdict_t_ *dict, collections_hash_fn hash_fn) {
    dict->_hash_key = hash_fn;
}

void valdict_set_equals_function(valdict_t_ *dict, collections_equals_fn equals_fn) {
    dict->_keys_equals = equals_fn;
}

bool valdict_set(valdict_t_ *dict, void *key, void *value) {
    unsigned long hash = valdict_hash_key(dict, key);
    bool found = false;
    unsigned int cell_ix = valdict_get_cell_ix(dict, key, hash, &found);
    if (found) {
        unsigned int item_ix = dict->cells[cell_ix];
        valdict_set_value_at(dict, item_ix, value);
        return true;
    }
    if (dict->count >= dict->item_capacity) {
        bool ok = valdict_grow_and_rehash(dict);
        if (!ok) {
            return false;
        }
        cell_ix = valdict_get_cell_ix(dict, key, hash, &found);
    }
    unsigned int last_ix = dict->count;
    dict->count++;
    dict->cells[cell_ix] = last_ix;
    valdict_set_key_at(dict, last_ix, key);
    valdict_set_value_at(dict, last_ix, value);
    dict->cell_ixs[last_ix] = cell_ix;
    dict->hashes[last_ix] = hash;
    return true;
}

void* valdict_get(const valdict_t_ *dict, const void *key) {
    unsigned long hash = valdict_hash_key(dict, key);
    bool found = false;
    unsigned long cell_ix = valdict_get_cell_ix(dict, key, hash, &found);
    if (!found) {
        return NULL;
    }
    unsigned int item_ix = dict->cells[cell_ix];
    return valdict_get_value_at(dict, item_ix);
}

void* valdict_get_key_at(const valdict_t_ *dict, unsigned int ix) {
    if (ix >= dict->count) {
        return NULL;
    }
    return (char*)dict->keys + (dict->key_size * ix);
}

void *valdict_get_value_at(const valdict_t_ *dict, unsigned int ix) {
    if (ix >= dict->count) {
        return NULL;
    }
    return (char*)dict->values + (dict->val_size * ix);
}

unsigned int valdict_get_capacity(const valdict_t_ *dict) {
    return dict->item_capacity;
}

bool valdict_set_value_at(const valdict_t_ *dict, unsigned int ix, const void *value) {
    if (ix >= dict->count) {
        return false;
    }
    size_t offset = ix * dict->val_size;
    memcpy((char*)dict->values + offset, value, dict->val_size);
    return true;
}

int valdict_count(const valdict_t_ *dict) {
    if (!dict) {
        return 0;
    }
    return dict->count;
}

bool valdict_remove(valdict_t_ *dict, void *key) {
    unsigned long hash = valdict_hash_key(dict, key);
    bool found = false;
    unsigned int cell = valdict_get_cell_ix(dict, key, hash, &found);
    if (!found) {
        return false;
    }

    unsigned int item_ix = dict->cells[cell];
    unsigned int last_item_ix = dict->count - 1;
    if (item_ix < last_item_ix) {
        void *last_key = valdict_get_key_at(dict, last_item_ix);
        valdict_set_key_at(dict, item_ix, last_key);
        void *last_value = valdict_get_key_at(dict, last_item_ix);
        valdict_set_value_at(dict, item_ix, last_value);
        dict->cell_ixs[item_ix] = dict->cell_ixs[last_item_ix];
        dict->hashes[item_ix] = dict->hashes[last_item_ix];
        dict->cells[dict->cell_ixs[item_ix]] = item_ix;
    }
    dict->count--;

    unsigned int i = cell;
    unsigned int j = i;
    for (unsigned int x = 0; x < (dict->cell_capacity - 1); x++) {
        j = (j + 1) & (dict->cell_capacity - 1);
        if (dict->cells[j] == VALDICT_INVALID_IX) {
            break;
        }
        unsigned int k = (unsigned int)(dict->hashes[dict->cells[j]]) & (dict->cell_capacity - 1);
        if ((j > i && (k <= i || k > j))
            || (j < i && (k <= i && k > j))) {
            dict->cell_ixs[dict->cells[j]] = i;
            dict->cells[i] = dict->cells[j];
            i = j;
        }
    }
    dict->cells[i] = VALDICT_INVALID_IX;
    return true;
}

void valdict_clear(valdict_t_ *dict) {
    dict->count = 0;
    for (unsigned int i = 0; i < dict->cell_capacity; i++) {
        dict->cells[i] = VALDICT_INVALID_IX;
    }
}

// Private definitions
static bool valdict_init(valdict_t_ *dict, allocator_t *alloc, size_t key_size, size_t val_size, unsigned int initial_capacity) {
    dict->alloc = alloc;
    dict->key_size = key_size;
    dict->val_size = val_size;
    dict->cells = NULL;
    dict->keys = NULL;
    dict->values = NULL;
    dict->cell_ixs = NULL;
    dict->hashes = NULL;

    dict->count = 0;
    dict->cell_capacity = initial_capacity;
    dict->item_capacity = (unsigned int)(initial_capacity * 0.7f);

    dict->_keys_equals = NULL;
    dict->_hash_key = NULL;

    dict->cells = allocator_malloc(dict->alloc, dict->cell_capacity * sizeof(*dict->cells));
    dict->keys = allocator_malloc(dict->alloc, dict->item_capacity * key_size);
    dict->values = allocator_malloc(dict->alloc, dict->item_capacity * val_size);
    dict->cell_ixs = allocator_malloc(dict->alloc, dict->item_capacity * sizeof(*dict->cell_ixs));
    dict->hashes = allocator_malloc(dict->alloc, dict->item_capacity * sizeof(*dict->hashes));
    if (dict->cells == NULL
     || dict->keys == NULL
     || dict->values == NULL
     || dict->cell_ixs == NULL
     || dict->hashes == NULL) {
        goto error;
    }
    for (unsigned int i = 0; i < dict->cell_capacity; i++) {
        dict->cells[i] = VALDICT_INVALID_IX;
    }
    return true;
error:
    allocator_free(dict->alloc, dict->cells);
    allocator_free(dict->alloc, dict->keys);
    allocator_free(dict->alloc, dict->values);
    allocator_free(dict->alloc, dict->cell_ixs);
    allocator_free(dict->alloc, dict->hashes);
    return false;
}

static void valdict_deinit(valdict_t_ *dict) {
    dict->key_size = 0;
    dict->val_size = 0;
    dict->count = 0;
    dict->item_capacity = 0;
    dict->cell_capacity = 0;

    allocator_free(dict->alloc, dict->cells);
    allocator_free(dict->alloc, dict->keys);
    allocator_free(dict->alloc, dict->values);
    allocator_free(dict->alloc, dict->cell_ixs);
    allocator_free(dict->alloc, dict->hashes);

    dict->cells = NULL;
    dict->keys = NULL;
    dict->values = NULL;
    dict->cell_ixs = NULL;
    dict->hashes = NULL;
}

static unsigned int valdict_get_cell_ix(const valdict_t_ *dict,
                                        const void *key,
                                        unsigned long hash,
                                        bool *out_found)
{
    *out_found = false;
    unsigned int cell_ix = (unsigned int)hash & (dict->cell_capacity - 1);
    for (unsigned int i = 0; i < dict->cell_capacity; i++) {
        unsigned int ix = (cell_ix + i) & (dict->cell_capacity - 1);
        unsigned int cell = dict->cells[ix];
        if (cell == VALDICT_INVALID_IX) {
            return ix;
        }
        unsigned long hash_to_check = dict->hashes[cell];
        if (hash != hash_to_check) {
            continue;
        }
        void *key_to_check = valdict_get_key_at(dict, cell);
        bool are_equal = valdict_keys_are_equal(dict, key, key_to_check);
        if (are_equal) {
            *out_found = true;
            return ix;
        }
    }
    return VALDICT_INVALID_IX;
}

static bool valdict_grow_and_rehash(valdict_t_ *dict) {
    valdict_t_ new_dict;
    unsigned new_capacity = dict->cell_capacity == 0 ? DICT_INITIAL_SIZE : dict->cell_capacity * 2;
    bool ok = valdict_init(&new_dict, dict->alloc, dict->key_size, dict->val_size, new_capacity);
    if (!ok) {
        return false;
    }
    new_dict._keys_equals = dict->_keys_equals;
    new_dict._hash_key = dict->_hash_key;
    for (unsigned int i = 0; i < dict->count; i++) {
        char *key = valdict_get_key_at(dict, i);
        void *value = valdict_get_value_at(dict, i);
        ok = valdict_set(&new_dict, key, value);
        if (!ok) {
            valdict_deinit(&new_dict);
            return false;
        }
    }
    valdict_deinit(dict);
    *dict = new_dict;
    return true;
}

static bool valdict_set_key_at(valdict_t_ *dict, unsigned int ix, void *key) {
    if (ix >= dict->count) {
        return false;
    }
    size_t offset = ix * dict->key_size;
    memcpy((char*)dict->keys + offset, key, dict->key_size);
    return true;
}

static bool valdict_keys_are_equal(const valdict_t_ *dict, const void *a, const void *b) {
    if (dict->_keys_equals) {
        return dict->_keys_equals(a, b);
    } else {
        return memcmp(a, b, dict->key_size) == 0;
    }
}

static unsigned long valdict_hash_key(const valdict_t_ *dict, const void *key) {
    if (dict->_hash_key) {
        return dict->_hash_key(key);
    } else {
        return collections_hash(key, dict->key_size);
    }
}

//-----------------------------------------------------------------------------
// Pointer dictionary
//-----------------------------------------------------------------------------
typedef struct ptrdict_ {
    allocator_t *alloc;
    valdict_t_ vd;
} ptrdict_t_;

// Public
ptrdict_t_* ptrdict_make(allocator_t *alloc) {
    ptrdict_t_ *dict = allocator_malloc(alloc, sizeof(ptrdict_t_));
    if (!dict) {
        return NULL;
    }
    dict->alloc = alloc;
    bool ok = valdict_init(&dict->vd, alloc, sizeof(void*), sizeof(void*), DICT_INITIAL_SIZE);
    if (!ok) {
        allocator_free(alloc, dict);
        return NULL;
    }
    return dict;
}

void ptrdict_destroy(ptrdict_t_ *dict) {
    if (dict == NULL) {
        return;
    }
    valdict_deinit(&dict->vd);
    allocator_free(dict->alloc, dict);
}

void  ptrdict_set_hash_function(ptrdict_t_ *dict, collections_hash_fn hash_fn) {
    valdict_set_hash_function(&dict->vd, hash_fn);
}

void ptrdict_set_equals_function(ptrdict_t_ *dict, collections_equals_fn equals_fn) {
    valdict_set_equals_function(&dict->vd, equals_fn);
}

bool ptrdict_set(ptrdict_t_ *dict, void *key, void *value) {
    return valdict_set(&dict->vd, &key, &value);
}

void* ptrdict_get(const ptrdict_t_ *dict, const void *key) {
    void* res = valdict_get(&dict->vd, &key);
    if (!res) {
        return NULL;
    }
    return *(void**)res;
}

void* ptrdict_get_value_at(const ptrdict_t_ *dict, unsigned int ix) {
    void* res = valdict_get_value_at(&dict->vd, ix);
    if (!res) {
        return NULL;
    }
    return *(void**)res;
}

void* ptrdict_get_key_at(const ptrdict_t_ *dict, unsigned int ix) {
    void* res = valdict_get_key_at(&dict->vd, ix);
    if (!res) {
        return NULL;
    }
    return *(void**)res;
}

int ptrdict_count(const ptrdict_t_ *dict) {
    return valdict_count(&dict->vd);
}

bool ptrdict_remove(ptrdict_t_ *dict, void *key) {
    return valdict_remove(&dict->vd, &key);
}

//-----------------------------------------------------------------------------
// Array
//-----------------------------------------------------------------------------

typedef struct array_ {
    allocator_t *alloc;
    unsigned char *data;
    unsigned char *data_allocated;
    unsigned int count;
    unsigned int capacity;
    size_t element_size;
    bool lock_capacity;
} array_t_;

static bool array_init_with_capacity(array_t_ *arr, allocator_t *alloc, unsigned int capacity, size_t element_size);
static void array_deinit(array_t_ *arr);

array_t_* array_make_(allocator_t *alloc, size_t element_size) {
    return array_make_with_capacity(alloc, 32, element_size);
}

array_t_* array_make_with_capacity(allocator_t *alloc, unsigned int capacity, size_t element_size) {
    array_t_ *arr = allocator_malloc(alloc, sizeof(array_t_));
    if (!arr) {
        return NULL;
    }

    bool ok = array_init_with_capacity(arr, alloc, capacity, element_size);
    if (!ok) {
        allocator_free(alloc, arr);
        return NULL;
    }
    return arr;
}

void array_destroy(array_t_ *arr) {
    if (!arr) {
        return;
    }
    allocator_t *alloc = arr->alloc;
    array_deinit(arr);
    allocator_free(alloc, arr);
}

void array_destroy_with_items_(array_t_ *arr, array_item_deinit_fn deinit_fn) {
    for (int i = 0; i < array_count(arr); i++) {
        void *item = array_get(arr, i);
        deinit_fn(item);
    }
    array_destroy(arr);
}

array_t_* array_copy(const array_t_ *arr) {
    array_t_ *copy = allocator_malloc(arr->alloc, sizeof(array_t_));
    if (!copy) {
        return NULL;
    }
    copy->alloc = arr->alloc;
    copy->capacity = arr->capacity;
    copy->count = arr->count;
    copy->element_size = arr->element_size;
    copy->lock_capacity = arr->lock_capacity;
    if (arr->data_allocated) {
        copy->data_allocated = allocator_malloc(arr->alloc, arr->capacity * arr->element_size);
        if (!copy->data_allocated) {
            allocator_free(arr->alloc, copy);
            return NULL;
        }
        copy->data = copy->data_allocated;
        memcpy(copy->data_allocated, arr->data, arr->capacity * arr->element_size);
    } else {
        copy->data_allocated = NULL;
        copy->data = NULL;
    }

    return copy;
}

bool array_add(array_t_ *arr, const void *value) {
    if (arr->count >= arr->capacity) {
        COLLECTIONS_ASSERT(!arr->lock_capacity);
        if (arr->lock_capacity) {
            return false;
        }
        unsigned int new_capacity = arr->capacity > 0 ? arr->capacity * 2 : 1;
        unsigned char *new_data = allocator_malloc(arr->alloc, new_capacity * arr->element_size);
        if (!new_data) {
            return false;
        }
        if(arr->data) {
            memcpy(new_data, arr->data, arr->count * arr->element_size);
        }
        allocator_free(arr->alloc, arr->data_allocated);
        arr->data_allocated = new_data;
        arr->data = arr->data_allocated;
        arr->capacity = new_capacity;
    }
    if (value) {
        memcpy(arr->data + (arr->count * arr->element_size), value, arr->element_size);
    }
    arr->count++;
    return true;
}

bool array_addn(array_t_ *arr, const void *values, int n) {
    for (int i = 0; i < n; i++) {
        const uint8_t *value = NULL;
        if (values) {
            value = (const uint8_t*)values + (i * arr->element_size);
        }
        bool ok = array_add(arr, value);
        if (!ok) {
            return false;
        }
    }
    return true;
}

bool array_add_array(array_t_ *dest, array_t_ *source) {
    COLLECTIONS_ASSERT(dest->element_size == source->element_size);
    if (dest->element_size != source->element_size) {
        return false;
    }
    int dest_before_count = array_count(dest);
    for (int i = 0; i < array_count(source); i++) {
        void *item = array_get(source, i);
        bool ok = array_add(dest, item);
        if (!ok) {
            dest->count = dest_before_count;
            return false;
        }
    }
    return true;
}

bool array_push(array_t_ *arr, const void *value) {
    return array_add(arr, value);
}

bool array_pop(array_t_ *arr, void *out_value) {
    if (arr->count <= 0) {
        return false;
    }
    if (out_value) {
        void *res = array_get(arr, arr->count - 1);
        memcpy(out_value, res, arr->element_size);
    }
    array_remove_at(arr, arr->count - 1);
    return true;
}

void* array_top(array_t_ *arr) {
    if (arr->count <= 0) {
        return NULL;
    }
    return array_get(arr, arr->count - 1);
}

bool array_set(array_t_ *arr, unsigned int ix, void *value) {
    if (ix >= arr->count) {
        COLLECTIONS_ASSERT(false);
        return false;
    }
    size_t offset = ix * arr->element_size;
    memmove(arr->data + offset, value, arr->element_size);
    return true;
}

bool array_setn(array_t_ *arr, unsigned int ix, void *values, int n) {
    for (int i = 0; i < n; i++) {
        int dest_ix = ix + i;
        unsigned char *value = (unsigned char*)values + (i * arr->element_size);
        if (dest_ix < array_count(arr)) {
            bool ok = array_set(arr, dest_ix, value);
            if (!ok) {
                return false;
            }
        } else {
            bool ok = array_add(arr, value);
            if (!ok) {
                return false;
            }
        }
    }
    return true;
}

void * array_get(array_t_ *arr, unsigned int ix) {
    if (ix >= arr->count) {
        COLLECTIONS_ASSERT(false);
        return NULL;
    }
    size_t offset = ix * arr->element_size;
    return arr->data + offset;
}

const void * array_get_const(const array_t_ *arr, unsigned int ix) {
    if (ix >= arr->count) {
        COLLECTIONS_ASSERT(false);
        return NULL;
    }
    size_t offset = ix * arr->element_size;
    return arr->data + offset;
}

void * array_get_last(array_t_ *arr) {
    if (arr->count <= 0) {
        return NULL;
    }
    return array_get(arr, arr->count - 1);
}

int array_count(const array_t_ *arr) {
    if (!arr) {
        return 0;
    }
    return arr->count;
}

unsigned int array_get_capacity(const array_t_ *arr) {
    return arr->capacity;
}

bool array_remove_at(array_t_ *arr, unsigned int ix) {
    if (ix >= arr->count) {
        return false;
    }
    if (ix == 0) {
        arr->data += arr->element_size;
        arr->capacity--;
        arr->count--;
        return true;
    }
    if (ix == (arr->count - 1)) {
        arr->count--;
        return true;
    }
    size_t to_move_bytes = (arr->count - 1 - ix) * arr->element_size;
    void *dest = arr->data + (ix * arr->element_size);
    void *src = arr->data + ((ix + 1) * arr->element_size);
    memmove(dest, src, to_move_bytes);
    arr->count--;
    return true;
}

bool array_remove_item(array_t_ *arr, void *ptr) {
    int ix = array_get_index(arr, ptr);
    if (ix < 0) {
        return false;
    }
    return array_remove_at(arr, ix);
}

void array_clear(array_t_ *arr) {
    arr->count = 0;
}

void array_clear_and_deinit_items_(array_t_ *arr, array_item_deinit_fn deinit_fn) {
    for (int i = 0; i < array_count(arr); i++) {
        void *item = array_get(arr, i);
        deinit_fn(item);
    }
    arr->count = 0;
}

void array_lock_capacity(array_t_ *arr) {
    arr->lock_capacity = true;
}

int array_get_index(const array_t_ *arr, void *ptr) {
    for (int i = 0; i < array_count(arr); i++) {
        if (array_get_const(arr, i) == ptr) {
            return i;
        }
    }
    return -1;
}

bool array_contains(const array_t_ *arr, void *ptr) {
    return array_get_index(arr, ptr) >= 0;
}

void* array_data(array_t_ *arr) {
    return arr->data;
}

const void* array_const_data(const array_t_ *arr) {
    return arr->data;
}

void array_orphan_data(array_t_ *arr) {
    array_init_with_capacity(arr, arr->alloc, 0, arr->element_size);
}

bool array_reverse(array_t_ *arr) {
    int count = array_count(arr);
    if (count < 2) {
        return true;
    }
    void *temp = allocator_malloc(arr->alloc, arr->element_size);
    if (!temp) {
        return false;
    }
    for (int a_ix = 0; a_ix < (count / 2); a_ix++) {
        int b_ix = count - a_ix - 1;
        void *a = array_get(arr, a_ix);
        void *b = array_get(arr, b_ix);
        memcpy(temp, a, arr->element_size);
        array_set(arr, a_ix, b); // no need for check because it will be within range
        array_set(arr, b_ix, temp);
    }
    allocator_free(arr->alloc, temp);
    return true;
}

static bool array_init_with_capacity(array_t_ *arr, allocator_t *alloc, unsigned int capacity, size_t element_size) {
    arr->alloc = alloc;
    if (capacity > 0) {
        arr->data_allocated = allocator_malloc(arr->alloc, capacity * element_size);
        arr->data = arr->data_allocated;
        if (!arr->data_allocated) {
            return false;
        }
    } else {
        arr->data_allocated = NULL;
        arr->data = NULL;
    }
    arr->capacity = capacity;
    arr->count = 0;
    arr->element_size = element_size;
    arr->lock_capacity = false;
    return true;
}

static void array_deinit(array_t_ *arr) {
    allocator_free(arr->alloc, arr->data_allocated);
}

//-----------------------------------------------------------------------------
// Pointer Array
//-----------------------------------------------------------------------------

typedef struct ptrarray_ {
    allocator_t *alloc;
    array_t_ arr;
} ptrarray_t_;

ptrarray_t_* ptrarray_make(allocator_t *alloc) {
    return ptrarray_make_with_capacity(alloc, 0);
}

ptrarray_t_* ptrarray_make_with_capacity(allocator_t *alloc, unsigned int capacity) {
    ptrarray_t_ *ptrarr = allocator_malloc(alloc, sizeof(ptrarray_t_));
    if (!ptrarr) {
        return NULL;
    }
    ptrarr->alloc = alloc;
    bool ok = array_init_with_capacity(&ptrarr->arr, alloc, capacity, sizeof(void*));
    if (!ok) {
        allocator_free(alloc, ptrarr);
        return NULL;
    }
    return ptrarr;
}

void ptrarray_destroy(ptrarray_t_ *arr) {
    if (!arr) {
        return;
    }
    array_deinit(&arr->arr);
    allocator_free(arr->alloc, arr);
}

void ptrarray_destroy_with_items_(ptrarray_t_ *arr, ptrarray_item_destroy_fn destroy_fn) { // todo: destroy and copy in make fn
    if (arr == NULL) {
        return;
    }

    if (destroy_fn) {
        ptrarray_clear_and_destroy_items_(arr, destroy_fn);
    }

    ptrarray_destroy(arr);
}

ptrarray_t_* ptrarray_copy(ptrarray_t_ *arr) {
    ptrarray_t_ *arr_copy = ptrarray_make_with_capacity(arr->alloc, arr->arr.capacity);
    if (!arr_copy) {
        return NULL;
    }
    for (int i = 0; i < ptrarray_count(arr); i++) {
        void *item = ptrarray_get(arr, i);
        bool ok = ptrarray_add(arr_copy, item);
        if (!ok) {
            ptrarray_destroy(arr_copy);
            return NULL;
        }
    }
    return arr_copy;
}

ptrarray_t_* ptrarray_copy_with_items_(ptrarray_t_ *arr, ptrarray_item_copy_fn copy_fn, ptrarray_item_destroy_fn destroy_fn) {
    ptrarray_t_ *arr_copy = ptrarray_make_with_capacity(arr->alloc, arr->arr.capacity);
    if (!arr_copy) {
        return NULL;
    }
    for (int i = 0; i < ptrarray_count(arr); i++) {
        void *item = ptrarray_get(arr, i);
        void *item_copy = copy_fn(item);
        if (item && !item_copy) {
            goto err;
        }
        bool ok = ptrarray_add(arr_copy, item_copy);
        if (!ok) {
            goto err;
        }
    }
    return arr_copy;
err:
    ptrarray_destroy_with_items_(arr_copy, destroy_fn);
    return NULL;
}

bool ptrarray_add(ptrarray_t_ *arr, void *ptr) {
    return array_add(&arr->arr, &ptr);
}

bool ptrarray_set(ptrarray_t_ *arr, unsigned int ix, void *ptr) {
    return array_set(&arr->arr, ix, &ptr);
}

bool ptrarray_add_array(ptrarray_t_ *dest, ptrarray_t_ *source) {
    return array_add_array(&dest->arr, &source->arr);
}

void * ptrarray_get(ptrarray_t_ *arr, unsigned int ix) {
    void* res = array_get(&arr->arr, ix);
    if (!res) {
        return NULL;
    }
    return *(void**)res;
}

const void * ptrarray_get_const(const ptrarray_t_ *arr, unsigned int ix) {
    const void* res = array_get_const(&arr->arr, ix);
    if (!res) {
        return NULL;
    }
    return *(void * const *)res;
}

bool ptrarray_push(ptrarray_t_ *arr, void *ptr) {
    return ptrarray_add(arr, ptr);
}


void *ptrarray_pop(ptrarray_t_ *arr) {
    int ix = ptrarray_count(arr) - 1;
    void *res = ptrarray_get(arr, ix);
    ptrarray_remove_at(arr, ix);
    return res;
}

void *ptrarray_top(ptrarray_t_ *arr) {
    int count = ptrarray_count(arr);
    if (count == 0) {
        return NULL;
    }
    return ptrarray_get(arr, count - 1);
}

int ptrarray_count(const ptrarray_t_ *arr) {
    if (!arr) {
        return 0;
    }
    return array_count(&arr->arr);
}

bool ptrarray_remove_at(ptrarray_t_ *arr, unsigned int ix) {
    return array_remove_at(&arr->arr, ix);
}

bool ptrarray_remove_item(ptrarray_t_ *arr, void *item) {
    for (int i = 0; i < ptrarray_count(arr); i++) {
        if (item == ptrarray_get(arr, i)) {
            ptrarray_remove_at(arr, i);
            return true;
        }
    }
    COLLECTIONS_ASSERT(false);
    return false;
}

void ptrarray_clear(ptrarray_t_ *arr) {
    array_clear(&arr->arr);
}

void ptrarray_clear_and_destroy_items_(ptrarray_t_ *arr, ptrarray_item_destroy_fn destroy_fn) {
    for (int i = 0; i < ptrarray_count(arr); i++) {
        void *item = ptrarray_get(arr, i);
        destroy_fn(item);
    }
    ptrarray_clear(arr);
}

void ptrarray_lock_capacity(ptrarray_t_ *arr) {
    array_lock_capacity(&arr->arr);
}

int ptrarray_get_index(ptrarray_t_ *arr, void *ptr) {
    for (int i = 0; i < ptrarray_count(arr); i++) {
        if (ptrarray_get(arr, i) == ptr) {
            return i;
        }
    }
    return -1;
}

bool ptrarray_contains(ptrarray_t_ *arr, void *item) {
    return ptrarray_get_index(arr, item) >= 0;
}

void * ptrarray_get_addr(ptrarray_t_ *arr, unsigned int ix) {
    void* res = array_get(&arr->arr, ix);
    if (res == NULL) {
        return NULL;
    }
    return res;
}

void* ptrarray_data(ptrarray_t_ *arr) {
    return array_data(&arr->arr);
}

void ptrarray_reverse(ptrarray_t_ *arr) {
    array_reverse(&arr->arr);
}

//-----------------------------------------------------------------------------
// String buffer
//-----------------------------------------------------------------------------

typedef struct strbuf {
    allocator_t *alloc;
    bool failed;
    char *data;
    size_t capacity;
    size_t len;
} strbuf_t;

static bool strbuf_grow(strbuf_t *buf, size_t new_capacity);

strbuf_t* strbuf_make(allocator_t *alloc) {
    return strbuf_make_with_capacity(alloc, 1);
}

strbuf_t* strbuf_make_with_capacity(allocator_t *alloc, unsigned int capacity) {
    strbuf_t *buf = allocator_malloc(alloc, sizeof(strbuf_t));
    if (buf == NULL) {
        return NULL;
    }
    memset(buf, 0, sizeof(strbuf_t));
    buf->alloc = alloc;
    buf->failed = false;
    buf->data = allocator_malloc(alloc, capacity);
    if (buf->data == NULL) {
        allocator_free(alloc, buf);
        return NULL;
    }
    buf->capacity = capacity;
    buf->len = 0;
    buf->data[0] = '\0';
    return buf;
}

void strbuf_destroy(strbuf_t *buf) {
    if (buf == NULL) {
        return;
    }
    allocator_free(buf->alloc, buf->data);
    allocator_free(buf->alloc, buf);
}

void strbuf_clear(strbuf_t *buf) {
    if (buf->failed) {
        return;
    }
    buf->len = 0;
    buf->data[0] = '\0';
}

bool strbuf_append(strbuf_t *buf, const char *str) {
    if (buf->failed) {
        return false;
    }
    size_t str_len = strlen(str);
    if (str_len == 0) {
        return true;
    }
    size_t required_capacity = buf->len + str_len + 1;
    if (required_capacity > buf->capacity) {
        bool ok = strbuf_grow(buf, required_capacity * 2);
        if (!ok) {
            return false;
        }
    }
    memcpy(buf->data + buf->len, str, str_len);
    buf->len = buf->len + str_len;
    buf->data[buf->len] = '\0';
    return true;
}

bool strbuf_appendf(strbuf_t *buf, const char *fmt, ...) {
    if (buf->failed) {
        return false;
    }
    va_list args;
    va_start(args, fmt);
    int to_write = vsnprintf(NULL, 0, fmt, args);
    va_end(args);
    if (to_write == 0) {
        return true;
    }
    size_t required_capacity = buf->len + to_write + 1;
    if (required_capacity > buf->capacity) {
        bool ok = strbuf_grow(buf, required_capacity * 2);
        if (!ok) {
            return false;
        }
    }
    va_start(args, fmt);
    int written = vsprintf(buf->data + buf->len, fmt, args);
    (void)written;
    va_end(args);
    if (written != to_write) {
        return false;
    }
    buf->len = buf->len + to_write;
    buf->data[buf->len] = '\0';
    return true;
}

const char * strbuf_get_string(const strbuf_t *buf) {
    if (buf->failed) {
        return NULL;
    }
    return buf->data;
}

size_t strbuf_get_length(const strbuf_t *buf) {
    if (buf->failed) {
        return 0;
    }
    return buf->len;
}

char * strbuf_get_string_and_destroy(strbuf_t *buf) {
    if (buf->failed) {
        strbuf_destroy(buf);
        return NULL;
    }
    char *res = buf->data;
    buf->data = NULL;
    strbuf_destroy(buf);
    return res;
}

bool strbuf_failed(strbuf_t *buf) {
    return buf->failed;
}

static bool strbuf_grow(strbuf_t *buf, size_t new_capacity) {
    char *new_data = allocator_malloc(buf->alloc, new_capacity);
    if (new_data == NULL) {
        buf->failed = true;
        return false;
    }
    memcpy(new_data, buf->data, buf->len);
    new_data[buf->len] = '\0';
    allocator_free(buf->alloc, buf->data);
    buf->data = new_data;
    buf->capacity = new_capacity;
    return true;
}

//-----------------------------------------------------------------------------
// Utils
//-----------------------------------------------------------------------------

ptrarray(char)* kg_split_string(allocator_t *alloc, const char *str, const char *delimiter) {
    ptrarray(char)* res = ptrarray_make(alloc);
    char *rest = NULL;
    if (!str) {
        return res;
    }
    const char *line_start = str;
    const char *line_end = strstr(line_start, delimiter);
    while (line_end != NULL) {
        long len = line_end - line_start;
        char *line = collections_strndup(alloc, line_start, len);
        if (!line) {
            goto err;
        }
        bool ok = ptrarray_add(res, line);
        if (!ok) {
            allocator_free(alloc, line);
            goto err;
        }
        line_start = line_end + 1;
        line_end = strstr(line_start, delimiter);
    }
    rest = collections_strdup(alloc, line_start);
    if (!rest) {
        goto err;
    }
    bool ok = ptrarray_add(res, rest);
    if (!ok) {
        goto err;
    }
    return res;
err:
    allocator_free(alloc, rest);
    if (res) {
        for (int i = 0; i < ptrarray_count(res); i++) {
            char *line = ptrarray_get(res, i);
            allocator_free(alloc, line);
        }
    }
    ptrarray_destroy(res);
    return NULL;
}

char* kg_join(allocator_t *alloc, ptrarray(char) *items, const char *with) {
    strbuf_t *res = strbuf_make(alloc);
    if (!res) {
        return NULL;
    }
    for (int i = 0; i < ptrarray_count(items); i++) {
        char *item = ptrarray_get(items, i);
        strbuf_append(res, item);
        if (i < (ptrarray_count(items) - 1)) {
            strbuf_append(res, with);
        }
    }
    return strbuf_get_string_and_destroy(res);
}

char* kg_canonicalise_path(allocator_t *alloc, const char *path) {
    if (!strchr(path, '/') || (!strstr(path, "/../") && !strstr(path, "./"))) {
        return collections_strdup(alloc, path);
    }

    ptrarray(char) *split = kg_split_string(alloc, path, "/");
    if (!split) {
        return NULL;
    }

    for (int i = 0; i < ptrarray_count(split) - 1; i++) {
        char *item = ptrarray_get(split, i);
        char *next_item = ptrarray_get(split, i + 1);
        if (kg_streq(item, ".")) {
            allocator_free(alloc, item);
            ptrarray_remove_at(split, i);
            i = -1;
            continue;
        }
        if (kg_streq(next_item, "..")) {
            allocator_free(alloc, item);
            allocator_free(alloc, next_item);
            ptrarray_remove_at(split, i);
            ptrarray_remove_at(split, i);
            i = -1;
            continue;
        }
    }

    char *joined = kg_join(alloc, split, "/");
    for (int i = 0; i < ptrarray_count(split); i++) {
        void *item = ptrarray_get(split, i);
        allocator_free(alloc, item);
    }
    ptrarray_destroy(split);
    return joined;
}

bool kg_is_path_absolute(const char *path) {
    return path[0] == '/';
}

bool kg_streq(const char *a, const char *b) {
    return strcmp(a, b) == 0;
}
//FILE_END
//FILE_START:errors.c
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

#ifndef APE_AMALGAMATED
#include "errors.h"
#include "traceback.h"
#endif

void errors_init(errors_t *errors) {
    memset(errors, 0, sizeof(errors_t));
    errors->count = 0;
}

void errors_deinit(errors_t *errors) {
    errors_clear(errors);
}

void errors_add_error(errors_t *errors, error_type_t type, src_pos_t pos, const char *message) {
    if (errors->count >= ERRORS_MAX_COUNT) {
        return;
    }
    error_t err;
    memset(&err, 0, sizeof(error_t));
    err.type = type;
    int len = (int)strlen(message);
    int to_copy = len;
    if (to_copy >= (ERROR_MESSAGE_MAX_LENGTH - 1)) {
        to_copy = ERROR_MESSAGE_MAX_LENGTH - 1;
    }
    memcpy(err.message, message, to_copy);
    err.message[to_copy] = '\0';
    err.pos = pos;
    err.traceback = NULL;
    errors->errors[errors->count] = err;
    errors->count++;
}

void errors_add_errorf(errors_t *errors, error_type_t type, src_pos_t pos, const char *format, ...) {
    va_list args;
    va_start(args, format);
    int to_write = vsnprintf(NULL, 0, format, args);
    (void)to_write;
    va_end(args);
    va_start(args, format);
    char res[ERROR_MESSAGE_MAX_LENGTH];
    int written = vsnprintf(res, ERROR_MESSAGE_MAX_LENGTH, format, args);
    (void)written;
    APE_ASSERT(to_write == written);
    va_end(args);
    errors_add_error(errors, type, pos, res);
}

void errors_clear(errors_t *errors) {
    for (int i = 0; i < errors_get_count(errors); i++) {
        error_t *error = errors_get(errors, i);
        if (error->traceback) {
            traceback_destroy(error->traceback);
        }
    }
    errors->count = 0;
}

int errors_get_count(const errors_t *errors) {
    return errors->count;
}

error_t *errors_get(errors_t *errors, int ix) {
    if (ix >= errors->count) {
        return NULL;
    }
    return &errors->errors[ix];
}

const error_t *errors_getc(const errors_t *errors, int ix) {
    if (ix >= errors->count) {
        return NULL;
    }
    return &errors->errors[ix];
}

const char *error_type_to_string(error_type_t type) {
    switch (type) {
        case ERROR_PARSING:     return "PARSING";
        case ERROR_COMPILATION: return "COMPILATION";
        case ERROR_RUNTIME:     return "RUNTIME";
        case ERROR_TIME_OUT:    return "TIMEOUT";
        case ERROR_ALLOCATION:  return "ALLOCATION";
        case ERROR_USER:        return "USER";
        default:                return "INVALID";
    }
}

error_t *errors_get_last_error(errors_t *errors) {
    if (errors->count <= 0) {
        return NULL;
    }
    return &errors->errors[errors->count - 1];
}

bool errors_has_errors(const errors_t *errors) {
    return errors_get_count(errors) > 0;
}
//FILE_END
//FILE_START:token.c
#include <string.h>
#include <stdlib.h>

#ifndef APE_AMALGAMATED
#include "token.h"
#endif

static const char *g_type_names[] = {
    "ILLEGAL",
    "EOF",
    "=",
    "+=",
    "-=",
    "*=",
    "/=",
    "%=",
    "&=",
    "|=",
    "^=",
    "<<=",
    ">>=",
    "?",
    "+",
    "++",
    "-",
    "--",
    "!",
    "*",
    "/",
    "<",
    "<=",
    ">",
    ">=",
    "==",
    "!=",
    "&&",
    "||",
    "&",
    "|",
    "^",
    "<<",
    ">>",
    ",",
    ";",
    ":",
    "(",
    ")",
    "{",
    "}",
    "[",
    "]",
    ".",
    "%",
    "FUNCTION",
    "CONST",
    "VAR",
    "TRUE",
    "FALSE",
    "IF",
    "ELSE",
    "RETURN",
    "WHILE",
    "BREAK",
    "FOR",
    "IN",
    "CONTINUE",
    "NULL",
    "IMPORT",
    "RECOVER",
    "IDENT",
    "NUMBER",
    "STRING",
    "TEMPLATE_STRING",
};

void token_init(token_t *tok, token_type_t type, const char *literal, int len) {
    tok->type = type;
    tok->literal = literal;
    tok->len = len;
}

char* token_duplicate_literal(allocator_t *alloc, const token_t *tok) {
    return ape_strndup(alloc, tok->literal, tok->len);
}

const char* token_type_to_string(token_type_t type) {
    return g_type_names[type];
}
//FILE_END
//FILE_START:compiled_file.c
#ifndef APE_AMALGAMATED
#include "compiled_file.h"
#endif

compiled_file_t* compiled_file_make(allocator_t *alloc, const char *path) {
    compiled_file_t *file = allocator_malloc(alloc, sizeof(compiled_file_t));
    if (!file) {
        return NULL;
    }
    memset(file, 0, sizeof(compiled_file_t));
    file->alloc = alloc;
    const char *last_slash_pos = strrchr(path, '/');
    if (last_slash_pos) {
        size_t len = last_slash_pos - path + 1;
        file->dir_path = ape_strndup(alloc, path, len);
    } else {
        file->dir_path = ape_strdup(alloc, "");
    }
    if (!file->dir_path) {
        goto error;
    }
    file->path = ape_strdup(alloc, path);
    if (!file->path) {
        goto error;
    }
    file->lines = ptrarray_make(alloc);
    if (!file->lines) {
        goto error;
    }
    return file;
error:
    compiled_file_destroy(file);
    return NULL;
}

void compiled_file_destroy(compiled_file_t *file) {
    if (!file) {
        return;
    }
    for (int i = 0; i < ptrarray_count(file->lines); i++) {
        void *item = ptrarray_get(file->lines, i);
        allocator_free(file->alloc, item);
    }
    ptrarray_destroy(file->lines);
    allocator_free(file->alloc, file->dir_path);
    allocator_free(file->alloc, file->path);
    allocator_free(file->alloc, file);
}
//FILE_END
//FILE_START:lexer.c
#include <stdlib.h>
#include <string.h>

#ifndef APE_AMALGAMATED
#include "lexer.h"
#include "collections.h"
#include "compiler.h"
#endif

static bool read_char(lexer_t *lex);
static char peek_char(lexer_t *lex);
static bool is_letter(char ch);
static bool is_digit(char ch);
static bool is_one_of(char ch, const char* allowed, int allowed_len);
static const char* read_identifier(lexer_t *lex, int *out_len);
static const char* read_number(lexer_t *lex, int *out_len);
static const char* read_string(lexer_t *lex, char delimiter, bool is_template, bool *out_template_found, int *out_len);
static token_type_t lookup_identifier(const char *ident, int len);
static void skip_whitespace(lexer_t *lex);
static bool add_line(lexer_t *lex, int offset);

bool lexer_init(lexer_t *lex, allocator_t *alloc, errors_t *errs, const char *input, size_t len, compiled_file_t *file) {
    lex->alloc = alloc;
    lex->errors = errs;
    lex->input = input;
    lex->input_len = (int)len;
    lex->position = 0;
    lex->next_position = 0;
    lex->ch = '\0';
    if (file) {
        lex->line = ptrarray_count(file->lines);
    } else {
        lex->line = 0;
    }
    lex->column = -1;
    lex->file = file;
    bool ok = add_line(lex, 0);
    if (!ok) {
        return false;
    }
    ok = read_char(lex);
    if (!ok) {
        return false;
    }
    lex->failed = false;
    lex->continue_template_string = false;

    memset(&lex->prev_token_state, 0, sizeof(lex->prev_token_state));
    token_init(&lex->prev_token, TOKEN_INVALID, NULL, 0);
    token_init(&lex->cur_token, TOKEN_INVALID, NULL, 0);
    token_init(&lex->peek_token, TOKEN_INVALID, NULL, 0);

    return true;
}

bool lexer_failed(lexer_t *lex) {
    return lex->failed;
}

void lexer_continue_template_string(lexer_t *lex) {
    lex->continue_template_string = true;
}

bool lexer_cur_token_is(lexer_t *lex, token_type_t type) {
    return lex->cur_token.type == type;
}

bool lexer_peek_token_is(lexer_t *lex, token_type_t type) {
    return lex->peek_token.type == type;
}

bool lexer_next_token(lexer_t *lex) {
    lex->prev_token = lex->cur_token;
    lex->cur_token = lex->peek_token;
    lex->peek_token = lexer_next_token_internal(lex);
    return !lex->failed;
}

bool lexer_previous_token(lexer_t *lex) {
    if (lex->prev_token.type == TOKEN_INVALID) {
        return false;
    }

    lex->peek_token = lex->cur_token;
    lex->cur_token = lex->prev_token;
    token_init(&lex->prev_token, TOKEN_INVALID, NULL, 0);

    lex->ch = lex->prev_token_state.ch;
    lex->column = lex->prev_token_state.column;
    lex->line = lex->prev_token_state.line;
    lex->position = lex->prev_token_state.position;
    lex->next_position = lex->prev_token_state.next_position;

    return true;
}

token_t lexer_next_token_internal(lexer_t *lex) {
    lex->prev_token_state.ch = lex->ch;
    lex->prev_token_state.column = lex->column;
    lex->prev_token_state.line = lex->line;
    lex->prev_token_state.position = lex->position;
    lex->prev_token_state.next_position = lex->next_position;

    while (true) {
        if (!lex->continue_template_string) {
            skip_whitespace(lex);
        }

        token_t out_tok;
        out_tok.type = TOKEN_INVALID;
        out_tok.literal = lex->input + lex->position;
        out_tok.len = 1;
        out_tok.pos = src_pos_make(lex->file, lex->line, lex->column);

        char c = lex->continue_template_string ? '`' : lex->ch;

        switch (c) {
            case '\0': token_init(&out_tok, TOKEN_EOF, "EOF", 3); break;
            case '=': {
                if (peek_char(lex) == '=') {
                    token_init(&out_tok, TOKEN_EQ, "==", 2);
                    read_char(lex);
                } else {
                    token_init(&out_tok, TOKEN_ASSIGN, "=", 1);
                }
                break;
            }
            case '&': {
                if (peek_char(lex) == '&') {
                    token_init(&out_tok, TOKEN_AND, "&&", 2);
                    read_char(lex);
                } else if (peek_char(lex) == '=') {
                    token_init(&out_tok, TOKEN_BIT_AND_ASSIGN, "&=", 2);
                    read_char(lex);
                } else {
                    token_init(&out_tok, TOKEN_BIT_AND, "&", 1);
                }
                break;
            }
            case '|': {
                if (peek_char(lex) == '|') {
                    token_init(&out_tok, TOKEN_OR, "||", 2);
                    read_char(lex);
                } else if (peek_char(lex) == '=') {
                    token_init(&out_tok, TOKEN_BIT_OR_ASSIGN, "|=", 2);
                    read_char(lex);
                } else {
                    token_init(&out_tok, TOKEN_BIT_OR, "|", 1);
                }
                break;
            }
            case '^': {
                if (peek_char(lex) == '=') {
                    token_init(&out_tok, TOKEN_BIT_XOR_ASSIGN, "^=", 2);
                    read_char(lex);
                } else {
                    token_init(&out_tok, TOKEN_BIT_XOR, "^", 1); break;
                }
                break;
            }
            case '+': {
                if (peek_char(lex) == '=') {
                    token_init(&out_tok, TOKEN_PLUS_ASSIGN, "+=", 2);
                    read_char(lex);
                } else if (peek_char(lex) == '+') {
                    token_init(&out_tok, TOKEN_PLUS_PLUS, "++", 2);
                    read_char(lex);
                } else {
                    token_init(&out_tok, TOKEN_PLUS, "+", 1); break;
                }
                break;
            }
            case '-': {
                if (peek_char(lex) == '=') {
                    token_init(&out_tok, TOKEN_MINUS_ASSIGN, "-=", 2);
                    read_char(lex);
                } else if (peek_char(lex) == '-') {
                    token_init(&out_tok, TOKEN_MINUS_MINUS, "--", 2);
                    read_char(lex);
                } else {
                    token_init(&out_tok, TOKEN_MINUS, "-", 1); break;
                }
                break;
            }
            case '!': {
                if (peek_char(lex) == '=') {
                    token_init(&out_tok, TOKEN_NOT_EQ, "!=", 2);
                    read_char(lex);
                } else {
                    token_init(&out_tok, TOKEN_BANG, "!", 1);
                }
                break;
            }
            case '*': {
                if (peek_char(lex) == '=') {
                    token_init(&out_tok, TOKEN_ASTERISK_ASSIGN, "*=", 2);
                    read_char(lex);
                } else {
                    token_init(&out_tok, TOKEN_ASTERISK, "*", 1); break;
                }
                break;
            }
            case '/': {
                if (peek_char(lex) == '/') {
                    read_char(lex);
                    while (lex->ch != '\n' && lex->ch != '\0') {
                        read_char(lex);
                    }
                    continue;
                } else if (peek_char(lex) == '=') {
                    token_init(&out_tok, TOKEN_SLASH_ASSIGN, "/=", 2);
                    read_char(lex);
                } else {
                    token_init(&out_tok, TOKEN_SLASH, "/", 1); break;
                }
                break;
            }
            case '<': {
                if (peek_char(lex) == '=') {
                    token_init(&out_tok, TOKEN_LTE, "<=", 2);
                    read_char(lex);
                } else if (peek_char(lex) == '<') {
                    read_char(lex);
                    if (peek_char(lex) == '=') {
                        token_init(&out_tok, TOKEN_LSHIFT_ASSIGN, "<<=", 3);
                        read_char(lex);
                    } else {
                        token_init(&out_tok, TOKEN_LSHIFT, "<<", 2);
                    }
                } else {
                    token_init(&out_tok, TOKEN_LT, "<", 1); break;
                }
                break;
            }
            case '>': {
                if (peek_char(lex) == '=') {
                    token_init(&out_tok, TOKEN_GTE, ">=", 2);
                    read_char(lex);
                } else if (peek_char(lex) == '>') {
                    read_char(lex);
                    if (peek_char(lex) == '=') {
                        token_init(&out_tok, TOKEN_RSHIFT_ASSIGN, ">>=", 3);
                        read_char(lex);
                    } else {
                        token_init(&out_tok, TOKEN_RSHIFT, ">>", 2);
                    }
                } else {
                    token_init(&out_tok, TOKEN_GT, ">", 1);
                }
                break;
            }
            case ',': token_init(&out_tok, TOKEN_COMMA, ",", 1); break;
            case ';': token_init(&out_tok, TOKEN_SEMICOLON, ";", 1); break;
            case ':': token_init(&out_tok, TOKEN_COLON, ":", 1); break;
            case '(': token_init(&out_tok, TOKEN_LPAREN, "(", 1); break;
            case ')': token_init(&out_tok, TOKEN_RPAREN, ")", 1); break;
            case '{': token_init(&out_tok, TOKEN_LBRACE, "{", 1); break;
            case '}': token_init(&out_tok, TOKEN_RBRACE, "}", 1); break;
            case '[': token_init(&out_tok, TOKEN_LBRACKET, "[", 1); break;
            case ']': token_init(&out_tok, TOKEN_RBRACKET, "]", 1); break;
            case '.': token_init(&out_tok, TOKEN_DOT, ".", 1); break;
            case '?': token_init(&out_tok, TOKEN_QUESTION, "?", 1); break;
            case '%': {
                if (peek_char(lex) == '=') {
                    token_init(&out_tok, TOKEN_PERCENT_ASSIGN, "%=", 2);
                    read_char(lex);
                } else {
                    token_init(&out_tok, TOKEN_PERCENT, "%", 1); break;
                }
                break;
            }
            case '"': {
                read_char(lex);
                int len;
                const char *str = read_string(lex, '"', false, NULL, &len);
                if (str) {
                    token_init(&out_tok, TOKEN_STRING, str, len);
                } else {
                    token_init(&out_tok, TOKEN_INVALID, NULL, 0);
                }
                break;
            }
            case '\'': {
                read_char(lex);
                int len;
                const char *str = read_string(lex, '\'', false, NULL, &len);
                if (str) {
                    token_init(&out_tok, TOKEN_STRING, str, len);
                } else {
                    token_init(&out_tok, TOKEN_INVALID, NULL, 0);
                }
                break;
            }
            case '`': {
                if (!lex->continue_template_string) {
                    read_char(lex);
                }
                int len;
                bool template_found = false;
                const char *str = read_string(lex, '`', true, &template_found, &len);
                if (str) {
                    if (template_found) {
                        token_init(&out_tok, TOKEN_TEMPLATE_STRING, str, len);
                    } else {
                        token_init(&out_tok, TOKEN_STRING, str, len);
                    }
                } else {
                    token_init(&out_tok, TOKEN_INVALID, NULL, 0);
                }
                break;
            }
            default: {
                if (is_letter(lex->ch)) {
                    int ident_len = 0;
                    const char *ident = read_identifier(lex, &ident_len);
                    token_type_t type = lookup_identifier(ident, ident_len);
                    token_init(&out_tok, type, ident, ident_len);
                    return out_tok;
                } else if (is_digit(lex->ch)) {
                    int number_len = 0;
                    const char *number = read_number(lex, &number_len);
                    token_init(&out_tok, TOKEN_NUMBER, number, number_len);
                    return out_tok;
                }
                break;
            }
        }
        read_char(lex);
        if (lexer_failed(lex)) {
            token_init(&out_tok, TOKEN_INVALID, NULL, 0);
        }
        lex->continue_template_string = false;
        return out_tok;
    }
}

bool lexer_expect_current(lexer_t *lex, token_type_t type) {
    if (lexer_failed(lex)) {
        return false;
    }

    if (!lexer_cur_token_is(lex, type)) {
        const char *expected_type_str = token_type_to_string(type);
        const char *actual_type_str = token_type_to_string(lex->cur_token.type);
        errors_add_errorf(lex->errors, ERROR_PARSING, lex->cur_token.pos,
                          "Expected current token to be \"%s\", got \"%s\" instead",
                          expected_type_str, actual_type_str);
        return false;
    }
    return true;
}

// INTERNAL

static bool read_char(lexer_t *lex) {
    if (lex->next_position >= lex->input_len) {
        lex->ch = '\0';
    } else {
        lex->ch = lex->input[lex->next_position];
    }
    lex->position = lex->next_position;
    lex->next_position++;

    if (lex->ch == '\n') {
        lex->line++;
        lex->column = -1;
        bool ok = add_line(lex, lex->next_position);
        if (!ok) {
            lex->failed = true;
            return false;
        }
    } else {
        lex->column++;
    }
    return true;
}

static char peek_char(lexer_t *lex) {
    if (lex->next_position >= lex->input_len) {
        return '\0';
    } else {
        return lex->input[lex->next_position];
    }
}

static bool is_letter(char ch) {
    return ('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z') || ch == '_';
}

static bool is_digit(char ch) {
    return ch >= '0' && ch <= '9';
}

static bool is_one_of(char ch, const char* allowed, int allowed_len) {
    for (int i = 0; i < allowed_len; i++) {
        if (ch == allowed[i]) {
            return true;
        }
    }
    return false;
}

static const char* read_identifier(lexer_t *lex, int *out_len) {
    int position = lex->position;
    int len = 0;
    while (is_digit(lex->ch) || is_letter(lex->ch) || lex->ch == ':') {
        if (lex->ch == ':') {
            if (peek_char(lex) != ':') {
                goto end;
            }
            read_char(lex);
        }
        read_char(lex);
    }
end:
    len = lex->position - position;
    *out_len = len;
    return lex->input + position;
}

static const char* read_number(lexer_t *lex, int *out_len) {
    char allowed[] = ".xXaAbBcCdDeEfF";
    int position = lex->position;
    while (is_digit(lex->ch) || is_one_of(lex->ch, allowed, APE_ARRAY_LEN(allowed) - 1)) {
        read_char(lex);
    }
    int len = lex->position - position;
    *out_len = len;
    return lex->input + position;
}

static const char* read_string(lexer_t *lex, char delimiter, bool is_template, bool *out_template_found, int *out_len) {
    *out_len = 0;

    bool escaped = false;
    int position = lex->position;

    while (true) {
        if (lex->ch == '\0') {
            return NULL;
        }
        if (lex->ch == delimiter && !escaped) {
            break;
        }
        if (is_template && !escaped && lex->ch == '$' && peek_char(lex) == '{') {
            *out_template_found = true;
            break;
        }
        escaped = false;
        if (lex->ch == '\\') {
            escaped = true;
        }
        read_char(lex);
    }
    int len = lex->position - position;
    *out_len = len;
    return lex->input + position;
}

static token_type_t lookup_identifier(const char *ident, int len) {
    struct {
        const char *value;
        int len;
        token_type_t type;
    } keywords[] = {
        {"fn", 2, TOKEN_FUNCTION},
        {"const", 5, TOKEN_CONST},
        {"var", 3, TOKEN_VAR},
        {"true", 4, TOKEN_TRUE},
        {"false", 5, TOKEN_FALSE},
        {"if", 2, TOKEN_IF},
        {"else", 4, TOKEN_ELSE},
        {"return", 6, TOKEN_RETURN},
        {"while", 5, TOKEN_WHILE},
        {"break", 5, TOKEN_BREAK},
        {"for", 3, TOKEN_FOR},
        {"in", 2, TOKEN_IN},
        {"continue", 8, TOKEN_CONTINUE},
        {"null", 4, TOKEN_NULL},
        {"import", 6, TOKEN_IMPORT},
        {"recover", 7, TOKEN_RECOVER},
    };

    for (int i = 0; i < APE_ARRAY_LEN(keywords); i++) {
        if (keywords[i].len == len && APE_STRNEQ(ident, keywords[i].value, len)) {
            return keywords[i].type;
        }
    }

    return TOKEN_IDENT;
}

static void skip_whitespace(lexer_t *lex) {
    char ch = lex->ch;
    while (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r') {
        read_char(lex);
        ch = lex->ch;
    }
}

static bool add_line(lexer_t *lex, int offset) {
    if (!lex->file) {
        return true;
    }

    if (lex->line < ptrarray_count(lex->file->lines)) {
        return true;
    }

    const char *line_start = lex->input + offset;
    const char *new_line_ptr = strchr(line_start, '\n');
    char *line = NULL;
    if (!new_line_ptr) {
        line = ape_strdup(lex->alloc, line_start);
    } else {
        size_t line_len = new_line_ptr - line_start;
        line = ape_strndup(lex->alloc, line_start, line_len);
    }
    if (!line) {
        lex->failed = true;
        return false;
    }
    bool ok = ptrarray_add(lex->file->lines, line);
    if (!ok) {
        lex->failed = true;
        allocator_free(lex->alloc, line);
        return false;
    }
    return true;
}
//FILE_END
//FILE_START:ast.c
#include <stdlib.h>
#include <string.h>

#ifndef APE_AMALGAMATED
#include "ast.h"
#include "common.h"
#endif

static expression_t* expression_make(allocator_t *alloc, expression_type_t type);
static statement_t* statement_make(allocator_t *alloc, statement_type_t type);

expression_t* expression_make_ident(allocator_t *alloc, ident_t *ident) {
    expression_t *res = expression_make(alloc, EXPRESSION_IDENT);
    if (!res) {
        return NULL;
    }
    res->ident = ident;
    return res;
}

expression_t* expression_make_number_literal(allocator_t *alloc, double val) {
    expression_t *res = expression_make(alloc, EXPRESSION_NUMBER_LITERAL);
    if (!res) {
        return NULL;
    }
    res->number_literal = val;
    return res;
}

expression_t* expression_make_bool_literal(allocator_t *alloc, bool val) {
    expression_t *res = expression_make(alloc, EXPRESSION_BOOL_LITERAL);
    if (!res) {
        return NULL;
    }
    res->bool_literal = val;
    return res;
}

expression_t* expression_make_string_literal(allocator_t *alloc, char *value) {
    expression_t *res = expression_make(alloc, EXPRESSION_STRING_LITERAL);
    if (!res) {
        return NULL;
    }
    res->string_literal = value;
    return res;
}

expression_t* expression_make_null_literal(allocator_t *alloc) {
    expression_t *res = expression_make(alloc, EXPRESSION_NULL_LITERAL);
    if (!res) {
        return NULL;
    }
    return res;
}

expression_t* expression_make_array_literal(allocator_t *alloc, ptrarray(expression_t) *values) {
    expression_t *res = expression_make(alloc, EXPRESSION_ARRAY_LITERAL);
    if (!res) {
        return NULL;
    }
    res->array = values;
    return res;
}

expression_t* expression_make_map_literal(allocator_t *alloc, ptrarray(expression_t) *keys, ptrarray(expression_t) *values) {
    expression_t *res = expression_make(alloc, EXPRESSION_MAP_LITERAL);
    if (!res) {
        return NULL;
    }
    res->map.keys = keys;
    res->map.values = values;
    return res;
}

expression_t* expression_make_prefix(allocator_t *alloc, operator_t op, expression_t *right) {
    expression_t *res = expression_make(alloc, EXPRESSION_PREFIX);
    if (!res) {
        return NULL;
    }
    res->prefix.op = op;
    res->prefix.right = right;
    return res;
}

expression_t* expression_make_infix(allocator_t *alloc, operator_t op, expression_t *left, expression_t *right) {
    expression_t *res = expression_make(alloc, EXPRESSION_INFIX);
    if (!res) {
        return NULL;
    }
    res->infix.op = op;
    res->infix.left = left;
    res->infix.right = right;
    return res;
}

expression_t* expression_make_fn_literal(allocator_t *alloc, ptrarray(ident_t) *params, code_block_t *body) {
    expression_t *res = expression_make(alloc, EXPRESSION_FUNCTION_LITERAL);
    if (!res) {
        return NULL;
    }
    res->fn_literal.name = NULL;
    res->fn_literal.params = params;
    res->fn_literal.body = body;
    return res;
}

expression_t* expression_make_call(allocator_t *alloc, expression_t *function, ptrarray(expression_t) *args) {
    expression_t *res = expression_make(alloc, EXPRESSION_CALL);
    if (!res) {
        return NULL;
    }
    res->call_expr.function = function;
    res->call_expr.args = args;
    return res;
}

expression_t* expression_make_index(allocator_t *alloc, expression_t *left, expression_t *index) {
    expression_t *res = expression_make(alloc, EXPRESSION_INDEX);
    if (!res) {
        return NULL;
    }
    res->index_expr.left = left;
    res->index_expr.index = index;
    return res;
}

expression_t* expression_make_assign(allocator_t *alloc, expression_t *dest, expression_t *source, bool is_postfix) {
    expression_t *res = expression_make(alloc, EXPRESSION_ASSIGN);
    if (!res) {
        return NULL;
    }
    res->assign.dest = dest;
    res->assign.source = source;
    res->assign.is_postfix = is_postfix;
    return res;
}

expression_t* expression_make_logical(allocator_t *alloc, operator_t op, expression_t *left, expression_t *right) {
    expression_t *res = expression_make(alloc, EXPRESSION_LOGICAL);
    if (!res) {
        return NULL;
    }
    res->logical.op = op;
    res->logical.left = left;
    res->logical.right = right;
    return res;
}

expression_t* expression_make_ternary(allocator_t *alloc, expression_t *test, expression_t *if_true, expression_t *if_false) {
    expression_t *res = expression_make(alloc, EXPRESSION_TERNARY);
    if (!res) {
        return NULL;
    }
    res->ternary.test = test;
    res->ternary.if_true = if_true;
    res->ternary.if_false = if_false;
    return res;
}

void expression_destroy(expression_t *expr) {
    if (!expr) {
        return;
    }

    switch (expr->type) {
        case EXPRESSION_NONE: {
            APE_ASSERT(false);
            break;
        }
        case EXPRESSION_IDENT: {
            ident_destroy(expr->ident);
            break;
        }
        case EXPRESSION_NUMBER_LITERAL:
        case EXPRESSION_BOOL_LITERAL: {
            break;
        }
        case EXPRESSION_STRING_LITERAL: {
            allocator_free(expr->alloc, expr->string_literal);
            break;
        }
        case EXPRESSION_NULL_LITERAL: {
            break;
        }
        case EXPRESSION_ARRAY_LITERAL: {
            ptrarray_destroy_with_items(expr->array, expression_destroy_wrapper);
            break;
        }
        case EXPRESSION_MAP_LITERAL: {
            ptrarray_destroy_with_items(expr->map.keys, expression_destroy_wrapper);
            ptrarray_destroy_with_items(expr->map.values, expression_destroy_wrapper);
            break;
        }
        case EXPRESSION_PREFIX: {
            expression_destroy(expr->prefix.right);
            break;
        }
        case EXPRESSION_INFIX: {
            expression_destroy(expr->infix.left);
            expression_destroy(expr->infix.right);
            break;
        }
        case EXPRESSION_FUNCTION_LITERAL: {
            fn_literal_t *fn = &expr->fn_literal;
            allocator_free(expr->alloc, fn->name);
            ptrarray_destroy_with_items(fn->params, ident_destroy_wrapper);
            code_block_destroy(fn->body);
            break;
        }
        case EXPRESSION_CALL: {
            ptrarray_destroy_with_items(expr->call_expr.args, expression_destroy_wrapper);
            expression_destroy(expr->call_expr.function);
            break;
        }
        case EXPRESSION_INDEX: {
            expression_destroy(expr->index_expr.left);
            expression_destroy(expr->index_expr.index);
            break;
        }
        case EXPRESSION_ASSIGN: {
            expression_destroy(expr->assign.dest);
            expression_destroy(expr->assign.source);
            break;
        }
        case EXPRESSION_LOGICAL: {
            expression_destroy(expr->logical.left);
            expression_destroy(expr->logical.right);
            break;
        }
        case EXPRESSION_TERNARY: {
            expression_destroy(expr->ternary.test);
            expression_destroy(expr->ternary.if_true);
            expression_destroy(expr->ternary.if_false);
            break;
        }
    }
    allocator_free(expr->alloc, expr);

}

void expression_destroy_wrapper(void *expr) {
    expression_destroy(expr);
}

expression_t* expression_copy(expression_t *expr) {
    if (!expr) {
        return NULL;
    }
    expression_t *res = NULL;
    switch (expr->type) {
        case EXPRESSION_NONE: {
            APE_ASSERT(false);
            break;
        }
        case EXPRESSION_IDENT: {
            ident_t *ident = ident_copy(expr->ident);
            if (!ident) {
                return NULL;
            }
            res = expression_make_ident(expr->alloc, ident);
            if (!res) {
                ident_destroy(ident);
                return NULL;
            }
            break;
        }
        case EXPRESSION_NUMBER_LITERAL: {
            res = expression_make_number_literal(expr->alloc, expr->number_literal);
            break;
        }
        case EXPRESSION_BOOL_LITERAL: {
            res = expression_make_bool_literal(expr->alloc, expr->bool_literal);
            break;
        }
        case EXPRESSION_STRING_LITERAL: {
            char *string_copy = ape_strdup(expr->alloc, expr->string_literal);
            if (!string_copy) {
                return NULL;
            }
            res = expression_make_string_literal(expr->alloc, string_copy);
            if (!res) {
                allocator_free(expr->alloc, string_copy);
                return NULL;
            }
            break;
        }
        case EXPRESSION_NULL_LITERAL: {
            res = expression_make_null_literal(expr->alloc);
            break;
        }
        case EXPRESSION_ARRAY_LITERAL: {
            ptrarray(expression_t) *values_copy = ptrarray_copy_with_items(expr->array, expression_copy, expression_destroy_wrapper);
            if (!values_copy) {
                return NULL;
            }
            res = expression_make_array_literal(expr->alloc, values_copy);
            if (!res) {
                ptrarray_destroy_with_items(values_copy, expression_destroy_wrapper);
                return NULL;
            }
            break;
        }
        case EXPRESSION_MAP_LITERAL: {
            ptrarray(expression_t) *keys_copy = ptrarray_copy_with_items(expr->map.keys, expression_copy, expression_destroy_wrapper);
            ptrarray(expression_t) *values_copy = ptrarray_copy_with_items(expr->map.values, expression_copy, expression_destroy_wrapper);
            if (!keys_copy || !values_copy) {
                ptrarray_destroy_with_items(keys_copy, expression_destroy_wrapper);
                ptrarray_destroy_with_items(values_copy, expression_destroy_wrapper);
                return NULL;
            }
            res = expression_make_map_literal(expr->alloc, keys_copy, values_copy);
            if (!res) {
                ptrarray_destroy_with_items(keys_copy, expression_destroy_wrapper);
                ptrarray_destroy_with_items(values_copy, expression_destroy_wrapper);
                return NULL;
            }
            break;
        }
        case EXPRESSION_PREFIX: {
            expression_t *right_copy = expression_copy(expr->prefix.right);
            if (!right_copy) {
                return NULL;
            }
            res = expression_make_prefix(expr->alloc, expr->prefix.op, right_copy);
            if (!res) {
                expression_destroy(right_copy);
                return NULL;
            }
            break;
        }
        case EXPRESSION_INFIX: {
            expression_t *left_copy = expression_copy(expr->infix.left);
            expression_t *right_copy = expression_copy(expr->infix.right);
            if (!left_copy || !right_copy) {
                expression_destroy(left_copy);
                expression_destroy(right_copy);
                return NULL;
            }
            res = expression_make_infix(expr->alloc, expr->infix.op, left_copy, right_copy);
            if (!res) {
                expression_destroy(left_copy);
                expression_destroy(right_copy);
                return NULL;
            }
            break;
        }
        case EXPRESSION_FUNCTION_LITERAL: {
            ptrarray(ident_t) *params_copy = ptrarray_copy_with_items(expr->fn_literal.params, ident_copy, ident_destroy_wrapper);
            code_block_t *body_copy = code_block_copy(expr->fn_literal.body);
            char *name_copy =  ape_strdup(expr->alloc, expr->fn_literal.name);
            if (!params_copy || !body_copy) {
                ptrarray_destroy_with_items(params_copy, ident_destroy_wrapper);
                code_block_destroy(body_copy);
                allocator_free(expr->alloc, name_copy);
                return NULL;
            }
            res = expression_make_fn_literal(expr->alloc, params_copy, body_copy);
            if (!res) {
                ptrarray_destroy_with_items(params_copy, ident_destroy_wrapper);
                code_block_destroy(body_copy);
                allocator_free(expr->alloc, name_copy);
                return NULL;
            }
            res->fn_literal.name = name_copy;
            break;
        }
        case EXPRESSION_CALL: {
            expression_t *function_copy = expression_copy(expr->call_expr.function);
            ptrarray(expression_t) *args_copy = ptrarray_copy_with_items(expr->call_expr.args, expression_copy, expression_destroy_wrapper);
            if (!function_copy || !args_copy) {
                expression_destroy(function_copy);
                ptrarray_destroy_with_items(expr->call_expr.args, expression_destroy_wrapper);
                return NULL;
            }
            res = expression_make_call(expr->alloc, function_copy, args_copy);
            if (!res) {
                expression_destroy(function_copy);
                ptrarray_destroy_with_items(expr->call_expr.args, expression_destroy_wrapper);
                return NULL;
            }
            break;
        }
        case EXPRESSION_INDEX: {
            expression_t *left_copy = expression_copy(expr->index_expr.left);
            expression_t *index_copy = expression_copy(expr->index_expr.index);
            if (!left_copy || !index_copy) {
                expression_destroy(left_copy);
                expression_destroy(index_copy);
                return NULL;
            }
            res = expression_make_index(expr->alloc, left_copy, index_copy);
            if (!res) {
                expression_destroy(left_copy);
                expression_destroy(index_copy);
                return NULL;
            }
            break;
        }
        case EXPRESSION_ASSIGN: {
            expression_t *dest_copy = expression_copy(expr->assign.dest);
            expression_t *source_copy = expression_copy(expr->assign.source);
            if (!dest_copy || !source_copy) {
                expression_destroy(dest_copy);
                expression_destroy(source_copy);
                return NULL;
            }
            res = expression_make_assign(expr->alloc, dest_copy, source_copy, expr->assign.is_postfix);
            if (!res) {
                expression_destroy(dest_copy);
                expression_destroy(source_copy);
                return NULL;
            }
            break;
        }
        case EXPRESSION_LOGICAL: {
            expression_t *left_copy = expression_copy(expr->logical.left);
            expression_t *right_copy = expression_copy(expr->logical.right);
            if (!left_copy || !right_copy) {
                expression_destroy(left_copy);
                expression_destroy(right_copy);
                return NULL;
            }
            res = expression_make_logical(expr->alloc, expr->logical.op, left_copy, right_copy);
            if (!res) {
                expression_destroy(left_copy);
                expression_destroy(right_copy);
                return NULL;
            }
            break;
        }
        case EXPRESSION_TERNARY: {
            expression_t *test_copy = expression_copy(expr->ternary.test);
            expression_t *if_true_copy = expression_copy(expr->ternary.if_true);
            expression_t *if_false_copy = expression_copy(expr->ternary.if_false);
            if (!test_copy || !if_true_copy || !if_false_copy) {
                expression_destroy(test_copy);
                expression_destroy(if_true_copy);
                expression_destroy(if_false_copy);
                return NULL;
            }
            res = expression_make_ternary(expr->alloc, test_copy, if_true_copy, if_false_copy);
            if (!res) {
                expression_destroy(test_copy);
                expression_destroy(if_true_copy);
                expression_destroy(if_false_copy);
                return NULL;
            }
            break;
        }
    }
    if (!res) {
        return NULL;
    }
    res->pos = expr->pos;
    return res;
}

statement_t* statement_make_define(allocator_t *alloc, ident_t *name, expression_t *value, bool assignable) {
    statement_t *res = statement_make(alloc, STATEMENT_DEFINE);
    if (!res) {
        return NULL;
    }
    res->define.name = name;
    res->define.value = value;
    res->define.assignable = assignable;
    return res;
}

statement_t* statement_make_if(allocator_t *alloc, ptrarray(if_case_t) *cases, code_block_t *alternative) {
    statement_t *res = statement_make(alloc, STATEMENT_IF);
    if (!res) {
        return NULL;
    }
    res->if_statement.cases = cases;
    res->if_statement.alternative = alternative;
    return res;
}

statement_t* statement_make_return(allocator_t *alloc, expression_t *value) {
    statement_t *res = statement_make(alloc, STATEMENT_RETURN_VALUE);
    if (!res) {
        return NULL;
    }
    res->return_value = value;
    return res;
}

statement_t* statement_make_expression(allocator_t *alloc, expression_t *value) {
    statement_t *res = statement_make(alloc, STATEMENT_EXPRESSION);
    if (!res) {
        return NULL;
    }
    res->expression = value;
    return res;
}

statement_t* statement_make_while_loop(allocator_t *alloc, expression_t *test, code_block_t *body) {
    statement_t *res = statement_make(alloc, STATEMENT_WHILE_LOOP);
    if (!res) {
        return NULL;
    }
    res->while_loop.test = test;
    res->while_loop.body = body;
    return res;
}

statement_t* statement_make_break(allocator_t *alloc) {
    statement_t *res = statement_make(alloc, STATEMENT_BREAK);
    if (!res) {
        return NULL;
    }
    return res;
}

statement_t* statement_make_foreach(allocator_t *alloc, ident_t *iterator, expression_t *source, code_block_t *body) {
    statement_t *res = statement_make(alloc, STATEMENT_FOREACH);
    if (!res) {
        return NULL;
    }
    res->foreach.iterator = iterator;
    res->foreach.source = source;
    res->foreach.body = body;
    return res;
}

statement_t* statement_make_for_loop(allocator_t *alloc, statement_t *init, expression_t *test, expression_t *update, code_block_t *body) {
    statement_t *res = statement_make(alloc, STATEMENT_FOR_LOOP);
    if (!res) {
        return NULL;
    }
    res->for_loop.init = init;
    res->for_loop.test = test;
    res->for_loop.update = update;
    res->for_loop.body = body;
    return res;
}

statement_t* statement_make_continue(allocator_t *alloc) {
    statement_t *res = statement_make(alloc, STATEMENT_CONTINUE);
    if (!res) {
        return NULL;
    }
    return res;
}

statement_t* statement_make_block(allocator_t *alloc, code_block_t *block) {
    statement_t *res = statement_make(alloc, STATEMENT_BLOCK);
    if (!res) {
        return NULL;
    }
    res->block = block;
    return res;
}

statement_t* statement_make_import(allocator_t *alloc, char *path) {
    statement_t *res = statement_make(alloc, STATEMENT_IMPORT);
    if (!res) {
        return NULL;
    }
    res->import.path = path;
    return res;
}

statement_t* statement_make_recover(allocator_t *alloc, ident_t *error_ident, code_block_t *body) {
    statement_t *res = statement_make(alloc, STATEMENT_RECOVER);
    if (!res) {
        return NULL;
    }
    res->recover.error_ident = error_ident;
    res->recover.body = body;
    return res;
}

void statement_destroy(void* arg) {
    statement_t *stmt = arg;
    if (!stmt) {
        return;
    }
    switch (stmt->type) {
        case STATEMENT_NONE: {
            APE_ASSERT(false);
            break;
        }
        case STATEMENT_DEFINE: {
            ident_destroy(stmt->define.name);
            expression_destroy(stmt->define.value);
            break;
        }
        case STATEMENT_IF: {
            ptrarray_destroy_with_items(stmt->if_statement.cases, if_case_destroy_wrapper);
            code_block_destroy(stmt->if_statement.alternative);
            break;
        }
        case STATEMENT_RETURN_VALUE: {
            expression_destroy(stmt->return_value);
            break;
        }
        case STATEMENT_EXPRESSION: {
            expression_destroy(stmt->expression);
            break;
        }
        case STATEMENT_WHILE_LOOP: {
            expression_destroy(stmt->while_loop.test);
            code_block_destroy(stmt->while_loop.body);
            break;
        }
        case STATEMENT_BREAK: {
            break;
        }
        case STATEMENT_CONTINUE: {
            break;
        }
        case STATEMENT_FOREACH: {
            ident_destroy(stmt->foreach.iterator);
            expression_destroy(stmt->foreach.source);
            code_block_destroy(stmt->foreach.body);
            break;
        }
        case STATEMENT_FOR_LOOP: {
            statement_destroy(stmt->for_loop.init);
            expression_destroy(stmt->for_loop.test);
            expression_destroy(stmt->for_loop.update);
            code_block_destroy(stmt->for_loop.body);
            break;
        }
        case STATEMENT_BLOCK: {
            code_block_destroy(stmt->block);
            break;
        }
        case STATEMENT_IMPORT: {
            allocator_free(stmt->alloc, stmt->import.path);
            break;
        }
        case STATEMENT_RECOVER: {
            code_block_destroy(stmt->recover.body);
            ident_destroy(stmt->recover.error_ident);
            break;
        }
    }
    allocator_free(stmt->alloc, stmt);
}

statement_t* statement_copy(const statement_t *stmt) {
    if (!stmt) {
        return NULL;
    }
    statement_t *res = NULL;
    switch (stmt->type) {
        case STATEMENT_NONE: {
            APE_ASSERT(false);
            break;
        }
        case STATEMENT_DEFINE: {
            expression_t *value_copy = expression_copy(stmt->define.value);
            if (!value_copy) {
                return NULL;
            }
            res = statement_make_define(stmt->alloc, ident_copy(stmt->define.name), value_copy, stmt->define.assignable);
            if (!res) {
                expression_destroy(value_copy);
                return NULL;
            }
            break;
        }
        case STATEMENT_IF: {
            ptrarray(if_case_t) *cases_copy = ptrarray_copy_with_items(stmt->if_statement.cases, if_case_copy, if_case_destroy_wrapper);
            code_block_t *alternative_copy = code_block_copy(stmt->if_statement.alternative);
            if (!cases_copy || !alternative_copy) {
                ptrarray_destroy_with_items(cases_copy, if_case_destroy_wrapper);
                code_block_destroy(alternative_copy);
                return NULL;
            }
            res = statement_make_if(stmt->alloc, cases_copy, alternative_copy);
            if (res) {
                ptrarray_destroy_with_items(cases_copy, if_case_destroy_wrapper);
                code_block_destroy(alternative_copy);
                return NULL;
            }
            break;
        }
        case STATEMENT_RETURN_VALUE: {
            expression_t *value_copy = expression_copy(stmt->return_value);
            if (!value_copy) {
                return NULL;
            }
            res = statement_make_return(stmt->alloc, value_copy);
            if (!res) {
                expression_destroy(value_copy);
                return NULL;
            }
            break;
        }
        case STATEMENT_EXPRESSION: {
            expression_t *value_copy = expression_copy(stmt->expression);
            if (!value_copy) {
                return NULL;
            }
            res = statement_make_expression(stmt->alloc, value_copy);
            if (!res) {
                expression_destroy(value_copy);
                return NULL;
            }
            break;
        }
        case STATEMENT_WHILE_LOOP: {
            expression_t *test_copy = expression_copy(stmt->while_loop.test);
            code_block_t *body_copy = code_block_copy(stmt->while_loop.body);
            if (!test_copy || !body_copy) {
                expression_destroy(test_copy);
                code_block_destroy(body_copy);
                return NULL;
            }
            res = statement_make_while_loop(stmt->alloc, test_copy, body_copy);
            if (!res) {
                expression_destroy(test_copy);
                code_block_destroy(body_copy);
                return NULL;
            }
            break;
        }
        case STATEMENT_BREAK: {
            res = statement_make_break(stmt->alloc);
            break;
        }
        case STATEMENT_CONTINUE: {
            res = statement_make_continue(stmt->alloc);
            break;
        }
        case STATEMENT_FOREACH: {
            expression_t *source_copy = expression_copy(stmt->foreach.source);
            code_block_t *body_copy = code_block_copy(stmt->foreach.body);
            if (!source_copy || !body_copy) {
                expression_destroy(source_copy);
                code_block_destroy(body_copy);
                return NULL;
            }
            res = statement_make_foreach(stmt->alloc, ident_copy(stmt->foreach.iterator), source_copy, body_copy);
            if (!res) {
                expression_destroy(source_copy);
                code_block_destroy(body_copy);
                return NULL;
            }
            break;
        }
        case STATEMENT_FOR_LOOP: {
            statement_t *init_copy = statement_copy(stmt->for_loop.init);
            expression_t *test_copy = expression_copy(stmt->for_loop.test);
            expression_t *update_copy = expression_copy(stmt->for_loop.update);
            code_block_t *body_copy = code_block_copy(stmt->for_loop.body);
            if (!init_copy || !test_copy || !update_copy || !body_copy) {
                statement_destroy(init_copy);
                expression_destroy(test_copy);
                expression_destroy(update_copy);
                code_block_destroy(body_copy);
                return NULL;
            }
            res = statement_make_for_loop(stmt->alloc, init_copy, test_copy, update_copy, body_copy);
            if (!res) {
                statement_destroy(init_copy);
                expression_destroy(test_copy);
                expression_destroy(update_copy);
                code_block_destroy(body_copy);
                return NULL;
            }
            break;
        }
        case STATEMENT_BLOCK: {
            code_block_t *block_copy = code_block_copy(stmt->block);
            if (!block_copy) {
                return NULL;
            }
            res = statement_make_block(stmt->alloc, block_copy);
            if (!res) {
                code_block_destroy(block_copy);
                return NULL;
            }
            break;
        }
        case STATEMENT_IMPORT: {
            char *path_copy = ape_strdup(stmt->alloc, stmt->import.path);
            if (!path_copy) {
                return NULL;
            }
            res = statement_make_import(stmt->alloc, path_copy);
            if (!res) {
                allocator_free(stmt->alloc, path_copy);
                return NULL;
            }
            break;
        }
        case STATEMENT_RECOVER: {
            code_block_t *body_copy = code_block_copy(stmt->recover.body);
            ident_t *error_ident_copy = ident_copy(stmt->recover.error_ident);
            if (!body_copy || !error_ident_copy) {
                code_block_destroy(body_copy);
                ident_destroy(error_ident_copy);
                return NULL;
            }
            res = statement_make_recover(stmt->alloc, error_ident_copy, body_copy);
            if (!res) {
                code_block_destroy(body_copy);
                ident_destroy(error_ident_copy);
                return NULL;
            }
            break;
        }
    }
    if (!res) {
        return NULL;
    }
    res->pos = stmt->pos;
    return res;
}

code_block_t* code_block_make(allocator_t *alloc, ptrarray(statement_t) *statements) {
    code_block_t *block = allocator_malloc(alloc, sizeof(code_block_t));
    if (!block) {
        return NULL;
    }
    block->alloc = alloc;
    block->statements = statements;
    return block;
}

void code_block_destroy(code_block_t *block) {
    if (!block) {
        return;
    }
    ptrarray_destroy_with_items(block->statements, statement_destroy);
    allocator_free(block->alloc, block);
}

code_block_t* code_block_copy(code_block_t *block) {
    if (!block) {
        return NULL;
    }
    ptrarray(statement_t) *statements_copy = ptrarray_copy_with_items(block->statements, statement_copy, statement_destroy);
    if (!statements_copy) {
        return NULL;
    }
    code_block_t* res = code_block_make(block->alloc, statements_copy);
    if (!res) {
        ptrarray_destroy_with_items(statements_copy, statement_destroy);
        return NULL;
    }
    return res;
}

char* statements_to_string(allocator_t *alloc, ptrarray(statement_t) *statements) {
    strbuf_t *buf = strbuf_make(alloc);
    if (!buf) {
        return NULL;
    }
    int count =  ptrarray_count(statements);
    for (int i = 0; i < count; i++) {
        const statement_t *stmt = ptrarray_get(statements, i);
        statement_to_string(stmt, buf);
        if (i < (count - 1)) {
            strbuf_append(buf, "\n");
        }
    }
    return strbuf_get_string_and_destroy(buf);
}

void statement_to_string(const statement_t *stmt, strbuf_t *buf) {
    switch (stmt->type) {
        case STATEMENT_DEFINE: {
            const define_statement_t *def_stmt = &stmt->define;
            if (stmt->define.assignable) {
                strbuf_append(buf, "var ");
            } else {
                strbuf_append(buf, "const ");
            }
            strbuf_append(buf, def_stmt->name->value);
            strbuf_append(buf, " = ");

            if (def_stmt->value) {
                expression_to_string(def_stmt->value, buf);
            }

            break;
        }
        case STATEMENT_IF: {
            if_case_t *if_case = ptrarray_get(stmt->if_statement.cases, 0);
            strbuf_append(buf, "if (");
            expression_to_string(if_case->test, buf);
            strbuf_append(buf, ") ");
            code_block_to_string(if_case->consequence, buf);
            for (int i = 1; i < ptrarray_count(stmt->if_statement.cases); i++) {
                if_case_t *elif_case = ptrarray_get(stmt->if_statement.cases, i);
                strbuf_append(buf, " elif (");
                expression_to_string(elif_case->test, buf);
                strbuf_append(buf, ") ");
                code_block_to_string(elif_case->consequence, buf);
            }
            if (stmt->if_statement.alternative) {
                strbuf_append(buf, " else ");
                code_block_to_string(stmt->if_statement.alternative, buf);
            }
            break;
        }
        case STATEMENT_RETURN_VALUE: {
            strbuf_append(buf, "return ");
            if (stmt->return_value) {
                expression_to_string(stmt->return_value, buf);
            }
            break;
        }
        case STATEMENT_EXPRESSION: {
            if (stmt->expression) {
                expression_to_string(stmt->expression, buf);
            }
            break;
        }
        case STATEMENT_WHILE_LOOP: {
            strbuf_append(buf, "while (");
            expression_to_string(stmt->while_loop.test, buf);
            strbuf_append(buf, ")");
            code_block_to_string(stmt->while_loop.body, buf);
            break;
        }
        case STATEMENT_FOR_LOOP: {
            strbuf_append(buf, "for (");
            if (stmt->for_loop.init) {
                statement_to_string(stmt->for_loop.init, buf);
                strbuf_append(buf, " ");
            } else {
                strbuf_append(buf, ";");
            }
            if (stmt->for_loop.test) {
                expression_to_string(stmt->for_loop.test, buf);
                strbuf_append(buf, "; ");
            } else {
                strbuf_append(buf, ";");
            }
            if (stmt->for_loop.update) {
                expression_to_string(stmt->for_loop.test, buf);
            }
            strbuf_append(buf, ")");
            code_block_to_string(stmt->for_loop.body, buf);
            break;
        }
        case STATEMENT_FOREACH: {
            strbuf_append(buf, "for (");
            strbuf_appendf(buf, "%s", stmt->foreach.iterator->value);
            strbuf_append(buf, " in ");
            expression_to_string(stmt->foreach.source, buf);
            strbuf_append(buf, ")");
            code_block_to_string(stmt->foreach.body, buf);
            break;
        }
        case STATEMENT_BLOCK: {
            code_block_to_string(stmt->block, buf);
            break;
        }
        case STATEMENT_BREAK: {
            strbuf_append(buf, "break");
            break;
        }
        case STATEMENT_CONTINUE: {
            strbuf_append(buf, "continue");
            break;
        }
        case STATEMENT_IMPORT: {
            strbuf_appendf(buf, "import \"%s\"", stmt->import.path);
            break;
        }
        case STATEMENT_NONE: {
            strbuf_append(buf, "STATEMENT_NONE");
            break;
        }
        case STATEMENT_RECOVER: {
            strbuf_appendf(buf, "recover (%s)", stmt->recover.error_ident->value);
            code_block_to_string(stmt->recover.body, buf);
            break;
        }
    }
}

void expression_to_string(expression_t *expr, strbuf_t *buf) {
    switch (expr->type) {
        case EXPRESSION_IDENT: {
            strbuf_append(buf, expr->ident->value);
            break;
        }
        case EXPRESSION_NUMBER_LITERAL: {
            strbuf_appendf(buf, "%1.17g", expr->number_literal);
            break;
        }
        case EXPRESSION_BOOL_LITERAL: {
            strbuf_appendf(buf, "%s", expr->bool_literal ? "true" : "false");
            break;
        }
        case EXPRESSION_STRING_LITERAL: {
            strbuf_appendf(buf, "\"%s\"", expr->string_literal);
            break;
        }
        case EXPRESSION_NULL_LITERAL: {
            strbuf_append(buf, "null");
            break;
        }
        case EXPRESSION_ARRAY_LITERAL: {
            strbuf_append(buf, "[");
            for (int i = 0; i < ptrarray_count(expr->array); i++) {
                expression_t *arr_expr = ptrarray_get(expr->array, i);
                expression_to_string(arr_expr, buf);
                if (i < (ptrarray_count(expr->array) - 1)) {
                    strbuf_append(buf, ", ");
                }
            }
            strbuf_append(buf, "]");
            break;
        }
        case EXPRESSION_MAP_LITERAL: {
            map_literal_t *map = &expr->map;

            strbuf_append(buf, "{");
            for (int i = 0; i < ptrarray_count(map->keys); i++) {
                expression_t *key_expr = ptrarray_get(map->keys, i);
                expression_t *val_expr = ptrarray_get(map->values, i);

                expression_to_string(key_expr, buf);
                strbuf_append(buf, " : ");
                expression_to_string(val_expr, buf);

                if (i < (ptrarray_count(map->keys) - 1)) {
                    strbuf_append(buf, ", ");
                }
            }
            strbuf_append(buf, "}");
            break;
        }
        case EXPRESSION_PREFIX: {
            strbuf_append(buf, "(");
            strbuf_append(buf, operator_to_string(expr->infix.op));
            expression_to_string(expr->prefix.right, buf);
            strbuf_append(buf, ")");
            break;
        }
        case EXPRESSION_INFIX: {
            strbuf_append(buf, "(");
            expression_to_string(expr->infix.left, buf);
            strbuf_append(buf, " ");
            strbuf_append(buf, operator_to_string(expr->infix.op));
            strbuf_append(buf, " ");
            expression_to_string(expr->infix.right, buf);
            strbuf_append(buf, ")");
            break;
        }
        case EXPRESSION_FUNCTION_LITERAL: {
            fn_literal_t *fn = &expr->fn_literal;

            strbuf_append(buf, "fn");

            strbuf_append(buf, "(");
            for (int i = 0; i < ptrarray_count(fn->params); i++) {
                ident_t *param = ptrarray_get(fn->params, i);
                strbuf_append(buf, param->value);
                if (i < (ptrarray_count(fn->params) - 1)) {
                    strbuf_append(buf, ", ");
                }
            }
            strbuf_append(buf, ") ");

            code_block_to_string(fn->body, buf);

            break;
        }
        case EXPRESSION_CALL: {
            call_expression_t *call_expr = &expr->call_expr;

            expression_to_string(call_expr->function, buf);

            strbuf_append(buf, "(");
            for (int i = 0; i < ptrarray_count(call_expr->args); i++) {
                expression_t *arg = ptrarray_get(call_expr->args, i);
                expression_to_string(arg, buf);
                if (i < (ptrarray_count(call_expr->args) - 1)) {
                    strbuf_append(buf, ", ");
                }
            }
            strbuf_append(buf, ")");

            break;
        }
        case EXPRESSION_INDEX: {
            strbuf_append(buf, "(");
            expression_to_string(expr->index_expr.left, buf);
            strbuf_append(buf, "[");
            expression_to_string(expr->index_expr.index, buf);
            strbuf_append(buf, "])");
            break;
        }
        case EXPRESSION_ASSIGN: {
            expression_to_string(expr->assign.dest, buf);
            strbuf_append(buf, " = ");
            expression_to_string(expr->assign.source, buf);
            break;
        }
        case EXPRESSION_LOGICAL: {
            expression_to_string(expr->logical.left, buf);
            strbuf_append(buf, " ");
            strbuf_append(buf, operator_to_string(expr->infix.op));
            strbuf_append(buf, " ");
            expression_to_string(expr->logical.right, buf);
            break;
        }
        case EXPRESSION_TERNARY: {
            expression_to_string(expr->ternary.test, buf);
            strbuf_append(buf, " ? ");
            expression_to_string(expr->ternary.if_true, buf);
            strbuf_append(buf, " : ");
            expression_to_string(expr->ternary.if_false, buf);
            break;
        }
        case EXPRESSION_NONE: {
            strbuf_append(buf, "EXPRESSION_NONE");
            break;
        }
    }
}

void code_block_to_string(const code_block_t *stmt, strbuf_t *buf) {
    strbuf_append(buf, "{ ");
    for (int i = 0; i < ptrarray_count(stmt->statements); i++) {
        statement_t *istmt = ptrarray_get(stmt->statements, i);
        statement_to_string(istmt, buf);
        strbuf_append(buf, "\n");
    }
    strbuf_append(buf, " }");
}

const char* operator_to_string(operator_t op) {
    switch (op) {
        case OPERATOR_NONE:        return "OPERATOR_NONE";
        case OPERATOR_ASSIGN:      return "=";
        case OPERATOR_PLUS:        return "+";
        case OPERATOR_MINUS:       return "-";
        case OPERATOR_BANG:        return "!";
        case OPERATOR_ASTERISK:    return "*";
        case OPERATOR_SLASH:       return "/";
        case OPERATOR_LT:          return "<";
        case OPERATOR_GT:          return ">";
        case OPERATOR_EQ:          return "==";
        case OPERATOR_NOT_EQ:      return "!=";
        case OPERATOR_MODULUS:     return "%";
        case OPERATOR_LOGICAL_AND: return "&&";
        case OPERATOR_LOGICAL_OR:  return "||";
        case OPERATOR_BIT_AND:     return "&";
        case OPERATOR_BIT_OR:      return "|";
        case OPERATOR_BIT_XOR:     return "^";
        case OPERATOR_LSHIFT:      return "<<";
        case OPERATOR_RSHIFT:      return ">>";
        default:                   return "OPERATOR_UNKNOWN";
    }
}

const char *expression_type_to_string(expression_type_t type) {
    switch (type) {
        case EXPRESSION_NONE:             return "NONE";
        case EXPRESSION_IDENT:            return "IDENT";
        case EXPRESSION_NUMBER_LITERAL:   return "INT_LITERAL";
        case EXPRESSION_BOOL_LITERAL:     return "BOOL_LITERAL";
        case EXPRESSION_STRING_LITERAL:   return "STRING_LITERAL";
        case EXPRESSION_ARRAY_LITERAL:    return "ARRAY_LITERAL";
        case EXPRESSION_MAP_LITERAL:      return "MAP_LITERAL";
        case EXPRESSION_PREFIX:           return "PREFIX";
        case EXPRESSION_INFIX:            return "INFIX";
        case EXPRESSION_FUNCTION_LITERAL: return "FN_LITERAL";
        case EXPRESSION_CALL:             return "CALL";
        case EXPRESSION_INDEX:            return "INDEX";
        case EXPRESSION_ASSIGN:           return "ASSIGN";
        case EXPRESSION_LOGICAL:          return "LOGICAL";
        case EXPRESSION_TERNARY:          return "TERNARY";
        default:                          return "UNKNOWN";
    }
}

ident_t* ident_make(allocator_t *alloc, token_t tok) {
    ident_t *res = allocator_malloc(alloc, sizeof(ident_t));
    if (!res) {
        return NULL;
    }
    res->alloc = alloc;
    res->value = token_duplicate_literal(alloc, &tok);
    if (!res->value) {
        allocator_free(alloc, res);
        return NULL;
    }
    res->pos = tok.pos;
    return res;
}

ident_t* ident_copy(ident_t *ident) {
    ident_t *res = allocator_malloc(ident->alloc, sizeof(ident_t));
    if (!res) {
        return NULL;
    }
    res->alloc = ident->alloc;
    res->value = ape_strdup(ident->alloc, ident->value);
    if (!res->value) {
        allocator_free(ident->alloc, res);
        return NULL;
    }
    res->pos = ident->pos;
    return res;
}

void ident_destroy(ident_t *ident) {
    if (!ident) {
        return;
    }
    allocator_free(ident->alloc, ident->value);
    ident->value = NULL;
    ident->pos = src_pos_invalid;
    allocator_free(ident->alloc, ident);
}

void ident_destroy_wrapper(void *ident) {
    ident_destroy(ident);
}

if_case_t *if_case_make(allocator_t *alloc, expression_t *test, code_block_t *consequence) {
    if_case_t *res = allocator_malloc(alloc, sizeof(if_case_t));
    if (!res) {
        return NULL;
    }
    res->alloc = alloc;
    res->test = test;
    res->consequence = consequence;
    return res;
}

void if_case_destroy(if_case_t *cond) {
    if (!cond) {
        return;
    }
    expression_destroy(cond->test);
    code_block_destroy(cond->consequence);
    allocator_free(cond->alloc, cond);
}

void if_case_destroy_wrapper(void *cond) {
    if_case_destroy(cond);
}

if_case_t* if_case_copy(if_case_t *if_case) {
    if (!if_case) {
        return NULL;
    }
    expression_t *test_copy = NULL;
    code_block_t *consequence_copy = NULL;
    if_case_t *if_case_copy = NULL;

    test_copy = expression_copy(if_case->test);
    if (!test_copy) {
        goto err;
    }
    consequence_copy = code_block_copy(if_case->consequence);
    if (!test_copy || !consequence_copy) {
        goto err;
    }
    if_case_copy = if_case_make(if_case->alloc, test_copy, consequence_copy);
    if (!if_case_copy) {
        goto err;
    }
    return if_case_copy;
err:
    expression_destroy(test_copy);
    code_block_destroy(consequence_copy);
    if_case_destroy(if_case_copy);
    return NULL;
}

// INTERNAL
static expression_t *expression_make(allocator_t *alloc, expression_type_t type) {
    expression_t *res = allocator_malloc(alloc, sizeof(expression_t));
    if (!res) {
        return NULL;
    }
    res->alloc = alloc;
    res->type = type;
    res->pos = src_pos_invalid;
    return res;
}

static statement_t* statement_make(allocator_t *alloc, statement_type_t type) {
    statement_t *res = allocator_malloc(alloc, sizeof(statement_t));
    if (!res) {
        return NULL;
    }
    res->alloc = alloc;
    res->type = type;
    res->pos = src_pos_invalid;
    return res;
}
//FILE_END
//FILE_START:parser.c
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include <errno.h>

#ifndef APE_AMALGAMATED
#include "parser.h"
#include "errors.h"
#endif

typedef enum precedence {
    PRECEDENCE_LOWEST = 0,
    PRECEDENCE_ASSIGN,      // a = b
    PRECEDENCE_TERNARY,     // a ? b : c
    PRECEDENCE_LOGICAL_OR,  // ||
    PRECEDENCE_LOGICAL_AND, // &&
    PRECEDENCE_BIT_OR,      // |
    PRECEDENCE_BIT_XOR,     // ^
    PRECEDENCE_BIT_AND,     // &
    PRECEDENCE_EQUALS,      // == !=
    PRECEDENCE_LESSGREATER, // >, >=, <, <=
    PRECEDENCE_SHIFT,       // << >>
    PRECEDENCE_SUM,         // + -
    PRECEDENCE_PRODUCT,     // * / %
    PRECEDENCE_PREFIX,      // -x !x ++x --x
    PRECEDENCE_INCDEC,      // x++ x--
    PRECEDENCE_POSTFIX,     // myFunction(x) x["foo"] x.foo
    PRECEDENCE_HIGHEST
} precedence_t;

static statement_t* parse_statement(parser_t *p);
static statement_t* parse_define_statement(parser_t *p);
static statement_t* parse_if_statement(parser_t *p);
static statement_t* parse_return_statement(parser_t *p);
static statement_t* parse_expression_statement(parser_t *p);
static statement_t* parse_while_loop_statement(parser_t *p);
static statement_t* parse_break_statement(parser_t *p);
static statement_t* parse_continue_statement(parser_t *p);
static statement_t* parse_for_loop_statement(parser_t *p);
static statement_t* parse_foreach(parser_t *p);
static statement_t* parse_classic_for_loop(parser_t *p);
static statement_t* parse_function_statement(parser_t *p);
static statement_t* parse_block_statement(parser_t *p);
static statement_t* parse_import_statement(parser_t *p);
static statement_t* parse_recover_statement(parser_t *p);

static code_block_t* parse_code_block(parser_t *p);

static expression_t* parse_expression(parser_t *p, precedence_t prec);
static expression_t* parse_identifier(parser_t *p);
static expression_t* parse_number_literal(parser_t *p);
static expression_t* parse_bool_literal(parser_t *p);
static expression_t* parse_string_literal(parser_t *p);
static expression_t* parse_template_string_literal(parser_t *p);
static expression_t* parse_null_literal(parser_t *p);
static expression_t* parse_array_literal(parser_t *p);
static expression_t* parse_map_literal(parser_t *p);
static expression_t* parse_prefix_expression(parser_t *p);
static expression_t* parse_infix_expression(parser_t *p, expression_t *left);
static expression_t* parse_grouped_expression(parser_t *p);
static expression_t* parse_function_literal(parser_t *p);
static bool parse_function_parameters(parser_t *p, ptrarray(ident_t) *out_params);
static expression_t* parse_call_expression(parser_t *p, expression_t *left);
static ptrarray(expression_t)* parse_expression_list(parser_t *p, token_type_t start_token, token_type_t end_token, bool trailing_comma_allowed);
static expression_t* parse_index_expression(parser_t *p, expression_t *left);
static expression_t* parse_dot_expression(parser_t *p, expression_t *left);
static expression_t* parse_assign_expression(parser_t *p, expression_t *left);
static expression_t* parse_logical_expression(parser_t *p, expression_t *left);
static expression_t* parse_ternary_expression(parser_t *p, expression_t *left);
static expression_t* parse_incdec_prefix_expression(parser_t *p);
static expression_t* parse_incdec_postfix_expression(parser_t *p, expression_t *left);

static precedence_t get_precedence(token_type_t tk);
static operator_t token_to_operator(token_type_t tk);

static char escape_char(const char c);
static char* process_and_copy_string(allocator_t *alloc, const char *input, size_t len);
static expression_t* wrap_expression_in_function_call(allocator_t *alloc, expression_t *expr, const char *function_name);

parser_t* parser_make(allocator_t *alloc, const ape_config_t *config, errors_t *errors) {
    parser_t *parser = allocator_malloc(alloc, sizeof(parser_t));
    if (!parser) {
        return NULL;
    }
    memset(parser, 0, sizeof(parser_t));

    parser->alloc = alloc;
    parser->config = config;
    parser->errors = errors;

    parser->right_assoc_parse_fns[TOKEN_IDENT] = parse_identifier;
    parser->right_assoc_parse_fns[TOKEN_NUMBER] = parse_number_literal;
    parser->right_assoc_parse_fns[TOKEN_TRUE] = parse_bool_literal;
    parser->right_assoc_parse_fns[TOKEN_FALSE] = parse_bool_literal;
    parser->right_assoc_parse_fns[TOKEN_STRING] = parse_string_literal;
    parser->right_assoc_parse_fns[TOKEN_TEMPLATE_STRING] = parse_template_string_literal;
    parser->right_assoc_parse_fns[TOKEN_NULL] = parse_null_literal;
    parser->right_assoc_parse_fns[TOKEN_BANG] = parse_prefix_expression;
    parser->right_assoc_parse_fns[TOKEN_MINUS] = parse_prefix_expression;
    parser->right_assoc_parse_fns[TOKEN_LPAREN] = parse_grouped_expression;
    parser->right_assoc_parse_fns[TOKEN_FUNCTION] = parse_function_literal;
    parser->right_assoc_parse_fns[TOKEN_LBRACKET] = parse_array_literal;
    parser->right_assoc_parse_fns[TOKEN_LBRACE] = parse_map_literal;
    parser->right_assoc_parse_fns[TOKEN_PLUS_PLUS] = parse_incdec_prefix_expression;
    parser->right_assoc_parse_fns[TOKEN_MINUS_MINUS] = parse_incdec_prefix_expression;

    parser->left_assoc_parse_fns[TOKEN_PLUS] = parse_infix_expression;
    parser->left_assoc_parse_fns[TOKEN_MINUS] = parse_infix_expression;
    parser->left_assoc_parse_fns[TOKEN_SLASH] = parse_infix_expression;
    parser->left_assoc_parse_fns[TOKEN_ASTERISK] = parse_infix_expression;
    parser->left_assoc_parse_fns[TOKEN_PERCENT] = parse_infix_expression;
    parser->left_assoc_parse_fns[TOKEN_EQ] = parse_infix_expression;
    parser->left_assoc_parse_fns[TOKEN_NOT_EQ] = parse_infix_expression;
    parser->left_assoc_parse_fns[TOKEN_LT] = parse_infix_expression;
    parser->left_assoc_parse_fns[TOKEN_LTE] = parse_infix_expression;
    parser->left_assoc_parse_fns[TOKEN_GT] = parse_infix_expression;
    parser->left_assoc_parse_fns[TOKEN_GTE] = parse_infix_expression;
    parser->left_assoc_parse_fns[TOKEN_LPAREN] = parse_call_expression;
    parser->left_assoc_parse_fns[TOKEN_LBRACKET] = parse_index_expression;
    parser->left_assoc_parse_fns[TOKEN_ASSIGN] = parse_assign_expression;
    parser->left_assoc_parse_fns[TOKEN_PLUS_ASSIGN] = parse_assign_expression;
    parser->left_assoc_parse_fns[TOKEN_MINUS_ASSIGN] = parse_assign_expression;
    parser->left_assoc_parse_fns[TOKEN_SLASH_ASSIGN] = parse_assign_expression;
    parser->left_assoc_parse_fns[TOKEN_ASTERISK_ASSIGN] = parse_assign_expression;
    parser->left_assoc_parse_fns[TOKEN_PERCENT_ASSIGN] = parse_assign_expression;
    parser->left_assoc_parse_fns[TOKEN_BIT_AND_ASSIGN] = parse_assign_expression;
    parser->left_assoc_parse_fns[TOKEN_BIT_OR_ASSIGN] = parse_assign_expression;
    parser->left_assoc_parse_fns[TOKEN_BIT_XOR_ASSIGN] = parse_assign_expression;
    parser->left_assoc_parse_fns[TOKEN_LSHIFT_ASSIGN] = parse_assign_expression;
    parser->left_assoc_parse_fns[TOKEN_RSHIFT_ASSIGN] = parse_assign_expression;
    parser->left_assoc_parse_fns[TOKEN_DOT] = parse_dot_expression;
    parser->left_assoc_parse_fns[TOKEN_AND] = parse_logical_expression;
    parser->left_assoc_parse_fns[TOKEN_OR] = parse_logical_expression;
    parser->left_assoc_parse_fns[TOKEN_BIT_AND] = parse_infix_expression;
    parser->left_assoc_parse_fns[TOKEN_BIT_OR] = parse_infix_expression;
    parser->left_assoc_parse_fns[TOKEN_BIT_XOR] = parse_infix_expression;
    parser->left_assoc_parse_fns[TOKEN_LSHIFT] = parse_infix_expression;
    parser->left_assoc_parse_fns[TOKEN_RSHIFT] = parse_infix_expression;
    parser->left_assoc_parse_fns[TOKEN_QUESTION] = parse_ternary_expression;
    parser->left_assoc_parse_fns[TOKEN_PLUS_PLUS] = parse_incdec_postfix_expression;
    parser->left_assoc_parse_fns[TOKEN_MINUS_MINUS] = parse_incdec_postfix_expression;

    parser->depth = 0;

    return parser;
}

void parser_destroy(parser_t *parser) {
    if (!parser) {
        return;
    }
    allocator_free(parser->alloc, parser);
}

ptrarray(statement_t)* parser_parse_all(parser_t *parser, const char *input, size_t len, compiled_file_t *file) {
    parser->depth = 0;

    bool ok = lexer_init(&parser->lexer, parser->alloc, parser->errors, input, len, file);
    if (!ok) {
        return NULL;
    }

    lexer_next_token(&parser->lexer);
    lexer_next_token(&parser->lexer);

    ptrarray(statement_t)* statements = ptrarray_make(parser->alloc);
    if (!statements) {
        return NULL;
    }

    while (!lexer_cur_token_is(&parser->lexer, TOKEN_EOF)) {
        if (lexer_cur_token_is(&parser->lexer, TOKEN_SEMICOLON)) {
            lexer_next_token(&parser->lexer);
            continue;
        }
        statement_t *stmt = parse_statement(parser);
        if (!stmt) {
            goto err;
        }
        bool ok = ptrarray_add(statements, stmt);
        if (!ok) {
            statement_destroy(stmt);
            goto err;
        }
    }

    if (errors_get_count(parser->errors) > 0) {
        goto err;
    }

    return statements;
err:
    ptrarray_destroy_with_items(statements, statement_destroy);
    return NULL;
}

// INTERNAL
static statement_t* parse_statement(parser_t *p) {
    src_pos_t pos = p->lexer.cur_token.pos;

    statement_t *res = NULL;
    switch (p->lexer.cur_token.type) {
        case TOKEN_VAR:
        case TOKEN_CONST: {
            res = parse_define_statement(p);
            break;
        }
        case TOKEN_IF: {
            res = parse_if_statement(p);
            break;
        }
        case TOKEN_RETURN: {
            res = parse_return_statement(p);
            break;
        }
        case TOKEN_WHILE: {
            res = parse_while_loop_statement(p);
            break;
        }
        case TOKEN_BREAK: {
            res = parse_break_statement(p);
            break;
        }
        case TOKEN_FOR: {
            res = parse_for_loop_statement(p);
            break;
        }
        case TOKEN_FUNCTION: {
            if (lexer_peek_token_is(&p->lexer, TOKEN_IDENT)) {
                res = parse_function_statement(p);
            } else {
                res = parse_expression_statement(p);
            }
            break;
        }
        case TOKEN_LBRACE: {
            if (p->config->repl_mode && p->depth == 0) {
                res = parse_expression_statement(p);
            } else {
                res = parse_block_statement(p);
            }
            break;
        }
        case TOKEN_CONTINUE: {
            res = parse_continue_statement(p);
            break;
        }
        case TOKEN_IMPORT: {
            res = parse_import_statement(p);
            break;
        }
        case TOKEN_RECOVER: {
            res = parse_recover_statement(p);
            break;
        }
        default: {
            res = parse_expression_statement(p);
            break;
        }
    }
    if (res) {
        res->pos = pos;
    }
    return res;
}

static statement_t* parse_define_statement(parser_t *p) {
    ident_t *name_ident = NULL;
    expression_t *value = NULL;

    bool assignable = lexer_cur_token_is(&p->lexer, TOKEN_VAR);

    lexer_next_token(&p->lexer);

    if (!lexer_expect_current(&p->lexer, TOKEN_IDENT)) {
        goto err;
    }

    name_ident = ident_make(p->alloc, p->lexer.cur_token);
    if (!name_ident) {
        goto err;
    }

    lexer_next_token(&p->lexer);

    if (!lexer_expect_current(&p->lexer, TOKEN_ASSIGN)) {
        goto err;
    }

    lexer_next_token(&p->lexer);

    value = parse_expression(p, PRECEDENCE_LOWEST);
    if (!value) {
        goto err;
    }

    if (value->type == EXPRESSION_FUNCTION_LITERAL) {
        value->fn_literal.name = ape_strdup(p->alloc, name_ident->value);
        if (!value->fn_literal.name) {
            goto err;
        }
    }

    statement_t *res = statement_make_define(p->alloc, name_ident, value, assignable);
    if (!res) {
        goto err;
    }
    return res;
err:
    expression_destroy(value);
    ident_destroy(name_ident);
    return NULL;
}

static statement_t* parse_if_statement(parser_t *p) {
    ptrarray(if_case_t) *cases = NULL;
    code_block_t *alternative = NULL;

    cases = ptrarray_make(p->alloc);
    if (!cases) {
        goto err;
    }

    lexer_next_token(&p->lexer);

    if (!lexer_expect_current(&p->lexer, TOKEN_LPAREN)) {
        goto err;
    }

    lexer_next_token(&p->lexer);

    if_case_t *cond = if_case_make(p->alloc, NULL, NULL);
    if (!cond) {
        goto err;
    }

    bool ok = ptrarray_add(cases, cond);
    if (!ok) {
        if_case_destroy(cond);
        goto err;
    }

    cond->test = parse_expression(p, PRECEDENCE_LOWEST);
    if (!cond->test) {
        goto err;
    }

    if (!lexer_expect_current(&p->lexer, TOKEN_RPAREN)) {
        goto err;
    }

    lexer_next_token(&p->lexer);

    cond->consequence = parse_code_block(p);
    if (!cond->consequence) {
        goto err;
    }

    while (lexer_cur_token_is(&p->lexer, TOKEN_ELSE)) {
        lexer_next_token(&p->lexer);

        if (lexer_cur_token_is(&p->lexer, TOKEN_IF)) {
            lexer_next_token(&p->lexer);

            if (!lexer_expect_current(&p->lexer, TOKEN_LPAREN)) {
                goto err;
            }

            lexer_next_token(&p->lexer);

            if_case_t *elif = if_case_make(p->alloc, NULL, NULL);
            if (!elif) {
                goto err;
            }

            ok = ptrarray_add(cases, elif);
            if (!ok) {
                if_case_destroy(elif);
                goto err;
            }

            elif->test = parse_expression(p, PRECEDENCE_LOWEST);
            if (!elif->test) {
                goto err;
            }

            if (!lexer_expect_current(&p->lexer, TOKEN_RPAREN)) {
                goto err;
            }

            lexer_next_token(&p->lexer);

            elif->consequence = parse_code_block(p);
            if (!elif->consequence) {
                goto err;
            }
        } else {
            alternative = parse_code_block(p);
            if (!alternative) {
                goto err;
            }
        }
    }

    statement_t *res = statement_make_if(p->alloc, cases, alternative);
    if (!res) {
        goto err;
    }
    return res;
err:
    ptrarray_destroy_with_items(cases, if_case_destroy_wrapper);
    code_block_destroy(alternative);
    return NULL;
}

static statement_t* parse_return_statement(parser_t *p) {
    expression_t *expr = NULL;

    lexer_next_token(&p->lexer);

    if (!lexer_cur_token_is(&p->lexer, TOKEN_SEMICOLON) && !lexer_cur_token_is(&p->lexer, TOKEN_RBRACE) && !lexer_cur_token_is(&p->lexer, TOKEN_EOF)) {
        expr = parse_expression(p, PRECEDENCE_LOWEST);
        if (!expr) {
            return NULL;
        }
    }

    statement_t *res = statement_make_return(p->alloc, expr);
    if (!res) {
        expression_destroy(expr);
        return NULL;
    }
    return res;
}

static statement_t* parse_expression_statement(parser_t *p) {
    expression_t *expr = parse_expression(p, PRECEDENCE_LOWEST);
    if (!expr) {
        return NULL;
    }

    if (expr && (!p->config->repl_mode || p->depth > 0)) {
        if (expr->type != EXPRESSION_ASSIGN && expr->type != EXPRESSION_CALL) {
            errors_add_errorf(p->errors, ERROR_PARSING, expr->pos,
                              "Only assignments and function calls can be expression statements");
            expression_destroy(expr);
            return NULL;
        }
    }

    statement_t *res = statement_make_expression(p->alloc, expr);
    if (!res) {
        expression_destroy(expr);
        return NULL;
    }
    return res;
}

static statement_t* parse_while_loop_statement(parser_t *p) {
    expression_t *test = NULL;
    code_block_t *body = NULL;

    lexer_next_token(&p->lexer);

    if (!lexer_expect_current(&p->lexer, TOKEN_LPAREN)) {
        goto err;
    }

    lexer_next_token(&p->lexer);

    test = parse_expression(p, PRECEDENCE_LOWEST);
    if (!test) {
        goto err;
    }

    if (!lexer_expect_current(&p->lexer, TOKEN_RPAREN)) {
        goto err;
    }

    lexer_next_token(&p->lexer);

    body = parse_code_block(p);
    if (!body) {
        goto err;
    }

    statement_t *res = statement_make_while_loop(p->alloc, test, body);
    if (!res) {
        goto err;
    }
    return res;
err:
    code_block_destroy(body);
    expression_destroy(test);
    return NULL;
}

static statement_t* parse_break_statement(parser_t *p) {
    lexer_next_token(&p->lexer);
    return statement_make_break(p->alloc);
}

static statement_t* parse_continue_statement(parser_t *p) {
    lexer_next_token(&p->lexer);
    return statement_make_continue(p->alloc);
}

static statement_t* parse_block_statement(parser_t *p) {
    code_block_t *block = parse_code_block(p);
    if (!block) {
        return NULL;
    }
    statement_t *res = statement_make_block(p->alloc, block);
    if (!res) {
        code_block_destroy(block);
        return NULL;
    }
    return res;
}

static statement_t* parse_import_statement(parser_t *p) {
    lexer_next_token(&p->lexer);

    if (!lexer_expect_current(&p->lexer, TOKEN_STRING)) {
        return NULL;
    }

    char *processed_name = process_and_copy_string(p->alloc, p->lexer.cur_token.literal, p->lexer.cur_token.len);
    if (!processed_name) {
        errors_add_error(p->errors, ERROR_PARSING, p->lexer.cur_token.pos, "Error when parsing module name");
        return NULL;
    }
    lexer_next_token(&p->lexer);

    statement_t *res = statement_make_import(p->alloc, processed_name);
    if (!res) {
        allocator_free(p->alloc, processed_name);
        return NULL;
    }
    return res;
}

static statement_t* parse_recover_statement(parser_t *p) {
    ident_t *error_ident = NULL;
    code_block_t *body = NULL;

    lexer_next_token(&p->lexer);

    if (!lexer_expect_current(&p->lexer, TOKEN_LPAREN)) {
        return NULL;
    }
    lexer_next_token(&p->lexer);

    if (!lexer_expect_current(&p->lexer, TOKEN_IDENT)) {
        return NULL;
    }

    error_ident = ident_make(p->alloc, p->lexer.cur_token);
    if (!error_ident) {
        return NULL;
    }

    lexer_next_token(&p->lexer);

    if (!lexer_expect_current(&p->lexer, TOKEN_RPAREN)) {
        goto err;
    }
    lexer_next_token(&p->lexer);

    body = parse_code_block(p);
    if (!body) {
        goto err;
    }

    statement_t *res = statement_make_recover(p->alloc, error_ident, body);
    if (!res) {
        goto err;
    }
    return res;
err:
    code_block_destroy(body);
    ident_destroy(error_ident);
    return NULL;

}

static statement_t* parse_for_loop_statement(parser_t *p) {
    lexer_next_token(&p->lexer);

    if (!lexer_expect_current(&p->lexer, TOKEN_LPAREN)) {
        return NULL;
    }

    lexer_next_token(&p->lexer);

    if (lexer_cur_token_is(&p->lexer, TOKEN_IDENT) && lexer_peek_token_is(&p->lexer, TOKEN_IN)) {
        return parse_foreach(p);
    } else {
        return parse_classic_for_loop(p);
    }
}

static statement_t* parse_foreach(parser_t *p) {
    expression_t *source = NULL;
    code_block_t *body = NULL;
    ident_t *iterator_ident = NULL;

    iterator_ident = ident_make(p->alloc, p->lexer.cur_token);
    if (!iterator_ident) {
        goto err;
    }

    lexer_next_token(&p->lexer);

    if (!lexer_expect_current(&p->lexer, TOKEN_IN)) {
        goto err;
    }

    lexer_next_token(&p->lexer);

    source = parse_expression(p, PRECEDENCE_LOWEST);
    if (!source) {
        goto err;
    }

    if (!lexer_expect_current(&p->lexer, TOKEN_RPAREN)) {
        goto err;
    }

    lexer_next_token(&p->lexer);

    body = parse_code_block(p);
    if (!body) {
        goto err;
    }

    statement_t *res = statement_make_foreach(p->alloc, iterator_ident, source, body);
    if (!res) {
        goto err;
    }
    return res;
err:
    code_block_destroy(body);
    ident_destroy(iterator_ident);
    expression_destroy(source);
    return NULL;
}

static statement_t* parse_classic_for_loop(parser_t *p) {
    statement_t *init = NULL;
    expression_t *test = NULL;
    expression_t *update = NULL;
    code_block_t *body = NULL;

    if (!lexer_cur_token_is(&p->lexer, TOKEN_SEMICOLON)) {
        init = parse_statement(p);
        if (!init) {
            goto err;
        }
        if (init->type != STATEMENT_DEFINE && init->type != STATEMENT_EXPRESSION) {
            errors_add_errorf(p->errors, ERROR_PARSING, init->pos,
                              "for loop's init clause should be a define statement or an expression");
            goto err;
        }
        if (!lexer_expect_current(&p->lexer, TOKEN_SEMICOLON)) {
            goto err;
        }
    }

    lexer_next_token(&p->lexer);

    if (!lexer_cur_token_is(&p->lexer, TOKEN_SEMICOLON)) {
        test = parse_expression(p, PRECEDENCE_LOWEST);
        if (!test) {
            goto err;
        }
        if (!lexer_expect_current(&p->lexer, TOKEN_SEMICOLON)) {
            goto err;
        }
    }

    lexer_next_token(&p->lexer);

    if (!lexer_cur_token_is(&p->lexer, TOKEN_RPAREN)) {
        update = parse_expression(p, PRECEDENCE_LOWEST);
        if (!update) {
            goto err;
        }
        if (!lexer_expect_current(&p->lexer, TOKEN_RPAREN)) {
            goto err;
        }
    }

    lexer_next_token(&p->lexer);

    body = parse_code_block(p);
    if (!body) {
        goto err;
    }

    statement_t *res = statement_make_for_loop(p->alloc, init, test, update, body);
    if (!res) {
        goto err;
    }

    return res;
err:
    statement_destroy(init);
    expression_destroy(test);
    expression_destroy(update);
    code_block_destroy(body);
    return NULL;
}

static statement_t* parse_function_statement(parser_t *p) {
    ident_t *name_ident = NULL;
    expression_t* value = NULL;

    src_pos_t pos = p->lexer.cur_token.pos;

    lexer_next_token(&p->lexer);

    if (!lexer_expect_current(&p->lexer, TOKEN_IDENT)) {
        goto err;
    }

    name_ident = ident_make(p->alloc, p->lexer.cur_token);
    if (!name_ident) {
        goto err;
    }

    lexer_next_token(&p->lexer);

    value = parse_function_literal(p);
    if (!value) {
        goto err;
    }

    value->pos = pos;
    value->fn_literal.name = ape_strdup(p->alloc, name_ident->value);

    if (!value->fn_literal.name) {
        goto err;
    }

    statement_t *res = statement_make_define(p->alloc, name_ident, value, false);
    if (!res) {
        goto err;
    }
    return res;

err:
    expression_destroy(value);
    ident_destroy(name_ident);
    return NULL;
}

static code_block_t* parse_code_block(parser_t *p) {
    if (!lexer_expect_current(&p->lexer, TOKEN_LBRACE)) {
        return NULL;
    }

    lexer_next_token(&p->lexer);
    p->depth++;

    ptrarray(statement_t)* statements = ptrarray_make(p->alloc);
    if (!statements) {
        goto err;
    }

    while (!lexer_cur_token_is(&p->lexer, TOKEN_RBRACE)) {
        if (lexer_cur_token_is(&p->lexer, TOKEN_EOF)) {
            errors_add_error(p->errors, ERROR_PARSING, p->lexer.cur_token.pos, "Unexpected EOF");
            goto err;
        }
        if (lexer_cur_token_is(&p->lexer, TOKEN_SEMICOLON)) {
            lexer_next_token(&p->lexer);
            continue;
        }
        statement_t *stmt = parse_statement(p);
        if (!stmt) {
            goto err;
        }
        bool ok = ptrarray_add(statements, stmt);
        if (!ok) {
            statement_destroy(stmt);
            goto err;
        }
    }

    lexer_next_token(&p->lexer);

    p->depth--;

    code_block_t *res = code_block_make(p->alloc, statements);
    if (!res) {
        goto err;
    }
    return res;

err:
    p->depth--;
    ptrarray_destroy_with_items(statements, statement_destroy);
    return NULL;
}

static expression_t* parse_expression(parser_t *p, precedence_t prec) {
    src_pos_t pos = p->lexer.cur_token.pos;

    if (p->lexer.cur_token.type == TOKEN_INVALID) {
        errors_add_error(p->errors, ERROR_PARSING, p->lexer.cur_token.pos, "Illegal token");
        return NULL;
    }

    right_assoc_parse_fn parse_right_assoc = p->right_assoc_parse_fns[p->lexer.cur_token.type];
    if (!parse_right_assoc) {
        char *literal = token_duplicate_literal(p->alloc, &p->lexer.cur_token);
        errors_add_errorf(p->errors, ERROR_PARSING, p->lexer.cur_token.pos,
                                  "No prefix parse function for \"%s\" found", literal);
        allocator_free(p->alloc, literal);
        return NULL;
    }

    expression_t *left_expr = parse_right_assoc(p);
    if (!left_expr) {
        return NULL;
    }
    left_expr->pos = pos;

    while (!lexer_cur_token_is(&p->lexer, TOKEN_SEMICOLON) && prec < get_precedence(p->lexer.cur_token.type)) {
        left_assoc_parse_fn parse_left_assoc = p->left_assoc_parse_fns[p->lexer.cur_token.type];
        if (!parse_left_assoc) {
            return left_expr;
        }
        pos = p->lexer.cur_token.pos;
        expression_t *new_left_expr = parse_left_assoc(p, left_expr);
        if (!new_left_expr) {
            expression_destroy(left_expr);
            return NULL;
        }
        new_left_expr->pos = pos;
        left_expr = new_left_expr;
    }

    return left_expr;
}

static expression_t* parse_identifier(parser_t *p) {
    ident_t *ident = ident_make(p->alloc, p->lexer.cur_token);
    if (!ident) {
        return NULL;
    }
    expression_t *res = expression_make_ident(p->alloc, ident);
    if (!res) {
        ident_destroy(ident);
        return NULL;
    }
    lexer_next_token(&p->lexer);
    return res;
}

static expression_t* parse_number_literal(parser_t *p) {
    char *end;
    double number = 0;
    errno = 0;
    number = strtod(p->lexer.cur_token.literal, &end);
    long parsed_len = end - p->lexer.cur_token.literal;
    if (errno || parsed_len != p->lexer.cur_token.len) {
        char *literal = token_duplicate_literal(p->alloc, &p->lexer.cur_token);
        errors_add_errorf(p->errors, ERROR_PARSING, p->lexer.cur_token.pos,
                          "Parsing number literal \"%s\" failed", literal);
        allocator_free(p->alloc, literal);
        return NULL;
    }
    lexer_next_token(&p->lexer);
    return expression_make_number_literal(p->alloc, number);
}

static expression_t* parse_bool_literal(parser_t *p) {
    expression_t *res = expression_make_bool_literal(p->alloc, p->lexer.cur_token.type == TOKEN_TRUE);
    lexer_next_token(&p->lexer);
    return res;
}

static expression_t* parse_string_literal(parser_t *p) {
    char *processed_literal = process_and_copy_string(p->alloc, p->lexer.cur_token.literal, p->lexer.cur_token.len);
    if (!processed_literal) {
        errors_add_error(p->errors, ERROR_PARSING, p->lexer.cur_token.pos, "Error when parsing string literal");
        return NULL;
    }
    lexer_next_token(&p->lexer);
    expression_t *res = expression_make_string_literal(p->alloc, processed_literal);
    if (!res) {
        allocator_free(p->alloc, processed_literal);
        return NULL;
    }
    return res;
}

static expression_t* parse_template_string_literal(parser_t *p) {
    char *processed_literal = NULL;
    expression_t *left_string_expr = NULL;
    expression_t *template_expr = NULL;
    expression_t *to_str_call_expr = NULL;
    expression_t *left_add_expr = NULL;
    expression_t *right_expr = NULL;
    expression_t *right_add_expr = NULL;

    processed_literal = process_and_copy_string(p->alloc, p->lexer.cur_token.literal, p->lexer.cur_token.len);
    if (!processed_literal) {
        errors_add_error(p->errors, ERROR_PARSING, p->lexer.cur_token.pos, "Error when parsing string literal");
        return NULL;
    }
    lexer_next_token(&p->lexer);

    if (!lexer_expect_current(&p->lexer, TOKEN_LBRACE)) {
        goto err;
    }
    lexer_next_token(&p->lexer);

    src_pos_t pos = p->lexer.cur_token.pos;

    left_string_expr = expression_make_string_literal(p->alloc, processed_literal);
    if (!left_string_expr) {
        goto err;
    }
    left_string_expr->pos = pos;
    processed_literal = NULL;

    pos = p->lexer.cur_token.pos;
    template_expr = parse_expression(p, PRECEDENCE_LOWEST);
    if (!template_expr) {
        goto err;
    }

    to_str_call_expr = wrap_expression_in_function_call(p->alloc, template_expr, "to_str");
    if (!to_str_call_expr) {
        goto err;
    }
    to_str_call_expr->pos = pos;
    template_expr = NULL;

    left_add_expr = expression_make_infix(p->alloc, OPERATOR_PLUS, left_string_expr, to_str_call_expr);
    if (!left_add_expr) {
        goto err;
    }
    left_add_expr->pos = pos;
    left_string_expr = NULL;
    to_str_call_expr = NULL;

    if (!lexer_expect_current(&p->lexer, TOKEN_RBRACE)) {
        goto err;
    }
    lexer_previous_token(&p->lexer);
    lexer_continue_template_string(&p->lexer);
    lexer_next_token(&p->lexer);
    lexer_next_token(&p->lexer);

    pos = p->lexer.cur_token.pos;

    right_expr = parse_expression(p, PRECEDENCE_HIGHEST);
    if (!right_expr) {
        goto err;
    }

    right_add_expr = expression_make_infix(p->alloc, OPERATOR_PLUS, left_add_expr, right_expr);
    if (!right_add_expr) {
        goto err;
    }
    right_add_expr->pos = pos;
    left_add_expr = NULL;
    right_expr = NULL;

    return right_add_expr;
err:
    expression_destroy(right_add_expr);
    expression_destroy(right_expr);
    expression_destroy(left_add_expr);
    expression_destroy(to_str_call_expr);
    expression_destroy(template_expr);
    expression_destroy(left_string_expr);
    allocator_free(p->alloc, processed_literal);
    return NULL;
}

static expression_t* parse_null_literal(parser_t *p) {
    lexer_next_token(&p->lexer);
    return expression_make_null_literal(p->alloc);
}

static expression_t* parse_array_literal(parser_t *p) {
    ptrarray(expression_t) *array = parse_expression_list(p, TOKEN_LBRACKET, TOKEN_RBRACKET, true);
    if (!array) {
        return NULL;
    }
    expression_t *res = expression_make_array_literal(p->alloc, array);
    if (!res) {
        ptrarray_destroy_with_items(array, expression_destroy_wrapper);
        return NULL;
    }
    return res;
}

static expression_t* parse_map_literal(parser_t *p) {
    ptrarray(expression_t) *keys = ptrarray_make(p->alloc);
    ptrarray(expression_t) *values = ptrarray_make(p->alloc);

    if (!keys || !values) {
        goto err;
    }

    lexer_next_token(&p->lexer);

    while (!lexer_cur_token_is(&p->lexer, TOKEN_RBRACE)) {
        expression_t *key = NULL;
        if (lexer_cur_token_is(&p->lexer, TOKEN_IDENT)) {
            char *str = token_duplicate_literal(p->alloc, &p->lexer.cur_token);
            key = expression_make_string_literal(p->alloc, str);
            if (!key) {
                allocator_free(p->alloc, str);
                goto err;
            }
            key->pos = p->lexer.cur_token.pos;
            lexer_next_token(&p->lexer);
        } else {
            key = parse_expression(p, PRECEDENCE_LOWEST);
            if (!key) {
                goto err;
            }
            switch (key->type) {
                case EXPRESSION_STRING_LITERAL:
                case EXPRESSION_NUMBER_LITERAL:
                case EXPRESSION_BOOL_LITERAL: {
                    break;
                }
                default: {
                    errors_add_errorf(p->errors, ERROR_PARSING, key->pos, "Invalid map literal key type");
                    expression_destroy(key);
                    goto err;
                }
            }
        }

        bool ok = ptrarray_add(keys, key);
        if (!ok) {
            expression_destroy(key);
            goto err;
        }

        if (!lexer_expect_current(&p->lexer, TOKEN_COLON)) {
            goto err;
        }

        lexer_next_token(&p->lexer);

        expression_t *value = parse_expression(p, PRECEDENCE_LOWEST);
        if (!value) {
            goto err;
        }
        ok = ptrarray_add(values, value);
        if (!ok) {
            expression_destroy(value);
            goto err;
        }

        if (lexer_cur_token_is(&p->lexer, TOKEN_RBRACE)) {
            break;
        }

        if (!lexer_expect_current(&p->lexer, TOKEN_COMMA)) {
            goto err;
        }

        lexer_next_token(&p->lexer);
    }

    lexer_next_token(&p->lexer);

    expression_t *res = expression_make_map_literal(p->alloc, keys, values);
    if (!res) {
        goto err;
    }
    return res;
err:
    ptrarray_destroy_with_items(keys, expression_destroy_wrapper);
    ptrarray_destroy_with_items(values, expression_destroy_wrapper);
    return NULL;
}

static expression_t* parse_prefix_expression(parser_t *p) {
    operator_t op = token_to_operator(p->lexer.cur_token.type);
    lexer_next_token(&p->lexer);
    expression_t *right = parse_expression(p, PRECEDENCE_PREFIX);
    if (!right) {
        return NULL;
    }
    expression_t *res = expression_make_prefix(p->alloc, op, right);
    if (!res) {
        expression_destroy(right);
        return NULL;
    }
    return res;
}

static expression_t* parse_infix_expression(parser_t *p, expression_t *left) {
    operator_t op = token_to_operator(p->lexer.cur_token.type);
    precedence_t prec = get_precedence(p->lexer.cur_token.type);
    lexer_next_token(&p->lexer);
    expression_t *right = parse_expression(p, prec);
    if (!right) {
        return NULL;
    }
    expression_t *res = expression_make_infix(p->alloc, op, left, right);
    if (!res) {
        expression_destroy(right);
        return NULL;
    }
    return res;
}

static expression_t* parse_grouped_expression(parser_t *p) {
    lexer_next_token(&p->lexer);
    expression_t *expr = parse_expression(p, PRECEDENCE_LOWEST);
    if (!expr || !lexer_expect_current(&p->lexer, TOKEN_RPAREN)) {
        expression_destroy(expr);
        return NULL;
    }
    lexer_next_token(&p->lexer);
    return expr;
}

static expression_t* parse_function_literal(parser_t *p) {
    p->depth++;
    ptrarray(ident) *params = NULL;
    code_block_t *body = NULL;

    if (lexer_cur_token_is(&p->lexer, TOKEN_FUNCTION)) {
        lexer_next_token(&p->lexer);
    }

    params = ptrarray_make(p->alloc);

    bool ok = parse_function_parameters(p, params);

    if (!ok) {
        goto err;
    }

    body = parse_code_block(p);
    if (!body) {
        goto err;
    }

    expression_t *res = expression_make_fn_literal(p->alloc, params, body);
    if (!res) {
        goto err;
    }

    p->depth -= 1;

    return res;
err:
    code_block_destroy(body);
    ptrarray_destroy_with_items(params, ident_destroy_wrapper);
    p->depth -= 1;
    return NULL;
}

static bool parse_function_parameters(parser_t *p, ptrarray(ident_t) *out_params) {
    if (!lexer_expect_current(&p->lexer, TOKEN_LPAREN)) {
        return false;
    }

    lexer_next_token(&p->lexer);

    if (lexer_cur_token_is(&p->lexer, TOKEN_RPAREN)) {
        lexer_next_token(&p->lexer);
        return true;
    }

    if (!lexer_expect_current(&p->lexer, TOKEN_IDENT)) {
        return false;
    }

    ident_t *ident = ident_make(p->alloc, p->lexer.cur_token);
    if (!ident) {
        return false;
    }

    bool ok = ptrarray_add(out_params, ident);
    if (!ok) {
        ident_destroy(ident);
        return false;
    }

    lexer_next_token(&p->lexer);

    while (lexer_cur_token_is(&p->lexer, TOKEN_COMMA)) {
        lexer_next_token(&p->lexer);

        if (!lexer_expect_current(&p->lexer, TOKEN_IDENT)) {
            return false;
        }

        ident_t *ident = ident_make(p->alloc, p->lexer.cur_token);
        if (!ident) {
            return false;
        }
        bool ok = ptrarray_add(out_params, ident);
        if (!ok) {
            ident_destroy(ident);
            return false;
        }

        lexer_next_token(&p->lexer);
    }

    if (!lexer_expect_current(&p->lexer, TOKEN_RPAREN)) {
        return false;
    }

    lexer_next_token(&p->lexer);

    return true;
}

static expression_t* parse_call_expression(parser_t *p, expression_t *left) {
    expression_t *function = left;
    ptrarray(expression_t) *args = parse_expression_list(p, TOKEN_LPAREN, TOKEN_RPAREN, false);
    if (!args) {
        return NULL;
    }
    expression_t *res = expression_make_call(p->alloc, function, args);
    if (!res) {
        ptrarray_destroy_with_items(args, expression_destroy_wrapper);
        return NULL;
    }
    return res;
}

static ptrarray(expression_t)* parse_expression_list(parser_t *p, token_type_t start_token, token_type_t end_token, bool trailing_comma_allowed) {
    if (!lexer_expect_current(&p->lexer, start_token)) {
        return NULL;
    }

    lexer_next_token(&p->lexer);

    ptrarray(expression_t)* res = ptrarray_make(p->alloc);

    if (lexer_cur_token_is(&p->lexer, end_token)) {
        lexer_next_token(&p->lexer);
        return res;
    }

    expression_t *arg_expr = parse_expression(p, PRECEDENCE_LOWEST);
    if (!arg_expr) {
        goto err;
    }
    bool ok = ptrarray_add(res, arg_expr);
    if (!ok) {
        expression_destroy(arg_expr);
        goto err;
    }

    while (lexer_cur_token_is(&p->lexer, TOKEN_COMMA)) {
        lexer_next_token(&p->lexer);

        if (trailing_comma_allowed && lexer_cur_token_is(&p->lexer, end_token)) {
            break;
        }

        arg_expr = parse_expression(p, PRECEDENCE_LOWEST);
        if (!arg_expr) {
            goto err;
        }

        bool ok = ptrarray_add(res, arg_expr);
        if (!ok) {
            expression_destroy(arg_expr);
            goto err;
        }
    }

    if (!lexer_expect_current(&p->lexer, end_token)) {
        goto err;
    }

    lexer_next_token(&p->lexer);

    return res;
err:
    ptrarray_destroy_with_items(res, expression_destroy_wrapper);
    return NULL;
}

static expression_t* parse_index_expression(parser_t *p, expression_t *left) {
    lexer_next_token(&p->lexer);

    expression_t *index = parse_expression(p, PRECEDENCE_LOWEST);
    if (!index) {
        return NULL;
    }

    if (!lexer_expect_current(&p->lexer, TOKEN_RBRACKET)) {
        expression_destroy(index);
        return NULL;
    }

    lexer_next_token(&p->lexer);

    expression_t *res = expression_make_index(p->alloc, left, index);
    if (!res) {
        expression_destroy(index);
        return NULL;
    }

    return res;
}

static expression_t* parse_assign_expression(parser_t *p, expression_t *left) {
    expression_t *source = NULL;
    token_type_t assign_type = p->lexer.cur_token.type;

    lexer_next_token(&p->lexer);

    source = parse_expression(p, PRECEDENCE_LOWEST);
    if (!source) {
        goto err;
    }

    switch (assign_type) {
        case TOKEN_PLUS_ASSIGN:
        case TOKEN_MINUS_ASSIGN:
        case TOKEN_SLASH_ASSIGN:
        case TOKEN_ASTERISK_ASSIGN:
        case TOKEN_PERCENT_ASSIGN:
        case TOKEN_BIT_AND_ASSIGN:
        case TOKEN_BIT_OR_ASSIGN:
        case TOKEN_BIT_XOR_ASSIGN:
        case TOKEN_LSHIFT_ASSIGN:
        case TOKEN_RSHIFT_ASSIGN:
        {
            operator_t op = token_to_operator(assign_type);
            expression_t *left_copy = expression_copy(left);
            if (!left_copy) {
                goto err;
            }
            src_pos_t pos = source->pos;
            expression_t *new_source = expression_make_infix(p->alloc, op, left_copy, source);
            if (!new_source) {
                expression_destroy(left_copy);
                goto err;
            }
            new_source->pos = pos;
            source = new_source;
            break;
        }
        case TOKEN_ASSIGN: break;
        default: APE_ASSERT(false); break;
    }

    expression_t *res = expression_make_assign(p->alloc, left, source, false);
    if (!res) {
        goto err;
    }
    return res;
err:
    expression_destroy(source);
    return NULL;
}

static expression_t* parse_logical_expression(parser_t *p, expression_t *left) {
    operator_t op = token_to_operator(p->lexer.cur_token.type);
    precedence_t prec = get_precedence(p->lexer.cur_token.type);
    lexer_next_token(&p->lexer);
    expression_t *right = parse_expression(p, prec);
    if (!right) {
        return NULL;
    }
    expression_t *res = expression_make_logical(p->alloc, op, left, right);
    if (!res) {
        expression_destroy(right);
        return NULL;
    }
    return res;
}

static expression_t* parse_ternary_expression(parser_t *p, expression_t *left) {
    lexer_next_token(&p->lexer);

    expression_t *if_true = parse_expression(p, PRECEDENCE_LOWEST);
    if (!if_true) {
        return NULL;
    }

    if (!lexer_expect_current(&p->lexer, TOKEN_COLON)) {
        expression_destroy(if_true);
        return NULL;
    }
    lexer_next_token(&p->lexer);

    expression_t *if_false = parse_expression(p, PRECEDENCE_LOWEST);
    if (!if_false) {
        expression_destroy(if_true);
        return NULL;
    }

    expression_t *res = expression_make_ternary(p->alloc, left, if_true, if_false);
    if (!res) {
        expression_destroy(if_true);
        expression_destroy(if_false);
        return NULL;
    }

    return res;
}

static expression_t* parse_incdec_prefix_expression(parser_t *p) {
    expression_t *source = NULL;
    token_type_t operation_type = p->lexer.cur_token.type;
    src_pos_t pos = p->lexer.cur_token.pos;

    lexer_next_token(&p->lexer);

    operator_t op = token_to_operator(operation_type);

    expression_t *dest = parse_expression(p, PRECEDENCE_PREFIX);
    if (!dest) {
        goto err;
    }

    expression_t *one_literal = expression_make_number_literal(p->alloc, 1);
    if (!one_literal) {
        expression_destroy(dest);
        goto err;
    }
    one_literal->pos = pos;

    expression_t *dest_copy = expression_copy(dest);
    if (!dest_copy) {
        expression_destroy(one_literal);
        expression_destroy(dest);
        goto err;
    }

    expression_t *operation = expression_make_infix(p->alloc, op, dest_copy, one_literal);
    if (!operation) {
        expression_destroy(dest_copy);
        expression_destroy(dest);
        expression_destroy(one_literal);
        goto err;
    }
    operation->pos = pos;

    expression_t *res = expression_make_assign(p->alloc, dest, operation, false);
    if (!res) {
        expression_destroy(dest);
        expression_destroy(operation);
        goto err;
    }
    return res;
err:
    expression_destroy(source);
    return NULL;
}

static expression_t* parse_incdec_postfix_expression(parser_t *p, expression_t *left) {
    expression_t *source = NULL;
    token_type_t operation_type = p->lexer.cur_token.type;
    src_pos_t pos = p->lexer.cur_token.pos;

    lexer_next_token(&p->lexer);

    operator_t op = token_to_operator(operation_type);
    expression_t *left_copy = expression_copy(left);
    if (!left_copy) {
        goto err;
    }

    expression_t *one_literal = expression_make_number_literal(p->alloc, 1);
    if (!one_literal) {
        expression_destroy(left_copy);
        goto err;
    }
    one_literal->pos = pos;

    expression_t *operation = expression_make_infix(p->alloc, op, left_copy, one_literal);
    if (!operation) {
        expression_destroy(one_literal);
        expression_destroy(left_copy);
        goto err;
    }
    operation->pos = pos;

    expression_t *res = expression_make_assign(p->alloc, left, operation, true);
    if (!res) {
        expression_destroy(operation);
        goto err;
    }

    return res;
err:
    expression_destroy(source);
    return NULL;
}


static expression_t* parse_dot_expression(parser_t *p, expression_t *left) {
    lexer_next_token(&p->lexer);

    if (!lexer_expect_current(&p->lexer, TOKEN_IDENT)) {
        return NULL;
    }

    char *str = token_duplicate_literal(p->alloc, &p->lexer.cur_token);
    expression_t *index = expression_make_string_literal(p->alloc, str);
    if (!index) {
        allocator_free(p->alloc, str);
        return NULL;
    }
    index->pos = p->lexer.cur_token.pos;

    lexer_next_token(&p->lexer);

    expression_t *res = expression_make_index(p->alloc, left, index);
    if (!res) {
        expression_destroy(index);
        return NULL;
    }
    return res;
}

static precedence_t get_precedence(token_type_t tk) {
    switch (tk) {
        case TOKEN_EQ:              return PRECEDENCE_EQUALS;
        case TOKEN_NOT_EQ:          return PRECEDENCE_EQUALS;
        case TOKEN_LT:              return PRECEDENCE_LESSGREATER;
        case TOKEN_LTE:             return PRECEDENCE_LESSGREATER;
        case TOKEN_GT:              return PRECEDENCE_LESSGREATER;
        case TOKEN_GTE:             return PRECEDENCE_LESSGREATER;
        case TOKEN_PLUS:            return PRECEDENCE_SUM;
        case TOKEN_MINUS:           return PRECEDENCE_SUM;
        case TOKEN_SLASH:           return PRECEDENCE_PRODUCT;
        case TOKEN_ASTERISK:        return PRECEDENCE_PRODUCT;
        case TOKEN_PERCENT:         return PRECEDENCE_PRODUCT;
        case TOKEN_LPAREN:          return PRECEDENCE_POSTFIX;
        case TOKEN_LBRACKET:        return PRECEDENCE_POSTFIX;
        case TOKEN_ASSIGN:          return PRECEDENCE_ASSIGN;
        case TOKEN_PLUS_ASSIGN:     return PRECEDENCE_ASSIGN;
        case TOKEN_MINUS_ASSIGN:    return PRECEDENCE_ASSIGN;
        case TOKEN_ASTERISK_ASSIGN: return PRECEDENCE_ASSIGN;
        case TOKEN_SLASH_ASSIGN:    return PRECEDENCE_ASSIGN;
        case TOKEN_PERCENT_ASSIGN:  return PRECEDENCE_ASSIGN;
        case TOKEN_BIT_AND_ASSIGN:  return PRECEDENCE_ASSIGN;
        case TOKEN_BIT_OR_ASSIGN:   return PRECEDENCE_ASSIGN;
        case TOKEN_BIT_XOR_ASSIGN:  return PRECEDENCE_ASSIGN;
        case TOKEN_LSHIFT_ASSIGN:   return PRECEDENCE_ASSIGN;
        case TOKEN_RSHIFT_ASSIGN:   return PRECEDENCE_ASSIGN;
        case TOKEN_DOT:             return PRECEDENCE_POSTFIX;
        case TOKEN_AND:             return PRECEDENCE_LOGICAL_AND;
        case TOKEN_OR:              return PRECEDENCE_LOGICAL_OR;
        case TOKEN_BIT_OR:          return PRECEDENCE_BIT_OR;
        case TOKEN_BIT_XOR:         return PRECEDENCE_BIT_XOR;
        case TOKEN_BIT_AND:         return PRECEDENCE_BIT_AND;
        case TOKEN_LSHIFT:          return PRECEDENCE_SHIFT;
        case TOKEN_RSHIFT:          return PRECEDENCE_SHIFT;
        case TOKEN_QUESTION:        return PRECEDENCE_TERNARY;
        case TOKEN_PLUS_PLUS:       return PRECEDENCE_INCDEC;
        case TOKEN_MINUS_MINUS:     return PRECEDENCE_INCDEC;
        default:                    return PRECEDENCE_LOWEST;
    }
}

static operator_t token_to_operator(token_type_t tk) {
    switch (tk) {
        case TOKEN_ASSIGN:          return OPERATOR_ASSIGN;
        case TOKEN_PLUS:            return OPERATOR_PLUS;
        case TOKEN_MINUS:           return OPERATOR_MINUS;
        case TOKEN_BANG:            return OPERATOR_BANG;
        case TOKEN_ASTERISK:        return OPERATOR_ASTERISK;
        case TOKEN_SLASH:           return OPERATOR_SLASH;
        case TOKEN_LT:              return OPERATOR_LT;
        case TOKEN_LTE:             return OPERATOR_LTE;
        case TOKEN_GT:              return OPERATOR_GT;
        case TOKEN_GTE:             return OPERATOR_GTE;
        case TOKEN_EQ:              return OPERATOR_EQ;
        case TOKEN_NOT_EQ:          return OPERATOR_NOT_EQ;
        case TOKEN_PERCENT:         return OPERATOR_MODULUS;
        case TOKEN_AND:             return OPERATOR_LOGICAL_AND;
        case TOKEN_OR:              return OPERATOR_LOGICAL_OR;
        case TOKEN_PLUS_ASSIGN:     return OPERATOR_PLUS;
        case TOKEN_MINUS_ASSIGN:    return OPERATOR_MINUS;
        case TOKEN_ASTERISK_ASSIGN: return OPERATOR_ASTERISK;
        case TOKEN_SLASH_ASSIGN:    return OPERATOR_SLASH;
        case TOKEN_PERCENT_ASSIGN:  return OPERATOR_MODULUS;
        case TOKEN_BIT_AND_ASSIGN:  return OPERATOR_BIT_AND;
        case TOKEN_BIT_OR_ASSIGN:   return OPERATOR_BIT_OR;
        case TOKEN_BIT_XOR_ASSIGN:  return OPERATOR_BIT_XOR;
        case TOKEN_LSHIFT_ASSIGN:   return OPERATOR_LSHIFT;
        case TOKEN_RSHIFT_ASSIGN:   return OPERATOR_RSHIFT;
        case TOKEN_BIT_AND:         return OPERATOR_BIT_AND;
        case TOKEN_BIT_OR:          return OPERATOR_BIT_OR;
        case TOKEN_BIT_XOR:         return OPERATOR_BIT_XOR;
        case TOKEN_LSHIFT:          return OPERATOR_LSHIFT;
        case TOKEN_RSHIFT:          return OPERATOR_RSHIFT;
        case TOKEN_PLUS_PLUS:       return OPERATOR_PLUS;
        case TOKEN_MINUS_MINUS:     return OPERATOR_MINUS;
        default: {
            APE_ASSERT(false);
            return OPERATOR_NONE;
        }
    }
}

static char escape_char(const char c) {
    switch (c) {
        case '\"': return '\"';
        case '\\': return '\\';
        case '/':  return '/';
        case 'b':  return '\b';
        case 'f':  return '\f';
        case 'n':  return '\n';
        case 'r':  return '\r';
        case 't':  return '\t';
        case '0':  return '\0';
        default: return c;
    }
}

static char* process_and_copy_string(allocator_t *alloc, const char *input, size_t len) {
    char *output = allocator_malloc(alloc, len + 1);
    if (!output) {
        return NULL;
    }

    size_t in_i = 0;
    size_t out_i = 0;

    while (input[in_i] != '\0' && in_i < len) {
        if (input[in_i] == '\\') {
            in_i++;
            output[out_i] = escape_char(input[in_i]);
            if (output[out_i] < 0) {
                goto error;
            }
        } else {
            output[out_i] = input[in_i];
        }
        out_i++;
        in_i++;
    }
    output[out_i] = '\0';
    return output;
error:
    allocator_free(alloc, output);
    return NULL;
}

static expression_t* wrap_expression_in_function_call(allocator_t *alloc, expression_t *expr, const char *function_name) {
    token_t fn_token;
    token_init(&fn_token, TOKEN_IDENT, function_name, (int)strlen(function_name));
    fn_token.pos = expr->pos;

    ident_t *ident = ident_make(alloc, fn_token);
    if (!ident) {
        return NULL;
    }
    ident->pos = fn_token.pos;

    expression_t *function_ident_expr = expression_make_ident(alloc, ident);;
    if (!function_ident_expr) {
        ident_destroy(ident);
        return NULL;
    }
    function_ident_expr->pos = expr->pos;
    ident = NULL;

    ptrarray(expression_t) *args = ptrarray_make(alloc);
    if (!args) {
        expression_destroy(function_ident_expr);
        return NULL;
    }

    bool ok = ptrarray_add(args, expr);
    if (!ok) {
        ptrarray_destroy(args);
        expression_destroy(function_ident_expr);
        return NULL;
    }

    expression_t *call_expr = expression_make_call(alloc, function_ident_expr, args);
    if (!call_expr) {
        ptrarray_destroy(args);
        expression_destroy(function_ident_expr);
        return NULL;
    }
    call_expr->pos = expr->pos;

    return call_expr;
}
//FILE_END
//FILE_START:global_store.c
#ifndef APE_AMALGAMATED
#include "global_store.h"

#include "symbol_table.h"
#include "builtins.h"
#endif

typedef struct global_store {
    allocator_t *alloc;
    dict(symbol_t) *symbols;
    array(object_t) *objects;
} global_store_t;

global_store_t *global_store_make(allocator_t *alloc, gcmem_t *mem) {
    global_store_t *store = allocator_malloc(alloc, sizeof(global_store_t));
    if (!store) {
        return NULL;
    }
    memset(store, 0, sizeof(global_store_t));
    store->alloc = alloc;
    store->symbols = dict_make(alloc, symbol_copy_wrapper, symbol_destroy_wrapper);
    if (!store->symbols) {
        goto err;
    }
    store->objects = array_make(alloc, object_t);
    if (!store->objects) {
        goto err;
    }

    if (mem) {
        for (int i = 0; i < builtins_count(); i++) {
            const char *name = builtins_get_name(i);
            object_t builtin = object_make_native_function(mem, name, builtins_get_fn(i), NULL, 0);
            if (object_is_null(builtin)) {
                goto err;
            }
            bool ok = global_store_set(store, name, builtin);
            if (!ok) {
                goto err;
            }
        }
    }

    return store;
err:
    global_store_destroy(store);
    return NULL;
}

void global_store_destroy(global_store_t *store) {
    if (!store) {
        return;
    }
    dict_destroy_with_items(store->symbols);
    array_destroy(store->objects);
    allocator_free(store->alloc, store);
}

const symbol_t* global_store_get_symbol(global_store_t *store, const char *name) {
    return dict_get(store->symbols, name);
}

object_t global_store_get_object(global_store_t *store, const char *name) {
    const symbol_t *symbol = global_store_get_symbol(store, name);
    if (!symbol) {
        return object_make_null();
    }
    APE_ASSERT(symbol->type == SYMBOL_APE_GLOBAL);
    object_t *res = array_get(store->objects, symbol->index);
    return *res;
}

bool global_store_set(global_store_t *store, const char *name, object_t object) {
    const symbol_t *existing_symbol = global_store_get_symbol(store, name);
    if (existing_symbol) {
        bool ok = array_set(store->objects, existing_symbol->index, &object);
        return ok;
    }
    int ix = array_count(store->objects);
    bool ok = array_add(store->objects, &object);
    if (!ok) {
        return false;
    }
    symbol_t *symbol = symbol_make(store->alloc, name, SYMBOL_APE_GLOBAL, ix, false);
    if (!symbol) {
        goto err;
    }
    ok = dict_set(store->symbols, name, symbol);
    if (!ok) {
        symbol_destroy(symbol);
        goto err;
    }
    return true;
err:
    array_pop(store->objects, NULL);
    return false;
}

object_t global_store_get_object_at(global_store_t *store, int ix, bool *out_ok) {
    object_t *res = array_get(store->objects, ix);
    if (!res) {
        *out_ok = false;
        return object_make_null();
    }
    *out_ok = true;
    return *res;
}

bool global_store_set_object_at(global_store_t *store, int ix, object_t object) {
    bool ok = array_set(store->objects, ix, &object);
    return ok;
}

object_t *global_store_get_object_data(global_store_t *store) {
    return array_data(store->objects);
}

int global_store_get_object_count(global_store_t *store) {
    return array_count(store->objects);
}
//FILE_END
//FILE_START:symbol_table.c
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#ifndef APE_AMALGAMATED
#include "symbol_table.h"
#include "global_store.h"
#endif

static void* block_scope_copy(void *arg);
static block_scope_t* block_scope_make(allocator_t *alloc, int offset);
static void block_scope_destroy(block_scope_t *scope);
static bool set_symbol(symbol_table_t *table, symbol_t *symbol);
static int next_symbol_index(symbol_table_t *table);
static int count_num_definitions(symbol_table_t *table);

symbol_t *symbol_make(allocator_t *alloc, const char *name, symbol_type_t type, int index, bool assignable) {
    symbol_t *symbol = allocator_malloc(alloc, sizeof(symbol_t));
    if (!symbol) {
        return NULL;
    }
    memset(symbol, 0, sizeof(symbol_t));
    symbol->alloc = alloc;
    symbol->name = ape_strdup(alloc, name);
    if (!symbol->name) {
        allocator_free(alloc, symbol);
        return NULL;
    }
    symbol->type = type;
    symbol->index = index;
    symbol->assignable = assignable;
    return symbol;
}

void symbol_destroy(symbol_t *symbol) {
    if (!symbol) {
        return;
    }
    allocator_free(symbol->alloc, symbol->name);
    allocator_free(symbol->alloc, symbol);
}

symbol_t* symbol_copy(symbol_t *symbol) {
    return symbol_make(symbol->alloc, symbol->name, symbol->type, symbol->index, symbol->assignable);
}

void symbol_destroy_wrapper(void *symbol) {
    symbol_destroy(symbol);
}

void* symbol_copy_wrapper(void *symbol) {
    return symbol_copy(symbol);
}

symbol_table_t *symbol_table_make(allocator_t *alloc, symbol_table_t *outer, global_store_t *global_store, int module_global_offset) {
    symbol_table_t *table = allocator_malloc(alloc, sizeof(symbol_table_t));
    if (!table) {
        return NULL;
    }
    memset(table, 0, sizeof(symbol_table_t));
    table->alloc = alloc;
    table->max_num_definitions = 0;
    table->outer = outer;
    table->global_store = global_store;
    table->module_global_offset = module_global_offset;

    table->block_scopes = ptrarray_make(alloc);
    if (!table->block_scopes) {
        goto err;
    }

    table->free_symbols = ptrarray_make(alloc);
    if (!table->free_symbols) {
        goto err;
    }

    table->module_global_symbols = ptrarray_make(alloc);
    if (!table->module_global_symbols) {
        goto err;
    }

    bool ok = symbol_table_push_block_scope(table);
    if (!ok) {
        goto err;
    }

    return table;
err:
    symbol_table_destroy(table);
    return NULL;
}

void symbol_table_destroy(symbol_table_t *table) {
    if (!table) {
        return;
    }

    while (ptrarray_count(table->block_scopes) > 0) {
        symbol_table_pop_block_scope(table);
    }
    ptrarray_destroy(table->block_scopes);
    ptrarray_destroy_with_items(table->module_global_symbols, symbol_destroy_wrapper);
    ptrarray_destroy_with_items(table->free_symbols, symbol_destroy_wrapper);
    allocator_t *alloc = table->alloc;
    memset(table, 0, sizeof(symbol_table_t));
    allocator_free(alloc, table);
}

symbol_table_t* symbol_table_copy(symbol_table_t *table) {
    symbol_table_t *copy = allocator_malloc(table->alloc, sizeof(symbol_table_t));
    if (!copy) {
        return NULL;
    }
    memset(copy, 0, sizeof(symbol_table_t));
    copy->alloc = table->alloc;
    copy->outer = table->outer;
    copy->global_store = table->global_store;
    copy->block_scopes = ptrarray_copy_with_items(table->block_scopes, block_scope_copy, block_scope_destroy);
    if (!copy->block_scopes) {
        goto err;
    }
    copy->free_symbols = ptrarray_copy_with_items(table->free_symbols, symbol_copy_wrapper, symbol_destroy_wrapper);
    if (!copy->free_symbols) {
        goto err;
    }
    copy->module_global_symbols = ptrarray_copy_with_items(table->module_global_symbols, symbol_copy_wrapper, symbol_destroy_wrapper);
    if (!copy->module_global_symbols) {
        goto err;
    }
    copy->max_num_definitions = table->max_num_definitions;
    copy->module_global_offset = table->module_global_offset;
    return copy;
err:
    symbol_table_destroy(copy);
    return NULL;
}

bool symbol_table_add_module_symbol(symbol_table_t *st, symbol_t *symbol) {
    if (symbol->type != SYMBOL_MODULE_GLOBAL) {
        APE_ASSERT(false);
        return false;
    }
    if (symbol_table_symbol_is_defined(st, symbol->name)) {
        return true; // todo: make sure it should be true in this case
    }
    symbol_t *copy = symbol_copy(symbol);
    if (!copy) {
        return false;
    }
    bool ok = set_symbol(st, copy);
    if (!ok) {
        symbol_destroy(copy);
        return false;
    }
    return true;
}

const symbol_t *symbol_table_define(symbol_table_t *table, const char *name, bool assignable) {
    const symbol_t *global_symbol = global_store_get_symbol(table->global_store, name);
    if (global_symbol) {
        return NULL;
    }

    if (strchr(name, ':')) {
        return NULL; // module symbol
    }
    if (APE_STREQ(name, "this")) {
        return NULL; // "this" is reserved
    }
    symbol_type_t symbol_type = table->outer == NULL ? SYMBOL_MODULE_GLOBAL : SYMBOL_LOCAL;
    int ix = next_symbol_index(table);
    symbol_t *symbol = symbol_make(table->alloc, name, symbol_type, ix, assignable);
    if (!symbol) {
        return NULL;
    }

    bool global_symbol_added = false;
    bool ok = false;

    if (symbol_type == SYMBOL_MODULE_GLOBAL && ptrarray_count(table->block_scopes) == 1) {
        symbol_t *global_symbol_copy = symbol_copy(symbol);
        if (!global_symbol_copy) {
            symbol_destroy(symbol);
            return NULL;
        }
        ok = ptrarray_add(table->module_global_symbols, global_symbol_copy);
        if (!ok) {
            symbol_destroy(global_symbol_copy);
            symbol_destroy(symbol);
            return NULL;
        }
        global_symbol_added = true;
    }

    ok = set_symbol(table, symbol);
    if (!ok) {
        if (global_symbol_added) {
            symbol_t *global_symbol_copy = ptrarray_pop(table->module_global_symbols);
            symbol_destroy(global_symbol_copy);
        }
        symbol_destroy(symbol);
        return NULL;
    }

    block_scope_t *top_scope = ptrarray_top(table->block_scopes);
    top_scope->num_definitions++;
    int definitions_count = count_num_definitions(table);
    if (definitions_count > table->max_num_definitions) {
        table->max_num_definitions = definitions_count;
    }

    return symbol;
}

const symbol_t *symbol_table_define_free(symbol_table_t *st, const symbol_t *original) {
    symbol_t *copy = symbol_make(st->alloc, original->name, original->type, original->index, original->assignable);
    if (!copy) {
        return NULL;
    }
    bool ok = ptrarray_add(st->free_symbols, copy);
    if (!ok) {
        symbol_destroy(copy);
        return NULL;
    }

    symbol_t *symbol = symbol_make(st->alloc, original->name, SYMBOL_FREE, ptrarray_count(st->free_symbols) - 1, original->assignable);
    if (!symbol) {
        return NULL;
    }

    ok = set_symbol(st, symbol);
    if (!ok) {
        symbol_destroy(symbol);
        return NULL;
    }

    return symbol;
}

const symbol_t * symbol_table_define_function_name(symbol_table_t *st, const char *name, bool assignable) {
    if (strchr(name, ':')) {
        return NULL; // module symbol
    }
    symbol_t *symbol = symbol_make(st->alloc, name, SYMBOL_FUNCTION, 0, assignable);
    if (!symbol) {
        return NULL;
    }

    bool ok = set_symbol(st, symbol);
    if (!ok) {
        symbol_destroy(symbol);
        return NULL;
    }

    return symbol;
}

const symbol_t *symbol_table_define_this(symbol_table_t *st) {
    symbol_t *symbol = symbol_make(st->alloc, "this", SYMBOL_THIS, 0, false);
    if (!symbol) {
        return NULL;
    }

    bool ok = set_symbol(st, symbol);
    if (!ok) {
        symbol_destroy(symbol);
        return NULL;
    }

    return symbol;
}

const symbol_t *symbol_table_resolve(symbol_table_t *table, const char *name) {
    const symbol_t *symbol = NULL;
    block_scope_t *scope = NULL;

    symbol = global_store_get_symbol(table->global_store, name);
    if (symbol) {
        return symbol;
    }

    for (int i = ptrarray_count(table->block_scopes) - 1; i >= 0; i--) {
        scope = ptrarray_get(table->block_scopes, i);
        symbol = dict_get(scope->store, name);
        if (symbol) {
            break;
        }
    }

    if (symbol && symbol->type == SYMBOL_THIS) {
        symbol = symbol_table_define_free(table, symbol);
    }

    if (!symbol && table->outer) {
        symbol = symbol_table_resolve(table->outer, name);
        if (!symbol) {
            return NULL;
        }
        if (symbol->type == SYMBOL_MODULE_GLOBAL || symbol->type == SYMBOL_APE_GLOBAL) {
            return symbol;
        }
        symbol = symbol_table_define_free(table, symbol);
    }
    return symbol;
}

bool symbol_table_symbol_is_defined(symbol_table_t *table, const char *name) { // todo: rename to something more obvious
    const symbol_t *symbol = global_store_get_symbol(table->global_store, name);
    if (symbol) {
        return true;
    }

    block_scope_t *top_scope = ptrarray_top(table->block_scopes);
    symbol = dict_get(top_scope->store, name);
    if (symbol) {
        return true;
    }
    return false;
}

bool symbol_table_push_block_scope(symbol_table_t *table) {

    int block_scope_offset = 0;
    block_scope_t *prev_block_scope = ptrarray_top(table->block_scopes);
    if (prev_block_scope) {
        block_scope_offset = table->module_global_offset + prev_block_scope->offset + prev_block_scope->num_definitions;
    } else {
        block_scope_offset = table->module_global_offset;
    }

    block_scope_t *new_scope = block_scope_make(table->alloc, block_scope_offset);
    if (!new_scope) {
        return false;
    }
    bool ok = ptrarray_push(table->block_scopes, new_scope);
    if (!ok) {
        block_scope_destroy(new_scope);
        return false;
    }
    return true;
}

void symbol_table_pop_block_scope(symbol_table_t *table) {
    block_scope_t *top_scope = ptrarray_top(table->block_scopes);
    ptrarray_pop(table->block_scopes);
    block_scope_destroy(top_scope);
}

block_scope_t* symbol_table_get_block_scope(symbol_table_t *table) {
    block_scope_t *top_scope = ptrarray_top(table->block_scopes);
    return top_scope;
}

bool symbol_table_is_module_global_scope(symbol_table_t *table) {
    return table->outer == NULL;
}

bool symbol_table_is_top_block_scope(symbol_table_t *table) {
    return ptrarray_count(table->block_scopes) == 1;
}

bool symbol_table_is_top_global_scope(symbol_table_t *table) {
    return symbol_table_is_module_global_scope(table) && symbol_table_is_top_block_scope(table);
}

int symbol_table_get_module_global_symbol_count(const symbol_table_t *table) {
    return ptrarray_count(table->module_global_symbols);
}

const symbol_t * symbol_table_get_module_global_symbol_at(const symbol_table_t *table, int ix) {
    return ptrarray_get(table->module_global_symbols, ix);
}

// INTERNAL
static block_scope_t* block_scope_make(allocator_t *alloc, int offset) {
    block_scope_t *new_scope = allocator_malloc(alloc, sizeof(block_scope_t));
    if (!new_scope) {
        return NULL;
    }
    memset(new_scope, 0, sizeof(block_scope_t));
    new_scope->alloc = alloc;
    new_scope->store = dict_make(alloc, symbol_copy_wrapper, symbol_destroy_wrapper);
    if (!new_scope->store) {
        block_scope_destroy(new_scope);
        return NULL;
    }
    new_scope->num_definitions = 0;
    new_scope->offset = offset;
    return new_scope;
}

static void block_scope_destroy(block_scope_t *scope) {
    dict_destroy_with_items(scope->store);
    allocator_free(scope->alloc, scope);
}

static void* block_scope_copy(void* arg) {
    block_scope_t *scope = arg;
    block_scope_t *copy = allocator_malloc(scope->alloc, sizeof(block_scope_t));
    if (!copy) {
        return NULL;
    }
    memset(copy, 0, sizeof(block_scope_t));
    copy->alloc = scope->alloc;
    copy->num_definitions = scope->num_definitions;
    copy->offset = scope->offset;
    copy->store = dict_copy_with_items(scope->store);
    if (!copy->store) {
        block_scope_destroy(copy);
        return NULL;
    }
    return copy;
}

static bool set_symbol(symbol_table_t *table, symbol_t *symbol) {
    block_scope_t *top_scope = ptrarray_top(table->block_scopes);
    symbol_t *existing = dict_get(top_scope->store, symbol->name);
    if (existing) {
        symbol_destroy(existing);
    }
    return dict_set(top_scope->store, symbol->name, symbol);
}

static int next_symbol_index(symbol_table_t *table) {
    block_scope_t *top_scope = ptrarray_top(table->block_scopes);
    int ix = top_scope->offset + top_scope->num_definitions;
    return ix;
}

static int count_num_definitions(symbol_table_t *table) {
    int count = 0;
    for (int i = ptrarray_count(table->block_scopes) - 1; i >= 0; i--) {
        block_scope_t *scope = ptrarray_get(table->block_scopes, i);
        count += scope->num_definitions;
    }
    return count;
}
//FILE_END
//FILE_START:code.c
#include <stdlib.h>

#ifndef APE_AMALGAMATED
#include "code.h"

#include "common.h"
#include "collections.h"
#endif

static opcode_definition_t g_definitions[OPCODE_MAX + 1] = {
    {"NONE", 0, {0}},
    {"CONSTANT", 1, {2}},
    {"ADD", 0, {0}},
    {"POP", 0, {0}},
    {"SUB", 0, {0}},
    {"MUL", 0, {0}},
    {"DIV", 0, {0}},
    {"MOD", 0, {0}},
    {"TRUE", 0, {0}},
    {"FALSE", 0, {0}},
    {"COMPARE", 0, {0}},
    {"COMPARE_EQ", 0, {0}},
    {"EQUAL", 0, {0}},
    {"NOT_EQUAL", 0, {0}},
    {"GREATER_THAN", 0, {0}},
    {"GREATER_THAN_EQUAL", 0, {0}},
    {"MINUS", 0, {0}},
    {"BANG", 0, {0}},
    {"JUMP", 1, {2}},
    {"JUMP_IF_FALSE", 1, {2}},
    {"JUMP_IF_TRUE", 1, {2}},
    {"NULL", 0, {0}},
    {"GET_MODULE_GLOBAL", 1, {2}},
    {"SET_MODULE_GLOBAL", 1, {2}},
    {"DEFINE_MODULE_GLOBAL", 1, {2}},
    {"ARRAY", 1, {2}},
    {"MAP_START", 1, {2}},
    {"MAP_END", 1, {2}},
    {"GET_THIS", 0, {0}},
    {"GET_INDEX", 0, {0}},
    {"SET_INDEX", 0, {0}},
    {"GET_VALUE_AT", 0, {0}},
    {"CALL", 1, {1}},
    {"RETURN_VALUE", 0, {0}},
    {"RETURN", 0, {0}},
    {"GET_LOCAL", 1, {1}},
    {"DEFINE_LOCAL", 1, {1}},
    {"SET_LOCAL", 1, {1}},
    {"GET_APE_GLOBAL", 1, {2}},
    {"FUNCTION", 2, {2, 1}},
    {"GET_FREE", 1, {1}},
    {"SET_FREE", 1, {1}},
    {"CURRENT_FUNCTION", 0, {0}},
    {"DUP", 0, {0}},
    {"NUMBER", 1, {8}},
    {"LEN", 0, {0}},
    {"SET_RECOVER", 1, {2}},
    {"OR", 0, {0}},
    {"XOR", 0, {0}},
    {"AND", 0, {0}},
    {"LSHIFT", 0, {0}},
    {"RSHIFT", 0, {0}},
    {"INVALID_MAX", 0, {0}},
};

opcode_definition_t* opcode_lookup(opcode_t op) {
    if (op <= OPCODE_NONE || op >= OPCODE_MAX) {
        return NULL;
    }
    return &g_definitions[op];
}

const char *opcode_get_name(opcode_t op) {
    if (op <= OPCODE_NONE || op >= OPCODE_MAX) {
        return NULL;
    }
    return g_definitions[op].name;
}

int code_make(opcode_t op, int operands_count, uint64_t *operands, array(uint8_t) *res) {
    opcode_definition_t *def = opcode_lookup(op);
    if (!def) {
        return 0;
    }

    int instr_len = 1;
    for (int i = 0; i < def->num_operands; i++) {
        instr_len += def->operand_widths[i];
    }

    uint8_t val = op;
    bool ok = false;

    ok = array_add(res, &val);
    if (!ok) {
        return 0;
    }

#define APPEND_BYTE(n) do {\
    val = (uint8_t)(operands[i] >> (n * 8));\
    ok = array_add(res, &val);\
    if (!ok) {\
        return 0;\
    }\
} while (0)

    for (int i = 0; i < operands_count; i++) {
        int width = def->operand_widths[i];
        switch (width) {
            case 1: {
                APPEND_BYTE(0);
                break;
            }
            case 2: {
                APPEND_BYTE(1);
                APPEND_BYTE(0);
                break;
            }
            case 4: {
                APPEND_BYTE(3);
                APPEND_BYTE(2);
                APPEND_BYTE(1);
                APPEND_BYTE(0);
                break;
            }
            case 8: {
                APPEND_BYTE(7);
                APPEND_BYTE(6);
                APPEND_BYTE(5);
                APPEND_BYTE(4);
                APPEND_BYTE(3);
                APPEND_BYTE(2);
                APPEND_BYTE(1);
                APPEND_BYTE(0);
                break;
            }
            default: {
                APE_ASSERT(false);
                break;
            }
        }
    }
#undef APPEND_BYTE
    return instr_len;
}

void code_to_string(uint8_t *code, src_pos_t *source_positions, size_t code_size, strbuf_t *res) {
    unsigned pos = 0;
    while (pos < code_size) {
        uint8_t op = code[pos];
        opcode_definition_t *def = opcode_lookup(op);
        APE_ASSERT(def);
        if (source_positions) {
            src_pos_t src_pos = source_positions[pos];
            strbuf_appendf(res, "%d:%-4d\t%04d\t%s", src_pos.line, src_pos.column, pos, def->name);
        } else {
            strbuf_appendf(res, "%04d %s", pos, def->name);
        }
        pos++;

        uint64_t operands[2];
        bool ok = code_read_operands(def, code + pos, operands);
        if (!ok) {
            return;
        }
        for (int i = 0; i < def->num_operands; i++) {
            if (op == OPCODE_NUMBER) {
                double val_double = ape_uint64_to_double(operands[i]);
                strbuf_appendf(res, " %1.17g", val_double);
            } else {
                strbuf_appendf(res, " %llu", (long long unsigned int)operands[i]);
            }
            pos += def->operand_widths[i];
        }
        strbuf_append(res, "\n");

    }
    return;
}

bool code_read_operands(opcode_definition_t *def, uint8_t *instr, uint64_t out_operands[2]) {
    int offset = 0;
    for (int i = 0; i < def->num_operands; i++) {
        int operand_width = def->operand_widths[i];
        switch (operand_width) {
            case 1: {
                out_operands[i] = instr[offset];
                break;
            }
            case 2: {
                uint64_t operand = 0;
                operand = operand | ((uint64_t)instr[offset] << 8);
                operand = operand | ((uint64_t)instr[offset + 1]);
                out_operands[i] = operand;
                break;
            }
            case 4: {
                uint64_t operand = 0;
                operand = operand | ((uint64_t)instr[offset + 0] << 24);
                operand = operand | ((uint64_t)instr[offset + 1] << 16);
                operand = operand | ((uint64_t)instr[offset + 2] << 8);
                operand = operand | ((uint64_t)instr[offset + 3]);
                out_operands[i] = operand;
                break;
            }
            case 8: {
                uint64_t operand = 0;
                operand = operand | ((uint64_t)instr[offset + 0] << 56);
                operand = operand | ((uint64_t)instr[offset + 1] << 48);
                operand = operand | ((uint64_t)instr[offset + 2] << 40);
                operand = operand | ((uint64_t)instr[offset + 3] << 32);
                operand = operand | ((uint64_t)instr[offset + 4] << 24);
                operand = operand | ((uint64_t)instr[offset + 5] << 16);
                operand = operand | ((uint64_t)instr[offset + 6] << 8);
                operand = operand | ((uint64_t)instr[offset + 7]);
                out_operands[i] = operand;
                break;
            }
            default: {
                APE_ASSERT(false);
                return false;
            }
        }
        offset += operand_width;
    }
    return true;;
}
//FILE_END
//FILE_START:compilation_scope.c
#ifndef APE_AMALGAMATED
#include "compilation_scope.h"
#endif

compilation_scope_t *compilation_scope_make(allocator_t *alloc, compilation_scope_t *outer) {
    compilation_scope_t *scope = allocator_malloc(alloc, sizeof(compilation_scope_t));
    if (!scope) {
        return NULL;
    }
    memset(scope, 0, sizeof(compilation_scope_t));
    scope->alloc = alloc;
    scope->outer = outer;
    scope->bytecode = array_make(alloc, uint8_t);
    if (!scope->bytecode) {
        goto err;
    }
    scope->src_positions = array_make(alloc, src_pos_t);
    if (!scope->src_positions) {
        goto err;
    }
    scope->break_ip_stack = array_make(alloc, int);
    if (!scope->break_ip_stack) {
        goto err;
    }
    scope->continue_ip_stack = array_make(alloc, int);
    if (!scope->continue_ip_stack) {
        goto err;
    }
    return scope;
err:
    compilation_scope_destroy(scope);
    return NULL;
}

void compilation_scope_destroy(compilation_scope_t *scope) {
    array_destroy(scope->continue_ip_stack);
    array_destroy(scope->break_ip_stack);
    array_destroy(scope->bytecode);
    array_destroy(scope->src_positions);
    allocator_free(scope->alloc, scope);
}

compilation_result_t* compilation_scope_orphan_result(compilation_scope_t *scope) {
    compilation_result_t *res = compilation_result_make(scope->alloc,
                                                        array_data(scope->bytecode),
                                                        array_data(scope->src_positions),
                                                        array_count(scope->bytecode));
    if (!res) {
        return NULL;
    }
    array_orphan_data(scope->bytecode);
    array_orphan_data(scope->src_positions);
    return res;
}

compilation_result_t* compilation_result_make(allocator_t *alloc, uint8_t *bytecode, src_pos_t *src_positions, int count) {
    compilation_result_t *res = allocator_malloc(alloc, sizeof(compilation_result_t));
    if (!res) {
        return NULL;
    }
    memset(res, 0, sizeof(compilation_result_t));
    res->alloc = alloc;
    res->bytecode = bytecode;
    res->src_positions = src_positions;
    res->count = count;
    return res;
}

void compilation_result_destroy(compilation_result_t *res) {
    if (!res) {
        return;
    }
    allocator_free(res->alloc, res->bytecode);
    allocator_free(res->alloc, res->src_positions);
    allocator_free(res->alloc, res);
}
//FILE_END
//FILE_START:optimisation.c
#ifndef APE_AMALGAMATED
#include "optimisation.h"
#endif

static expression_t* optimise_infix_expression(expression_t* expr);
static expression_t* optimise_prefix_expression(expression_t* expr);

expression_t* optimise_expression(expression_t* expr) {
    switch (expr->type) {
        case EXPRESSION_INFIX: return optimise_infix_expression(expr);
        case EXPRESSION_PREFIX: return optimise_prefix_expression(expr);
        default: return NULL;
    }
}

// INTERNAL
static expression_t* optimise_infix_expression(expression_t* expr) {
    expression_t *left = expr->infix.left;
    expression_t *left_optimised = optimise_expression(left);
    if (left_optimised) {
        left = left_optimised;
    }

    expression_t *right = expr->infix.right;
    expression_t *right_optimised = optimise_expression(right);
    if (right_optimised) {
        right = right_optimised;
    }

    expression_t *res = NULL;

    bool left_is_numeric = left->type == EXPRESSION_NUMBER_LITERAL || left->type == EXPRESSION_BOOL_LITERAL;
    bool right_is_numeric = right->type == EXPRESSION_NUMBER_LITERAL || right->type == EXPRESSION_BOOL_LITERAL;

    bool left_is_string = left->type == EXPRESSION_STRING_LITERAL;
    bool right_is_string = right->type == EXPRESSION_STRING_LITERAL;

    allocator_t *alloc = expr->alloc;
    if (left_is_numeric && right_is_numeric) {
        double left_val = left->type == EXPRESSION_NUMBER_LITERAL ? left->number_literal : left->bool_literal;
        double right_val = right->type == EXPRESSION_NUMBER_LITERAL ? right->number_literal : right->bool_literal;
        int64_t left_val_int = (int64_t)left_val;
        int64_t right_val_int = (int64_t)right_val;
        switch (expr->infix.op) {
            case OPERATOR_PLUS:     { res = expression_make_number_literal(alloc, left_val + right_val); break; }
            case OPERATOR_MINUS:    { res = expression_make_number_literal(alloc, left_val - right_val); break; }
            case OPERATOR_ASTERISK: { res = expression_make_number_literal(alloc, left_val * right_val); break; }
            case OPERATOR_SLASH:    { res = expression_make_number_literal(alloc, left_val / right_val); break; }
            case OPERATOR_LT:       { res = expression_make_bool_literal(alloc, left_val < right_val); break; }
            case OPERATOR_LTE:      { res = expression_make_bool_literal(alloc, left_val <= right_val); break; }
            case OPERATOR_GT:       { res = expression_make_bool_literal(alloc, left_val > right_val); break; }
            case OPERATOR_GTE:      { res = expression_make_bool_literal(alloc, left_val >= right_val); break; }
            case OPERATOR_EQ:       { res = expression_make_bool_literal(alloc, APE_DBLEQ(left_val, right_val)); break; }
            case OPERATOR_NOT_EQ:   { res = expression_make_bool_literal(alloc, !APE_DBLEQ(left_val, right_val)); break; }
            case OPERATOR_MODULUS:  { res = expression_make_number_literal(alloc, fmod(left_val, right_val)); break; }
            case OPERATOR_BIT_AND:  { res = expression_make_number_literal(alloc, (double)(left_val_int & right_val_int)); break; }
            case OPERATOR_BIT_OR:   { res = expression_make_number_literal(alloc, (double)(left_val_int | right_val_int)); break; }
            case OPERATOR_BIT_XOR:  { res = expression_make_number_literal(alloc, (double)(left_val_int ^ right_val_int)); break; }
            case OPERATOR_LSHIFT:   { res = expression_make_number_literal(alloc, (double)(left_val_int << right_val_int)); break; }
            case OPERATOR_RSHIFT:   { res = expression_make_number_literal(alloc, (double)(left_val_int >> right_val_int)); break; }
            default: {
                break;
            }
        }
    } else if (expr->infix.op == OPERATOR_PLUS && left_is_string && right_is_string) {
        const char* left_val = left->string_literal;
        const char* right_val = right->string_literal;
        char *res_str = ape_stringf(alloc, "%s%s", left_val, right_val);
        if (res_str) {
            res = expression_make_string_literal(alloc, res_str);
            if (!res) {
                allocator_free(alloc, res_str);
            }
        }
    }

    expression_destroy(left_optimised);
    expression_destroy(right_optimised);

    if (res) {
        res->pos = expr->pos;
    }

    return res;
}

expression_t* optimise_prefix_expression(expression_t* expr) {
    expression_t *right = expr->prefix.right;
    expression_t *right_optimised = optimise_expression(right);
    if (right_optimised) {
        right = right_optimised;
    }
    expression_t *res = NULL;
    if (expr->prefix.op == OPERATOR_MINUS && right->type == EXPRESSION_NUMBER_LITERAL) {
        res = expression_make_number_literal(expr->alloc, -right->number_literal);
    } else if (expr->prefix.op == OPERATOR_BANG && right->type == EXPRESSION_BOOL_LITERAL) {
        res = expression_make_bool_literal(expr->alloc, !right->bool_literal);
    }
    expression_destroy(right_optimised);
    if (res) {
        res->pos = expr->pos;
    }
    return res;
}
//FILE_END
//FILE_START:compiler.c
#include <stdlib.h>
#include <math.h>

#ifndef APE_AMALGAMATED
#include "compiler.h"

#include "ape.h"
#include "ast.h"
#include "object.h"
#include "gc.h"
#include "code.h"
#include "symbol_table.h"
#include "errors.h"
#include "optimisation.h"
#endif

typedef struct module {
    allocator_t *alloc;
    char *name;
    ptrarray(symbol_t) *symbols;
} module_t;

typedef struct file_scope {
    allocator_t *alloc;
    parser_t *parser;
    symbol_table_t *symbol_table;
    compiled_file_t *file;
    ptrarray(char) *loaded_module_names;
} file_scope_t;

typedef struct compiler {
    allocator_t *alloc;
    const ape_config_t *config;
    gcmem_t *mem;
    errors_t *errors;
    ptrarray(compiled_file_t) *files;
    global_store_t *global_store;
    array(object_t) *constants;
    compilation_scope_t *compilation_scope;
    ptrarray(file_scope_t) *file_scopes;
    array(src_pos_t) *src_positions_stack;
    dict(module_t) *modules;
    dict(int) *string_constants_positions;
} compiler_t;

static bool compiler_init(compiler_t *comp,
                          allocator_t *alloc,
                          const ape_config_t *config,
                          gcmem_t *mem, errors_t *errors,
                          ptrarray(compiled_file_t) *files,
                          global_store_t *global_store);
static void compiler_deinit(compiler_t *comp);

static bool compiler_init_shallow_copy(compiler_t *copy, compiler_t *src); // used to restore compiler's state if something fails

static int emit(compiler_t *comp, opcode_t op, int operands_count, uint64_t *operands);
static compilation_scope_t* get_compilation_scope(compiler_t *comp);
static bool push_compilation_scope(compiler_t *comp);
static void pop_compilation_scope(compiler_t *comp);
static bool push_symbol_table(compiler_t *comp, int global_offset);
static void pop_symbol_table(compiler_t *comp);
static opcode_t get_last_opcode(compiler_t *comp);
static bool compile_code(compiler_t *comp, const char *code, size_t len);
static bool compile_statements(compiler_t *comp, ptrarray(statement_t) *statements);
static bool import_module(compiler_t *comp, const statement_t *import_stmt);
static bool compile_statement(compiler_t *comp, const statement_t *stmt);
static bool compile_expression(compiler_t *comp, expression_t *expr);
static bool compile_code_block(compiler_t *comp, const code_block_t *block);
static int  add_constant(compiler_t *comp, object_t obj);
static void change_uint16_operand(compiler_t *comp, int ip, uint16_t operand);
static bool last_opcode_is(compiler_t *comp, opcode_t op);
static bool read_symbol(compiler_t *comp, const symbol_t *symbol);
static bool write_symbol(compiler_t *comp, const symbol_t *symbol, bool define);

static bool push_break_ip(compiler_t *comp, int ip);
static void pop_break_ip(compiler_t *comp);
static int  get_break_ip(compiler_t *comp);

static bool push_continue_ip(compiler_t *comp, int ip);
static void pop_continue_ip(compiler_t *comp);
static int  get_continue_ip(compiler_t *comp);

static int  get_ip(compiler_t *comp);

static array(src_pos_t)* get_src_positions(compiler_t *comp);
static array(uint8_t)*   get_bytecode(compiler_t *comp);

static file_scope_t* file_scope_make(compiler_t *comp, compiled_file_t *file);
static void file_scope_destroy(file_scope_t *file_scope);
static bool push_file_scope(compiler_t *comp, const char *filepath);
static void pop_file_scope(compiler_t *comp);

static void set_compilation_scope(compiler_t *comp, compilation_scope_t *scope);

static module_t* module_make(allocator_t *alloc, const char *name);
static void module_destroy(module_t *module);
static module_t* module_copy(module_t *module);
static bool module_add_symbol(module_t *module, const symbol_t *symbol);

static const char* get_module_name(const char *path);
static const symbol_t* define_symbol(compiler_t *comp, src_pos_t pos, const char *name, bool assignable, bool can_shadow);

compiler_t *compiler_make(allocator_t *alloc, const ape_config_t *config, gcmem_t *mem, errors_t *errors, ptrarray(compiled_file_t) *files, global_store_t *global_store) {
    compiler_t *comp = allocator_malloc(alloc, sizeof(compiler_t));
    if (!comp) {
        return NULL;
    }
    bool ok = compiler_init(comp, alloc, config, mem, errors, files, global_store);
    if (!ok) {
        allocator_free(alloc, comp);
        return NULL;
    }
    return comp;
}

void compiler_destroy(compiler_t *comp) {
    if (!comp) {
        return;
    }
    allocator_t *alloc = comp->alloc;
    compiler_deinit(comp);
    allocator_free(alloc, comp);
}

compilation_result_t* compiler_compile(compiler_t *comp, const char *code, size_t len) {
    compilation_scope_t *compilation_scope = get_compilation_scope(comp);

    APE_ASSERT(array_count(comp->src_positions_stack) == 0);
    APE_ASSERT(array_count(compilation_scope->bytecode) == 0);
    APE_ASSERT(array_count(compilation_scope->break_ip_stack) == 0);
    APE_ASSERT(array_count(compilation_scope->continue_ip_stack) == 0);

    array_clear(comp->src_positions_stack);
    array_clear(compilation_scope->bytecode);
    array_clear(compilation_scope->src_positions);
    array_clear(compilation_scope->break_ip_stack);
    array_clear(compilation_scope->continue_ip_stack);

    compiler_t comp_shallow_copy;
    bool ok = compiler_init_shallow_copy(&comp_shallow_copy, comp);
    if (!ok) {
        return NULL;
    }

    ok = compile_code(comp, code, len);
    if (!ok) {
        goto err;
    }

    compilation_scope = get_compilation_scope(comp); // might've changed
    APE_ASSERT(compilation_scope->outer == NULL);

    compilation_scope = get_compilation_scope(comp);
    compilation_result_t *res = compilation_scope_orphan_result(compilation_scope);
    if (!res) {
        goto err;
    }
    compiler_deinit(&comp_shallow_copy);
    return res;
err:
    compiler_deinit(comp);
    *comp = comp_shallow_copy;
    return NULL;
}

compilation_result_t* compiler_compile_file(compiler_t *comp, const char *path) {
    char *code = NULL;
    compiled_file_t *file = NULL;
    compilation_result_t *res = NULL;

    if (!comp->config->fileio.read_file.read_file) { // todo: read code function
        errors_add_error(comp->errors, ERROR_COMPILATION, src_pos_invalid, "File read function not configured");
        goto err;
    }

    code = comp->config->fileio.read_file.read_file(comp->config->fileio.read_file.context, path);
    if (!code) {
        errors_add_errorf(comp->errors, ERROR_COMPILATION, src_pos_invalid, "Reading file \"%s\" failed", path);
        goto err;
    }

    file = compiled_file_make(comp->alloc, path);
    if (!file) {
        goto err;
    }

    bool ok = ptrarray_add(comp->files, file);
    if (!ok) {
        compiled_file_destroy(file);
        goto err;
    }

    APE_ASSERT(ptrarray_count(comp->file_scopes) == 1);
    file_scope_t *file_scope = ptrarray_top(comp->file_scopes);
    if (!file_scope) {
        goto err;
    }

    compiled_file_t *prev_file = file_scope->file; // todo: push file scope instead?
    file_scope->file = file;

    res = compiler_compile(comp, code, strlen(code));
    if (!res) {
        file_scope->file = prev_file;
        goto err;
    }
    file_scope->file = prev_file;

    allocator_free(comp->alloc, code);
    return res;
err:
    allocator_free(comp->alloc, code);
    return NULL;
}

symbol_table_t* compiler_get_symbol_table(compiler_t *comp) {
    file_scope_t *file_scope = ptrarray_top(comp->file_scopes);
    if (!file_scope) {
        APE_ASSERT(false);
        return NULL;
    }
    return file_scope->symbol_table;
}

void compiler_set_symbol_table(compiler_t *comp, symbol_table_t *table) {
    file_scope_t *file_scope = ptrarray_top(comp->file_scopes);
    if (!file_scope) {
        APE_ASSERT(false);
        return;
    }
    file_scope->symbol_table = table;
}

array(object_t)* compiler_get_constants(const compiler_t *comp) {
    return comp->constants;
}

// INTERNAL
static bool compiler_init(compiler_t *comp,
                          allocator_t *alloc,
                          const ape_config_t *config,
                          gcmem_t *mem, errors_t *errors,
                          ptrarray(compiled_file_t) *files,
                          global_store_t *global_store) {

    memset(comp, 0, sizeof(compiler_t));
    comp->alloc = alloc;
    comp->config = config;
    comp->mem = mem;
    comp->errors = errors;
    comp->files = files;
    comp->global_store = global_store;

    comp->file_scopes = ptrarray_make(alloc);
    if (!comp->file_scopes) {
        goto err;
    }
    comp->constants = array_make(alloc, object_t);
    if (!comp->constants) {
        goto err;
    }
    comp->src_positions_stack = array_make(alloc, src_pos_t);
    if (!comp->src_positions_stack) {
        goto err;
    }
    comp->modules = dict_make(alloc, module_copy, module_destroy);
    if (!comp->modules) {
        goto err;
    }
    bool ok = push_compilation_scope(comp);
    if (!ok) {
        goto err;
    }
    ok = push_file_scope(comp, "none");
    if (!ok) {
        goto err;
    }
    comp->string_constants_positions = dict_make(comp->alloc, NULL, NULL);
    if (!comp->string_constants_positions) {
        goto err;
    }

    return true;
err:
    compiler_deinit(comp);
    return false;
}

static void compiler_deinit(compiler_t *comp) {
    if (!comp) {
        return;
    }
    for (int i = 0; i < dict_count(comp->string_constants_positions); i++) {
        int *val = dict_get_value_at(comp->string_constants_positions, i);
        allocator_free(comp->alloc, val);
    }
    dict_destroy(comp->string_constants_positions);

    while (ptrarray_count(comp->file_scopes) > 0) {
        pop_file_scope(comp);
    }
    while (get_compilation_scope(comp)) {
        pop_compilation_scope(comp);
    }
    dict_destroy_with_items(comp->modules);
    array_destroy(comp->src_positions_stack);

    array_destroy(comp->constants);
    ptrarray_destroy(comp->file_scopes);
    memset(comp, 0, sizeof(compiler_t));
}

static bool compiler_init_shallow_copy(compiler_t *copy, compiler_t *src) {
    bool ok = compiler_init(copy, src->alloc, src->config, src->mem, src->errors, src->files, src->global_store);
    if (!ok) {
        return false;
    }

    symbol_table_t *src_st = compiler_get_symbol_table(src);
    APE_ASSERT(ptrarray_count(src->file_scopes) == 1);
    APE_ASSERT(src_st->outer == NULL);
    symbol_table_t *src_st_copy = symbol_table_copy(src_st);
    if (!src_st_copy) {
        goto err;
    }
    symbol_table_t *copy_st = compiler_get_symbol_table(copy);
    symbol_table_destroy(copy_st);
    copy_st = NULL;
    compiler_set_symbol_table(copy, src_st_copy);

    dict(module_t) *modules_copy = dict_copy_with_items(src->modules);
    if (!modules_copy) {
        goto err;
    }
    dict_destroy_with_items(copy->modules);
    copy->modules = modules_copy;

    array(object_t) *constants_copy = array_copy(src->constants);
    if (!constants_copy) {
        goto err;
    }
    array_destroy(copy->constants);
    copy->constants = constants_copy;

    for (int i = 0; i < dict_count(src->string_constants_positions); i++) {
        const char *key = dict_get_key_at(src->string_constants_positions, i);
        int *val = dict_get_value_at(src->string_constants_positions, i);
        int *val_copy = allocator_malloc(src->alloc, sizeof(int));
        if (!val_copy) {
            goto err;
        }
        *val_copy = *val;
        ok = dict_set(copy->string_constants_positions, key, val_copy);
        if (!ok) {
            allocator_free(src->alloc, val_copy);
            goto err;
        }
    }

    file_scope_t *src_file_scope = ptrarray_top(src->file_scopes);
    file_scope_t *copy_file_scope = ptrarray_top(copy->file_scopes);

    ptrarray(char) *src_loaded_module_names = src_file_scope->loaded_module_names;
    ptrarray(char) *copy_loaded_module_names = copy_file_scope->loaded_module_names;

    for (int i = 0; i < ptrarray_count(src_loaded_module_names); i++) {
        const char *loaded_name = ptrarray_get(src_loaded_module_names, i);
        char *loaded_name_copy = ape_strdup(copy->alloc, loaded_name);
        if (!loaded_name_copy) {
            goto err;
        }
        ok = ptrarray_add(copy_loaded_module_names, loaded_name_copy);
        if (!ok) {
            allocator_free(copy->alloc, loaded_name_copy);
            goto err;
        }
    }

    return true;
err:
    compiler_deinit(copy);
    return false;
}

static int emit(compiler_t *comp, opcode_t op, int operands_count, uint64_t *operands) {
    int ip = get_ip(comp);
    int len = code_make(op, operands_count, operands, get_bytecode(comp));
    if (len == 0) {
        return -1;
    }
    for (int i = 0; i < len; i++) {
        src_pos_t *src_pos = array_top(comp->src_positions_stack);
        APE_ASSERT(src_pos->line >= 0);
        APE_ASSERT(src_pos->column >= 0);
        bool ok = array_add(get_src_positions(comp), src_pos);
        if (!ok) {
            return -1;
        }
    }
    compilation_scope_t *compilation_scope = get_compilation_scope(comp);
    compilation_scope->last_opcode = op;
    return ip;
}

static compilation_scope_t* get_compilation_scope(compiler_t *comp) {
    return comp->compilation_scope;
}

static bool push_compilation_scope(compiler_t *comp) {
    compilation_scope_t *current_scope = get_compilation_scope(comp);
    compilation_scope_t *new_scope = compilation_scope_make(comp->alloc, current_scope);
    if (!new_scope) {
        return false;
    }
    set_compilation_scope(comp, new_scope);
    return true;
}

static void pop_compilation_scope(compiler_t *comp) {
    compilation_scope_t *current_scope = get_compilation_scope(comp);
    APE_ASSERT(current_scope);
    set_compilation_scope(comp, current_scope->outer);
    compilation_scope_destroy(current_scope);
}

static bool push_symbol_table(compiler_t *comp, int global_offset) {
    file_scope_t *file_scope = ptrarray_top(comp->file_scopes);
    if (!file_scope) {
        APE_ASSERT(false);
        return false;
    }
    symbol_table_t *current_table = file_scope->symbol_table;
    file_scope->symbol_table = symbol_table_make(comp->alloc, current_table, comp->global_store, global_offset);
    if (!file_scope->symbol_table) {
        file_scope->symbol_table = current_table;
        return false;
    }
    return true;
}

static void pop_symbol_table(compiler_t *comp) {
    file_scope_t *file_scope = ptrarray_top(comp->file_scopes);
    if (!file_scope) {
        APE_ASSERT(false);
        return;
    }
    symbol_table_t *current_table = file_scope->symbol_table;
    if (!current_table) {
        APE_ASSERT(false);
        return;
    }
    file_scope->symbol_table = current_table->outer;
    symbol_table_destroy(current_table);
}

static opcode_t get_last_opcode(compiler_t *comp) {
    compilation_scope_t *current_scope = get_compilation_scope(comp);
    return current_scope->last_opcode;
}

static bool compile_code(compiler_t *comp, const char *code, size_t len) {
    file_scope_t *file_scope = ptrarray_top(comp->file_scopes);
    APE_ASSERT(file_scope);

    ptrarray(statement_t) *statements = parser_parse_all(file_scope->parser, code, len, file_scope->file);
    if (!statements) {
        // errors are added by parser
        return false;
    }

    bool ok = compile_statements(comp, statements);

    ptrarray_destroy_with_items(statements, statement_destroy);

    // Left for debugging purposes
//    if (ok) {
//        strbuf_t *buf = strbuf_make(NULL);
//        code_to_string(array_data(comp->compilation_scope->bytecode),
//                       array_data(comp->compilation_scope->src_positions),
//                       array_count(comp->compilation_scope->bytecode), buf);
//        puts(strbuf_get_string(buf));
//        strbuf_destroy(buf);
//    }

    return ok;
}

static bool compile_statements(compiler_t *comp, ptrarray(statement_t) *statements) {
    bool ok = true;
    for (int i = 0; i < ptrarray_count(statements); i++) {
        const statement_t *stmt = ptrarray_get(statements, i);
        ok = compile_statement(comp, stmt);
        if (!ok) {
            break;
        }
    }
    return ok;
}

static bool import_module(compiler_t *comp, const statement_t *import_stmt) { // todo: split into smaller functions
    bool result = false;
    char *filepath = NULL;
    char *code = NULL;

    file_scope_t *file_scope = ptrarray_top(comp->file_scopes);

    const char *module_path = import_stmt->import.path;
    const char *module_name = get_module_name(module_path);

    for (int i = 0; i < ptrarray_count(file_scope->loaded_module_names); i++) {
        const char *loaded_name = ptrarray_get(file_scope->loaded_module_names, i);
        if (kg_streq(loaded_name, module_name)) {
            errors_add_errorf(comp->errors, ERROR_COMPILATION, import_stmt->pos, "Module \"%s\" was already imported", module_name);
            result = false;
            goto end;
        }
    }

    strbuf_t *filepath_buf = strbuf_make(comp->alloc);
    if (!filepath_buf) {
        result = false;
        goto end;
    }
    if (kg_is_path_absolute(module_path)) {
        strbuf_appendf(filepath_buf, "%s.ape", module_path);
    } else {
        strbuf_appendf(filepath_buf, "%s%s.ape", file_scope->file->dir_path, module_path);
    }

    if (strbuf_failed(filepath_buf)) {
        strbuf_destroy(filepath_buf);
        result = false;
        goto end;
    }

    const char *filepath_non_canonicalised = strbuf_get_string(filepath_buf);
    filepath = kg_canonicalise_path(comp->alloc, filepath_non_canonicalised);
    strbuf_destroy(filepath_buf);
    if (!filepath) {
        result = false;
        goto end;
    }

    symbol_table_t *symbol_table = compiler_get_symbol_table(comp);
    if (symbol_table->outer != NULL || ptrarray_count(symbol_table->block_scopes) > 1) {
        errors_add_error(comp->errors, ERROR_COMPILATION, import_stmt->pos, "Modules can only be imported in global scope");
        result = false;
        goto end;
    }

    for (int i = 0; i < ptrarray_count(comp->file_scopes); i++) {
        file_scope_t *fs = ptrarray_get(comp->file_scopes, i);
        if (APE_STREQ(fs->file->path, filepath)) {
            errors_add_errorf(comp->errors, ERROR_COMPILATION, import_stmt->pos, "Cyclic reference of file \"%s\"", filepath);
            result = false;
            goto end;
        }
    }

    module_t *module = dict_get(comp->modules, filepath);
    if (!module) { // todo: create new module function
        if (!comp->config->fileio.read_file.read_file) {
            errors_add_errorf(comp->errors, ERROR_COMPILATION, import_stmt->pos, "Cannot import module \"%s\", file read function not configured", filepath);
            result = false;
            goto end;
        }

        code = comp->config->fileio.read_file.read_file(comp->config->fileio.read_file.context, filepath);
        if (!code) {
            errors_add_errorf(comp->errors, ERROR_COMPILATION, import_stmt->pos, "Reading module file \"%s\" failed", filepath);
            result = false;
            goto end;
        }

        module = module_make(comp->alloc, module_name);
        if (!module) {
            result = false;
            goto end;
        }

        bool ok = push_file_scope(comp, filepath);
        if (!ok) {
            module_destroy(module);
            result = false;
            goto end;
        }

        ok = compile_code(comp, code, strlen(code));
        if (!ok) {
            module_destroy(module);
            result = false;
            goto end;
        }

        symbol_table_t *st = compiler_get_symbol_table(comp);
        for (int i = 0; i < symbol_table_get_module_global_symbol_count(st); i++) {
            const symbol_t *symbol = symbol_table_get_module_global_symbol_at(st, i);
            module_add_symbol(module, symbol);
        }

        pop_file_scope(comp);

        ok = dict_set(comp->modules, filepath, module);
        if (!ok) {
            module_destroy(module);
            result = false;
            goto end;
        }
    }

    for (int i = 0; i < ptrarray_count(module->symbols); i++) {
        symbol_t *symbol = ptrarray_get(module->symbols, i);
        bool ok = symbol_table_add_module_symbol(symbol_table, symbol);
        if (!ok) {
            result = false;
            goto end;
        }
    }

    char *name_copy = ape_strdup(comp->alloc, module_name);
    if (!name_copy) {
        result = false;
        goto end;
    }

    bool ok = ptrarray_add(file_scope->loaded_module_names, name_copy);
    if (!ok) {
        allocator_free(comp->alloc, name_copy);
        result = false;
        goto end;
    }

    result = true;

end:
    allocator_free(comp->alloc, filepath);
    allocator_free(comp->alloc, code);
    return result;
}

static bool compile_statement(compiler_t *comp, const statement_t *stmt) {
    bool ok = false;
    int ip = -1;

    ok = array_push(comp->src_positions_stack, &stmt->pos);
    if (!ok) {
        return false;
    }

    compilation_scope_t *compilation_scope = get_compilation_scope(comp);
    symbol_table_t *symbol_table = compiler_get_symbol_table(comp);
    switch (stmt->type) {
        case STATEMENT_EXPRESSION: {
            ok = compile_expression(comp, stmt->expression);
            if (!ok) {
                return false;
            }
            ip = emit(comp, OPCODE_POP, 0, NULL);
            if (ip < 0) {
                return false;
            }
            break;
        }
        case STATEMENT_DEFINE: {
            ok = compile_expression(comp, stmt->define.value);
            if (!ok) {
                return false;
            }

            const symbol_t *symbol = define_symbol(comp, stmt->define.name->pos, stmt->define.name->value, stmt->define.assignable, false);
            if (!symbol) {
                return false;
            }

            ok = write_symbol(comp, symbol, true);
            if (!ok) {
                return false;
            }

            break;
        }
        case STATEMENT_IF: {
            const if_statement_t *if_stmt = &stmt->if_statement;

            array(int) *jump_to_end_ips = array_make(comp->alloc, int);
            if (!jump_to_end_ips) {
                goto statement_if_error;
            }

            for (int i = 0; i < ptrarray_count(if_stmt->cases); i++) {
                if_case_t *if_case = ptrarray_get(if_stmt->cases, i);

                ok = compile_expression(comp, if_case->test);
                if (!ok) {
                    goto statement_if_error;
                }

                int next_case_jump_ip = emit(comp, OPCODE_JUMP_IF_FALSE, 1, (uint64_t[]){0xbeef});

                ok = compile_code_block(comp, if_case->consequence);
                if (!ok) {
                    goto statement_if_error;
                }

                // don't emit jump for the last statement
                if (i < (ptrarray_count(if_stmt->cases) - 1) || if_stmt->alternative) {
                    int jump_to_end_ip = emit(comp, OPCODE_JUMP, 1, (uint64_t[]){0xbeef});
                    bool ok = array_add(jump_to_end_ips, &jump_to_end_ip);
                    if (!ok) {
                        goto statement_if_error;
                    }
                }

                int after_elif_ip = get_ip(comp);
                change_uint16_operand(comp, next_case_jump_ip + 1, after_elif_ip);
            }

            if (if_stmt->alternative) {
                ok = compile_code_block(comp, if_stmt->alternative);
                if (!ok) {
                    goto statement_if_error;
                }
            }

            int after_alt_ip = get_ip(comp);

            for (int i = 0; i < array_count(jump_to_end_ips); i++) {
                int *pos = array_get(jump_to_end_ips, i);
                change_uint16_operand(comp, *pos + 1, after_alt_ip);
            }

            array_destroy(jump_to_end_ips);

            break;
        statement_if_error:
            array_destroy(jump_to_end_ips);
            return false;
        }
        case STATEMENT_RETURN_VALUE: {
            if (compilation_scope->outer == NULL) {
                errors_add_errorf(comp->errors, ERROR_COMPILATION, stmt->pos, "Nothing to return from");
                return false;
            }
            ip = -1;
            if (stmt->return_value) {
                ok = compile_expression(comp, stmt->return_value);
                if (!ok) {
                    return false;
                }
                ip = emit(comp, OPCODE_RETURN_VALUE, 0, NULL);
            } else {
                ip = emit(comp, OPCODE_RETURN, 0, NULL);
            }
            if (ip < 0) {
                return false;
            }
            break;
        }
        case STATEMENT_WHILE_LOOP: {
            const while_loop_statement_t *loop = &stmt->while_loop;

            int before_test_ip = get_ip(comp);

            ok = compile_expression(comp, loop->test);
            if (!ok) {
                return false;
            }

            int after_test_ip = get_ip(comp);
            ip = emit(comp, OPCODE_JUMP_IF_TRUE, 1, (uint64_t[]){after_test_ip + 6});
            if (ip < 0) {
                return false;
            }

            int jump_to_after_body_ip = emit(comp, OPCODE_JUMP, 1, (uint64_t[]){0xdead});
            if (jump_to_after_body_ip < 0) {
                return false;
            }

            ok = push_continue_ip(comp, before_test_ip);
            if (!ok) {
                return false;
            }

            ok = push_break_ip(comp, jump_to_after_body_ip);
            if (!ok) {
                return false;
            }

            ok = compile_code_block(comp, loop->body);
            if (!ok) {
                return false;
            }

            pop_break_ip(comp);
            pop_continue_ip(comp);

            ip = emit(comp, OPCODE_JUMP, 1, (uint64_t[]){before_test_ip});
            if (ip < 0) {
                return false;
            }

            int after_body_ip = get_ip(comp);
            change_uint16_operand(comp, jump_to_after_body_ip + 1, after_body_ip);

            break;
        }
        case STATEMENT_BREAK: {
            int break_ip = get_break_ip(comp);
            if (break_ip < 0) {
                errors_add_errorf(comp->errors, ERROR_COMPILATION, stmt->pos, "Nothing to break from.");
                return false;
            }
            ip = emit(comp, OPCODE_JUMP, 1, (uint64_t[]){break_ip});
            if (ip < 0) {
                return false;
            }
            break;
        }
        case STATEMENT_CONTINUE: {
            int continue_ip = get_continue_ip(comp);
            if (continue_ip < 0) {
                errors_add_errorf(comp->errors, ERROR_COMPILATION, stmt->pos, "Nothing to continue from.");
                return false;
            }
            ip = emit(comp, OPCODE_JUMP, 1, (uint64_t[]){continue_ip});
            if (ip < 0) {
                return false;
            }
            break;
        }
        case STATEMENT_FOREACH: {
            const foreach_statement_t *foreach = &stmt->foreach;
            ok = symbol_table_push_block_scope(symbol_table);
            if (!ok) {
                return false;
            }

            // Init
            const symbol_t *index_symbol = define_symbol(comp, stmt->pos, "@i", false, true);
            if (!index_symbol) {
                return false;
            }

            ip = emit(comp, OPCODE_NUMBER, 1, (uint64_t[]){0});
            if (ip < 0) {
                return false;
            }

            ok = write_symbol(comp, index_symbol, true);
            if (!ok) {
                return false;
            }

            const symbol_t *source_symbol = NULL;
            if (foreach->source->type == EXPRESSION_IDENT) {
                source_symbol = symbol_table_resolve(symbol_table, foreach->source->ident->value);
                if (!source_symbol) {
                    errors_add_errorf(comp->errors, ERROR_COMPILATION, foreach->source->pos,
                                      "Symbol \"%s\" could not be resolved", foreach->source->ident->value);
                    return false;
                }
            } else {
                ok = compile_expression(comp, foreach->source);
                if (!ok) {
                    return false;
                }
                source_symbol = define_symbol(comp, foreach->source->pos, "@source", false, true);
                if (!source_symbol) {
                    return false;
                }
                ok = write_symbol(comp, source_symbol, true);
                if (!ok) {
                    return false;
                }
            }

            // Update
            int jump_to_after_update_ip = emit(comp, OPCODE_JUMP, 1, (uint64_t[]){0xbeef});
            if (jump_to_after_update_ip < 0) {
                return false;
            }

            int update_ip = get_ip(comp);
            ok = read_symbol(comp, index_symbol);
            if (!ok) {
                return false;
            }

            ip = emit(comp, OPCODE_NUMBER, 1, (uint64_t[]){ape_double_to_uint64(1)});
            if (ip < 0) {
                return false;
            }

            ip = emit(comp, OPCODE_ADD, 0, NULL);
            if (ip < 0) {
                return false;
            }

            ok = write_symbol(comp, index_symbol, false);
            if (!ok) {
                return false;
            }

            int after_update_ip = get_ip(comp);
            change_uint16_operand(comp, jump_to_after_update_ip + 1, after_update_ip);

            // Test
            ok = array_push(comp->src_positions_stack, &foreach->source->pos);
            if (!ok) {
                return false;
            }

            ok = read_symbol(comp, source_symbol);
            if (!ok) {
                return false;
            }

            ip = emit(comp, OPCODE_LEN, 0, NULL);
            if (ip < 0) {
                return false;
            }

            array_pop(comp->src_positions_stack, NULL);
            ok = read_symbol(comp, index_symbol);
            if (!ok) {
                return false;
            }

            ip = emit(comp, OPCODE_COMPARE, 0, NULL);
            if (ip < 0) {
                return false;
            }

            ip = emit(comp, OPCODE_EQUAL, 0, NULL);
            if (ip < 0) {
                return false;
            }

            int after_test_ip = get_ip(comp);
            ip = emit(comp, OPCODE_JUMP_IF_FALSE, 1, (uint64_t[]){after_test_ip + 6});
            if (ip < 0) {
                return false;
            }

            int jump_to_after_body_ip = emit(comp, OPCODE_JUMP, 1, (uint64_t[]){0xdead});
            if (jump_to_after_body_ip < 0) {
                return false;
            }

            ok = read_symbol(comp, source_symbol);
            if (!ok) {
                return false;
            }

            ok = read_symbol(comp, index_symbol);
            if (!ok) {
                return false;
            }

            ip = emit(comp, OPCODE_GET_VALUE_AT, 0, NULL);
            if (ip < 0) {
                return false;
            }

            const symbol_t *iter_symbol  = define_symbol(comp, foreach->iterator->pos, foreach->iterator->value, false, false);
            if (!iter_symbol) {
                return false;
            }

            ok = write_symbol(comp, iter_symbol, true);
            if (!ok) {
                return false;
            }

            // Body
            ok = push_continue_ip(comp, update_ip);
            if (!ok) {
                return false;
            }

            ok = push_break_ip(comp, jump_to_after_body_ip);
            if (!ok) {
                return false;
            }

            ok = compile_code_block(comp, foreach->body);
            if (!ok) {
                return false;
            }

            pop_break_ip(comp);
            pop_continue_ip(comp);

            ip = emit(comp, OPCODE_JUMP, 1, (uint64_t[]){update_ip});
            if (ip < 0) {
                return false;
            }

            int after_body_ip = get_ip(comp);
            change_uint16_operand(comp, jump_to_after_body_ip + 1, after_body_ip);

            symbol_table_pop_block_scope(symbol_table);
            break;
        }
        case STATEMENT_FOR_LOOP: {
            const for_loop_statement_t *loop = &stmt->for_loop;

            ok = symbol_table_push_block_scope(symbol_table);
            if (!ok) {
                return false;
            }

            // Init
            int jump_to_after_update_ip = 0;
            bool ok = false;
            if (loop->init) {
                ok = compile_statement(comp, loop->init);
                if (!ok) {
                    return false;
                }
                jump_to_after_update_ip = emit(comp, OPCODE_JUMP, 1, (uint64_t[]){0xbeef});
                if (jump_to_after_update_ip < 0) {
                    return false;
                }
            }

            // Update
            int update_ip = get_ip(comp);
            if (loop->update) {
                ok = compile_expression(comp, loop->update);
                if (!ok) {
                    return false;
                }
                ip = emit(comp, OPCODE_POP, 0, NULL);
                if (ip < 0) {
                    return false;
                }
            }

            if (loop->init) {
                int after_update_ip = get_ip(comp);
                change_uint16_operand(comp, jump_to_after_update_ip + 1, after_update_ip);
            }

            // Test
            if (loop->test) {
                ok = compile_expression(comp, loop->test);
                if (!ok) {
                    return false;
                }
            } else {
                ip = emit(comp, OPCODE_TRUE, 0, NULL);
                if (ip < 0) {
                    return false;
                }
            }
            int after_test_ip = get_ip(comp);

            ip = emit(comp, OPCODE_JUMP_IF_TRUE, 1, (uint64_t[]){after_test_ip + 6});
            if (ip < 0) {
                return false;
            }
            int jmp_to_after_body_ip = emit(comp, OPCODE_JUMP, 1, (uint64_t[]){0xdead});
            if (jmp_to_after_body_ip < 0) {
                return false;
            }

            // Body
            ok = push_continue_ip(comp, update_ip);
            if (!ok) {
                return false;
            }

            ok = push_break_ip(comp, jmp_to_after_body_ip);
            if (!ok) {
                return false;
            }

            ok = compile_code_block(comp, loop->body);
            if (!ok) {
                return false;
            }

            pop_break_ip(comp);
            pop_continue_ip(comp);

            ip = emit(comp, OPCODE_JUMP, 1, (uint64_t[]){update_ip});
            if (ip < 0) {
                return false;
            }

            int after_body_ip = get_ip(comp);
            change_uint16_operand(comp, jmp_to_after_body_ip + 1, after_body_ip);

            symbol_table_pop_block_scope(symbol_table);
            break;
        }
        case STATEMENT_BLOCK: {
            ok = compile_code_block(comp, stmt->block);
            if (!ok) {
                return false;
            }
            break;
        }
        case STATEMENT_IMPORT: {
            ok = import_module(comp, stmt);
            if (!ok) {
                return false;
            }
            break;
        }
        case STATEMENT_RECOVER: {
            const recover_statement_t *recover = &stmt->recover;

            if (symbol_table_is_module_global_scope(symbol_table)) {
                errors_add_error(comp->errors, ERROR_COMPILATION, stmt->pos,
                                 "Recover statement cannot be defined in global scope");
                return false;
            }

            if (!symbol_table_is_top_block_scope(symbol_table)) {
                errors_add_error(comp->errors, ERROR_COMPILATION, stmt->pos,
                                 "Recover statement cannot be defined within other statements");
                return false;
            }

            int recover_ip = emit(comp, OPCODE_SET_RECOVER, 1, (uint64_t[]){0xbeef});
            if (recover_ip < 0) {
                return false;
            }

            int jump_to_after_recover_ip = emit(comp, OPCODE_JUMP, 1, (uint64_t[]){0xbeef});
            if (jump_to_after_recover_ip < 0) {
                return false;
            }

            int after_jump_to_recover_ip = get_ip(comp);
            change_uint16_operand(comp, recover_ip + 1, after_jump_to_recover_ip);

            ok = symbol_table_push_block_scope(symbol_table);
            if (!ok) {
                return false;
            }

            const symbol_t *error_symbol = define_symbol(comp, recover->error_ident->pos, recover->error_ident->value, false, false);
            if (!error_symbol) {
                return false;
            }

            ok = write_symbol(comp, error_symbol, true);
            if (!ok) {
                return false;
            }

            ok = compile_code_block(comp, recover->body);
            if (!ok) {
                return false;
            }

            if (!last_opcode_is(comp, OPCODE_RETURN) && !last_opcode_is(comp, OPCODE_RETURN_VALUE)) {
                errors_add_error(comp->errors, ERROR_COMPILATION, stmt->pos,
                                 "Recover body must end with a return statement");
                return false;
            }

            symbol_table_pop_block_scope(symbol_table);

            int after_recover_ip = get_ip(comp);
            change_uint16_operand(comp, jump_to_after_recover_ip + 1, after_recover_ip);

            break;
        }
        default: {
            APE_ASSERT(false);
            return false;
        }
    }
    array_pop(comp->src_positions_stack, NULL);
    return true;
}

static bool compile_expression(compiler_t *comp, expression_t *expr) {
    bool ok = false;
    int ip = -1;

    expression_t *expr_optimised = optimise_expression(expr);
    if (expr_optimised) {
        expr = expr_optimised;
    }

    ok = array_push(comp->src_positions_stack, &expr->pos);
    if (!ok) {
        return false;
    }

    compilation_scope_t *compilation_scope = get_compilation_scope(comp);
    symbol_table_t *symbol_table = compiler_get_symbol_table(comp);

    bool res = false;

    switch (expr->type) {
        case EXPRESSION_INFIX: {
            bool rearrange = false;

            opcode_t op = OPCODE_NONE;
            switch (expr->infix.op) {
                case OPERATOR_PLUS:     op = OPCODE_ADD; break;
                case OPERATOR_MINUS:    op = OPCODE_SUB; break;
                case OPERATOR_ASTERISK: op = OPCODE_MUL; break;
                case OPERATOR_SLASH:    op = OPCODE_DIV; break;
                case OPERATOR_MODULUS:  op = OPCODE_MOD; break;
                case OPERATOR_EQ:       op = OPCODE_EQUAL; break;
                case OPERATOR_NOT_EQ:   op = OPCODE_NOT_EQUAL; break;
                case OPERATOR_GT:       op = OPCODE_GREATER_THAN; break;
                case OPERATOR_GTE:      op = OPCODE_GREATER_THAN_EQUAL; break;
                case OPERATOR_LT:       op = OPCODE_GREATER_THAN; rearrange = true; break;
                case OPERATOR_LTE:      op = OPCODE_GREATER_THAN_EQUAL; rearrange = true; break;
                case OPERATOR_BIT_OR:   op = OPCODE_OR; break;
                case OPERATOR_BIT_XOR:  op = OPCODE_XOR; break;
                case OPERATOR_BIT_AND:  op = OPCODE_AND; break;
                case OPERATOR_LSHIFT:   op = OPCODE_LSHIFT; break;
                case OPERATOR_RSHIFT:   op = OPCODE_RSHIFT; break;
                default: {
                    errors_add_errorf(comp->errors, ERROR_COMPILATION, expr->pos, "Unknown infix operator");
                    goto error;
                }
            }

            expression_t *left = rearrange ? expr->infix.right : expr->infix.left;
            expression_t *right = rearrange ? expr->infix.left : expr->infix.right;

            ok = compile_expression(comp, left);
            if (!ok) {
                goto error;
            }

            ok = compile_expression(comp, right);
            if (!ok) {
                goto error;
            }

            switch (expr->infix.op) {
                case OPERATOR_EQ:
                case OPERATOR_NOT_EQ:
                {
                    ip = emit(comp, OPCODE_COMPARE_EQ, 0, NULL);
                    if (ip < 0) {
                        goto error;
                    }
                    break;
                }
                case OPERATOR_GT:
                case OPERATOR_GTE:
                case OPERATOR_LT:
                case OPERATOR_LTE:
                {
                    ip = emit(comp, OPCODE_COMPARE, 0, NULL);
                    if (ip < 0) {
                        goto error;
                    }
                    break;
                }
                default: break;
            }

            ip = emit(comp, op, 0, NULL);
            if (ip < 0) {
                goto error;
            }

            break;
        }
        case EXPRESSION_NUMBER_LITERAL: {
            double number = expr->number_literal;
            ip = emit(comp, OPCODE_NUMBER, 1, (uint64_t[]){ape_double_to_uint64(number)});
            if (ip < 0) {
                goto error;
            }

            break;
        }
        case EXPRESSION_STRING_LITERAL: {
            int pos = 0;
            int *current_pos = dict_get(comp->string_constants_positions, expr->string_literal);
            if (current_pos) {
                pos = *current_pos;
            } else {
                object_t obj = object_make_string(comp->mem, expr->string_literal);
                if (object_is_null(obj)) {
                    goto error;
                }

                pos = add_constant(comp, obj);
                if (pos < 0) {
                    goto error;
                }

                int *pos_val = allocator_malloc(comp->alloc, sizeof(int));
                if (!pos_val) {
                    goto error;
                }

                *pos_val = pos;
                ok = dict_set(comp->string_constants_positions, expr->string_literal, pos_val);
                if (!ok) {
                    allocator_free(comp->alloc, pos_val);
                    goto error;
                }
            }

            ip = emit(comp, OPCODE_CONSTANT, 1, (uint64_t[]){pos});
            if (ip < 0) {
                goto error;
            }

            break;
        }
        case EXPRESSION_NULL_LITERAL: {
            ip = emit(comp, OPCODE_NULL, 0, NULL);
            if (ip < 0) {
                goto error;
            }
            break;
        }
        case EXPRESSION_BOOL_LITERAL: {
            ip = emit(comp, expr->bool_literal ? OPCODE_TRUE : OPCODE_FALSE, 0, NULL);
            if (ip < 0) {
                goto error;
            }
            break;
        }
        case EXPRESSION_ARRAY_LITERAL: {
            for (int i = 0; i < ptrarray_count(expr->array); i++) {
                ok = compile_expression(comp, ptrarray_get(expr->array, i));
                if (!ok) {
                    goto error;
                }
            }
            ip = emit(comp, OPCODE_ARRAY, 1, (uint64_t[]){ptrarray_count(expr->array)});
            if (ip < 0) {
                goto error;
            }
            break;
        }
        case EXPRESSION_MAP_LITERAL: {
            const map_literal_t *map = &expr->map;
            int len = ptrarray_count(map->keys);
            ip = emit(comp, OPCODE_MAP_START, 1, (uint64_t[]){len});
            if (ip < 0) {
                goto error;
            }

            for (int i = 0; i < len; i++) {
                expression_t *key = ptrarray_get(map->keys, i);
                expression_t *val = ptrarray_get(map->values, i);

                ok = compile_expression(comp, key);
                if (!ok) {
                    goto error;
                }

                ok = compile_expression(comp, val);
                if (!ok) {
                    goto error;
                }
            }

            ip = emit(comp, OPCODE_MAP_END, 1, (uint64_t[]){len});
            if (ip < 0) {
                goto error;
            }

            break;
        }
        case EXPRESSION_PREFIX: {
            ok = compile_expression(comp, expr->prefix.right);
            if (!ok) {
                goto error;
            }

            opcode_t op = OPCODE_NONE;
            switch (expr->prefix.op) {
                case OPERATOR_MINUS: op = OPCODE_MINUS; break;
                case OPERATOR_BANG: op = OPCODE_BANG; break;
                default: {
                    errors_add_errorf(comp->errors, ERROR_COMPILATION, expr->pos, "Unknown prefix operator.");
                    goto error;
                }
            }
            ip = emit(comp, op, 0, NULL);
            if (ip < 0) {
                goto error;
            }

            break;
        }
        case EXPRESSION_IDENT: {
            const ident_t *ident = expr->ident;
            const symbol_t *symbol = symbol_table_resolve(symbol_table, ident->value);
            if (!symbol) {
                errors_add_errorf(comp->errors, ERROR_COMPILATION, ident->pos,
                                  "Symbol \"%s\" could not be resolved", ident->value);
                goto error;
            }
            ok = read_symbol(comp, symbol);
            if (!ok) {
                goto error;
            }

            break;
        }
        case EXPRESSION_INDEX: {
            const index_expression_t *index = &expr->index_expr;
            ok = compile_expression(comp, index->left);
            if (!ok) {
                goto error;
            }
            ok = compile_expression(comp, index->index);
            if (!ok) {
                goto error;
            }
            ip = emit(comp, OPCODE_GET_INDEX, 0, NULL);
            if (ip < 0) {
                goto error;
            }

            break;
        }
        case EXPRESSION_FUNCTION_LITERAL: {
            const fn_literal_t *fn = &expr->fn_literal;

            ok = push_compilation_scope(comp);
            if (!ok) {
                goto error;
            }

            ok = push_symbol_table(comp, 0);
            if (!ok) {
                goto error;
            }

            compilation_scope = get_compilation_scope(comp);
            symbol_table = compiler_get_symbol_table(comp);

            if (fn->name) {
                const symbol_t *fn_symbol = symbol_table_define_function_name(symbol_table, fn->name, false);
                if (!fn_symbol) {
                    errors_add_errorf(comp->errors, ERROR_COMPILATION, expr->pos,
                                               "Cannot define symbol \"%s\"", fn->name);
                    goto error;
                }
            }

            const symbol_t *this_symbol = symbol_table_define_this(symbol_table);
            if (!this_symbol) {
                errors_add_error(comp->errors, ERROR_COMPILATION, expr->pos, "Cannot define \"this\" symbol");
                goto error;
            }

            for (int i = 0; i < ptrarray_count(expr->fn_literal.params); i++) {
                ident_t *param = ptrarray_get(expr->fn_literal.params, i);
                const symbol_t *param_symbol = define_symbol(comp, param->pos, param->value, true, false);
                if (!param_symbol) {
                    goto error;
                }
            }

            ok = compile_statements(comp, fn->body->statements);
            if (!ok) {
                goto error;
            }

            if (!last_opcode_is(comp, OPCODE_RETURN_VALUE) && !last_opcode_is(comp, OPCODE_RETURN)) {
                ip = emit(comp, OPCODE_RETURN, 0, NULL);
                if (ip < 0) {
                    goto error;
                }
            }

            ptrarray(symbol_t) *free_symbols = symbol_table->free_symbols;
            symbol_table->free_symbols = NULL; // because it gets destroyed with compiler_pop_compilation_scope()

            int num_locals = symbol_table->max_num_definitions;

            compilation_result_t *comp_res = compilation_scope_orphan_result(compilation_scope);
            if (!comp_res) {
                ptrarray_destroy_with_items(free_symbols, symbol_destroy_wrapper);
                goto error;
            }
            pop_symbol_table(comp);
            pop_compilation_scope(comp);
            compilation_scope = get_compilation_scope(comp);
            symbol_table = compiler_get_symbol_table(comp);

            object_t obj = object_make_function(comp->mem, fn->name, comp_res, true,
                                                num_locals, ptrarray_count(fn->params), 0);

            if (object_is_null(obj)) {
                ptrarray_destroy_with_items(free_symbols, symbol_destroy_wrapper);
                compilation_result_destroy(comp_res);
                goto error;
            }

            for (int i = 0; i < ptrarray_count(free_symbols); i++) {
                symbol_t *symbol = ptrarray_get(free_symbols, i);
                ok = read_symbol(comp, symbol);
                if (!ok) {
                    ptrarray_destroy_with_items(free_symbols, symbol_destroy_wrapper);
                    goto error;
                }
            }

            int pos = add_constant(comp, obj);
            if (pos < 0) {
                ptrarray_destroy_with_items(free_symbols, symbol_destroy_wrapper);
                goto error;
            }

            ip = emit(comp, OPCODE_FUNCTION, 2, (uint64_t[]){pos, ptrarray_count(free_symbols)});
            if (ip < 0) {
                ptrarray_destroy_with_items(free_symbols, symbol_destroy_wrapper);
                goto error;
            }

            ptrarray_destroy_with_items(free_symbols, symbol_destroy_wrapper);

            break;
        }
        case EXPRESSION_CALL: {
            ok = compile_expression(comp, expr->call_expr.function);
            if (!ok) {
                goto error;
            }

            for (int i = 0; i < ptrarray_count(expr->call_expr.args); i++) {
                expression_t *arg_expr = ptrarray_get(expr->call_expr.args, i);
                ok = compile_expression(comp, arg_expr);
                if (!ok) {
                    goto error;
                }
            }

            ip = emit(comp, OPCODE_CALL, 1, (uint64_t[]){ptrarray_count(expr->call_expr.args)});
            if (ip < 0) {
                goto error;
            }

            break;
        }
        case EXPRESSION_ASSIGN: {
            const assign_expression_t *assign = &expr->assign;
            if (assign->dest->type != EXPRESSION_IDENT && assign->dest->type != EXPRESSION_INDEX) {
                errors_add_errorf(comp->errors, ERROR_COMPILATION, assign->dest->pos,
                                          "Expression is not assignable.");
                goto error;
            }

            if (assign->is_postfix) {
                ok = compile_expression(comp, assign->dest);
                if (!ok) {
                    goto error;
                }
            }

            ok = compile_expression(comp, assign->source);
            if (!ok) {
                goto error;
            }

            ip = emit(comp, OPCODE_DUP, 0, NULL);
            if (ip < 0) {
                goto error;
            }

            ok = array_push(comp->src_positions_stack, &assign->dest->pos);
            if (!ok) {
                goto error;
            }

            if (assign->dest->type == EXPRESSION_IDENT) {
                const ident_t *ident = assign->dest->ident;
                const symbol_t *symbol = symbol_table_resolve(symbol_table, ident->value);
                if (!symbol) {
                    errors_add_errorf(comp->errors, ERROR_COMPILATION, assign->dest->pos,
                                              "Symbol \"%s\" could not be resolved", ident->value);
                    goto error;
                }
                if (!symbol->assignable) {
                    errors_add_errorf(comp->errors, ERROR_COMPILATION, assign->dest->pos,
                                              "Symbol \"%s\" is not assignable", ident->value);
                    goto error;
                }
                ok = write_symbol(comp, symbol, false);
                if (!ok) {
                    goto error;
                }
            } else if (assign->dest->type == EXPRESSION_INDEX) {
                const index_expression_t *index = &assign->dest->index_expr;
                ok = compile_expression(comp, index->left);
                if (!ok) {
                    goto error;
                }
                ok = compile_expression(comp, index->index);
                if (!ok) {
                    goto error;
                }
                ip = emit(comp, OPCODE_SET_INDEX, 0, NULL);
                if (ip < 0) {
                    goto error;
                }
            }

            if (assign->is_postfix) {
                ip = emit(comp, OPCODE_POP, 0, NULL);
                if (ip < 0) {
                    goto error;
                }
            }

            array_pop(comp->src_positions_stack, NULL);
            break;
        }
        case EXPRESSION_LOGICAL: {
            const logical_expression_t* logi = &expr->logical;

            ok = compile_expression(comp, logi->left);
            if (!ok) {
                goto error;
            }

            ip = emit(comp, OPCODE_DUP, 0, NULL);
            if (ip < 0) {
                goto error;
            }

            int after_left_jump_ip = 0;
            if (logi->op == OPERATOR_LOGICAL_AND) {
                after_left_jump_ip = emit(comp, OPCODE_JUMP_IF_FALSE, 1, (uint64_t[]){0xbeef});
            } else {
                after_left_jump_ip = emit(comp, OPCODE_JUMP_IF_TRUE, 1, (uint64_t[]){0xbeef});
            }

            if (after_left_jump_ip < 0) {
                goto error;
            }

            ip = emit(comp, OPCODE_POP, 0, NULL);
            if (ip < 0) {
                goto error;
            }

            ok = compile_expression(comp, logi->right);
            if (!ok) {
                goto error;
            }

            int after_right_ip = get_ip(comp);
            change_uint16_operand(comp, after_left_jump_ip + 1, after_right_ip);

            break;
        }
        case EXPRESSION_TERNARY: {
            const ternary_expression_t* ternary = &expr->ternary;

            ok = compile_expression(comp, ternary->test);
            if (!ok) {
                goto error;
            }

            int else_jump_ip = emit(comp, OPCODE_JUMP_IF_FALSE, 1, (uint64_t[]){0xbeef});

            ok = compile_expression(comp, ternary->if_true);
            if (!ok) {
                goto error;
            }

            int end_jump_ip = emit(comp, OPCODE_JUMP, 1, (uint64_t[]){0xbeef});

            int else_ip = get_ip(comp);
            change_uint16_operand(comp, else_jump_ip + 1, else_ip);

            ok = compile_expression(comp, ternary->if_false);
            if (!ok) {
                goto error;
            }

            int end_ip = get_ip(comp);
            change_uint16_operand(comp, end_jump_ip + 1, end_ip);

            break;
        }
        default: {
            APE_ASSERT(false);
            break;
        }
    }
    res = true;
    goto end;
error:
    res = false;
end:
    array_pop(comp->src_positions_stack, NULL);
    expression_destroy(expr_optimised);
    return res;
}

static bool compile_code_block(compiler_t *comp, const code_block_t *block) {
    symbol_table_t *symbol_table = compiler_get_symbol_table(comp);
    if (!symbol_table) {
        return false;
    }

    bool ok = symbol_table_push_block_scope(symbol_table);
    if (!ok) {
        return false;
    }

    if (ptrarray_count(block->statements) == 0) {
        int ip = emit(comp, OPCODE_NULL, 0, NULL);
        if (ip < 0) {
            return false;
        }
        ip = emit(comp, OPCODE_POP, 0, NULL);
        if (ip < 0) {
            return false;
        }
    }

    for (int i = 0; i < ptrarray_count(block->statements); i++) {
        const statement_t *stmt = ptrarray_get(block->statements, i);
        bool ok = compile_statement(comp, stmt);
        if (!ok) {
            return false;
        }
    }
    symbol_table_pop_block_scope(symbol_table);
    return true;
}

static int add_constant(compiler_t *comp, object_t obj) {
    bool ok = array_add(comp->constants, &obj);
    if (!ok) {
        return -1;
    }
    int pos = array_count(comp->constants) - 1;
    return pos;
}

static void change_uint16_operand(compiler_t *comp, int ip, uint16_t operand) {
    array(uint8_t) *bytecode = get_bytecode(comp);
    if ((ip + 1) >= array_count(bytecode)) {
        APE_ASSERT(false);
        return;
    }
    uint8_t hi = (uint8_t)(operand >> 8);
    array_set(bytecode, ip, &hi);
    uint8_t lo = (uint8_t)(operand);
    array_set(bytecode, ip + 1, &lo);
}

static bool last_opcode_is(compiler_t *comp, opcode_t op) {
    opcode_t last_opcode = get_last_opcode(comp);
    return last_opcode == op;
}

static bool read_symbol(compiler_t *comp, const symbol_t *symbol) {
    int ip = -1;
    if (symbol->type == SYMBOL_MODULE_GLOBAL) {
        ip = emit(comp, OPCODE_GET_MODULE_GLOBAL, 1, (uint64_t[]){symbol->index});
    } else if (symbol->type == SYMBOL_APE_GLOBAL) {
        ip = emit(comp, OPCODE_GET_APE_GLOBAL, 1, (uint64_t[]){symbol->index});
    } else if (symbol->type == SYMBOL_LOCAL) {
        ip = emit(comp, OPCODE_GET_LOCAL, 1, (uint64_t[]){symbol->index});
    } else if (symbol->type == SYMBOL_FREE) {
        ip = emit(comp, OPCODE_GET_FREE, 1, (uint64_t[]){symbol->index});
    } else if (symbol->type == SYMBOL_FUNCTION) {
        ip = emit(comp, OPCODE_CURRENT_FUNCTION, 0, NULL);
    } else if (symbol->type == SYMBOL_THIS) {
        ip = emit(comp, OPCODE_GET_THIS, 0, NULL);
    }
    return ip >= 0;
}

static bool write_symbol(compiler_t *comp, const symbol_t *symbol, bool define) {
    int ip = -1;
    if (symbol->type == SYMBOL_MODULE_GLOBAL) {
        if (define) {
            ip = emit(comp, OPCODE_DEFINE_MODULE_GLOBAL, 1, (uint64_t[]){symbol->index});
        } else {
            ip = emit(comp, OPCODE_SET_MODULE_GLOBAL, 1, (uint64_t[]){symbol->index});
        }
    } else if (symbol->type == SYMBOL_LOCAL) {
        if (define) {
            ip = emit(comp, OPCODE_DEFINE_LOCAL, 1, (uint64_t[]){symbol->index});
        } else {
            ip = emit(comp, OPCODE_SET_LOCAL, 1, (uint64_t[]){symbol->index});
        }
    } else if (symbol->type == SYMBOL_FREE) {
        ip = emit(comp, OPCODE_SET_FREE, 1, (uint64_t[]){symbol->index});
    }
    return ip >= 0;
}

static bool push_break_ip(compiler_t *comp, int ip) {
    compilation_scope_t *comp_scope = get_compilation_scope(comp);
    return array_push(comp_scope->break_ip_stack, &ip);
}

static void pop_break_ip(compiler_t *comp) {
    compilation_scope_t *comp_scope = get_compilation_scope(comp);
    if (array_count(comp_scope->break_ip_stack) == 0) {
        APE_ASSERT(false);
        return;
    }
    array_pop(comp_scope->break_ip_stack, NULL);
}

static int get_break_ip(compiler_t *comp) {
    compilation_scope_t *comp_scope = get_compilation_scope(comp);
    if (array_count(comp_scope->break_ip_stack) == 0) {
        return -1;
    }
    int *res = array_top(comp_scope->break_ip_stack);
    return *res;
}

static bool push_continue_ip(compiler_t *comp, int ip) {
    compilation_scope_t *comp_scope = get_compilation_scope(comp);
    return array_push(comp_scope->continue_ip_stack, &ip);
}

static void pop_continue_ip(compiler_t *comp) {
    compilation_scope_t *comp_scope = get_compilation_scope(comp);
    if (array_count(comp_scope->continue_ip_stack) == 0) {
        APE_ASSERT(false);
        return;
    }
    array_pop(comp_scope->continue_ip_stack, NULL);
}

static int get_continue_ip(compiler_t *comp) {
    compilation_scope_t *comp_scope = get_compilation_scope(comp);
    if (array_count(comp_scope->continue_ip_stack) == 0) {
        APE_ASSERT(false);
        return -1;
    }
    int *res = array_top(comp_scope->continue_ip_stack);
    return *res;
}

static int get_ip(compiler_t *comp) {
    compilation_scope_t *compilation_scope = get_compilation_scope(comp);
    return array_count(compilation_scope->bytecode);
}

static array(src_pos_t)* get_src_positions(compiler_t *comp) {
    compilation_scope_t *compilation_scope = get_compilation_scope(comp);
    return compilation_scope->src_positions;
}

static array(uint8_t)* get_bytecode(compiler_t *comp) {
    compilation_scope_t *compilation_scope = get_compilation_scope(comp);
    return compilation_scope->bytecode;
}

static file_scope_t* file_scope_make(compiler_t *comp, compiled_file_t *file) {
    file_scope_t *file_scope = allocator_malloc(comp->alloc, sizeof(file_scope_t));
    if (!file_scope) {
        return NULL;
    }
    memset(file_scope, 0, sizeof(file_scope_t));
    file_scope->alloc = comp->alloc;
    file_scope->parser = parser_make(comp->alloc, comp->config, comp->errors);
    if (!file_scope->parser) {
        goto err;
    }
    file_scope->symbol_table = NULL;
    file_scope->file = file;
    file_scope->loaded_module_names = ptrarray_make(comp->alloc);
    if (!file_scope->loaded_module_names) {
        goto err;
    }
    return file_scope;
err:
    file_scope_destroy(file_scope);
    return NULL;
}

static void file_scope_destroy(file_scope_t *scope) {
    for (int i = 0; i < ptrarray_count(scope->loaded_module_names); i++) {
        void *name = ptrarray_get(scope->loaded_module_names, i);
        allocator_free(scope->alloc, name);
    }
    ptrarray_destroy(scope->loaded_module_names);
    parser_destroy(scope->parser);
    allocator_free(scope->alloc, scope);
}

static bool push_file_scope(compiler_t *comp, const char *filepath) {
    symbol_table_t *prev_st = NULL;
    if (ptrarray_count(comp->file_scopes) > 0) {
        prev_st = compiler_get_symbol_table(comp);
    }

    compiled_file_t *file = compiled_file_make(comp->alloc, filepath);
    if (!file) {
        return false;
    }

    bool ok = ptrarray_add(comp->files, file);
    if (!ok) {
        compiled_file_destroy(file);
        return false;
    }

    file_scope_t *file_scope = file_scope_make(comp, file);
    if (!file_scope) {
        return false;
    }

    ok = ptrarray_push(comp->file_scopes, file_scope);
    if (!ok) {
        file_scope_destroy(file_scope);
        return false;
    }

    int global_offset = 0;
    if (prev_st) {
        block_scope_t *prev_st_top_scope = symbol_table_get_block_scope(prev_st);
        global_offset = prev_st_top_scope->offset + prev_st_top_scope->num_definitions;
    }

    ok = push_symbol_table(comp, global_offset);
    if (!ok) {
        ptrarray_pop(comp->file_scopes);
        file_scope_destroy(file_scope);
        return false;
    }

    return true;
}

static void pop_file_scope(compiler_t *comp) {
    symbol_table_t *popped_st = compiler_get_symbol_table(comp);
    block_scope_t *popped_st_top_scope = symbol_table_get_block_scope(popped_st);
    int popped_num_defs = popped_st_top_scope->num_definitions;

    while (compiler_get_symbol_table(comp)) {
        pop_symbol_table(comp);
    }
    file_scope_t *scope = ptrarray_top(comp->file_scopes);
    if (!scope) {
        APE_ASSERT(false);
        return;
    }
    file_scope_destroy(scope);

    ptrarray_pop(comp->file_scopes);

    if (ptrarray_count(comp->file_scopes) > 0) {
        symbol_table_t *current_st = compiler_get_symbol_table(comp);
        block_scope_t *current_st_top_scope = symbol_table_get_block_scope(current_st);
        current_st_top_scope->num_definitions += popped_num_defs;
    }
}

static void set_compilation_scope(compiler_t *comp, compilation_scope_t *scope) {
    comp->compilation_scope = scope;
}

static module_t* module_make(allocator_t *alloc, const char *name) {
    module_t *module = allocator_malloc(alloc, sizeof(module_t));
    if (!module) {
        return NULL;
    }
    memset(module, 0, sizeof(module_t));
    module->alloc = alloc;
    module->name = ape_strdup(alloc, name);
    if (!module->name) {
        module_destroy(module);
        return NULL;
    }
    module->symbols = ptrarray_make(alloc);
    if (!module->symbols) {
        module_destroy(module);
        return NULL;
    }
    return module;
}

static void module_destroy(module_t *module) {
    if (!module) {
        return;
    }
    allocator_free(module->alloc, module->name);
    ptrarray_destroy_with_items(module->symbols, symbol_destroy_wrapper);
    allocator_free(module->alloc, module);
}

static module_t* module_copy(module_t *src) {
    module_t *copy = allocator_malloc(src->alloc, sizeof(module_t));
    if (!copy) {
        return NULL;
    }
    memset(copy, 0, sizeof(module_t));
    copy->alloc = src->alloc;
    copy->name = ape_strdup(copy->alloc, src->name);
    if (!copy->name) {
        module_destroy(copy);
        return NULL;
    }
    copy->symbols = ptrarray_copy_with_items(src->symbols, symbol_copy_wrapper, symbol_destroy_wrapper);
    if (!copy->symbols) {
        module_destroy(copy);
        return NULL;
    }
    return copy;
}

static const char* get_module_name(const char *path) {
    const char *last_slash_pos = strrchr(path, '/');
    if (last_slash_pos) {
        return last_slash_pos + 1;
    }
    return path;
}

static bool module_add_symbol(module_t *module, const symbol_t *symbol) {
    strbuf_t *name_buf = strbuf_make(module->alloc);
    if (!name_buf) {
        return false;
    }
    bool ok = strbuf_appendf(name_buf, "%s::%s", module->name, symbol->name);
    if (!ok) {
        strbuf_destroy(name_buf);
        return false;
    }
    symbol_t *module_symbol = symbol_make(module->alloc, strbuf_get_string(name_buf), SYMBOL_MODULE_GLOBAL, symbol->index, false);
    strbuf_destroy(name_buf);
    if (!module_symbol) {
        return false;
    }
    ok = ptrarray_add(module->symbols, module_symbol);
    if (!ok) {
        symbol_destroy(module_symbol);
        return false;
    }
    return true;
}

static const symbol_t* define_symbol(compiler_t *comp, src_pos_t pos, const char *name, bool assignable, bool can_shadow) {
    symbol_table_t *symbol_table = compiler_get_symbol_table(comp);
    if (!can_shadow && !symbol_table_is_top_global_scope(symbol_table)) {
        const symbol_t *current_symbol = symbol_table_resolve(symbol_table, name);
        if (current_symbol) {
            errors_add_errorf(comp->errors, ERROR_COMPILATION, pos, "Symbol \"%s\" is already defined", name);
            return NULL;
        }
    }

    const symbol_t *symbol = symbol_table_define(symbol_table, name, assignable);
    if (!symbol) {
        errors_add_errorf(comp->errors, ERROR_COMPILATION, pos, "Cannot define symbol \"%s\"", name);
        return false;
    }

    return symbol;
}
//FILE_END
//FILE_START:object.c
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <float.h>
#include <math.h>

#ifndef APE_AMALGAMATED
#include "object.h"
#include "code.h"
#include "compiler.h"
#include "traceback.h"
#include "gc.h"
#endif

#define OBJECT_PATTERN          0xfff8000000000000
#define OBJECT_HEADER_MASK      0xffff000000000000
#define OBJECT_ALLOCATED_HEADER 0xfffc000000000000
#define OBJECT_BOOL_HEADER      0xfff9000000000000
#define OBJECT_NULL_PATTERN     0xfffa000000000000

static object_t object_deep_copy_internal(gcmem_t *mem, object_t obj, valdict(object_t, object_t) *copies);
static bool object_equals_wrapped(const object_t *a, const object_t *b);
static bool object_equals_wrapped_ext(const void *a, const void *b);
static unsigned long object_hash(object_t *obj_ptr);
static unsigned long object_hash_string(const char *str);
static unsigned long object_hash_double(double val);
static unsigned long object_hash_wrapper(const void *obj_ptr);
static array(object_t)* object_get_allocated_array(object_t object);
static bool object_is_number(object_t obj);
static uint64_t get_type_tag(object_type_t type);
static bool freevals_are_allocated(function_t *fun);
static char *object_data_get_string(object_data_t *data);
static bool object_data_string_reserve_capacity(object_data_t *data, int capacity);

object_t object_make_from_data(object_type_t type, object_data_t *data) {
    object_t object;
    object.handle = OBJECT_PATTERN;
    uint64_t type_tag = get_type_tag(type) & 0x7;
    object.handle |= (type_tag << 48);
    object.handle |= (uintptr_t)data; // assumes no pointer exceeds 48 bits
    return object;
}

object_t object_make_number(double val) {
    object_t o = { .number = val };
    if ((o.handle & OBJECT_PATTERN) == OBJECT_PATTERN) {
        o.handle = 0x7ff8000000000000;
    }
    return o;
}

object_t object_make_bool(bool val) {
    return (object_t) { .handle = OBJECT_BOOL_HEADER | val };
}

object_t object_make_null() {
    return (object_t) { .handle = OBJECT_NULL_PATTERN };
}

object_t object_make_string(gcmem_t *mem, const char *string) {
    int len = (int)strlen(string);
    object_t res = object_make_string_with_capacity(mem, len);
    if (object_is_null(res)) {
        return res;
    }
    bool ok = object_string_append(res, string, len);
    if (!ok) {
        return object_make_null();
    }
    return res;
}

object_t object_make_string_with_capacity(gcmem_t *mem, int capacity) {
    object_data_t *data = gcmem_get_object_data_from_pool(mem, OBJECT_STRING);
    if (!data) {
        data = gcmem_alloc_object_data(mem, OBJECT_STRING);
        if (!data) {
            return object_make_null();
        }
        data->string.capacity = OBJECT_STRING_BUF_SIZE - 1;
        data->string.is_allocated = false;
    }

    data->string.length = 0;
    data->string.hash = 0;

    if (capacity > data->string.capacity) {
        bool ok = object_data_string_reserve_capacity(data, capacity);
        if (!ok) {
            return object_make_null();
        }
    }

    return object_make_from_data(OBJECT_STRING, data);
}

object_t object_make_stringf(gcmem_t *mem, const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    int to_write = vsnprintf(NULL, 0, fmt, args);
    va_end(args);
    va_start(args, fmt);
    object_t res = object_make_string_with_capacity(mem, to_write);
    if (object_is_null(res)) {
        return object_make_null();
    }
    char *res_buf = object_get_mutable_string(res);
    int written = vsprintf(res_buf, fmt, args);
    (void)written;
    APE_ASSERT(written == to_write);
    va_end(args);
    object_set_string_length(res, to_write);
    return res;
}

object_t object_make_native_function(gcmem_t *mem, const char *name, native_fn fn, void *data, int data_len) {
    if (data_len > NATIVE_FN_MAX_DATA_LEN) {
        return object_make_null();
    }
    object_data_t *obj = gcmem_alloc_object_data(mem, OBJECT_NATIVE_FUNCTION);
    if (!obj) {
        return object_make_null();
    }
    obj->native_function.name = ape_strdup(mem->alloc, name);
    if (!obj->native_function.name) {
        return object_make_null();
    }
    obj->native_function.fn = fn;
    if (data) {
        memcpy(obj->native_function.data, data, data_len);
    }
    obj->native_function.data_len = data_len;
    return object_make_from_data(OBJECT_NATIVE_FUNCTION, obj);
}

object_t object_make_array(gcmem_t *mem) {
    return object_make_array_with_capacity(mem, 8);
}

object_t object_make_array_with_capacity(gcmem_t *mem, unsigned capacity) {
    object_data_t *data = gcmem_get_object_data_from_pool(mem, OBJECT_ARRAY);
    if (data) {
        array_clear(data->array);
        return object_make_from_data(OBJECT_ARRAY, data);
    }
    data = gcmem_alloc_object_data(mem, OBJECT_ARRAY);
    if (!data) {
        return object_make_null();
    }
    data->array = array_make_with_capacity(mem->alloc, capacity, sizeof(object_t));
    if (!data->array) {
        return object_make_null();
    }
    return object_make_from_data(OBJECT_ARRAY, data);
}

object_t object_make_map(gcmem_t *mem) {
    return object_make_map_with_capacity(mem, 32);
}

object_t object_make_map_with_capacity(gcmem_t *mem, unsigned capacity) {
    object_data_t *data = gcmem_get_object_data_from_pool(mem, OBJECT_MAP);
    if (data) {
        valdict_clear(data->map);
        return object_make_from_data(OBJECT_MAP, data);
    }
    data = gcmem_alloc_object_data(mem, OBJECT_MAP);
    if (!data) {
        return object_make_null();
    }
    data->map = valdict_make_with_capacity(mem->alloc, capacity, sizeof(object_t), sizeof(object_t));
    if (!data->map) {
        return object_make_null();
    }
    valdict_set_hash_function(data->map, (collections_hash_fn)object_hash_wrapper);
    valdict_set_equals_function(data->map, (collections_equals_fn)object_equals_wrapped_ext);
    return object_make_from_data(OBJECT_MAP, data);
}

object_t object_make_error(gcmem_t *mem, const char *error) {
    char *error_str = ape_strdup(mem->alloc, error);
    if (!error_str) {
        return object_make_null();
    }
    object_t res = object_make_error_no_copy(mem, error_str);
    if (object_is_null(res)) {
        allocator_free(mem->alloc, error_str);
        return object_make_null();
    }
    return res;
}

object_t object_make_error_no_copy(gcmem_t *mem, char *error) {
    object_data_t *data = gcmem_alloc_object_data(mem, OBJECT_ERROR);
    if (!data) {
        return object_make_null();
    }
    data->error.message = error;
    data->error.traceback = NULL;
    return object_make_from_data(OBJECT_ERROR, data);
}

object_t object_make_errorf(gcmem_t *mem, const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    int to_write = vsnprintf(NULL, 0, fmt, args);
    va_end(args);
    va_start(args, fmt);
    char *res = (char*)allocator_malloc(mem->alloc, to_write + 1);
    if (!res) {
        return object_make_null();
    }
    int written = vsprintf(res, fmt, args);
    (void)written;
    APE_ASSERT(written == to_write);
    va_end(args);
    object_t res_obj = object_make_error_no_copy(mem, res);
    if (object_is_null(res_obj)) {
        allocator_free(mem->alloc, res);
        return object_make_null();
    }
    return res_obj;
}

object_t object_make_function(gcmem_t *mem, const char *name, compilation_result_t *comp_res, bool owns_data,
                              int num_locals, int num_args,
                              int free_vals_count) {

    object_data_t *data = gcmem_alloc_object_data(mem, OBJECT_FUNCTION);
    if (!data) {
        return object_make_null();
    }
    if (owns_data) {
        data->function.name = name ? ape_strdup(mem->alloc, name) : ape_strdup(mem->alloc, "anonymous");
        if (!data->function.name) {
            return object_make_null();
        }
    } else {
        data->function.const_name = name ? name : "anonymous";
    }
    data->function.comp_result = comp_res;
    data->function.owns_data = owns_data;
    data->function.num_locals = num_locals;
    data->function.num_args = num_args;
    if (free_vals_count >= APE_ARRAY_LEN(data->function.free_vals_buf)) {
        data->function.free_vals_allocated = allocator_malloc(mem->alloc, sizeof(object_t) * free_vals_count);
        if (!data->function.free_vals_allocated) {
            return object_make_null();
        }
    }
    data->function.free_vals_count = free_vals_count;
    return object_make_from_data(OBJECT_FUNCTION, data);
}

object_t object_make_external(gcmem_t *mem, void *data) {
    object_data_t *obj = gcmem_alloc_object_data(mem, OBJECT_EXTERNAL);
    if (!obj) {
        return object_make_null();
    }
    obj->external.data = data;
    obj->external.data_destroy_fn = NULL;
    obj->external.data_copy_fn = NULL;
    return object_make_from_data(OBJECT_EXTERNAL, obj);
}

void object_deinit(object_t obj) {
    if (object_is_allocated(obj)) {
        object_data_t *data = object_get_allocated_data(obj);
        object_data_deinit(data);
    }
}

void object_data_deinit(object_data_t *data) {
    switch (data->type) {
        case OBJECT_FREED: {
            APE_ASSERT(false);
            return;
        }
        case OBJECT_STRING: {
            if (data->string.is_allocated) {
                allocator_free(data->mem->alloc, data->string.value_allocated);
            }
            break;
        }
        case OBJECT_FUNCTION: {
            if (data->function.owns_data) {
                allocator_free(data->mem->alloc, data->function.name);
                compilation_result_destroy(data->function.comp_result);
            }
            if (freevals_are_allocated(&data->function)) {
                allocator_free(data->mem->alloc, data->function.free_vals_allocated);
            }
            break;
        }
        case OBJECT_ARRAY: {
            array_destroy(data->array);
            break;
        }
        case OBJECT_MAP: {
            valdict_destroy(data->map);
            break;
        }
        case OBJECT_NATIVE_FUNCTION: {
            allocator_free(data->mem->alloc, data->native_function.name);
            break;
        }
        case OBJECT_EXTERNAL: {
            if (data->external.data_destroy_fn) {
                data->external.data_destroy_fn(data->external.data);
            }
            break;
        }
        case OBJECT_ERROR: {
            allocator_free(data->mem->alloc, data->error.message);
            traceback_destroy(data->error.traceback);
            break;
        }
        default: {
            break;
        }
    }
    data->type = OBJECT_FREED;
}

bool object_is_allocated(object_t object) {
    return (object.handle & OBJECT_ALLOCATED_HEADER) == OBJECT_ALLOCATED_HEADER;
}

gcmem_t* object_get_mem(object_t obj) {
    object_data_t *data = object_get_allocated_data(obj);
    return data->mem;
}

bool object_is_hashable(object_t obj) {
    object_type_t type = object_get_type(obj);
    switch (type) {
        case OBJECT_STRING: return true;
        case OBJECT_NUMBER: return true;
        case OBJECT_BOOL:   return true;
        default: return false;
    }
}

void object_to_string(object_t obj, strbuf_t *buf, bool quote_str) {
    object_type_t type = object_get_type(obj);
    switch (type) {
        case OBJECT_FREED: {
            strbuf_append(buf, "FREED");
            break;
        }
        case OBJECT_NONE: {
            strbuf_append(buf, "NONE");
            break;
        }
        case OBJECT_NUMBER: {
            double number = object_get_number(obj);
            strbuf_appendf(buf, "%1.10g", number);
            break;
        }
        case OBJECT_BOOL: {
            strbuf_append(buf, object_get_bool(obj) ? "true" : "false");
            break;
        }
        case OBJECT_STRING: {
            const char *string = object_get_string(obj);
            if (quote_str) {
                strbuf_appendf(buf, "\"%s\"", string);
            } else {
                strbuf_append(buf, string);
            }
            break;
        }
        case OBJECT_NULL: {
            strbuf_append(buf, "null");
            break;
        }
        case OBJECT_FUNCTION: {
            const function_t *function = object_get_function(obj);
            strbuf_appendf(buf, "CompiledFunction: %s\n", object_get_function_name(obj));
            code_to_string(function->comp_result->bytecode, function->comp_result->src_positions, function->comp_result->count, buf);
            break;
        }
        case OBJECT_ARRAY: {
            strbuf_append(buf, "[");
            for (int i = 0; i < object_get_array_length(obj); i++) {
                object_t iobj = object_get_array_value_at(obj, i);
                object_to_string(iobj, buf, true);
                if (i < (object_get_array_length(obj) - 1)) {
                    strbuf_append(buf, ", ");
                }
            }
            strbuf_append(buf, "]");
            break;
        }
        case OBJECT_MAP: {
            strbuf_append(buf, "{");
            for (int i = 0; i < object_get_map_length(obj); i++) {
                object_t key = object_get_map_key_at(obj, i);
                object_t val = object_get_map_value_at(obj, i);
                object_to_string(key, buf, true);
                strbuf_append(buf, ": ");
                object_to_string(val, buf, true);
                if (i < (object_get_map_length(obj) - 1)) {
                    strbuf_append(buf, ", ");
                }
            }
            strbuf_append(buf, "}");
            break;
        }
        case OBJECT_NATIVE_FUNCTION: {
            strbuf_append(buf, "NATIVE_FUNCTION");
            break;
        }
        case OBJECT_EXTERNAL: {
            strbuf_append(buf, "EXTERNAL");
            break;
        }
        case OBJECT_ERROR: {
            strbuf_appendf(buf, "ERROR: %s\n", object_get_error_message(obj));
            traceback_t *traceback = object_get_error_traceback(obj);
            APE_ASSERT(traceback);
            if (traceback) {
                strbuf_append(buf, "Traceback:\n");
                traceback_to_string(traceback, buf);
            }
            break;
        }
        case OBJECT_ANY: {
            APE_ASSERT(false);
        }
    }
}

const char *object_get_type_name(const object_type_t type) {
    switch (type) {
        case OBJECT_NONE:            return "NONE";
        case OBJECT_FREED:           return "NONE";
        case OBJECT_NUMBER:          return "NUMBER";
        case OBJECT_BOOL:            return "BOOL";
        case OBJECT_STRING:          return "STRING";
        case OBJECT_NULL:            return "NULL";
        case OBJECT_NATIVE_FUNCTION: return "NATIVE_FUNCTION";
        case OBJECT_ARRAY:           return "ARRAY";
        case OBJECT_MAP:             return "MAP";
        case OBJECT_FUNCTION:        return "FUNCTION";
        case OBJECT_EXTERNAL:        return "EXTERNAL";
        case OBJECT_ERROR:           return "ERROR";
        case OBJECT_ANY:             return "ANY";
    }
    return "NONE";
}

char* object_get_type_union_name(allocator_t *alloc, const object_type_t type) {
    if (type == OBJECT_ANY || type == OBJECT_NONE || type == OBJECT_FREED) {
        return ape_strdup(alloc, object_get_type_name(type));
    }
    strbuf_t *res = strbuf_make(alloc);
    if (!res) {
        return NULL;
    }
    bool in_between = false;
#define CHECK_TYPE(t) \
    do {\
        if ((type & t) == t) {\
            if (in_between) {\
                strbuf_append(res, "|");\
            }\
            strbuf_append(res, object_get_type_name(t));\
            in_between = true;\
        }\
    } while (0)

    CHECK_TYPE(OBJECT_NUMBER);
    CHECK_TYPE(OBJECT_BOOL);
    CHECK_TYPE(OBJECT_STRING);
    CHECK_TYPE(OBJECT_NULL);
    CHECK_TYPE(OBJECT_NATIVE_FUNCTION);
    CHECK_TYPE(OBJECT_ARRAY);
    CHECK_TYPE(OBJECT_MAP);
    CHECK_TYPE(OBJECT_FUNCTION);
    CHECK_TYPE(OBJECT_EXTERNAL);
    CHECK_TYPE(OBJECT_ERROR);

    return strbuf_get_string_and_destroy(res);
}

char* object_serialize(allocator_t *alloc, object_t object) {
    strbuf_t *buf = strbuf_make(alloc);
    if (!buf) {
        return NULL;
    }
    object_to_string(object, buf, true);
    char *string = strbuf_get_string_and_destroy(buf);
    return string;
}

object_t object_deep_copy(gcmem_t *mem, object_t obj) {
    valdict(object_t, object_t) *copies = valdict_make(mem->alloc, object_t, object_t);
    if (!copies) {
        return object_make_null();
    }
    object_t res = object_deep_copy_internal(mem, obj, copies);
    valdict_destroy(copies);
    return res;
}

object_t object_copy(gcmem_t *mem, object_t obj) {
    object_t copy = object_make_null();
    object_type_t type = object_get_type(obj);
    switch (type) {
        case OBJECT_ANY:
        case OBJECT_FREED:
        case OBJECT_NONE: {
            APE_ASSERT(false);
            copy = object_make_null();
            break;
        }
        case OBJECT_NUMBER:
        case OBJECT_BOOL:
        case OBJECT_NULL:
        case OBJECT_FUNCTION:
        case OBJECT_NATIVE_FUNCTION:
        case OBJECT_ERROR: {
            copy = obj;
            break;
        }
        case OBJECT_STRING: {
            const char *str = object_get_string(obj);
            copy = object_make_string(mem, str);
            break;
        }
        case OBJECT_ARRAY: {
            int len = object_get_array_length(obj);
            copy = object_make_array_with_capacity(mem, len);
            if (object_is_null(copy)) {
                return object_make_null();
            }
            for (int i = 0; i < len; i++) {
                object_t item = object_get_array_value_at(obj, i);
                bool ok = object_add_array_value(copy, item);
                if (!ok) {
                    return object_make_null();
                }
            }
            break;
        }
        case OBJECT_MAP: {
            copy = object_make_map(mem);
            for (int i = 0; i < object_get_map_length(obj); i++) {
                object_t key = object_get_map_key_at(obj, i);
                object_t val = object_get_map_value_at(obj, i);
                bool ok = object_set_map_value(copy, key, val);
                if (!ok) {
                    return object_make_null();
                }
            }
            break;
        }
        case OBJECT_EXTERNAL: {
            copy = object_make_external(mem, NULL);
            if (object_is_null(copy)) {
                return object_make_null();
            }
            external_data_t *external = object_get_external_data(obj);
            void *data_copy = NULL;
            if (external->data_copy_fn) {
                data_copy = external->data_copy_fn(external->data);
            } else {
                data_copy = external->data;
            }
            object_set_external_data(copy, data_copy);
            object_set_external_destroy_function(copy, external->data_destroy_fn);
            object_set_external_copy_function(copy, external->data_copy_fn);
            break;
        }
    }
    return copy;
}

double object_compare(object_t a, object_t b, bool *out_ok) {
    if (a.handle == b.handle) {
        return 0;
    }

    *out_ok = true;

    object_type_t a_type = object_get_type(a);
    object_type_t b_type = object_get_type(b);

    if ((a_type == OBJECT_NUMBER || a_type == OBJECT_BOOL || a_type == OBJECT_NULL)
        && (b_type == OBJECT_NUMBER || b_type == OBJECT_BOOL || b_type == OBJECT_NULL)) {
        double left_val = object_get_number(a);
        double right_val = object_get_number(b);
        return left_val - right_val;
    } else if (a_type == b_type && a_type == OBJECT_STRING) {
        int a_len = object_get_string_length(a);
        int b_len = object_get_string_length(b);
        if (a_len != b_len) {
            return a_len - b_len;
        }
        unsigned long a_hash = object_get_string_hash(a);
        unsigned long b_hash = object_get_string_hash(b);
        if (a_hash != b_hash) {
            return a_hash - b_hash;
        }
        const char *a_string = object_get_string(a);
        const char *b_string = object_get_string(b);
        return strcmp(a_string, b_string);
    } else if ((object_is_allocated(a) || object_is_null(a))
            && (object_is_allocated(b) || object_is_null(b))) {
        intptr_t a_data_val = (intptr_t)object_get_allocated_data(a);
        intptr_t b_data_val = (intptr_t)object_get_allocated_data(b);
        return (double)(a_data_val - b_data_val);
    } else {
        *out_ok = false;
    }
    return 1;
}

bool object_equals(object_t a, object_t b) {
    object_type_t a_type = object_get_type(a);
    object_type_t b_type = object_get_type(b);

    if (a_type != b_type) {
        return false;
    }
    bool ok = false;
    double res = object_compare(a, b, &ok);
    return APE_DBLEQ(res, 0);
}

external_data_t* object_get_external_data(object_t object) {
    APE_ASSERT(object_get_type(object) == OBJECT_EXTERNAL);
    object_data_t *data = object_get_allocated_data(object);
    return &data->external;
}

bool object_set_external_destroy_function(object_t object, external_data_destroy_fn destroy_fn) {
    APE_ASSERT(object_get_type(object) == OBJECT_EXTERNAL);
    external_data_t* data = object_get_external_data(object);
    if (!data) {
        return false;
    }
    data->data_destroy_fn = destroy_fn;
    return true;
}

object_data_t* object_get_allocated_data(object_t object) {
    APE_ASSERT(object_is_allocated(object) || object_get_type(object) == OBJECT_NULL);
    return (object_data_t*)(object.handle & ~OBJECT_HEADER_MASK);
}

bool object_get_bool(object_t obj) {
    if (object_is_number(obj)) {
        return obj.handle;
    }
    return obj.handle & (~OBJECT_HEADER_MASK);
}

double object_get_number(object_t obj) {
    if (object_is_number(obj)) { // todo: optimise? always return number?
        return obj.number;
    }
    return (double)(obj.handle & (~OBJECT_HEADER_MASK));
}

const char * object_get_string(object_t object) {
    APE_ASSERT(object_get_type(object) == OBJECT_STRING);
    object_data_t *data = object_get_allocated_data(object);
    return object_data_get_string(data);
}

int object_get_string_length(object_t object) {
    APE_ASSERT(object_get_type(object) == OBJECT_STRING);
    object_data_t *data = object_get_allocated_data(object);
    return data->string.length;
}

void object_set_string_length(object_t object, int len) {
    APE_ASSERT(object_get_type(object) == OBJECT_STRING);
    object_data_t *data = object_get_allocated_data(object);
    data->string.length = len;
}


int object_get_string_capacity(object_t object) {
    APE_ASSERT(object_get_type(object) == OBJECT_STRING);
    object_data_t *data = object_get_allocated_data(object);
    return data->string.capacity;
}

char* object_get_mutable_string(object_t object) {
    APE_ASSERT(object_get_type(object) == OBJECT_STRING);
    object_data_t *data = object_get_allocated_data(object);
    return object_data_get_string(data);
}

bool object_string_append(object_t obj, const char *src, int len) {
    APE_ASSERT(object_get_type(obj) == OBJECT_STRING);
    object_data_t *data = object_get_allocated_data(obj);
    object_string_t *string = &data->string;
    char *str_buf = object_get_mutable_string(obj);
    int current_len = string->length;
    int capacity = string->capacity;
    if ((len + current_len) > capacity) {
        APE_ASSERT(false);
        return false;
    }
    memcpy(str_buf + current_len, src, len);
    string->length += len;
    str_buf[string->length] = '\0';
    return true;
}

unsigned long object_get_string_hash(object_t obj) {
    APE_ASSERT(object_get_type(obj) == OBJECT_STRING);
    object_data_t *data = object_get_allocated_data(obj);
    if (data->string.hash == 0) {
        data->string.hash = object_hash_string(object_get_string(obj));
        if (data->string.hash == 0) {
            data->string.hash = 1;
        }
    }
    return data->string.hash;
}

function_t* object_get_function(object_t object) {
    APE_ASSERT(object_get_type(object) == OBJECT_FUNCTION);
    object_data_t *data = object_get_allocated_data(object);
    return &data->function;
}

native_function_t* object_get_native_function(object_t obj) {
    object_data_t *data = object_get_allocated_data(obj);
    return &data->native_function;
}

object_type_t object_get_type(object_t obj) {
    if (object_is_number(obj)) {
        return OBJECT_NUMBER;
    }
    uint64_t tag = (obj.handle >> 48) & 0x7;
    switch (tag) {
        case 0: return OBJECT_NONE;
        case 1: return OBJECT_BOOL;
        case 2: return OBJECT_NULL;
        case 4: {
            object_data_t *data = object_get_allocated_data(obj);
            return data->type;
        }
        default: return OBJECT_NONE;
    }
}

bool object_is_numeric(object_t obj) {
    object_type_t type = object_get_type(obj);
    return type == OBJECT_NUMBER || type == OBJECT_BOOL;
}

bool object_is_null(object_t obj) {
    return object_get_type(obj) == OBJECT_NULL;
}

bool object_is_callable(object_t obj) {
    object_type_t type = object_get_type(obj);
    return type == OBJECT_NATIVE_FUNCTION || type == OBJECT_FUNCTION;
}

const char* object_get_function_name(object_t obj) {
    APE_ASSERT(object_get_type(obj) == OBJECT_FUNCTION);
    object_data_t *data = object_get_allocated_data(obj);
    APE_ASSERT(data);
    if (!data) {
        return NULL;
    }

    if (data->function.owns_data) {
        return data->function.name;
    } else {
        return data->function.const_name;
    }
}

object_t object_get_function_free_val(object_t obj, int ix) {
    APE_ASSERT(object_get_type(obj) == OBJECT_FUNCTION);
    object_data_t *data = object_get_allocated_data(obj);
    APE_ASSERT(data);
    if (!data) {
        return object_make_null();
    }
    function_t *fun = &data->function;
    APE_ASSERT(ix >= 0 && ix < fun->free_vals_count);
    if (ix < 0 || ix >= fun->free_vals_count) {
        return object_make_null();
    }
    if (freevals_are_allocated(fun)) {
        return fun->free_vals_allocated[ix];
    } else {
        return fun->free_vals_buf[ix];
    }
}

void object_set_function_free_val(object_t obj, int ix, object_t val) {
    APE_ASSERT(object_get_type(obj) == OBJECT_FUNCTION);
    object_data_t *data = object_get_allocated_data(obj);
    APE_ASSERT(data);
    if (!data) {
        return;
    }
    function_t *fun = &data->function;
    APE_ASSERT(ix >= 0 && ix < fun->free_vals_count);
    if (ix < 0 || ix >= fun->free_vals_count) {
        return;
    }
    if (freevals_are_allocated(fun)) {
        fun->free_vals_allocated[ix] = val;
    } else {
        fun->free_vals_buf[ix] = val;
    }
}

object_t* object_get_function_free_vals(object_t obj) {
    APE_ASSERT(object_get_type(obj) == OBJECT_FUNCTION);
    object_data_t *data = object_get_allocated_data(obj);
    APE_ASSERT(data);
    if (!data) {
        return NULL;
    }
    function_t *fun = &data->function;
    if (freevals_are_allocated(fun)) {
        return fun->free_vals_allocated;
    } else {
        return fun->free_vals_buf;
    }
}

const char* object_get_error_message(object_t object) {
    APE_ASSERT(object_get_type(object) == OBJECT_ERROR);
    object_data_t *data = object_get_allocated_data(object);
    return data->error.message;
}

void object_set_error_traceback(object_t object, traceback_t *traceback) {
    APE_ASSERT(object_get_type(object) == OBJECT_ERROR);
    if (object_get_type(object) != OBJECT_ERROR) {
        return;
    }
    object_data_t *data = object_get_allocated_data(object);
    APE_ASSERT(data->error.traceback == NULL);
    data->error.traceback = traceback;
}

traceback_t* object_get_error_traceback(object_t object) {
    APE_ASSERT(object_get_type(object) == OBJECT_ERROR);
    object_data_t *data = object_get_allocated_data(object);
    return data->error.traceback;
}

bool object_set_external_data(object_t object, void *ext_data) {
    APE_ASSERT(object_get_type(object) == OBJECT_EXTERNAL);
    external_data_t* data = object_get_external_data(object);
    if (!data) {
        return false;
    }
    data->data = ext_data;
    return true;
}

bool object_set_external_copy_function(object_t object, external_data_copy_fn copy_fn) {
    APE_ASSERT(object_get_type(object) == OBJECT_EXTERNAL);
    external_data_t* data = object_get_external_data(object);
    if (!data) {
        return false;
    }
    data->data_copy_fn = copy_fn;
    return true;
}

object_t object_get_array_value_at(object_t object, int ix) {
    APE_ASSERT(object_get_type(object) == OBJECT_ARRAY);
    array(object_t)* array = object_get_allocated_array(object);
    if (ix < 0 || ix >= array_count(array)) {
        return object_make_null();
    }
    object_t *res = array_get(array, ix);
    if (!res) {
        return object_make_null();
    }
    return *res;
}

bool object_set_array_value_at(object_t object, int ix, object_t val) {
    APE_ASSERT(object_get_type(object) == OBJECT_ARRAY);
    array(object_t)* array = object_get_allocated_array(object);
    if (ix < 0 || ix >= array_count(array)) {
        return false;
    }
    return array_set(array, ix, &val);
}

bool object_add_array_value(object_t object, object_t val) {
    APE_ASSERT(object_get_type(object) == OBJECT_ARRAY);
    array(object_t)* array = object_get_allocated_array(object);
    return array_add(array, &val);
}

int object_get_array_length(object_t object) {
    APE_ASSERT(object_get_type(object) == OBJECT_ARRAY);
    array(object_t)* array = object_get_allocated_array(object);
    return array_count(array);
}

APE_INTERNAL bool object_remove_array_value_at(object_t object, int ix) {
    array(object_t)* array = object_get_allocated_array(object);
    return array_remove_at(array, ix);
}

int object_get_map_length(object_t object) {
    APE_ASSERT(object_get_type(object) == OBJECT_MAP);
    object_data_t *data = object_get_allocated_data(object);
    return valdict_count(data->map);
}

object_t object_get_map_key_at(object_t object, int ix) {
    APE_ASSERT(object_get_type(object) == OBJECT_MAP);
    object_data_t *data = object_get_allocated_data(object);
    object_t *res = valdict_get_key_at(data->map, ix);
    if (!res) {
        return object_make_null();
    }
    return *res;
}

object_t object_get_map_value_at(object_t object, int ix) {
    APE_ASSERT(object_get_type(object) == OBJECT_MAP);
    object_data_t *data = object_get_allocated_data(object);
    object_t *res = valdict_get_value_at(data->map, ix);
    if (!res) {
        return object_make_null();
    }
    return *res;
}

bool object_set_map_value_at(object_t object, int ix, object_t val) {
    APE_ASSERT(object_get_type(object) == OBJECT_MAP);
    if (ix >= object_get_map_length(object)) {
        return false;
    }
    object_data_t *data = object_get_allocated_data(object);
    return valdict_set_value_at(data->map, ix, &val);
}

object_t object_get_kv_pair_at(gcmem_t *mem, object_t object, int ix) {
    APE_ASSERT(object_get_type(object) == OBJECT_MAP);
    object_data_t *data = object_get_allocated_data(object);
    if (ix >= valdict_count(data->map)) {
        return object_make_null();
    }
    object_t key = object_get_map_key_at(object, ix);
    object_t val = object_get_map_value_at(object, ix);
    object_t res = object_make_map(mem);
    if (object_is_null(res)) {
        return object_make_null();
    }

    object_t key_obj = object_make_string(mem, "key");
    if (object_is_null(key_obj)) {
        return object_make_null();
    }
    object_set_map_value(res, key_obj, key);

    object_t val_obj = object_make_string(mem, "value");
    if (object_is_null(val_obj)) {
        return object_make_null();
    }
    object_set_map_value(res, val_obj, val);

    return res;
}

bool object_set_map_value(object_t object, object_t key, object_t val) {
    APE_ASSERT(object_get_type(object) == OBJECT_MAP);
    object_data_t *data = object_get_allocated_data(object);
    return valdict_set(data->map, &key, &val);
}

object_t object_get_map_value(object_t object, object_t key) {
    APE_ASSERT(object_get_type(object) == OBJECT_MAP);
    object_data_t *data = object_get_allocated_data(object);
    object_t *res = valdict_get(data->map, &key);
    if (!res) {
        return object_make_null();
    }
    return *res;
}

bool object_map_has_key(object_t object, object_t key) {
    APE_ASSERT(object_get_type(object) == OBJECT_MAP);
    object_data_t *data = object_get_allocated_data(object);
    object_t *res = valdict_get(data->map, &key);
    return res != NULL;
}

// INTERNAL
static object_t object_deep_copy_internal(gcmem_t *mem, object_t obj, valdict(object_t, object_t) *copies) {
    object_t *copy_ptr = valdict_get(copies, &obj);
    if (copy_ptr) {
        return *copy_ptr;
    }

    object_t copy = object_make_null()  ;

    object_type_t type = object_get_type(obj);
    switch (type) {
        case OBJECT_FREED:
        case OBJECT_ANY:
        case OBJECT_NONE: {
            APE_ASSERT(false);
            copy = object_make_null();
            break;
        }
        case OBJECT_NUMBER:
        case OBJECT_BOOL:
        case OBJECT_NULL:
        case OBJECT_NATIVE_FUNCTION: {
            copy = obj;
            break;
        }
        case OBJECT_STRING: {
            const char *str = object_get_string(obj);
            copy = object_make_string(mem, str);
            break;
        }
        case OBJECT_FUNCTION: {
            function_t *function = object_get_function(obj);
            uint8_t *bytecode_copy = NULL;
            src_pos_t *src_positions_copy = NULL;
            compilation_result_t *comp_res_copy = NULL;

            bytecode_copy = allocator_malloc(mem->alloc, sizeof(uint8_t) * function->comp_result->count);
            if (!bytecode_copy) {
                return object_make_null();
            }
            memcpy(bytecode_copy, function->comp_result->bytecode, sizeof(uint8_t) * function->comp_result->count);

            src_positions_copy = allocator_malloc(mem->alloc, sizeof(src_pos_t) * function->comp_result->count);
            if (!src_positions_copy) {
                allocator_free(mem->alloc, bytecode_copy);
                return object_make_null();
            }
            memcpy(src_positions_copy, function->comp_result->src_positions, sizeof(src_pos_t) * function->comp_result->count);

            comp_res_copy = compilation_result_make(mem->alloc, bytecode_copy, src_positions_copy, function->comp_result->count); // todo: add compilation result copy function
            if (!comp_res_copy) {
                allocator_free(mem->alloc, src_positions_copy);
                allocator_free(mem->alloc, bytecode_copy);
                return object_make_null();
            }

            copy = object_make_function(mem, object_get_function_name(obj), comp_res_copy, true,
                                        function->num_locals, function->num_args, 0);
            if (object_is_null(copy)) {
                compilation_result_destroy(comp_res_copy);
                return object_make_null();
            }

            bool ok = valdict_set(copies, &obj, &copy);
            if (!ok) {
                return object_make_null();
            }

            function_t *function_copy = object_get_function(copy);
            if (freevals_are_allocated(function)) {
                function_copy->free_vals_allocated = allocator_malloc(mem->alloc, sizeof(object_t) * function->free_vals_count);
                if (!function_copy->free_vals_allocated) {
                    return object_make_null();
                }
            }

            function_copy->free_vals_count = function->free_vals_count;
            for (int i = 0; i < function->free_vals_count; i++) {
                object_t free_val = object_get_function_free_val(obj, i);
                object_t free_val_copy = object_deep_copy_internal(mem, free_val, copies);
                if (!object_is_null(free_val) && object_is_null(free_val_copy)) {
                    return object_make_null();
                }
                object_set_function_free_val(copy, i, free_val_copy);
            }
            break;
        }
        case OBJECT_ARRAY: {
            int len = object_get_array_length(obj);
            copy = object_make_array_with_capacity(mem, len);
            if (object_is_null(copy)) {
                return object_make_null();
            }
            bool ok = valdict_set(copies, &obj, &copy);
            if (!ok) {
                return object_make_null();
            }
            for (int i = 0; i < len; i++) {
                object_t item = object_get_array_value_at(obj, i);
                object_t item_copy = object_deep_copy_internal(mem, item, copies);
                if (!object_is_null(item) && object_is_null(item_copy)) {
                    return object_make_null();
                }
                bool ok = object_add_array_value(copy, item_copy);
                if (!ok) {
                    return object_make_null();
                }
            }
            break;
        }
        case OBJECT_MAP: {
            copy = object_make_map(mem);
            if (object_is_null(copy)) {
                return object_make_null();
            }
            bool ok = valdict_set(copies, &obj, &copy);
            if (!ok) {
                return object_make_null();
            }
            for (int i = 0; i < object_get_map_length(obj); i++) {
                object_t key = object_get_map_key_at(obj, i);
                object_t val = object_get_map_value_at(obj, i);

                object_t key_copy = object_deep_copy_internal(mem, key, copies);
                if (!object_is_null(key) && object_is_null(key_copy)) {
                    return object_make_null();
                }

                object_t val_copy = object_deep_copy_internal(mem, val, copies);
                if (!object_is_null(val) && object_is_null(val_copy)) {
                    return object_make_null();
                }

                bool ok = object_set_map_value(copy, key_copy, val_copy);
                if (!ok) {
                    return object_make_null();
                }
            }
            break;
        }
        case OBJECT_EXTERNAL: {
            copy = object_copy(mem, obj);
            break;
        }
        case OBJECT_ERROR: {
            copy = obj;
            break;
        }
    }
    return copy;
}


static bool object_equals_wrapped(const object_t *a_ptr, const object_t *b_ptr) {
    object_t a = *a_ptr;
    object_t b = *b_ptr;
    return object_equals(a, b);
}

static bool object_equals_wrapped_ext(const void *a_ptr, const void *b_ptr) {
    return object_equals_wrapped(a_ptr, b_ptr);
}

static unsigned long object_hash(object_t *obj_ptr) {
    object_t obj = *obj_ptr;
    object_type_t type = object_get_type(obj);

    switch (type) {
        case OBJECT_NUMBER: {
            double val = object_get_number(obj);
            return object_hash_double(val);
        }
        case OBJECT_BOOL: {
            bool val = object_get_bool(obj);
            return val;
        }
        case OBJECT_STRING: {
            return object_get_string_hash(obj);
        }
        default: {
            return 0;
        }
    }
}

static unsigned long object_hash_wrapper(const void *obj_ptr) {
    return object_hash((object_t*)obj_ptr);
}

static unsigned long object_hash_string(const char *str) { /* djb2 */
    unsigned long hash = 5381;
    int c;
    while ((c = *str++)) {
        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
    }
    return hash;
}

static unsigned long object_hash_double(double val) { /* djb2 */
    uint32_t *val_ptr = (uint32_t*)&val;
    unsigned long hash = 5381;
    hash = ((hash << 5) + hash) + val_ptr[0];
    hash = ((hash << 5) + hash) + val_ptr[1];
    return hash;
}

array(object_t)* object_get_allocated_array(object_t object) {
    APE_ASSERT(object_get_type(object) == OBJECT_ARRAY);
    object_data_t *data = object_get_allocated_data(object);
    return data->array;
}

static bool object_is_number(object_t o) {
    return (o.handle & OBJECT_PATTERN) != OBJECT_PATTERN;
}

static uint64_t get_type_tag(object_type_t type) {
    switch (type) {
        case OBJECT_NONE: return 0;
        case OBJECT_BOOL: return 1;
        case OBJECT_NULL: return 2;
        default:          return 4;
    }
}

static bool freevals_are_allocated(function_t *fun) {
    return fun->free_vals_count >= APE_ARRAY_LEN(fun->free_vals_buf);
}

static char *object_data_get_string(object_data_t *data) {
    APE_ASSERT(data->type == OBJECT_STRING);
    if (data->string.is_allocated) {
        return data->string.value_allocated;
    } else {
        return data->string.value_buf;
    }
}

static bool object_data_string_reserve_capacity(object_data_t *data, int capacity) {
    APE_ASSERT(capacity >= 0);

    object_string_t *string = &data->string;

    string->length = 0;
    string->hash = 0;

    if (capacity <= string->capacity) {
        return true;
    }

    if (capacity <= (OBJECT_STRING_BUF_SIZE - 1)) {
        if (string->is_allocated) {
            APE_ASSERT(false); // should never happen
            allocator_free(data->mem->alloc, string->value_allocated); // just in case
        }
        string->capacity = OBJECT_STRING_BUF_SIZE - 1;
        string->is_allocated = false;
        return true;
    }

    char *new_value = allocator_malloc(data->mem->alloc, capacity + 1);
    if (!new_value) {
        return false;
    }

    if (string->is_allocated) {
        allocator_free(data->mem->alloc, string->value_allocated);
    }

    string->value_allocated = new_value;
    string->is_allocated = true;
    string->capacity = capacity;
    return true;
}
//FILE_END
//FILE_START:gc.c
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#ifndef APE_AMALGAMATED
#include "gc.h"
#include "object.h"
#endif

static object_data_pool_t* get_pool_for_type(gcmem_t *mem, object_type_t type);
static bool can_data_be_put_in_pool(gcmem_t *mem, object_data_t *data);

gcmem_t *gcmem_make(allocator_t *alloc) {
    gcmem_t *mem = allocator_malloc(alloc, sizeof(gcmem_t));
    if (!mem) {
        return NULL;
    }
    memset(mem, 0, sizeof(gcmem_t));
    mem->alloc = alloc;
    mem->objects = ptrarray_make(alloc);
    if (!mem->objects) {
        goto error;
    }
    mem->objects_back = ptrarray_make(alloc);
    if (!mem->objects_back) {
        goto error;
    }
    mem->objects_not_gced = array_make(alloc, object_t);
    if (!mem->objects_not_gced) {
        goto error;
    }
    mem->allocations_since_sweep = 0;
    mem->data_only_pool.count = 0;

    for (int i = 0; i < GCMEM_POOLS_NUM; i++) {
        object_data_pool_t *pool = &mem->pools[i];
        mem->pools[i].count = 0;
        memset(pool, 0, sizeof(object_data_pool_t));
    }

    return mem;
error:
    gcmem_destroy(mem);
    return NULL;
}

void gcmem_destroy(gcmem_t *mem) {
    if (!mem) {
        return;
    }

    array_destroy(mem->objects_not_gced);
    ptrarray_destroy(mem->objects_back);

    for (int i = 0; i < ptrarray_count(mem->objects); i++) {
        object_data_t *obj = ptrarray_get(mem->objects, i);
        object_data_deinit(obj);
        allocator_free(mem->alloc, obj);
    }
    ptrarray_destroy(mem->objects);

    for (int i = 0; i < GCMEM_POOLS_NUM; i++) {
        object_data_pool_t *pool = &mem->pools[i];
        for (int j = 0; j < pool->count; j++) {
            object_data_t *data = pool->data[j];
            object_data_deinit(data);
            allocator_free(mem->alloc, data);
        }
        memset(pool, 0, sizeof(object_data_pool_t));
    }

    for (int i = 0; i < mem->data_only_pool.count; i++) {
        allocator_free(mem->alloc, mem->data_only_pool.data[i]);
    }

    allocator_free(mem->alloc, mem);
}

object_data_t* gcmem_alloc_object_data(gcmem_t *mem, object_type_t type) {
    object_data_t *data = NULL;
    mem->allocations_since_sweep++;
    if (mem->data_only_pool.count > 0) {
        data = mem->data_only_pool.data[mem->data_only_pool.count - 1];
        mem->data_only_pool.count--;
    } else {
        data = allocator_malloc(mem->alloc, sizeof(object_data_t));
        if (!data) {
            return NULL;
        }
    }

    memset(data, 0, sizeof(object_data_t));

    APE_ASSERT(ptrarray_count(mem->objects_back) >= ptrarray_count(mem->objects));
    // we want to make sure that appending to objects_back never fails in sweep
    // so this only reserves space there.
    bool ok = ptrarray_add(mem->objects_back, data);
    if (!ok) {
        allocator_free(mem->alloc, data);
        return NULL;
    }
    ok = ptrarray_add(mem->objects, data);
    if (!ok) {
        allocator_free(mem->alloc, data);
        return NULL;
    }
    data->mem = mem;
    data->type = type;
    return data;
}

object_data_t* gcmem_get_object_data_from_pool(gcmem_t *mem, object_type_t type) {
    object_data_pool_t *pool = get_pool_for_type(mem, type);
    if (!pool || pool->count <= 0) {
        return NULL;
    }
    object_data_t *data = pool->data[pool->count - 1];

    APE_ASSERT(ptrarray_count(mem->objects_back) >= ptrarray_count(mem->objects));

    // we want to make sure that appending to objects_back never fails in sweep
    // so this only reserves space there.
    bool ok = ptrarray_add(mem->objects_back, data);
    if (!ok) {
        return NULL;
    }
    ok = ptrarray_add(mem->objects, data);
    if (!ok) {
        return NULL;
    }

    pool->count--;

    return data;
}

void gc_unmark_all(gcmem_t *mem) {
    for (int i = 0; i < ptrarray_count(mem->objects); i++) {
        object_data_t *data = ptrarray_get(mem->objects, i);
        data->gcmark = false;
    }
}

void gc_mark_objects(object_t *objects, int count) {
    for (int i = 0; i < count; i++) {
        object_t obj = objects[i];
        gc_mark_object(obj);
    }
}

void gc_mark_object(object_t obj) {
    if (!object_is_allocated(obj)) {
        return;
    }

    object_data_t *data = object_get_allocated_data(obj);
    if (data->gcmark) {
        return;
    }

    data->gcmark = true;
    switch (data->type) {
        case OBJECT_MAP: {
            int len = object_get_map_length(obj);
            for (int i = 0; i < len; i++) {
                object_t key = object_get_map_key_at(obj, i);
                if (object_is_allocated(key)) {
                    object_data_t *key_data = object_get_allocated_data(key);
                    if (!key_data->gcmark) {
                        gc_mark_object(key);
                    }
                }
                object_t val = object_get_map_value_at(obj, i);
                if (object_is_allocated(val)) {
                    object_data_t *val_data = object_get_allocated_data(val);
                    if (!val_data->gcmark) {
                        gc_mark_object(val);
                    }
                }
            }
            break;
        }
        case OBJECT_ARRAY: {
            int len = object_get_array_length(obj);
            for (int i = 0; i < len; i++) {
                object_t val = object_get_array_value_at(obj, i);
                if (object_is_allocated(val)) {
                    object_data_t *val_data = object_get_allocated_data(val);
                    if (!val_data->gcmark) {
                        gc_mark_object(val);
                    }
                }
            }
            break;
        }
        case OBJECT_FUNCTION: {
            function_t *function = object_get_function(obj);
            for (int i = 0; i < function->free_vals_count; i++) {
                object_t free_val = object_get_function_free_val(obj, i);
                gc_mark_object(free_val);
                if (object_is_allocated(free_val)) {
                    object_data_t *free_val_data = object_get_allocated_data(free_val);
                    if (!free_val_data->gcmark) {
                        gc_mark_object(free_val);
                    }
                }
            }
            break;
        }
        default: {
            break;
        }
    }
}

void gc_sweep(gcmem_t *mem) {
    gc_mark_objects(array_data(mem->objects_not_gced), array_count(mem->objects_not_gced));

    APE_ASSERT(ptrarray_count(mem->objects_back) >= ptrarray_count(mem->objects));

    ptrarray_clear(mem->objects_back);
    for (int i = 0; i < ptrarray_count(mem->objects); i++) {
        object_data_t *data = ptrarray_get(mem->objects, i);
        if (data->gcmark) {
            // this should never fail because objects_back's size should be equal to objects
            bool ok = ptrarray_add(mem->objects_back, data);
            (void)ok;
            APE_ASSERT(ok);
        } else {
            if (can_data_be_put_in_pool(mem, data)) {
                object_data_pool_t *pool = get_pool_for_type(mem, data->type);
                pool->data[pool->count] = data;
                pool->count++;
            } else {
                object_data_deinit(data);
                if (mem->data_only_pool.count < GCMEM_POOL_SIZE) {
                    mem->data_only_pool.data[mem->data_only_pool.count] = data;
                    mem->data_only_pool.count++;
                } else {
                    allocator_free(mem->alloc, data);
                }
            }
        }
    }
    ptrarray(object_t) *objs_temp = mem->objects;
    mem->objects = mem->objects_back;
    mem->objects_back = objs_temp;
    mem->allocations_since_sweep = 0;
}

bool gc_disable_on_object(object_t obj) {
    if (!object_is_allocated(obj)) {
        return false;
    }
    object_data_t *data = object_get_allocated_data(obj);
    if (array_contains(data->mem->objects_not_gced, &obj)) {
        return false;
    }
    bool ok = array_add(data->mem->objects_not_gced, &obj);
    return ok;
}

void gc_enable_on_object(object_t obj) {
    if (!object_is_allocated(obj)) {
        return;
    }
    object_data_t *data = object_get_allocated_data(obj);
    array_remove_item(data->mem->objects_not_gced, &obj);
}

int gc_should_sweep(gcmem_t *mem) {
    return mem->allocations_since_sweep > GCMEM_SWEEP_INTERVAL;
}

// INTERNAL
static object_data_pool_t* get_pool_for_type(gcmem_t *mem, object_type_t type) {
    switch (type) {
        case OBJECT_ARRAY:  return &mem->pools[0];
        case OBJECT_MAP:    return &mem->pools[1];
        case OBJECT_STRING: return &mem->pools[2];
        default:            return NULL;
    }
}

static bool can_data_be_put_in_pool(gcmem_t *mem, object_data_t *data) {
    object_t obj = object_make_from_data(data->type, data);

    // this is to ensure that large objects won't be kept in pool indefinitely
    switch (data->type) {
        case OBJECT_ARRAY: {
            if (object_get_array_length(obj) > 1024) {
                return false;
            }
            break;
        }
        case OBJECT_MAP: {
            if (object_get_map_length(obj) > 1024) {
                return false;
            }
            break;
        }
        case OBJECT_STRING: {
            if (!data->string.is_allocated || data->string.capacity > 4096) {
                return false;
            }
            break;
        }
        default:
            break;
    }

    object_data_pool_t *pool = get_pool_for_type(mem, data->type);
    if (!pool || pool->count >= GCMEM_POOL_SIZE) {
        return false;
    }

    return true;
}
//FILE_END
//FILE_START:builtins.c
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>

#ifndef APE_AMALGAMATED
#include "builtins.h"

#include "common.h"
#include "object.h"
#include "vm.h"
#endif

static object_t len_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t first_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t last_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t rest_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t reverse_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t array_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t append_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t remove_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t remove_at_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t println_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t print_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t read_file_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t write_file_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t to_str_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t to_num_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t char_to_str_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t range_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t keys_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t values_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t copy_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t deep_copy_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t concat_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t error_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t crash_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t assert_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t random_seed_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t random_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t slice_fn(vm_t *vm, void *data, int argc, object_t *args);

// Type checks
static object_t is_string_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t is_array_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t is_map_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t is_number_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t is_bool_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t is_null_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t is_function_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t is_external_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t is_error_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t is_native_function_fn(vm_t *vm, void *data, int argc, object_t *args);

// Math
static object_t sqrt_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t pow_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t sin_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t cos_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t tan_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t log_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t ceil_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t floor_fn(vm_t *vm, void *data, int argc, object_t *args);
static object_t abs_fn(vm_t *vm, void *data, int argc, object_t *args);

static bool check_args(vm_t *vm, bool generate_error, int argc, object_t *args, int expected_argc, object_type_t *expected_types);
#define CHECK_ARGS(vm, generate_error, argc, args, ...) \
    check_args(\
        (vm),\
        (generate_error),\
        (argc),\
        (args),\
        sizeof((object_type_t[]){__VA_ARGS__}) / sizeof(object_type_t),\
        (object_type_t[]){__VA_ARGS__})

static struct {
    const char *name;
    native_fn fn;
} g_native_functions[] = {
    {"len",         len_fn},
    {"println",     println_fn},
    {"print",       print_fn},
    {"read_file",   read_file_fn},
    {"write_file",  write_file_fn},
    {"first",       first_fn},
    {"last",        last_fn},
    {"rest",        rest_fn},
    {"append",      append_fn},
    {"remove",      remove_fn},
    {"remove_at",   remove_at_fn},
    {"to_str",      to_str_fn},
    {"to_num",      to_num_fn},
    {"range",       range_fn},
    {"keys",        keys_fn},
    {"values",      values_fn},
    {"copy",        copy_fn},
    {"deep_copy",   deep_copy_fn},
    {"concat",      concat_fn},
    {"char_to_str", char_to_str_fn},
    {"reverse",     reverse_fn},
    {"array",       array_fn},
    {"error",       error_fn},
    {"crash",       crash_fn},
    {"assert",      assert_fn},
    {"random_seed", random_seed_fn},
    {"random",      random_fn},
    {"slice",       slice_fn},

    // Type checks
    {"is_string",   is_string_fn},
    {"is_array",    is_array_fn},
    {"is_map",      is_map_fn},
    {"is_number",   is_number_fn},
    {"is_bool",     is_bool_fn},
    {"is_null",     is_null_fn},
    {"is_function", is_function_fn},
    {"is_external", is_external_fn},
    {"is_error",    is_error_fn},
    {"is_native_function", is_native_function_fn},

    // Math
    {"sqrt",  sqrt_fn},
    {"pow",   pow_fn},
    {"sin",   sin_fn},
    {"cos",   cos_fn},
    {"tan",   tan_fn},
    {"log",   log_fn},
    {"ceil",  ceil_fn},
    {"floor", floor_fn},
    {"abs",   abs_fn},
};

int builtins_count() {
    return APE_ARRAY_LEN(g_native_functions);
}

native_fn builtins_get_fn(int ix) {
    return g_native_functions[ix].fn;
}

const char* builtins_get_name(int ix) {
    return g_native_functions[ix].name;
}

// INTERNAL
static object_t len_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_STRING | OBJECT_ARRAY | OBJECT_MAP)) {
        return object_make_null();
    }

    object_t arg = args[0];
    object_type_t type = object_get_type(arg);
    if (type == OBJECT_STRING) {
        int len = object_get_string_length(arg);
        return object_make_number(len);
    } else if (type == OBJECT_ARRAY) {
        int len = object_get_array_length(arg);
        return object_make_number(len);
    } else if (type == OBJECT_MAP) {
        int len = object_get_map_length(arg);
        return object_make_number(len);
    }

    return object_make_null();
}

static object_t first_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ARRAY)) {
        return object_make_null();
    }
     object_t arg = args[0];
    return object_get_array_value_at(arg, 0);
}

static object_t last_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ARRAY)) {
        return object_make_null();
    }
    object_t arg = args[0];
    return object_get_array_value_at(arg, object_get_array_length(arg) - 1);
}

static object_t rest_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ARRAY)) {
        return object_make_null();
    }
    object_t arg = args[0];
    int len = object_get_array_length(arg);
    if (len == 0) {
        return object_make_null();
    }

    object_t res = object_make_array(vm->mem);
    if (object_is_null(res)) {
        return object_make_null();
    }
    for (int i = 1; i < len; i++) {
        object_t item = object_get_array_value_at(arg, i);
        bool ok = object_add_array_value(res, item);
        if (!ok) {
            return object_make_null();
        }
    }
    return res;
}

static object_t reverse_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ARRAY | OBJECT_STRING)) {
        return object_make_null();
    }
    object_t arg = args[0];
    object_type_t type = object_get_type(arg);
    if (type == OBJECT_ARRAY) {
        int len = object_get_array_length(arg);
        object_t res = object_make_array_with_capacity(vm->mem, len);
        if (object_is_null(res)) {
            return object_make_null();
        }
        for (int i = 0; i < len; i++) {
            object_t obj = object_get_array_value_at(arg, i);
            bool ok = object_set_array_value_at(res, len - i - 1, obj);
            if (!ok) {
                return object_make_null();
            }
        }
        return res;
    } else if (type == OBJECT_STRING) {
        const char *str = object_get_string(arg);
        int len = object_get_string_length(arg);

        object_t res = object_make_string_with_capacity(vm->mem, len);
        if (object_is_null(res)) {
            return object_make_null();
        }
        char *res_buf = object_get_mutable_string(res);
        for (int i = 0; i < len; i++) {
            res_buf[len - i - 1] = str[i];
        }
        res_buf[len] = '\0';
        object_set_string_length(res, len);
        return res;
    }
    return object_make_null();
}

static object_t array_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (argc == 1) {
        if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
            return object_make_null();
        }
        int capacity = (int)object_get_number(args[0]);
        object_t res = object_make_array_with_capacity(vm->mem, capacity);
        if (object_is_null(res)) {
            return object_make_null();
        }
        object_t obj_null = object_make_null();
        for (int i = 0; i < capacity; i++) {
            bool ok = object_add_array_value(res, obj_null);
            if (!ok) {
                return object_make_null();
            }
        }
        return res;
    } else if (argc == 2) {
        if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER, OBJECT_ANY)) {
            return object_make_null();
        }
        int capacity = (int)object_get_number(args[0]);
        object_t res = object_make_array_with_capacity(vm->mem, capacity);
        if (object_is_null(res)) {
            return object_make_null();
        }
        for (int i = 0; i < capacity; i++) {
            bool ok = object_add_array_value(res, args[1]);
            if (!ok) {
                return object_make_null();
            }
        }
        return res;
    }
    CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER);
    return object_make_null();
}

static object_t append_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ARRAY, OBJECT_ANY)) {
        return object_make_null();
    }
    bool ok = object_add_array_value(args[0], args[1]);
    if (!ok) {
        return object_make_null();
    }
    int len = object_get_array_length(args[0]);
    return object_make_number(len);
}

static object_t println_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;

    const ape_config_t *config = vm->config;

    if (!config->stdio.write.write) {
        return object_make_null(); // todo: runtime error?
    }

    strbuf_t *buf = strbuf_make(vm->alloc);
    if (!buf) {
        return object_make_null();
    }
    for (int i = 0; i < argc; i++) {
        object_t arg = args[i];
        object_to_string(arg, buf, false);
    }
    strbuf_append(buf, "\n");
    if (strbuf_failed(buf)) {
        strbuf_destroy(buf);
        return object_make_null();
    }
    config->stdio.write.write(config->stdio.write.context, strbuf_get_string(buf), strbuf_get_length(buf));
    strbuf_destroy(buf);
    return object_make_null();
}

static object_t print_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    const ape_config_t *config = vm->config;

    if (!config->stdio.write.write) {
        return object_make_null(); // todo: runtime error?
    }

    strbuf_t *buf = strbuf_make(vm->alloc);
    if (!buf) {
        return object_make_null();
    }
    for (int i = 0; i < argc; i++) {
        object_t arg = args[i];
        object_to_string(arg, buf, false);
    }
    if (strbuf_failed(buf)) {
        strbuf_destroy(buf);
        return object_make_null();
    }
    config->stdio.write.write(config->stdio.write.context, strbuf_get_string(buf), strbuf_get_length(buf));
    strbuf_destroy(buf);
    return object_make_null();
}

static object_t write_file_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_STRING, OBJECT_STRING)) {
        return object_make_null();
    }

    const ape_config_t *config = vm->config;

    if (!config->fileio.write_file.write_file) {
        return object_make_null();
    }

    const char *path = object_get_string(args[0]);
    const char *string = object_get_string(args[1]);
    int string_len = object_get_string_length(args[1]);

    int written = (int)config->fileio.write_file.write_file(config->fileio.write_file.context, path, string, string_len);

    return object_make_number(written);
}

static object_t read_file_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_STRING)) {
        return object_make_null();
    }

    const ape_config_t *config = vm->config;

    if (!config->fileio.read_file.read_file) {
        return object_make_null();
    }

    const char *path = object_get_string(args[0]);

    char *contents = config->fileio.read_file.read_file(config->fileio.read_file.context, path);
    if (!contents) {
        return object_make_null();
    }
    object_t res = object_make_string(vm->mem, contents);
    allocator_free(vm->alloc, contents);
    return res;
}

static object_t to_str_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_STRING | OBJECT_NUMBER | OBJECT_BOOL | OBJECT_NULL | OBJECT_MAP | OBJECT_ARRAY)) {
        return object_make_null();
    }
    object_t arg = args[0];
    strbuf_t *buf = strbuf_make(vm->alloc);
    if (!buf) {
        return object_make_null();
    }
    object_to_string(arg, buf, false);
    if (strbuf_failed(buf)) {
        strbuf_destroy(buf);
        return object_make_null();
    }
    object_t res = object_make_string(vm->mem, strbuf_get_string(buf));
    strbuf_destroy(buf);
    return res;
}

static object_t to_num_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_STRING | OBJECT_NUMBER | OBJECT_BOOL | OBJECT_NULL)) {
        return object_make_null();
    }
    double result = 0;
    const char *string = "";
    if (object_is_numeric(args[0])) {
        result = object_get_number(args[0]);
    } else if (object_is_null(args[0])) {
        result = 0;
    } else if (object_get_type(args[0]) == OBJECT_STRING) {
        string = object_get_string(args[0]);
        char *end;
        errno = 0;
        result = strtod(string, &end);
        if (errno == ERANGE && (result <= -HUGE_VAL || result >= HUGE_VAL)) {
            goto err;;
        }
        if (errno && errno != ERANGE) {
            goto err;
        }
        int string_len = object_get_string_length(args[0]);
        int parsed_len = (int)(end - string);
        if (string_len != parsed_len) {
            goto err;
        }
    } else {
        goto err;
    }
    return object_make_number(result);
err:
    errors_add_errorf(vm->errors, ERROR_RUNTIME, src_pos_invalid, "Cannot convert \"%s\" to number", string);
    return object_make_null();
}

static object_t char_to_str_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
        return object_make_null();
    }

    double val = object_get_number(args[0]);

    char c = (char)val;
    char str[2] = {c, '\0'};
    return object_make_string(vm->mem, str);
}

static object_t range_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    for (int i = 0; i < argc; i++) {
        object_type_t type = object_get_type(args[i]);
        if (type != OBJECT_NUMBER) {
            const char *type_str = object_get_type_name(type);
            const char *expected_str = object_get_type_name(OBJECT_NUMBER);
            errors_add_errorf(vm->errors, ERROR_RUNTIME, src_pos_invalid,
                                       "Invalid argument %d passed to range, got %s instead of %s",
                                       i, type_str, expected_str);
            return object_make_null();
        }
    }

    int start = 0;
    int end = 0;
    int step = 1;

    if (argc == 1) {
        end = (int)object_get_number(args[0]);
    } else if (argc == 2) {
        start = (int)object_get_number(args[0]);
        end = (int)object_get_number(args[1]);
    } else if (argc == 3) {
        start = (int)object_get_number(args[0]);
        end = (int)object_get_number(args[1]);
        step = (int)object_get_number(args[2]);
    } else {
        errors_add_errorf(vm->errors, ERROR_RUNTIME, src_pos_invalid, "Invalid number of arguments passed to range, got %d", argc);
        return object_make_null();
    }

    if (step == 0) {
        errors_add_error(vm->errors, ERROR_RUNTIME, src_pos_invalid, "range step cannot be 0");
        return object_make_null();
    }

    object_t res = object_make_array(vm->mem);
    if (object_is_null(res)) {
        return object_make_null();
    }
    for (int i = start; i < end; i += step) {
        object_t item = object_make_number(i);
        bool ok = object_add_array_value(res, item);
        if (!ok) {
            return object_make_null();
        }
    }
    return res;
}

static object_t keys_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_MAP)) {
        return object_make_null();
    }
    object_t arg = args[0];
    object_t res = object_make_array(vm->mem);
    if (object_is_null(res)) {
        return object_make_null();
    }
    int len = object_get_map_length(arg);
    for (int i = 0; i < len; i++) {
        object_t key = object_get_map_key_at(arg, i);
        bool ok = object_add_array_value(res, key);
        if (!ok) {
            return object_make_null();
        }
    }
    return res;
}

static object_t values_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_MAP)) {
        return object_make_null();
    }
    object_t arg = args[0];
    object_t res = object_make_array(vm->mem);
    if (object_is_null(res)) {
        return object_make_null();
    }
    int len = object_get_map_length(arg);
    for (int i = 0; i < len; i++) {
        object_t key = object_get_map_value_at(arg, i);
        bool ok = object_add_array_value(res, key);
        if (!ok) {
            return object_make_null();
        }
    }
    return res;
}

static object_t copy_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_copy(vm->mem, args[0]);
}

static object_t deep_copy_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_deep_copy(vm->mem, args[0]);
}

static object_t concat_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ARRAY | OBJECT_STRING, OBJECT_ARRAY | OBJECT_STRING)) {
        return object_make_null();
    }
    object_type_t type = object_get_type(args[0]);
    object_type_t item_type = object_get_type(args[1]);
    if (type == OBJECT_ARRAY) {
        if (item_type != OBJECT_ARRAY) {
            const char *item_type_str = object_get_type_name(item_type);
            errors_add_errorf(vm->errors, ERROR_RUNTIME, src_pos_invalid,
                              "Invalid argument 2 passed to concat, got %s",
                              item_type_str);
            return object_make_null();
        }
        for (int i = 0; i < object_get_array_length(args[1]); i++) {
            object_t item = object_get_array_value_at(args[1], i);
            bool ok = object_add_array_value(args[0], item);
            if (!ok) {
                return object_make_null();
            }
        }
        return object_make_number(object_get_array_length(args[0]));
    } else if (type == OBJECT_STRING) {
        if (!CHECK_ARGS(vm, true, argc, args, OBJECT_STRING, OBJECT_STRING)) {
            return object_make_null();
        }
        const char* left_val = object_get_string(args[0]);
        int left_len = (int)object_get_string_length(args[0]);

        const char* right_val = object_get_string(args[1]);
        int right_len = (int)object_get_string_length(args[1]);

        object_t res = object_make_string_with_capacity(vm->mem, left_len + right_len);
        if (object_is_null(res)) {
            return object_make_null();
        }

        bool ok = object_string_append(res, left_val, left_len);
        if (!ok) {
            return object_make_null();
        }

        ok = object_string_append(res, right_val, right_len);
        if (!ok) {
            return object_make_null();
        }

        return res;
    }
    return object_make_null();
}

static object_t remove_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ARRAY, OBJECT_ANY)) {
        return object_make_null();
    }

    int ix = -1;
    for (int i = 0; i < object_get_array_length(args[0]); i++) {
        object_t obj = object_get_array_value_at(args[0], i);
        if (object_equals(obj, args[1])) {
            ix = i;
            break;
        }
    }

    if (ix == -1) {
        return object_make_bool(false);
    }

    bool res = object_remove_array_value_at(args[0], ix);
    return object_make_bool(res);
}

static object_t remove_at_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ARRAY, OBJECT_NUMBER)) {
        return object_make_null();
    }

    object_type_t type = object_get_type(args[0]);
    int ix = (int)object_get_number(args[1]);

    switch (type) {
        case OBJECT_ARRAY: {
            bool res = object_remove_array_value_at(args[0], ix);
            return object_make_bool(res);
        }
        default:
            break;
    }

    return object_make_bool(true);
}


static object_t error_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (argc == 1 && object_get_type(args[0]) == OBJECT_STRING) {
        return object_make_error(vm->mem, object_get_string(args[0]));
    } else {
        return object_make_error(vm->mem, "");
    }
}

static object_t crash_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (argc == 1 && object_get_type(args[0]) == OBJECT_STRING) {
        errors_add_error(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame), object_get_string(args[0]));
    } else {
        errors_add_error(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame), "");
    }
    return object_make_null();
}

static object_t assert_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_BOOL)) {
        return object_make_null();
    }

    if (!object_get_bool(args[0])) {
        errors_add_error(vm->errors, ERROR_RUNTIME, src_pos_invalid, "assertion failed");
        return object_make_null();
    }

    return object_make_bool(true);
}

static object_t random_seed_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
        return object_make_null();
    }
    int seed = (int)object_get_number(args[0]);
    srand(seed);
    return object_make_bool(true);
}

static object_t random_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    double res = (double)rand() / RAND_MAX;
    if (argc == 0) {
        return object_make_number(res);
    } else if (argc == 2) {
        if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER, OBJECT_NUMBER)) {
            return object_make_null();
        }
        double min = object_get_number(args[0]);
        double max = object_get_number(args[1]);
        if (min >= max) {
            errors_add_error(vm->errors, ERROR_RUNTIME, src_pos_invalid, "max is bigger than min");
            return object_make_null();
        }
        double range = max - min;
        res = min + (res * range);
        return object_make_number(res);
    } else {
        errors_add_error(vm->errors, ERROR_RUNTIME, src_pos_invalid, "Invalid number or arguments");
        return object_make_null();
    }
}

static object_t slice_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_STRING | OBJECT_ARRAY, OBJECT_NUMBER)) {
        return object_make_null();
    }
    object_type_t arg_type = object_get_type(args[0]);
    int index = (int)object_get_number(args[1]);
    if (arg_type == OBJECT_ARRAY) {
        int len = object_get_array_length(args[0]);
        if (index < 0) {
            index = len + index;
            if (index < 0) {
                index = 0;
            }
        }
        object_t res = object_make_array_with_capacity(vm->mem, len - index);
        if (object_is_null(res)) {
            return object_make_null();
        }
        for (int i = index; i < len; i++) {
            object_t item = object_get_array_value_at(args[0], i);
            bool ok = object_add_array_value(res, item);
            if (!ok) {
                return object_make_null();
            }
        }
        return res;
    } else if (arg_type == OBJECT_STRING) {
        const char *str = object_get_string(args[0]);
        int len = (int)object_get_string_length(args[0]);
        if (index < 0) {
            index = len + index;
            if (index < 0) {
                return object_make_string(vm->mem, "");
            }
        }
        if (index >= len) {
            return object_make_string(vm->mem, "");
        }
        int res_len = len - index;
        object_t res = object_make_string_with_capacity(vm->mem, res_len);
        if (object_is_null(res)) {
            return object_make_null();
        }

        char *res_buf = object_get_mutable_string(res);
        memset(res_buf, 0, res_len + 1);
        for (int i = index; i < len; i++) {
            char c = str[i];
            res_buf[i - index] = c;
        }
        object_set_string_length(res, res_len);
        return res;
    } else {
        const char *type_str = object_get_type_name(arg_type);
        errors_add_errorf(vm->errors, ERROR_RUNTIME, src_pos_invalid,
                          "Invalid argument 0 passed to slice, got %s instead", type_str);
        return object_make_null();
    }
}

//-----------------------------------------------------------------------------
// Type checks
//-----------------------------------------------------------------------------

static object_t is_string_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_make_bool(object_get_type(args[0]) == OBJECT_STRING);
}

static object_t is_array_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_make_bool(object_get_type(args[0]) == OBJECT_ARRAY);
}

static object_t is_map_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_make_bool(object_get_type(args[0]) == OBJECT_MAP);
}

static object_t is_number_fn(vm_t *vm, void *data, int argc, object_t *args){
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_make_bool(object_get_type(args[0]) == OBJECT_NUMBER);
}

static object_t is_bool_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_make_bool(object_get_type(args[0]) == OBJECT_BOOL);
}

static object_t is_null_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_make_bool(object_get_type(args[0]) == OBJECT_NULL);
}

static object_t is_function_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_make_bool(object_get_type(args[0]) == OBJECT_FUNCTION);
}

static object_t is_external_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_make_bool(object_get_type(args[0]) == OBJECT_EXTERNAL);
}

static object_t is_error_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_make_bool(object_get_type(args[0]) == OBJECT_ERROR);
}

static object_t is_native_function_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_ANY)) {
        return object_make_null();
    }
    return object_make_bool(object_get_type(args[0]) == OBJECT_NATIVE_FUNCTION);
}

//-----------------------------------------------------------------------------
// Math
//-----------------------------------------------------------------------------

static object_t sqrt_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
        return object_make_null();
    }
    double arg = object_get_number(args[0]);
    double res = sqrt(arg);
    return object_make_number(res);
}

static object_t pow_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER, OBJECT_NUMBER)) {
        return object_make_null();
    }
    double arg1 = object_get_number(args[0]);
    double arg2 = object_get_number(args[1]);
    double res = pow(arg1, arg2);
    return object_make_number(res);
}

static object_t sin_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
        return object_make_null();
    }
    double arg = object_get_number(args[0]);
    double res = sin(arg);
    return object_make_number(res);
}

static object_t cos_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
        return object_make_null();
    }
    double arg = object_get_number(args[0]);
    double res = cos(arg);
    return object_make_number(res);
}

static object_t tan_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
        return object_make_null();
    }
    double arg = object_get_number(args[0]);
    double res = tan(arg);
    return object_make_number(res);
}

static object_t log_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
        return object_make_null();
    }
    double arg = object_get_number(args[0]);
    double res = log(arg);
    return object_make_number(res);
}

static object_t ceil_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
        return object_make_null();
    }
    double arg = object_get_number(args[0]);
    double res = ceil(arg);
    return object_make_number(res);
}

static object_t floor_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
        return object_make_null();
    }
    double arg = object_get_number(args[0]);
    double res = floor(arg);
    return object_make_number(res);
}

static object_t abs_fn(vm_t *vm, void *data, int argc, object_t *args) {
    (void)data;
    if (!CHECK_ARGS(vm, true, argc, args, OBJECT_NUMBER)) {
        return object_make_null();
    }
    double arg = object_get_number(args[0]);
    double res = fabs(arg);
    return object_make_number(res);
}

static bool check_args(vm_t *vm, bool generate_error, int argc, object_t *args, int expected_argc, object_type_t *expected_types) {
    if (argc != expected_argc) {
        if (generate_error) {
            errors_add_errorf(vm->errors, ERROR_RUNTIME, src_pos_invalid,
                              "Invalid number or arguments, got %d instead of %d",
                              argc, expected_argc);
        }
        return false;
    }

    for (int i = 0; i < argc; i++) {
       object_t arg = args[i];
        object_type_t type = object_get_type(arg);
        object_type_t expected_type = expected_types[i];
        if (!(type & expected_type)) {
            if (generate_error) {
                const char *type_str = object_get_type_name(type);
                char *expected_type_str = object_get_type_union_name(vm->alloc, expected_type);
                if (!expected_type_str) {
                    return false;
                }
                errors_add_errorf(vm->errors, ERROR_RUNTIME, src_pos_invalid,
                                  "Invalid argument %d type, got %s, expected %s",
                                  i, type_str, expected_type_str);
                allocator_free(vm->alloc, expected_type_str);
            }
            return false;
        }
    }
    return true;
}
//FILE_END
//FILE_START:traceback.c
#ifndef APE_AMALGAMATED
#include "traceback.h"
#include "vm.h"
#include "compiler.h"
#include "collections.h"
#endif

traceback_t* traceback_make(allocator_t *alloc) {
    traceback_t *traceback = allocator_malloc(alloc, sizeof(traceback_t));
    if (!traceback) {
        return NULL;
    }
    memset(traceback, 0, sizeof(traceback_t));
    traceback->alloc = alloc;
    traceback->items = array_make(alloc, traceback_item_t);
    if (!traceback->items) {
        traceback_destroy(traceback);
        return NULL;
    }
    return traceback;
}

void traceback_destroy(traceback_t *traceback) {
    if (!traceback) {
        return;
    }
    for (int i = 0; i < array_count(traceback->items); i++) {
        traceback_item_t *item = array_get(traceback->items, i);
        allocator_free(traceback->alloc, item->function_name);
    }
    array_destroy(traceback->items);
    allocator_free(traceback->alloc, traceback);
}

bool traceback_append(traceback_t *traceback, const char *function_name, src_pos_t pos) {
    traceback_item_t item;
    item.function_name = ape_strdup(traceback->alloc, function_name);
    if (!item.function_name) {
        return false;
    }
    item.pos = pos;
    bool ok = array_add(traceback->items, &item);
    if (!ok) {
        allocator_free(traceback->alloc, item.function_name);
        return false;
    }
    return true;
}

bool traceback_append_from_vm(traceback_t *traceback, vm_t *vm) {
    for (int i = vm->frames_count - 1; i >= 0; i--) {
        frame_t *frame = &vm->frames[i];
        bool ok = traceback_append(traceback, object_get_function_name(frame->function), frame_src_position(frame));
        if (!ok) {
            return false;
        }
    }
    return true;
}

bool traceback_to_string(const traceback_t *traceback, strbuf_t *buf) {
    int depth  = array_count(traceback->items);
    for (int i = 0; i < depth; i++) {
        traceback_item_t *item = array_get(traceback->items, i);
        const char *filename = traceback_item_get_filepath(item);
        if (item->pos.line >= 0 && item->pos.column >= 0) {
            strbuf_appendf(buf, "%s in %s on %d:%d\n", item->function_name, filename, item->pos.line, item->pos.column);
        } else {
            strbuf_appendf(buf, "%s\n", item->function_name);
        }
    }
    return !strbuf_failed(buf);
}

const char* traceback_item_get_line(traceback_item_t *item) {
    if (!item->pos.file) {
        return NULL;
    }
    ptrarray(char*) *lines = item->pos.file->lines;
    if (item->pos.line >= ptrarray_count(lines)) {
        return NULL;
    }
    const char *line = ptrarray_get(lines, item->pos.line);
    return line;
}

const char* traceback_item_get_filepath(traceback_item_t *item) {
    if (!item->pos.file) {
        return NULL;
    }
    return item->pos.file->path;
}
//FILE_END
//FILE_START:frame.c
#include <stdlib.h>

#ifndef APE_AMALGAMATED
#include "frame.h"
#include "compiler.h"
#endif

bool frame_init(frame_t* frame, object_t function_obj, int base_pointer) {
    if (object_get_type(function_obj) != OBJECT_FUNCTION) {
        return false;
    }
    function_t* function = object_get_function(function_obj);
    frame->function = function_obj;
    frame->ip = 0;
    frame->base_pointer = base_pointer;
    frame->src_ip = 0;
    frame->bytecode = function->comp_result->bytecode;
    frame->src_positions = function->comp_result->src_positions;
    frame->bytecode_size = function->comp_result->count;
    frame->recover_ip = -1;
    frame->is_recovering = false;
    return true;
}

opcode_val_t frame_read_opcode(frame_t* frame){
    frame->src_ip = frame->ip;
    return frame_read_uint8(frame);
}

uint64_t frame_read_uint64(frame_t* frame) {
    const uint8_t *data = frame->bytecode + frame->ip;
    frame->ip += 8;
    uint64_t res = 0;
    res |= (uint64_t)data[7];
    res |= (uint64_t)data[6] << 8;
    res |= (uint64_t)data[5] << 16;
    res |= (uint64_t)data[4] << 24;
    res |= (uint64_t)data[3] << 32;
    res |= (uint64_t)data[2] << 40;
    res |= (uint64_t)data[1] << 48;
    res |= (uint64_t)data[0] << 56;
    return res;
}

uint16_t frame_read_uint16(frame_t* frame) {
    const uint8_t *data = frame->bytecode + frame->ip;
    frame->ip += 2;
    return (data[0] << 8) | data[1];
}

uint8_t frame_read_uint8(frame_t* frame) {
    const uint8_t *data = frame->bytecode + frame->ip;
    frame->ip++;
    return data[0];
}

src_pos_t frame_src_position(const frame_t *frame) {
    if (frame->src_positions) {
        return frame->src_positions[frame->src_ip];
    }
    return src_pos_invalid;
}
//FILE_END
//FILE_START:vm.c
#include <stdlib.h>
#include <stdio.h>
#include <float.h>
#include <math.h>

#ifndef APE_AMALGAMATED
#include "vm.h"

#include "code.h"
#include "compiler.h"
#include "traceback.h"
#include "builtins.h"
#include "gc.h"
#endif

static void set_sp(vm_t *vm, int new_sp);
static void stack_push(vm_t *vm, object_t obj);
static object_t stack_pop(vm_t *vm);
static object_t stack_get(vm_t *vm, int nth_item);

static void this_stack_push(vm_t *vm, object_t obj);
static object_t this_stack_pop(vm_t *vm);
static object_t this_stack_get(vm_t *vm, int nth_item);

static bool push_frame(vm_t *vm, frame_t frame);
static bool pop_frame(vm_t *vm);
static void run_gc(vm_t *vm, array(object_t) *constants);
static bool call_object(vm_t *vm, object_t callee, int num_args);
static object_t call_native_function(vm_t *vm, object_t callee, src_pos_t src_pos, int argc, object_t *args);
static bool check_assign(vm_t *vm, object_t old_value, object_t new_value);
static bool try_overload_operator(vm_t *vm, object_t left, object_t right, opcode_t op, bool *out_overload_found);

vm_t *vm_make(allocator_t *alloc, const ape_config_t *config, gcmem_t *mem, errors_t *errors, global_store_t *global_store) {
    vm_t *vm = allocator_malloc(alloc, sizeof(vm_t));
    if (!vm) {
        return NULL;
    }
    memset(vm, 0, sizeof(vm_t));
    vm->alloc = alloc;
    vm->config = config;
    vm->mem = mem;
    vm->errors = errors;
    vm->global_store = global_store;
    vm->globals_count = 0;
    vm->sp = 0;
    vm->this_sp = 0;
    vm->frames_count = 0;
    vm->last_popped = object_make_null();
    vm->running = false;

    for (int i = 0; i < OPCODE_MAX; i++) {
        vm->operator_oveload_keys[i] = object_make_null();
    }
#define SET_OPERATOR_OVERLOAD_KEY(op, key) do {\
    object_t key_obj = object_make_string(vm->mem, key);\
    if (object_is_null(key_obj)) {\
        goto err;\
    }\
    vm->operator_oveload_keys[op] = key_obj;\
} while (0)
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_ADD,     "__operator_add__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_SUB,     "__operator_sub__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_MUL,     "__operator_mul__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_DIV,     "__operator_div__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_MOD,     "__operator_mod__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_OR,      "__operator_or__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_XOR,     "__operator_xor__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_AND,     "__operator_and__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_LSHIFT,  "__operator_lshift__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_RSHIFT,  "__operator_rshift__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_MINUS,   "__operator_minus__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_BANG,    "__operator_bang__");
    SET_OPERATOR_OVERLOAD_KEY(OPCODE_COMPARE, "__cmp__");
#undef SET_OPERATOR_OVERLOAD_KEY

    return vm;
err:
    vm_destroy(vm);
    return NULL;
}

void vm_destroy(vm_t *vm) {
    if (!vm) {
        return;
    }
    allocator_free(vm->alloc, vm);
}

void vm_reset(vm_t *vm) {
    vm->sp = 0;
    vm->this_sp = 0;
    while (vm->frames_count > 0) {
        pop_frame(vm);
    }
}

bool vm_run(vm_t *vm, compilation_result_t *comp_res, array(object_t) *constants) {
#ifdef APE_DEBUG
    int old_sp = vm->sp;
#endif
    int old_this_sp = vm->this_sp;
    int old_frames_count = vm->frames_count;
    object_t main_fn = object_make_function(vm->mem, "main", comp_res, false, 0, 0, 0);
    if (object_is_null(main_fn)) {
        return false;
    }
    stack_push(vm, main_fn);
    bool res = vm_execute_function(vm, main_fn, constants);
    while (vm->frames_count > old_frames_count) {
        pop_frame(vm);
    }
    APE_ASSERT(vm->sp == old_sp);
    vm->this_sp = old_this_sp;
    return res;
}

object_t vm_call(vm_t *vm, array(object_t) *constants, object_t callee, int argc, object_t *args) {
    object_type_t type = object_get_type(callee);
    if (type == OBJECT_FUNCTION) {
#ifdef APE_DEBUG
        int old_sp = vm->sp;
#endif
        int old_this_sp = vm->this_sp;
        int old_frames_count = vm->frames_count;
        stack_push(vm, callee);
        for (int i = 0; i < argc; i++) {
            stack_push(vm, args[i]);
        }
        bool ok = vm_execute_function(vm, callee, constants);
        if (!ok) {
            return object_make_null();
        }
        while (vm->frames_count > old_frames_count) {
            pop_frame(vm);
        }
        APE_ASSERT(vm->sp == old_sp);
        vm->this_sp = old_this_sp;
        return vm_get_last_popped(vm);
    } else if (type == OBJECT_NATIVE_FUNCTION) {
        return call_native_function(vm, callee, src_pos_invalid, argc, args);
    } else {
        errors_add_error(vm->errors, ERROR_USER, src_pos_invalid, "Object is not callable");
        return object_make_null();
    }
}

bool vm_execute_function(vm_t *vm, object_t function, array(object_t) *constants) {
    if (vm->running) {
        errors_add_error(vm->errors, ERROR_USER, src_pos_invalid, "VM is already executing code");
        return false;
    }

    function_t *function_function = object_get_function(function); // naming is hard
    frame_t new_frame;
    bool ok = false;
    ok = frame_init(&new_frame, function, vm->sp - function_function->num_args);
    if (!ok) {
        return false;
    }
    ok = push_frame(vm, new_frame);
    if (!ok) {
        errors_add_error(vm->errors, ERROR_USER, src_pos_invalid, "Pushing frame failed");
        return false;
    }

    vm->running = true;
    vm->last_popped = object_make_null();

    bool check_time = false;
    double max_exec_time_ms = 0;
    if (vm->config) {
        check_time = vm->config->max_execution_time_set;
        max_exec_time_ms = vm->config->max_execution_time_ms;
    }
    unsigned time_check_interval = 1000;
    unsigned time_check_counter = 0;
    ape_timer_t timer;
    memset(&timer, 0, sizeof(ape_timer_t));
    if (check_time) {
        timer = ape_timer_start();
    }

    while (vm->current_frame->ip < vm->current_frame->bytecode_size) {
        opcode_val_t opcode = frame_read_opcode(vm->current_frame);
        switch (opcode) {
            case OPCODE_CONSTANT: {
                uint16_t constant_ix = frame_read_uint16(vm->current_frame);
                object_t *constant = array_get(constants, constant_ix);
                if (!constant) {
                    errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                      "Constant at %d not found", constant_ix);
                    goto err;
                }
                stack_push(vm, *constant);
                break;
            }
            case OPCODE_ADD:
            case OPCODE_SUB:
            case OPCODE_MUL:
            case OPCODE_DIV:
            case OPCODE_MOD:
            case OPCODE_OR:
            case OPCODE_XOR:
            case OPCODE_AND:
            case OPCODE_LSHIFT:
            case OPCODE_RSHIFT:
            {
                object_t right = stack_pop(vm);
                object_t left = stack_pop(vm);
                object_type_t left_type = object_get_type(left);
                object_type_t right_type = object_get_type(right);
                if (object_is_numeric(left) && object_is_numeric(right)) {
                    double right_val = object_get_number(right);
                    double left_val = object_get_number(left);

                    int64_t left_val_int = (int64_t)left_val;
                    int64_t right_val_int = (int64_t)right_val;

                    double res = 0;
                    switch (opcode) {
                        case OPCODE_ADD:    res = left_val + right_val; break;
                        case OPCODE_SUB:    res = left_val - right_val; break;
                        case OPCODE_MUL:    res = left_val * right_val; break;
                        case OPCODE_DIV:    res = left_val / right_val; break;
                        case OPCODE_MOD:    res = fmod(left_val, right_val); break;
                        case OPCODE_OR:     res = (double)(left_val_int | right_val_int); break;
                        case OPCODE_XOR:    res = (double)(left_val_int ^ right_val_int); break;
                        case OPCODE_AND:    res = (double)(left_val_int & right_val_int); break;
                        case OPCODE_LSHIFT: res = (double)(left_val_int << right_val_int); break;
                        case OPCODE_RSHIFT: res = (double)(left_val_int >> right_val_int); break;
                        default: APE_ASSERT(false); break;
                    }
                    stack_push(vm, object_make_number(res));
                } else if (left_type == OBJECT_STRING  && right_type == OBJECT_STRING && opcode == OPCODE_ADD) {
                    int left_len = (int)object_get_string_length(left);
                    int right_len = (int)object_get_string_length(right);

                    if (left_len == 0) {
                        stack_push(vm, right);
                    } else if (right_len == 0) {
                        stack_push(vm, left);
                    } else {
                        const char* left_val = object_get_string(left);
                        const char* right_val = object_get_string(right);

                        object_t res = object_make_string_with_capacity(vm->mem, left_len + right_len);
                        if (object_is_null(res)) {
                            goto err;
                        }

                        ok = object_string_append(res, left_val, left_len);
                        if (!ok) {
                            goto err;
                        }

                        ok = object_string_append(res, right_val, right_len);
                        if (!ok) {
                            goto err;
                        }
                        stack_push(vm, res);
                    }
                } else {
                    bool overload_found = false;
                    bool ok = try_overload_operator(vm, left, right, opcode, &overload_found);
                    if (!ok) {
                        goto err;
                    }
                    if (!overload_found) {
                        const char *opcode_name = opcode_get_name(opcode);
                        const char *left_type_name = object_get_type_name(left_type);
                        const char *right_type_name = object_get_type_name(right_type);
                        errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                          "Invalid operand types for %s, got %s and %s",
                                          opcode_name, left_type_name, right_type_name);
                        goto err;
                    }
                }
                break;
            }
            case OPCODE_POP: {
                stack_pop(vm);
                break;
            }
            case OPCODE_TRUE: {
                stack_push(vm, object_make_bool(true));
                break;
            }
            case OPCODE_FALSE: {
                stack_push(vm, object_make_bool(false));
                break;
            }
            case OPCODE_COMPARE:
            case OPCODE_COMPARE_EQ:
            {
                object_t right = stack_pop(vm);
                object_t left = stack_pop(vm);
                bool is_overloaded = false;
                bool ok = try_overload_operator(vm, left, right, OPCODE_COMPARE, &is_overloaded);
                if (!ok) {
                    goto err;
                }
                if (!is_overloaded) {
                    double comparison_res = object_compare(left, right, &ok);
                    if (ok || opcode == OPCODE_COMPARE_EQ) {
                        object_t res = object_make_number(comparison_res);
                        stack_push(vm, res);
                    } else {
                        const char *right_type_string = object_get_type_name(object_get_type(right));
                        const char *left_type_string = object_get_type_name(object_get_type(left));
                        errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                          "Cannot compare %s and %s",
                                          left_type_string, right_type_string);
                        goto err;
                    }
                }
                break;
            }
            case OPCODE_EQUAL:
            case OPCODE_NOT_EQUAL:
            case OPCODE_GREATER_THAN:
            case OPCODE_GREATER_THAN_EQUAL:
            {
                object_t value = stack_pop(vm);
                double comparison_res = object_get_number(value);
                bool res_val = false;
                switch (opcode) {
                    case OPCODE_EQUAL: res_val = APE_DBLEQ(comparison_res, 0); break;
                    case OPCODE_NOT_EQUAL: res_val = !APE_DBLEQ(comparison_res, 0); break;
                    case OPCODE_GREATER_THAN: res_val = comparison_res > 0; break;
                    case OPCODE_GREATER_THAN_EQUAL: {
                        res_val = comparison_res > 0 || APE_DBLEQ(comparison_res, 0);
                        break;
                    }
                    default: APE_ASSERT(false); break;
                }
                object_t res = object_make_bool(res_val);
                stack_push(vm, res);
                break;
            }
            case OPCODE_MINUS:
            {
                object_t operand = stack_pop(vm);
                object_type_t operand_type = object_get_type(operand);
                if (operand_type == OBJECT_NUMBER) {
                    double val = object_get_number(operand);
                    object_t res = object_make_number(-val);
                    stack_push(vm, res);
                } else {
                    bool overload_found = false;
                    bool ok = try_overload_operator(vm, operand, object_make_null(), OPCODE_MINUS, &overload_found);
                    if (!ok) {
                        goto err;
                    }
                    if (!overload_found) {
                        const char *operand_type_string = object_get_type_name(operand_type);
                        errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                          "Invalid operand type for MINUS, got %s",
                                          operand_type_string);
                        goto err;
                    }
                }
                break;
            }
            case OPCODE_BANG: {
                object_t operand = stack_pop(vm);
                object_type_t type = object_get_type(operand);
                if (type == OBJECT_BOOL) {
                    object_t res = object_make_bool(!object_get_bool(operand));
                    stack_push(vm, res);
                } else if (type == OBJECT_NULL) {
                    object_t res = object_make_bool(true);
                    stack_push(vm, res);
                } else {
                    bool overload_found = false;
                    bool ok = try_overload_operator(vm, operand, object_make_null(), OPCODE_BANG, &overload_found);
                    if (!ok) {
                        goto err;
                    }
                    if (!overload_found) {
                        object_t res = object_make_bool(false);
                        stack_push(vm, res);
                    }
                }
                break;
            }
            case OPCODE_JUMP: {
                uint16_t pos = frame_read_uint16(vm->current_frame);
                vm->current_frame->ip = pos;
                break;
            }
            case OPCODE_JUMP_IF_FALSE: {
                uint16_t pos = frame_read_uint16(vm->current_frame);
                object_t test = stack_pop(vm);
                if (!object_get_bool(test)) {
                    vm->current_frame->ip = pos;
                }
                break;
            }
            case OPCODE_JUMP_IF_TRUE: {
                uint16_t pos = frame_read_uint16(vm->current_frame);
                object_t test = stack_pop(vm);
                if (object_get_bool(test)) {
                    vm->current_frame->ip = pos;
                }
                break;
            }
            case OPCODE_NULL: {
                stack_push(vm, object_make_null());
                break;
            }
            case OPCODE_DEFINE_MODULE_GLOBAL: {
                uint16_t ix = frame_read_uint16(vm->current_frame);
                object_t value = stack_pop(vm);
                vm_set_global(vm, ix, value);
                break;
            }
            case OPCODE_SET_MODULE_GLOBAL: {
                uint16_t ix = frame_read_uint16(vm->current_frame);
                object_t new_value = stack_pop(vm);
                object_t old_value = vm_get_global(vm, ix);
                if (!check_assign(vm, old_value, new_value)) {
                    goto err;
                }
                vm_set_global(vm, ix, new_value);
                break;
            }
            case OPCODE_GET_MODULE_GLOBAL: {
                uint16_t ix = frame_read_uint16(vm->current_frame);
                object_t global = vm->globals[ix];
                stack_push(vm, global);
                break;
            }
            case OPCODE_ARRAY: {
                uint16_t count = frame_read_uint16(vm->current_frame);
                object_t array_obj = object_make_array_with_capacity(vm->mem, count);
                if (object_is_null(array_obj)) {
                    goto err;
                }
                object_t *items = vm->stack + vm->sp - count;
                for (int i = 0; i < count; i++) {
                    object_t item = items[i];
                    ok = object_add_array_value(array_obj, item);
                    if (!ok) {
                        goto err;
                    }
                }
                set_sp(vm, vm->sp - count);
                stack_push(vm, array_obj);
                break;
            }
            case OPCODE_MAP_START: {
                uint16_t count = frame_read_uint16(vm->current_frame);
                object_t map_obj = object_make_map_with_capacity(vm->mem, count);
                if (object_is_null(map_obj)) {
                    goto err;
                }
                this_stack_push(vm, map_obj);
                break;
            }
            case OPCODE_MAP_END: {
                uint16_t kvp_count = frame_read_uint16(vm->current_frame);
                uint16_t items_count = kvp_count * 2;
                object_t map_obj = this_stack_pop(vm);
                object_t *kv_pairs = vm->stack + vm->sp - items_count;
                for (int i = 0; i < items_count; i += 2) {
                    object_t key = kv_pairs[i];
                    if (!object_is_hashable(key)) {
                        object_type_t key_type = object_get_type(key);
                        const char *key_type_name = object_get_type_name(key_type);
                        errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                          "Key of type %s is not hashable", key_type_name);
                        goto err;
                    }
                    object_t val = kv_pairs[i + 1];
                    ok = object_set_map_value(map_obj, key, val);
                    if (!ok) {
                        goto err;
                    }
                }
                set_sp(vm, vm->sp - items_count);
                stack_push(vm, map_obj);
                break;
            }
            case OPCODE_GET_THIS: {
                object_t obj = this_stack_get(vm, 0);
                stack_push(vm, obj);
                break;
            }
            case OPCODE_GET_INDEX: {
                object_t index = stack_pop(vm);
                object_t left = stack_pop(vm);
                object_type_t left_type = object_get_type(left);
                object_type_t index_type = object_get_type(index);
                const char *left_type_name = object_get_type_name(left_type);
                const char *index_type_name = object_get_type_name(index_type);

                if (left_type != OBJECT_ARRAY && left_type != OBJECT_MAP && left_type != OBJECT_STRING) {
                    errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                      "Type %s is not indexable", left_type_name);
                    goto err;
                }

                object_t res = object_make_null();

                if (left_type == OBJECT_ARRAY) {
                    if (index_type != OBJECT_NUMBER) {
                        errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                          "Cannot index %s with %s", left_type_name, index_type_name);
                        goto err;
                    }
                    int ix = (int)object_get_number(index);
                    if (ix < 0) {
                        ix = object_get_array_length(left) + ix;
                    }
                    if (ix >= 0 && ix < object_get_array_length(left)) {
                        res = object_get_array_value_at(left, ix);
                    }
                } else if (left_type == OBJECT_MAP) {
                    res = object_get_map_value(left, index);
                } else if (left_type == OBJECT_STRING) {
                    const char *str = object_get_string(left);
                    int left_len = object_get_string_length(left);
                    int ix = (int)object_get_number(index);
                    if (ix >= 0 && ix < left_len) {
                        char res_str[2] = {str[ix], '\0'};
                        res = object_make_string(vm->mem, res_str);
                    }
                }
                stack_push(vm, res);
                break;
            }
            case OPCODE_GET_VALUE_AT: {
                object_t index = stack_pop(vm);
                object_t left = stack_pop(vm);
                object_type_t left_type = object_get_type(left);
                object_type_t index_type = object_get_type(index);
                const char *left_type_name = object_get_type_name(left_type);
                const char *index_type_name = object_get_type_name(index_type);

                if (left_type != OBJECT_ARRAY && left_type != OBJECT_MAP && left_type != OBJECT_STRING) {
                    errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                      "Type %s is not indexable", left_type_name);
                    goto err;
                }

                object_t res = object_make_null();
                if (index_type != OBJECT_NUMBER) {
                    errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                      "Cannot index %s with %s", left_type_name, index_type_name);
                    goto err;
                }
                int ix = (int)object_get_number(index);

                if (left_type == OBJECT_ARRAY) {
                    res = object_get_array_value_at(left, ix);
                } else if (left_type == OBJECT_MAP) {
                    res = object_get_kv_pair_at(vm->mem, left, ix);
                } else if (left_type == OBJECT_STRING) {
                    const char *str = object_get_string(left);
                    int left_len = object_get_string_length(left);
                    int ix = (int)object_get_number(index);
                    if (ix >= 0 && ix < left_len) {
                        char res_str[2] = {str[ix], '\0'};
                        res = object_make_string(vm->mem, res_str);
                    }
                }
                stack_push(vm, res);
                break;
            }
            case OPCODE_CALL: {
                uint8_t num_args = frame_read_uint8(vm->current_frame);
                object_t callee = stack_get(vm, num_args);
                bool ok = call_object(vm, callee, num_args);
                if (!ok) {
                    goto err;
                }
                break;
            }
            case OPCODE_RETURN_VALUE: {
                object_t res = stack_pop(vm);
                bool ok = pop_frame(vm);
                if (!ok) {
                    goto end;
                }
                stack_push(vm, res);
                break;
            }
            case OPCODE_RETURN: {
                bool ok = pop_frame(vm);
                stack_push(vm, object_make_null());
                if (!ok) {
                    stack_pop(vm);
                    goto end;
                }
                break;
            }
            case OPCODE_DEFINE_LOCAL: {
                uint8_t pos = frame_read_uint8(vm->current_frame);
                vm->stack[vm->current_frame->base_pointer + pos] = stack_pop(vm);
                break;
            }
            case OPCODE_SET_LOCAL: {
                uint8_t pos = frame_read_uint8(vm->current_frame);
                object_t new_value = stack_pop(vm);
                object_t old_value = vm->stack[vm->current_frame->base_pointer + pos];
                if (!check_assign(vm, old_value, new_value)) {
                    goto err;
                }
                vm->stack[vm->current_frame->base_pointer + pos] = new_value;
                break;
            }
            case OPCODE_GET_LOCAL: {
                uint8_t pos = frame_read_uint8(vm->current_frame);
                object_t val = vm->stack[vm->current_frame->base_pointer + pos];
                stack_push(vm, val);
                break;
            }
            case OPCODE_GET_APE_GLOBAL: {
                uint16_t ix = frame_read_uint16(vm->current_frame);
                bool ok = false;
                object_t val = global_store_get_object_at(vm->global_store, ix, &ok);
                if (!ok) {
                    errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame), "Global value %d not found", ix);
                    goto err;
                }
                stack_push(vm, val);
                break;
            }
            case OPCODE_FUNCTION: {
                uint16_t constant_ix = frame_read_uint16(vm->current_frame);
                uint8_t num_free = frame_read_uint8(vm->current_frame);
                object_t *constant = array_get(constants, constant_ix);
                if (!constant) {
                    errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame), "Constant %d not found", constant_ix);
                    goto err;
                }
                object_type_t constant_type = object_get_type(*constant);
                if (constant_type != OBJECT_FUNCTION) {
                    const char *type_name = object_get_type_name(constant_type);
                    errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame), "%s is not a function", type_name);
                    goto err;
                }

                const function_t *constant_function = object_get_function(*constant);
                object_t function_obj = object_make_function(vm->mem, object_get_function_name(*constant),
                                                            constant_function->comp_result, false,
                                                            constant_function->num_locals, constant_function->num_args,
                                                            num_free);
                if (object_is_null(function_obj)) {
                    goto err;
                }
                for (int i = 0; i < num_free; i++) {
                    object_t free_val = vm->stack[vm->sp - num_free + i];
                    object_set_function_free_val(function_obj, i, free_val);
                }
                set_sp(vm, vm->sp - num_free);
                stack_push(vm, function_obj);
                break;
            }
            case OPCODE_GET_FREE: {
                uint8_t free_ix = frame_read_uint8(vm->current_frame);
                object_t val = object_get_function_free_val(vm->current_frame->function, free_ix);
                stack_push(vm, val);
                break;
            }
            case OPCODE_SET_FREE: {
                uint8_t free_ix = frame_read_uint8(vm->current_frame);
                object_t val = stack_pop(vm);
                object_set_function_free_val(vm->current_frame->function, free_ix, val);
                break;
            }
            case OPCODE_CURRENT_FUNCTION: {
                object_t current_function = vm->current_frame->function;
                stack_push(vm, current_function);
                break;
            }
            case OPCODE_SET_INDEX: {
                object_t index = stack_pop(vm);
                object_t left = stack_pop(vm);
                object_t new_value = stack_pop(vm);
                object_type_t left_type = object_get_type(left);
                object_type_t index_type = object_get_type(index);
                const char *left_type_name = object_get_type_name(left_type);
                const char *index_type_name = object_get_type_name(index_type);

                if (left_type != OBJECT_ARRAY && left_type != OBJECT_MAP) {
                    errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                      "Type %s is not indexable", left_type_name);
                    goto err;
                }

                if (left_type == OBJECT_ARRAY) {
                    if (index_type != OBJECT_NUMBER) {
                        errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                          "Cannot index %s with %s", left_type_name, index_type_name);
                        goto err;
                    }
                    int ix = (int)object_get_number(index);
                    ok = object_set_array_value_at(left, ix, new_value);
                    if (!ok) {
                        errors_add_error(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame), "Setting array item failed (out of bounds?)");
                        goto err;
                    }
                } else if (left_type == OBJECT_MAP) {
                    object_t old_value = object_get_map_value(left, index);
                    if (!check_assign(vm, old_value, new_value)) {
                        goto err;
                    }
                    ok = object_set_map_value(left, index, new_value);
                    if (!ok) {
                        goto err;
                    }
                }
                break;
            }
            case OPCODE_DUP: {
                object_t val = stack_get(vm, 0);
                stack_push(vm, val);
                break;
            }
            case OPCODE_LEN: {
                object_t val = stack_pop(vm);
                int len = 0;
                object_type_t type = object_get_type(val);
                if (type == OBJECT_ARRAY) {
                    len = object_get_array_length(val);
                } else if (type == OBJECT_MAP) {
                    len = object_get_map_length(val);
                } else if (type == OBJECT_STRING) {
                    len = object_get_string_length(val);
                } else {
                    const char *type_name = object_get_type_name(type);
                    errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame), "Cannot get length of %s", type_name);
                    goto err;
                }
                stack_push(vm, object_make_number(len));
                break;
            }
            case OPCODE_NUMBER: {
                uint64_t val = frame_read_uint64(vm->current_frame);
                double val_double = ape_uint64_to_double(val);
                object_t obj = object_make_number(val_double);
                stack_push(vm, obj);
                break;
            }
            case OPCODE_SET_RECOVER: {
                uint16_t recover_ip = frame_read_uint16(vm->current_frame);
                vm->current_frame->recover_ip = recover_ip;
                break;
            }
            default: {
                APE_ASSERT(false);
                errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame), "Unknown opcode: 0x%x", opcode);
                goto err;
            }
        }

        if (check_time) {
            time_check_counter++;
            if (time_check_counter > time_check_interval) {
                int elapsed_ms = (int)ape_timer_get_elapsed_ms(&timer);
                if (elapsed_ms > max_exec_time_ms) {
                    errors_add_errorf(vm->errors, ERROR_TIME_OUT, frame_src_position(vm->current_frame), "Execution took more than %1.17g ms", max_exec_time_ms);
                    goto err;
                }
                time_check_counter = 0;
            }
        }
    err:
        if (errors_get_count(vm->errors) > 0) {
            error_t *err = errors_get_last_error(vm->errors);
            if (err->type == ERROR_RUNTIME && errors_get_count(vm->errors) == 1) {
                int recover_frame_ix = -1;
                for (int i = vm->frames_count - 1; i >= 0; i--) {
                    frame_t *frame = &vm->frames[i];
                    if (frame->recover_ip >= 0 && !frame->is_recovering) {
                        recover_frame_ix = i;
                        break;
                    }
                }
                if (recover_frame_ix < 0) {
                    goto end;
                } else {
                    if (!err->traceback) {
                        err->traceback = traceback_make(vm->alloc);
                    }
                    if (err->traceback) {
                        traceback_append_from_vm(err->traceback, vm);
                    }
                    while (vm->frames_count > (recover_frame_ix + 1)) {
                        pop_frame(vm);
                    }
                    object_t err_obj = object_make_error(vm->mem, err->message);
                    if (!object_is_null(err_obj)) {
                        object_set_error_traceback(err_obj, err->traceback);
                        err->traceback = NULL;
                    }
                    stack_push(vm, err_obj);
                    vm->current_frame->ip = vm->current_frame->recover_ip;
                    vm->current_frame->is_recovering = true;
                    errors_clear(vm->errors);
                }
            } else {
                goto end;
            }
        }
        if (gc_should_sweep(vm->mem)) {
            run_gc(vm, constants);
        }
    }

end:
    if (errors_get_count(vm->errors) > 0) {
        error_t *err = errors_get_last_error(vm->errors);
        if (!err->traceback) {
            err->traceback = traceback_make(vm->alloc);
        }
        if (err->traceback) {
            traceback_append_from_vm(err->traceback, vm);
        }
    }

    run_gc(vm, constants);

    vm->running = false;
    return errors_get_count(vm->errors) == 0;
}

object_t vm_get_last_popped(vm_t *vm) {
    return vm->last_popped;
}

bool vm_has_errors(vm_t *vm) {
    return errors_get_count(vm->errors) > 0;
}

bool vm_set_global(vm_t *vm, int ix, object_t val) {
    if (ix >= VM_MAX_GLOBALS) {
        APE_ASSERT(false);
        errors_add_error(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame), "Global write out of range");
        return false;
    }
    vm->globals[ix] = val;
    if (ix >= vm->globals_count) {
        vm->globals_count = ix + 1;
    }
    return true;
}

object_t vm_get_global(vm_t *vm, int ix) {
    if (ix >= VM_MAX_GLOBALS) {
        APE_ASSERT(false);
        errors_add_error(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame), "Global read out of range");
        return object_make_null();
    }
    return vm->globals[ix];
}

// INTERNAL
static void set_sp(vm_t *vm, int new_sp) {
    if (new_sp > vm->sp) { // to avoid gcing freed objects
        int count = new_sp - vm->sp;
        size_t bytes_count = count * sizeof(object_t);
        memset(vm->stack + vm->sp, 0, bytes_count);
    }
    vm->sp = new_sp;
}

static void stack_push(vm_t *vm, object_t obj) {
#ifdef APE_DEBUG
    if (vm->sp >= VM_STACK_SIZE) {
        APE_ASSERT(false);
        errors_add_error(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame), "Stack overflow");
        return;
    }
    if (vm->current_frame) {
        frame_t *frame = vm->current_frame;
        function_t *current_function = object_get_function(frame->function);
        int num_locals = current_function->num_locals;
        APE_ASSERT(vm->sp >= (frame->base_pointer + num_locals));
    }
#endif
    vm->stack[vm->sp] = obj;
    vm->sp++;
}

static object_t stack_pop(vm_t *vm) {
#ifdef APE_DEBUG
    if (vm->sp == 0) {
        errors_add_error(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame), "Stack underflow");
        APE_ASSERT(false);
        return object_make_null();
    }
    if (vm->current_frame) {
        frame_t *frame = vm->current_frame;
        function_t *current_function = object_get_function(frame->function);
        int num_locals = current_function->num_locals;
        APE_ASSERT((vm->sp - 1) >= (frame->base_pointer + num_locals));
    }
#endif
    vm->sp--;
    object_t res = vm->stack[vm->sp];
    vm->last_popped = res;
    return res;
}

static object_t stack_get(vm_t *vm, int nth_item) {
    int ix = vm->sp - 1 - nth_item;
#ifdef APE_DEBUG
    if (ix < 0 || ix >= VM_STACK_SIZE) {
        errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                  "Invalid stack index: %d", nth_item);
        APE_ASSERT(false);
        return object_make_null();
    }
#endif
    return vm->stack[ix];
}

static void this_stack_push(vm_t *vm, object_t obj) {
#ifdef APE_DEBUG
    if (vm->this_sp >= VM_THIS_STACK_SIZE) {
        APE_ASSERT(false);
        errors_add_error(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame), "this stack overflow");
        return;
    }
#endif
    vm->this_stack[vm->this_sp] = obj;
    vm->this_sp++;
}

static object_t this_stack_pop(vm_t *vm) {
#ifdef APE_DEBUG
    if (vm->this_sp == 0) {
        errors_add_error(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame), "this stack underflow");
        APE_ASSERT(false);
        return object_make_null();
    }
#endif
    vm->this_sp--;
    return vm->this_stack[vm->this_sp];
}

static object_t this_stack_get(vm_t *vm, int nth_item) {
    int ix = vm->this_sp - 1 - nth_item;
#ifdef APE_DEBUG
    if (ix < 0 || ix >= VM_THIS_STACK_SIZE) {
        errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                   "Invalid this stack index: %d", nth_item);
        APE_ASSERT(false);
        return object_make_null();
    }
#endif
    return vm->this_stack[ix];
}

static bool push_frame(vm_t *vm, frame_t frame) {
    if (vm->frames_count >= VM_MAX_FRAMES) {
        APE_ASSERT(false);
        return false;
    }
    vm->frames[vm->frames_count] = frame;
    vm->current_frame = &vm->frames[vm->frames_count];
    vm->frames_count++;
    function_t *frame_function = object_get_function(frame.function);
    set_sp(vm, frame.base_pointer + frame_function->num_locals);
    return true;
}

static bool pop_frame(vm_t *vm) {
    set_sp(vm, vm->current_frame->base_pointer - 1);
    if (vm->frames_count <= 0) {
        APE_ASSERT(false);
        vm->current_frame = NULL;
        return false;
    }
    vm->frames_count--;
    if (vm->frames_count == 0) {
        vm->current_frame = NULL;
        return false;
    }
    vm->current_frame = &vm->frames[vm->frames_count - 1];
    return true;
}

static void run_gc(vm_t *vm, array(object_t) *constants) {
    gc_unmark_all(vm->mem);
    gc_mark_objects(global_store_get_object_data(vm->global_store), global_store_get_object_count(vm->global_store));
    gc_mark_objects(array_data(constants), array_count(constants));
    gc_mark_objects(vm->globals, vm->globals_count);
    for (int i = 0; i < vm->frames_count; i++) {
        frame_t *frame = &vm->frames[i];
        gc_mark_object(frame->function);
    }
    gc_mark_objects(vm->stack, vm->sp);
    gc_mark_objects(vm->this_stack, vm->this_sp);
    gc_mark_object(vm->last_popped);
    gc_mark_objects(vm->operator_oveload_keys, OPCODE_MAX);
    gc_sweep(vm->mem);
}

static bool call_object(vm_t *vm, object_t callee, int num_args) {
    object_type_t callee_type = object_get_type(callee);
    if (callee_type == OBJECT_FUNCTION) {
        function_t *callee_function = object_get_function(callee);
        if (num_args != callee_function->num_args) {
            errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame),
                              "Invalid number of arguments to \"%s\", expected %d, got %d",
                              object_get_function_name(callee), callee_function->num_args, num_args);
            return false;
        }
        frame_t callee_frame;
        bool ok = frame_init(&callee_frame, callee, vm->sp - num_args);
        if (!ok) {
            errors_add_error(vm->errors, ERROR_RUNTIME, src_pos_invalid, "Frame init failed in call_object");
            return false;
        }
        ok = push_frame(vm, callee_frame);
        if (!ok) {
            errors_add_error(vm->errors, ERROR_RUNTIME, src_pos_invalid, "Pushing frame failed in call_object");
            return false;
        }
    } else if (callee_type == OBJECT_NATIVE_FUNCTION) {
        object_t *stack_pos = vm->stack + vm->sp - num_args;
        object_t res = call_native_function(vm, callee, frame_src_position(vm->current_frame), num_args, stack_pos);
        if (vm_has_errors(vm)) {
            return false;
        }
        set_sp(vm, vm->sp - num_args - 1);
        stack_push(vm, res);
    } else {
        const char *callee_type_name = object_get_type_name(callee_type);
        errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame),
                          "%s object is not callable", callee_type_name);
        return false;
    }
    return true;
}

static object_t call_native_function(vm_t *vm, object_t callee, src_pos_t src_pos, int argc, object_t *args) {
    native_function_t *native_fun = object_get_native_function(callee);
    object_t res = native_fun->fn(vm, native_fun->data, argc, args);
    if (errors_has_errors(vm->errors) && !APE_STREQ(native_fun->name, "crash")) {
        error_t *err = errors_get_last_error(vm->errors);
        err->pos = src_pos;
        err->traceback = traceback_make(vm->alloc);
        if (err->traceback) {
            traceback_append(err->traceback, native_fun->name, src_pos_invalid);
        }
        return object_make_null();
    }
    object_type_t res_type = object_get_type(res);
    if (res_type == OBJECT_ERROR) {
        traceback_t *traceback = traceback_make(vm->alloc);
        if (traceback) {
            // error builtin is treated in a special way
            if (!APE_STREQ(native_fun->name, "error")) {
                traceback_append(traceback, native_fun->name, src_pos_invalid);
            }
            traceback_append_from_vm(traceback, vm);
            object_set_error_traceback(res, traceback);
        }
    }
    return res;
}

static bool check_assign(vm_t *vm, object_t old_value, object_t new_value) {
    object_type_t old_value_type = object_get_type(old_value);
    object_type_t new_value_type = object_get_type(new_value);
    if (old_value_type == OBJECT_NULL || new_value_type == OBJECT_NULL) {
        return true;
    }
    if (old_value_type != new_value_type) {
        errors_add_errorf(vm->errors, ERROR_RUNTIME, frame_src_position(vm->current_frame),
                                   "Trying to assign variable of type %s to %s",
                                   object_get_type_name(new_value_type),
                                   object_get_type_name(old_value_type)
                                   );
        return false;
    }
    return true;
}

static bool try_overload_operator(vm_t *vm, object_t left, object_t right, opcode_t op, bool *out_overload_found) {
    *out_overload_found = false;
    object_type_t left_type = object_get_type(left);
    object_type_t right_type = object_get_type(right);
    if (left_type != OBJECT_MAP && right_type != OBJECT_MAP) {
        *out_overload_found = false;
        return true;
    }

    int num_operands = 2;
    if (op == OPCODE_MINUS || op == OPCODE_BANG) {
        num_operands = 1;
    }

    object_t key = vm->operator_oveload_keys[op];
    object_t callee = object_make_null();
    if (left_type == OBJECT_MAP) {
        callee = object_get_map_value(left, key);
    }
    if (!object_is_callable(callee)) {
        if (right_type == OBJECT_MAP) {
            callee = object_get_map_value(right, key);
        }

        if (!object_is_callable(callee)) {
            *out_overload_found = false;
            return true;
        }
    }

    *out_overload_found = true;

    stack_push(vm, callee);
    stack_push(vm, left);
    if (num_operands == 2) {
        stack_push(vm, right);
    }
    return call_object(vm, callee, num_operands);
}

//FILE_END
//FILE_START:ape.c
// #include "ape.h"

#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>

#define APE_IMPL_VERSION_MAJOR 0
#define APE_IMPL_VERSION_MINOR 15
#define APE_IMPL_VERSION_PATCH 0

#if (APE_VERSION_MAJOR != APE_IMPL_VERSION_MAJOR)\
 || (APE_VERSION_MINOR != APE_IMPL_VERSION_MINOR)\
 || (APE_VERSION_PATCH != APE_IMPL_VERSION_PATCH)
    #error "Version mismatch"
#endif

#ifndef APE_AMALGAMATED
#include "ape.h"
#include "gc.h"
#include "compiler.h"
#include "lexer.h"
#include "parser.h"
#include "vm.h"
#include "errors.h"
#include "symbol_table.h"
#include "traceback.h"
#include "global_store.h"
#endif

typedef struct native_fn_wrapper {
    ape_native_fn fn;
    ape_t *ape;
    void *data;
} native_fn_wrapper_t;

typedef struct ape_program {
    ape_t *ape;
    compilation_result_t *comp_res;
} ape_program_t;

typedef struct ape {
    allocator_t alloc;
    gcmem_t *mem;
    ptrarray(compiled_file_t) *files;
    global_store_t *global_store;
    compiler_t *compiler;
    vm_t *vm;
    errors_t errors;
    ape_config_t config;

    allocator_t custom_allocator;

} ape_t;

static void ape_deinit(ape_t *ape);
static object_t ape_native_fn_wrapper(vm_t *vm, void *data, int argc, object_t *args);
static object_t ape_object_to_object(ape_object_t obj);
static ape_object_t object_to_ape_object(object_t obj);
static ape_object_t ape_object_make_native_function_with_name(ape_t *ape, const char *name, ape_native_fn fn, void *data);

static void reset_state(ape_t *ape);
static void set_default_config(ape_t *ape);
static char* read_file_default(void *ctx, const char *filename);
static size_t write_file_default(void* context, const char *path, const char *string, size_t string_size);
static size_t stdout_write_default(void* context, const void *data, size_t size);

static void* ape_malloc(void *ctx, size_t size);
static void ape_free(void *ctx, void *ptr);

//-----------------------------------------------------------------------------
// Ape
//-----------------------------------------------------------------------------
ape_t *ape_make(void) {
    return ape_make_ex(NULL, NULL, NULL);
}

ape_t* ape_make_ex(ape_malloc_fn malloc_fn, ape_free_fn free_fn, void *ctx) {
    allocator_t custom_alloc = allocator_make((allocator_malloc_fn)malloc_fn, (allocator_free_fn)free_fn, ctx);

    ape_t *ape = allocator_malloc(&custom_alloc, sizeof(ape_t));
    if (!ape) {
        return NULL;
    }

    memset(ape, 0, sizeof(ape_t));
    ape->alloc = allocator_make(ape_malloc, ape_free, ape);
    ape->custom_allocator = custom_alloc;

    set_default_config(ape);

    errors_init(&ape->errors);

    ape->mem = gcmem_make(&ape->alloc);
    if (!ape->mem) {
        goto err;
    }

    ape->files = ptrarray_make(&ape->alloc);
    if (!ape->files) {
        goto err;
    }

    ape->global_store = global_store_make(&ape->alloc, ape->mem);
    if (!ape->global_store) {
        goto err;
    }

    ape->compiler = compiler_make(&ape->alloc, &ape->config, ape->mem, &ape->errors, ape->files, ape->global_store);
    if (!ape->compiler) {
        goto err;
    }

    ape->vm = vm_make(&ape->alloc, &ape->config, ape->mem, &ape->errors, ape->global_store);
    if (!ape->vm) {
        goto err;
    }

    return ape;
err:
    ape_deinit(ape);
    allocator_free(&custom_alloc, ape);
    return NULL;
}

void ape_destroy(ape_t *ape) {
    if (!ape) {
        return;
    }
    ape_deinit(ape);
    allocator_t alloc = ape->alloc;
    allocator_free(&alloc, ape);
}

void ape_free_allocated(ape_t *ape, void *ptr) {
    allocator_free(&ape->alloc, ptr);
}

void ape_set_repl_mode(ape_t *ape, bool enabled) {
    ape->config.repl_mode = enabled;
}

bool ape_set_timeout(ape_t *ape, double max_execution_time_ms) {
    if (!ape_timer_platform_supported()) {
        ape->config.max_execution_time_ms = 0;
        ape->config.max_execution_time_set = false;
        return false;
    }

    if (max_execution_time_ms >= 0) {
        ape->config.max_execution_time_ms = max_execution_time_ms;
        ape->config.max_execution_time_set = true;
    } else {
        ape->config.max_execution_time_ms = 0;
        ape->config.max_execution_time_set = false;
    }
    return true;
}

void ape_set_stdout_write_function(ape_t *ape, ape_stdout_write_fn stdout_write, void *context) {
    ape->config.stdio.write.write = stdout_write;
    ape->config.stdio.write.context = context;
}

void ape_set_file_write_function(ape_t *ape, ape_write_file_fn file_write, void *context) {
    ape->config.fileio.write_file.write_file = file_write;
    ape->config.fileio.write_file.context = context;
}

void ape_set_file_read_function(ape_t *ape, ape_read_file_fn file_read, void *context) {
    ape->config.fileio.read_file.read_file = file_read;
    ape->config.fileio.read_file.context = context;
}

ape_program_t* ape_compile(ape_t *ape, const char *code) {
    ape_clear_errors(ape);

    compilation_result_t *comp_res = NULL;

    comp_res = compiler_compile(ape->compiler, code, strlen(code));
    if (!comp_res || errors_get_count(&ape->errors) > 0) {
        goto err;
    }

    ape_program_t *program = allocator_malloc(&ape->alloc, sizeof(ape_program_t));
    if (!program) {
        goto err;
    }
    program->ape = ape;
    program->comp_res = comp_res;
    return program;

err:
    compilation_result_destroy(comp_res);
    return NULL;
}

ape_program_t* ape_compile_file(ape_t *ape, const char *path) {
    ape_clear_errors(ape);

    compilation_result_t *comp_res = NULL;

    comp_res = compiler_compile_file(ape->compiler, path);
    if (!comp_res || errors_get_count(&ape->errors) > 0) {
        goto err;
    }

    ape_program_t *program = allocator_malloc(&ape->alloc, sizeof(ape_program_t));
    if (!program) {
        goto err;
    }

    program->ape = ape;
    program->comp_res = comp_res;
    return program;

err:
    compilation_result_destroy(comp_res);
    return NULL;
}

ape_object_t ape_execute_program(ape_t *ape, const ape_program_t *program) {
    reset_state(ape);

    if (ape != program->ape) {
        errors_add_error(&ape->errors, ERROR_USER, src_pos_invalid, "ape program was compiled with a different ape instance");
        return ape_object_make_null();
    }

    bool ok = vm_run(ape->vm, program->comp_res, compiler_get_constants(ape->compiler));
    if (!ok || errors_get_count(&ape->errors) > 0) {
        return ape_object_make_null();
    }

    APE_ASSERT(ape->vm->sp == 0);

    object_t res = vm_get_last_popped(ape->vm);
    if (object_get_type(res) == OBJECT_NONE) {
        return ape_object_make_null();
    }

    return object_to_ape_object(res);
}

void ape_program_destroy(ape_program_t *program) {
    if (!program) {
        return;
    }
    compilation_result_destroy(program->comp_res);
    allocator_free(&program->ape->alloc, program);
}

ape_object_t ape_execute(ape_t *ape, const char *code, size_t len) {
    reset_state(ape);

    compilation_result_t *comp_res = NULL;

    comp_res = compiler_compile(ape->compiler, code, len);
    if (!comp_res || errors_get_count(&ape->errors) > 0) {
        goto err;
    }

    bool ok = vm_run(ape->vm, comp_res, compiler_get_constants(ape->compiler));
    if (!ok || errors_get_count(&ape->errors) > 0) {
        goto err;
    }

    APE_ASSERT(ape->vm->sp == 0);

    object_t res = vm_get_last_popped(ape->vm);
    if (object_get_type(res) == OBJECT_NONE) {
        goto err;
    }

    compilation_result_destroy(comp_res);

    return object_to_ape_object(res);

err:
    compilation_result_destroy(comp_res);
    return ape_object_make_null();
}

ape_object_t ape_execute_file(ape_t *ape, const char *path) {
    reset_state(ape);

    compilation_result_t *comp_res = NULL;

    comp_res = compiler_compile_file(ape->compiler, path);
    if (!comp_res || errors_get_count(&ape->errors) > 0) {
        goto err;
    }

    bool ok = vm_run(ape->vm, comp_res, compiler_get_constants(ape->compiler));
    if (!ok || errors_get_count(&ape->errors) > 0) {
        goto err;
    }

    APE_ASSERT(ape->vm->sp == 0);

    object_t res = vm_get_last_popped(ape->vm);
    if (object_get_type(res) == OBJECT_NONE) {
        goto err;
    }

    compilation_result_destroy(comp_res);

    return object_to_ape_object(res);

err:
    compilation_result_destroy(comp_res);
    return ape_object_make_null();
}

ape_object_t ape_call(ape_t *ape, const char *function_name, int argc, ape_object_t *args) {
    reset_state(ape);

    object_t callee = ape_object_to_object(ape_get_object(ape, function_name));
    if (object_get_type(callee) == OBJECT_NULL) {
        return ape_object_make_null();
    }
    object_t res = vm_call(ape->vm, compiler_get_constants(ape->compiler), callee, argc, (object_t*)args);
    if (errors_get_count(&ape->errors) > 0) {
        return ape_object_make_null();
    }
    return object_to_ape_object(res);
}

bool ape_has_errors(const ape_t *ape) {
    return ape_errors_count(ape) > 0;
}

int ape_errors_count(const ape_t *ape) {
    return errors_get_count(&ape->errors);
}

void ape_clear_errors(ape_t *ape) {
    errors_clear(&ape->errors);
}

const ape_error_t* ape_get_error(const ape_t *ape, int index) {
    return (const ape_error_t*)errors_getc(&ape->errors, index);
}

bool ape_set_native_function(ape_t *ape, const char *name, ape_native_fn fn, void *data) {
    ape_object_t obj = ape_object_make_native_function_with_name(ape, name, fn, data);
    if (ape_object_is_null(obj)) {
        return false;
    }
    return ape_set_global_constant(ape, name, obj);
}

bool ape_set_global_constant(ape_t *ape, const char *name, ape_object_t obj) {
    return global_store_set(ape->global_store, name, ape_object_to_object(obj));
}

ape_object_t ape_get_object(ape_t *ape, const char *name) {
    symbol_table_t *st = compiler_get_symbol_table(ape->compiler);
    const symbol_t *symbol = symbol_table_resolve(st, name);
    if (!symbol) {
        errors_add_errorf(&ape->errors, ERROR_USER, src_pos_invalid, "Symbol \"%s\" is not defined", name);
        return ape_object_make_null();
    }
    object_t res = object_make_null();
    if (symbol->type == SYMBOL_MODULE_GLOBAL) {
        res = vm_get_global(ape->vm, symbol->index);
    } else if (symbol->type == SYMBOL_APE_GLOBAL) {
        bool ok = false;
        res = global_store_get_object_at(ape->global_store, symbol->index, &ok);
        if (!ok) {
            errors_add_errorf(&ape->errors, ERROR_USER, src_pos_invalid, "Failed to get global object at %d", symbol->index);
            return ape_object_make_null();
        }
    } else {
        errors_add_errorf(&ape->errors, ERROR_USER, src_pos_invalid, "Value associated with symbol \"%s\" could not be loaded", name);
        return ape_object_make_null();
    }
    return object_to_ape_object(res);
}

bool ape_check_args(ape_t *ape, bool generate_error, int argc, ape_object_t *args, int expected_argc, int *expected_types) {
    if (argc != expected_argc) {
        if (generate_error) {
            ape_set_runtime_errorf(ape, "Invalid number or arguments, got %d instead of %d", argc, expected_argc);
        }
        return false;
    }

    for(int i = 0; i < argc; i++) {
        ape_object_t arg = args[i];
        ape_object_type_t type = ape_object_get_type(arg);
        ape_object_type_t expected_type = expected_types[i];
        if (!(type & expected_type)) {
            if (generate_error) {
                const char *type_str = ape_object_get_type_name(type);
                const char *expected_type_str = ape_object_get_type_name(expected_type);
                ape_set_runtime_errorf(ape, "Invalid argument type, got %s, expected %s", type_str, expected_type_str);
            }
            return false;
        }
    }
    return true;
}

//-----------------------------------------------------------------------------
// Ape object
//-----------------------------------------------------------------------------

ape_object_t ape_object_make_number(double val) {
    return object_to_ape_object(object_make_number(val));
}

ape_object_t ape_object_make_bool(bool val) {
    return object_to_ape_object(object_make_bool(val));
}

ape_object_t ape_object_make_string(ape_t *ape, const char *str) {
    return object_to_ape_object(object_make_string(ape->mem, str));
}

ape_object_t ape_object_make_stringf(ape_t *ape, const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    int to_write = vsnprintf(NULL, 0, fmt, args);
    va_end(args);
    va_start(args, fmt);
    object_t res = object_make_string_with_capacity(ape->mem, to_write);
    if (object_is_null(res)) {
        return ape_object_make_null();
    }
    char *res_buf = object_get_mutable_string(res);
    int written = vsprintf(res_buf, fmt, args);
    (void)written;
    APE_ASSERT(written == to_write);
    va_end(args);
    object_set_string_length(res, to_write);
    return object_to_ape_object(res);
}

ape_object_t ape_object_make_null() {
    return object_to_ape_object(object_make_null());
}

ape_object_t ape_object_make_array(ape_t *ape) {
    return object_to_ape_object(object_make_array(ape->mem));
}

ape_object_t ape_object_make_map(ape_t *ape) {
    return object_to_ape_object(object_make_map(ape->mem));
}

ape_object_t ape_object_make_native_function(ape_t *ape, ape_native_fn fn, void *data) {
    return ape_object_make_native_function_with_name(ape, "", fn, data);
}

ape_object_t ape_object_make_error(ape_t *ape, const char *msg) {
    return object_to_ape_object(object_make_error(ape->mem, msg));
}

ape_object_t ape_object_make_errorf(ape_t *ape, const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    int to_write = vsnprintf(NULL, 0, fmt, args);
    va_end(args);
    va_start(args, fmt);
    char *res = (char*)allocator_malloc(&ape->alloc, to_write + 1);
    if (!res) {
        return ape_object_make_null();
    }
    int written = vsprintf(res, fmt, args);
    (void)written;
    APE_ASSERT(written == to_write);
    va_end(args);
    return object_to_ape_object(object_make_error_no_copy(ape->mem, res));
}

ape_object_t ape_object_make_external(ape_t *ape, void *data) {
    object_t res = object_make_external(ape->mem, data);
    return object_to_ape_object(res);
}

char *ape_object_serialize(ape_t *ape, ape_object_t obj) {
    return object_serialize(&ape->alloc, ape_object_to_object(obj));
}

bool ape_object_disable_gc(ape_object_t ape_obj) {
    object_t obj = ape_object_to_object(ape_obj);
    return gc_disable_on_object(obj);
}

void ape_object_enable_gc(ape_object_t ape_obj) {
    object_t obj = ape_object_to_object(ape_obj);
    gc_enable_on_object(obj);
}

bool ape_object_equals(ape_object_t ape_a, ape_object_t ape_b){
    object_t a = ape_object_to_object(ape_a);
    object_t b = ape_object_to_object(ape_b);
    return object_equals(a, b);
}

bool ape_object_is_null(ape_object_t obj) {
    return ape_object_get_type(obj) == APE_OBJECT_NULL;
}

ape_object_t ape_object_copy(ape_object_t ape_obj) {
    object_t obj = ape_object_to_object(ape_obj);
    gcmem_t *mem = object_get_mem(obj);
    object_t res = object_copy(mem, obj);
    return object_to_ape_object(res);
}

ape_object_t ape_object_deep_copy(ape_object_t ape_obj) {
    object_t obj = ape_object_to_object(ape_obj);
    gcmem_t *mem = object_get_mem(obj);
    object_t res = object_deep_copy(mem, obj);
    return object_to_ape_object(res);
}

void ape_set_runtime_error(ape_t *ape, const char *message) {
    errors_add_error(&ape->errors, ERROR_RUNTIME, src_pos_invalid, message);
}

void ape_set_runtime_errorf(ape_t *ape, const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    int to_write = vsnprintf(NULL, 0, fmt, args);
    (void)to_write;
    va_end(args);
    va_start(args, fmt);
    char res[ERROR_MESSAGE_MAX_LENGTH];
    int written = vsnprintf(res, ERROR_MESSAGE_MAX_LENGTH, fmt, args);
    (void)written;
    APE_ASSERT(to_write == written);
    va_end(args);
    errors_add_error(&ape->errors, ERROR_RUNTIME, src_pos_invalid, res);
}

ape_object_type_t ape_object_get_type(ape_object_t ape_obj) {
    object_t obj = ape_object_to_object(ape_obj);
    switch (object_get_type(obj)) {
        case OBJECT_NONE:            return APE_OBJECT_NONE;
        case OBJECT_ERROR:           return APE_OBJECT_ERROR;
        case OBJECT_NUMBER:          return APE_OBJECT_NUMBER;
        case OBJECT_BOOL:            return APE_OBJECT_BOOL;
        case OBJECT_STRING:          return APE_OBJECT_STRING;
        case OBJECT_NULL:            return APE_OBJECT_NULL;
        case OBJECT_NATIVE_FUNCTION: return APE_OBJECT_NATIVE_FUNCTION;
        case OBJECT_ARRAY:           return APE_OBJECT_ARRAY;
        case OBJECT_MAP:             return APE_OBJECT_MAP;
        case OBJECT_FUNCTION:        return APE_OBJECT_FUNCTION;
        case OBJECT_EXTERNAL:        return APE_OBJECT_EXTERNAL;
        case OBJECT_FREED:           return APE_OBJECT_FREED;
        case OBJECT_ANY:             return APE_OBJECT_ANY;
        default:                     return APE_OBJECT_NONE;
    }
}

const char* ape_object_get_type_string(ape_object_t obj) {
    return ape_object_get_type_name(ape_object_get_type(obj));
}

const char* ape_object_get_type_name(ape_object_type_t type) {
    switch (type) {
        case APE_OBJECT_NONE:            return "NONE";
        case APE_OBJECT_ERROR:           return "ERROR";
        case APE_OBJECT_NUMBER:          return "NUMBER";
        case APE_OBJECT_BOOL:            return "BOOL";
        case APE_OBJECT_STRING:          return "STRING";
        case APE_OBJECT_NULL:            return "NULL";
        case APE_OBJECT_NATIVE_FUNCTION: return "NATIVE_FUNCTION";
        case APE_OBJECT_ARRAY:           return "ARRAY";
        case APE_OBJECT_MAP:             return "MAP";
        case APE_OBJECT_FUNCTION:        return "FUNCTION";
        case APE_OBJECT_EXTERNAL:        return "EXTERNAL";
        case APE_OBJECT_FREED:           return "FREED";
        case APE_OBJECT_ANY:             return "ANY";
        default:                         return "NONE";
    }
}

double ape_object_get_number(ape_object_t obj) {
    return object_get_number(ape_object_to_object(obj));
}

bool ape_object_get_bool(ape_object_t obj) {
    return object_get_bool(ape_object_to_object(obj));
}

const char *ape_object_get_string(ape_object_t obj) {
    return object_get_string(ape_object_to_object(obj));
}

void *ape_object_get_external(ape_object_t obj) {
    external_data_t* data = object_get_external_data(ape_object_to_object(obj));
    if(!data) {
        return NULL;
    }
    return data->data;
}

const char *ape_object_get_error_message(ape_object_t obj) {
    return object_get_error_message(ape_object_to_object(obj));
}

const ape_traceback_t* ape_object_get_error_traceback(ape_object_t ape_obj) {
    object_t obj = ape_object_to_object(ape_obj);
    return (const ape_traceback_t*)object_get_error_traceback(obj);
}

bool ape_object_set_external_destroy_function(ape_object_t object, ape_data_destroy_fn destroy_fn) {
    return object_set_external_destroy_function(ape_object_to_object(object), (external_data_destroy_fn)destroy_fn);
}

bool ape_object_set_external_copy_function(ape_object_t object, ape_data_copy_fn copy_fn) {
    return object_set_external_copy_function(ape_object_to_object(object), (external_data_copy_fn)copy_fn);
}

//-----------------------------------------------------------------------------
// Ape object array
//-----------------------------------------------------------------------------

int ape_object_get_array_length(ape_object_t obj) {
    return object_get_array_length(ape_object_to_object(obj));
}

ape_object_t ape_object_get_array_value(ape_object_t obj, int ix) {
    object_t res = object_get_array_value_at(ape_object_to_object(obj), ix);
    return object_to_ape_object(res);
}

const char* ape_object_get_array_string(ape_object_t obj, int ix) {
    ape_object_t object = ape_object_get_array_value(obj, ix);
    if (ape_object_get_type(object) != APE_OBJECT_STRING) {
        return NULL;
    }
    return ape_object_get_string(object);
}

double ape_object_get_array_number(ape_object_t obj, int ix) {
    ape_object_t object = ape_object_get_array_value(obj, ix);
    if (ape_object_get_type(object) != APE_OBJECT_NUMBER) {
        return 0;
    }
    return ape_object_get_number(object);
}

bool ape_object_get_array_bool(ape_object_t obj, int ix) {
    ape_object_t object = ape_object_get_array_value(obj, ix);
    if (ape_object_get_type(object) != APE_OBJECT_BOOL) {
        return 0;
    }
    return ape_object_get_bool(object);
}

bool ape_object_set_array_value(ape_object_t ape_obj, int ix, ape_object_t ape_value) {
    object_t obj = ape_object_to_object(ape_obj);
    object_t value = ape_object_to_object(ape_value);
    return object_set_array_value_at(obj, ix, value);
}

bool ape_object_set_array_string(ape_object_t obj, int ix, const char *string) {
    gcmem_t *mem = object_get_mem(ape_object_to_object(obj));
    if (!mem) {
        return false;
    }
    object_t new_value = object_make_string(mem, string);
    return ape_object_set_array_value(obj, ix, object_to_ape_object(new_value));
}

bool ape_object_set_array_number(ape_object_t obj, int ix, double number) {
    object_t new_value = object_make_number(number);
    return ape_object_set_array_value(obj, ix, object_to_ape_object(new_value));
}

bool ape_object_set_array_bool(ape_object_t obj, int ix, bool value) {
    object_t new_value = object_make_bool(value);
    return ape_object_set_array_value(obj, ix, object_to_ape_object(new_value));
}

bool ape_object_add_array_value(ape_object_t ape_obj, ape_object_t ape_value) {
    object_t obj = ape_object_to_object(ape_obj);
    object_t value = ape_object_to_object(ape_value);
    return object_add_array_value(obj, value);
}

bool ape_object_add_array_string(ape_object_t obj, const char *string) {
    gcmem_t *mem = object_get_mem(ape_object_to_object(obj));
    if (!mem) {
        return false;
    }
    object_t new_value = object_make_string(mem, string);
    return ape_object_add_array_value(obj, object_to_ape_object(new_value));
}

bool ape_object_add_array_number(ape_object_t obj, double number) {
    object_t new_value = object_make_number(number);
    return ape_object_add_array_value(obj, object_to_ape_object(new_value));
}

bool ape_object_add_array_bool(ape_object_t obj, bool value) {
    object_t new_value = object_make_bool(value);
    return ape_object_add_array_value(obj, object_to_ape_object(new_value));
}

//-----------------------------------------------------------------------------
// Ape object map
//-----------------------------------------------------------------------------

int ape_object_get_map_length(ape_object_t obj) {
    return object_get_map_length(ape_object_to_object(obj));
}

ape_object_t ape_object_get_map_key_at(ape_object_t ape_obj, int ix) {
    object_t obj = ape_object_to_object(ape_obj);
    return object_to_ape_object(object_get_map_key_at(obj, ix));
}

ape_object_t ape_object_get_map_value_at(ape_object_t ape_obj, int ix) {
    object_t obj = ape_object_to_object(ape_obj);
    object_t res = object_get_map_value_at(obj, ix);
    return object_to_ape_object(res);
}

bool ape_object_set_map_value_at(ape_object_t ape_obj, int ix, ape_object_t ape_val) {
    object_t obj = ape_object_to_object(ape_obj);
    object_t val = ape_object_to_object(ape_val);
    return object_set_map_value_at(obj, ix, val);
}

bool ape_object_set_map_value_with_value_key(ape_object_t obj, ape_object_t key, ape_object_t val) {
    return object_set_map_value(ape_object_to_object(obj), ape_object_to_object(key), ape_object_to_object(val));
}

bool ape_object_set_map_value(ape_object_t obj, const char *key, ape_object_t value) {
    gcmem_t *mem = object_get_mem(ape_object_to_object(obj));
    if (!mem) {
        return false;
    }
    object_t key_object = object_make_string(mem, key);
    if (object_is_null(key_object)) {
        return false;
    }
    return ape_object_set_map_value_with_value_key(obj, object_to_ape_object(key_object), value);
}

bool ape_object_set_map_string(ape_object_t obj, const char *key, const char *string) {
    gcmem_t *mem = object_get_mem(ape_object_to_object(obj));
    if (!mem) {
        return false;
    }
    object_t string_object = object_make_string(mem, string);
    if (object_is_null(string_object)) {
        return false;
    }
    return ape_object_set_map_value(obj, key, object_to_ape_object(string_object));
}

bool ape_object_set_map_number(ape_object_t obj, const char *key, double number) {
    object_t number_object = object_make_number(number);
    return ape_object_set_map_value(obj, key, object_to_ape_object(number_object));
}

bool ape_object_set_map_bool(ape_object_t obj, const char *key, bool value) {
    object_t bool_object = object_make_bool(value);
    return ape_object_set_map_value(obj, key, object_to_ape_object(bool_object));
}

ape_object_t ape_object_get_map_value_with_value_key(ape_object_t obj, ape_object_t key) {
    return object_to_ape_object(object_get_map_value(ape_object_to_object(obj), ape_object_to_object(key)));
}

ape_object_t ape_object_get_map_value(ape_object_t object, const char *key) {
    gcmem_t *mem = object_get_mem(ape_object_to_object(object));
    if (!mem) {
        return ape_object_make_null();
    }
    object_t key_object = object_make_string(mem, key);
    if (object_is_null(key_object)) {
        return ape_object_make_null();
    }
    ape_object_t res = ape_object_get_map_value_with_value_key(object, object_to_ape_object(key_object));
    return res;
}

const char* ape_object_get_map_string(ape_object_t object, const char *key) {
    ape_object_t res = ape_object_get_map_value(object, key);
    return ape_object_get_string(res);
}

double ape_object_get_map_number(ape_object_t object, const char *key) {
    ape_object_t res = ape_object_get_map_value(object, key);
    return ape_object_get_number(res);
}

bool ape_object_get_map_bool(ape_object_t object, const char *key) {
    ape_object_t res = ape_object_get_map_value(object, key);
    return ape_object_get_bool(res);
}

bool ape_object_map_has_key(ape_object_t ape_object, const char *key) {
    object_t object = ape_object_to_object(ape_object);
    gcmem_t *mem = object_get_mem(object);
    if (!mem) {
        return false;
    }
    object_t key_object = object_make_string(mem, key);
    if (object_is_null(key_object)) {
        return false;
    }
    return object_map_has_key(object, key_object);
}

//-----------------------------------------------------------------------------
// Ape error
//-----------------------------------------------------------------------------

const char* ape_error_get_message(const ape_error_t *ape_error) {
    const error_t *error = (const error_t*)ape_error;
    return error->message;
}

const char* ape_error_get_filepath(const ape_error_t *ape_error) {
    const error_t *error = (const error_t*)ape_error;
    if (!error->pos.file) {
        return NULL;
    }
    return error->pos.file->path;
}

const char* ape_error_get_line(const ape_error_t *ape_error) {
    const error_t *error = (const error_t*)ape_error;
    if (!error->pos.file) {
        return NULL;
    }
    ptrarray(char*) *lines = error->pos.file->lines;
    if (error->pos.line >= ptrarray_count(lines)) {
        return NULL;
    }
    const char *line = ptrarray_get(lines, error->pos.line);
    return line;
}

int ape_error_get_line_number(const ape_error_t *ape_error) {
    const error_t *error = (const error_t*)ape_error;
    if (error->pos.line < 0) {
        return -1;
    }
    return error->pos.line + 1;
}

int ape_error_get_column_number(const ape_error_t *ape_error) {
    const error_t *error = (const error_t*)ape_error;
    if (error->pos.column < 0) {
        return -1;
    }
    return error->pos.column + 1;
}

ape_error_type_t ape_error_get_type(const ape_error_t *ape_error) {
    const error_t *error = (const error_t*)ape_error;
    switch (error->type) {
        case ERROR_NONE:        return APE_ERROR_NONE;
        case ERROR_PARSING:     return APE_ERROR_PARSING;
        case ERROR_COMPILATION: return APE_ERROR_COMPILATION;
        case ERROR_RUNTIME:     return APE_ERROR_RUNTIME;
        case ERROR_TIME_OUT:    return APE_ERROR_TIMEOUT;
        case ERROR_ALLOCATION:  return APE_ERROR_ALLOCATION;
        case ERROR_USER:        return APE_ERROR_USER;
        default:                return APE_ERROR_NONE;
    }
}

const char* ape_error_get_type_string(const ape_error_t *error) {
    return ape_error_type_to_string(ape_error_get_type(error));
}

const char* ape_error_type_to_string(ape_error_type_t type) {
    switch (type) {
        case APE_ERROR_PARSING:     return "PARSING";
        case APE_ERROR_COMPILATION: return "COMPILATION";
        case APE_ERROR_RUNTIME:     return "RUNTIME";
        case APE_ERROR_TIMEOUT:     return "TIMEOUT";
        case APE_ERROR_ALLOCATION:  return "ALLOCATION";
        case APE_ERROR_USER:        return "USER";
        default:                    return "NONE";
    }
}

char* ape_error_serialize(ape_t *ape, const ape_error_t *err) {
    const char *type_str = ape_error_get_type_string(err);
    const char *filename = ape_error_get_filepath(err);
    const char *line = ape_error_get_line(err);
    int line_num = ape_error_get_line_number(err);
    int col_num = ape_error_get_column_number(err);
    strbuf_t *buf = strbuf_make(&ape->alloc);
    if (!buf) {
        return NULL;
    }
    if (line) {
        strbuf_append(buf, line);
        strbuf_append(buf, "\n");
        if (col_num >= 0) {
            for (int j = 0; j < (col_num - 1); j++) {
                strbuf_append(buf, " ");
            }
            strbuf_append(buf, "^\n");
        }
    }
    strbuf_appendf(buf, "%s ERROR in \"%s\" on %d:%d: %s\n", type_str,
           filename, line_num, col_num, ape_error_get_message(err));
    const ape_traceback_t *traceback = ape_error_get_traceback(err);
    if (traceback) {
        strbuf_appendf(buf, "Traceback:\n");
        traceback_to_string((const traceback_t*)ape_error_get_traceback(err), buf);
    }
    if (strbuf_failed(buf)) {
        strbuf_destroy(buf);
        return NULL;
    }
    return strbuf_get_string_and_destroy(buf);
}

const ape_traceback_t* ape_error_get_traceback(const ape_error_t *ape_error) {
    const error_t *error = (const error_t*)ape_error;
    return (const ape_traceback_t*)error->traceback;
}

//-----------------------------------------------------------------------------
// Ape traceback
//-----------------------------------------------------------------------------

int ape_traceback_get_depth(const ape_traceback_t *ape_traceback) {
    const traceback_t *traceback = (const traceback_t*)ape_traceback;
    return array_count(traceback->items);
}

const char* ape_traceback_get_filepath(const ape_traceback_t *ape_traceback, int depth) {
    const traceback_t *traceback = (const traceback_t*)ape_traceback;
    traceback_item_t *item = array_get(traceback->items, depth);
    if (!item) {
        return NULL;
    }
    return traceback_item_get_filepath(item);
}

const char* ape_traceback_get_line(const ape_traceback_t *ape_traceback, int depth) {
    const traceback_t *traceback = (const traceback_t*)ape_traceback;
    traceback_item_t *item = array_get(traceback->items, depth);
    if (!item) {
        return NULL;
    }
    return traceback_item_get_line(item);
}

int ape_traceback_get_line_number(const ape_traceback_t *ape_traceback, int depth) {
    const traceback_t *traceback = (const traceback_t*)ape_traceback;
    traceback_item_t *item = array_get(traceback->items, depth);
    if (!item) {
        return -1;
    }
    return item->pos.line;
}

int ape_traceback_get_column_number(const ape_traceback_t *ape_traceback, int depth) {
    const traceback_t *traceback = (const traceback_t*)ape_traceback;
    traceback_item_t *item = array_get(traceback->items, depth);
    if (!item) {
        return -1;
    }
    return item->pos.column;
}

const char* ape_traceback_get_function_name(const ape_traceback_t *ape_traceback, int depth) {
    const traceback_t *traceback = (const traceback_t*)ape_traceback;
    traceback_item_t *item = array_get(traceback->items, depth);
    if (!item) {
        return "";
    }
    return item->function_name;
}

//-----------------------------------------------------------------------------
// Ape internal
//-----------------------------------------------------------------------------
static void ape_deinit(ape_t *ape) {
    vm_destroy(ape->vm);
    compiler_destroy(ape->compiler);
    global_store_destroy(ape->global_store);
    gcmem_destroy(ape->mem);
    ptrarray_destroy_with_items(ape->files, compiled_file_destroy);
    errors_deinit(&ape->errors);
}

static object_t ape_native_fn_wrapper(vm_t *vm, void *data, int argc, object_t *args) {
    (void)vm;
    native_fn_wrapper_t *wrapper = (native_fn_wrapper_t*)data;
    APE_ASSERT(vm == wrapper->ape->vm);
    ape_object_t res = wrapper->fn(wrapper->ape, wrapper->data, argc, (ape_object_t*)args);
    if (ape_has_errors(wrapper->ape)) {
        return object_make_null();
    }
    return ape_object_to_object(res);
}

static object_t ape_object_to_object(ape_object_t obj) {
    return (object_t){ .handle = obj._internal };
}

static ape_object_t object_to_ape_object(object_t obj) {
    return (ape_object_t){ ._internal = obj.handle };
}

static ape_object_t ape_object_make_native_function_with_name(ape_t *ape, const char *name, ape_native_fn fn, void *data) {
    native_fn_wrapper_t wrapper;
    memset(&wrapper, 0, sizeof(native_fn_wrapper_t));
    wrapper.fn = fn;
    wrapper.ape = ape;
    wrapper.data = data;
    object_t wrapper_native_function = object_make_native_function(ape->mem, name, ape_native_fn_wrapper, &wrapper, sizeof(wrapper));
    if (object_is_null(wrapper_native_function)) {
        return ape_object_make_null();
    }
    return object_to_ape_object(wrapper_native_function);
}

static void reset_state(ape_t *ape) {
    ape_clear_errors(ape);
    vm_reset(ape->vm);
}

static void set_default_config(ape_t *ape) {
    memset(&ape->config, 0, sizeof(ape_config_t));
    ape_set_repl_mode(ape, false);
    ape_set_timeout(ape, -1);
    ape_set_file_read_function(ape, read_file_default, ape);
    ape_set_file_write_function(ape, write_file_default, ape);
    ape_set_stdout_write_function(ape, stdout_write_default, ape);
}

static char* read_file_default(void *ctx, const char *filename){
    ape_t *ape = (ape_t*)ctx;
    FILE *fp = fopen(filename, "r");
    size_t size_to_read = 0;
    size_t size_read = 0;
    long pos;
    char *file_contents;
    if (!fp) {
        return NULL;
    }
    fseek(fp, 0L, SEEK_END);
    pos = ftell(fp);
    if (pos < 0) {
        fclose(fp);
        return NULL;
    }
    size_to_read = pos;
    rewind(fp);
    file_contents = (char*)allocator_malloc(&ape->alloc, sizeof(char) * (size_to_read + 1));
    if (!file_contents) {
        fclose(fp);
        return NULL;
    }
    size_read = fread(file_contents, 1, size_to_read, fp);
    if (ferror(fp)) {
        fclose(fp);
        free(file_contents);
        return NULL;
    }
    fclose(fp);
    file_contents[size_read] = '\0';
    return file_contents;
}

static size_t write_file_default(void* ctx, const char *path, const char *string, size_t string_size) {
    (void)ctx;
    FILE *fp = fopen(path, "w");
    if (!fp) {
        return 0;
    }
    size_t written = fwrite(string, 1, string_size, fp);
    fclose(fp);
    return written;
}

static size_t stdout_write_default(void* ctx, const void *data, size_t size) {
    (void)ctx;
    return fwrite(data, 1, size, stdout);
}

static void* ape_malloc(void *ctx, size_t size) {
    ape_t *ape = (ape_t*)ctx;
    void *res = allocator_malloc(&ape->custom_allocator, size);
    if (!res) {
        errors_add_error(&ape->errors, ERROR_ALLOCATION, src_pos_invalid, "Allocation failed");
    }
    return res;
}

static void ape_free(void *ctx, void *ptr) {
    ape_t *ape = (ape_t*)ctx;
    allocator_free(&ape->custom_allocator, ptr);
}
//FILE_END


#include <curl/curl.h>





/*
Copyright (c) 2013-2021, tinydir authors:
- Cong Xu
- Lautis Sun
- Baudouin Feildel
- Andargor <andargor@yahoo.com>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#ifndef TINYDIR_H
#define TINYDIR_H

#ifdef __cplusplus
extern "C" {
#endif

#if ((defined _UNICODE) && !(defined UNICODE))
#define UNICODE
#endif

#if ((defined UNICODE) && !(defined _UNICODE))
#define _UNICODE
#endif

#include <errno.h>
#include <stdlib.h>
#include <string.h>
#ifdef _MSC_VER
# ifndef WIN32_LEAN_AND_MEAN
#  define WIN32_LEAN_AND_MEAN
# endif
# include <windows.h>
# include <tchar.h>
# pragma warning(push)
# pragma warning (disable : 4996)
#else
# include <dirent.h>
# include <libgen.h>
# include <sys/stat.h>
# include <stddef.h>
#endif
#ifdef __MINGW32__
# include <tchar.h>
#endif


/* types */

/* Windows UNICODE wide character support */
#if defined _MSC_VER || defined __MINGW32__
# define _tinydir_char_t TCHAR
# define TINYDIR_STRING(s) _TEXT(s)
# define _tinydir_strlen _tcslen
# define _tinydir_strcpy _tcscpy
# define _tinydir_strcat _tcscat
# define _tinydir_strcmp _tcscmp
# define _tinydir_strrchr _tcsrchr
# define _tinydir_strncmp _tcsncmp
#else
# define _tinydir_char_t char
# define TINYDIR_STRING(s) s
# define _tinydir_strlen strlen
# define _tinydir_strcpy strcpy
# define _tinydir_strcat strcat
# define _tinydir_strcmp strcmp
# define _tinydir_strrchr strrchr
# define _tinydir_strncmp strncmp
#endif

#if (defined _MSC_VER || defined __MINGW32__)
# include <windows.h>
# define _TINYDIR_PATH_MAX MAX_PATH
#elif defined  __linux__
# include <limits.h>
# ifdef PATH_MAX
#  define _TINYDIR_PATH_MAX PATH_MAX
# endif
#elif defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
# include <sys/param.h>
# if defined(BSD)
#  include <limits.h>
#  ifdef PATH_MAX
#   define _TINYDIR_PATH_MAX PATH_MAX
#  endif
# endif
#endif

#ifndef _TINYDIR_PATH_MAX
#define _TINYDIR_PATH_MAX 4096
#endif

#ifdef _MSC_VER
/* extra chars for the "\\*" mask */
# define _TINYDIR_PATH_EXTRA 2
#else
# define _TINYDIR_PATH_EXTRA 0
#endif

#define _TINYDIR_FILENAME_MAX 256

#if (defined _MSC_VER || defined __MINGW32__)
#define _TINYDIR_DRIVE_MAX 3
#endif

#ifdef _MSC_VER
# define _TINYDIR_FUNC static __inline
#elif !defined __STDC_VERSION__ || __STDC_VERSION__ < 199901L
# define _TINYDIR_FUNC static __inline__
#elif defined(__cplusplus)
# define _TINYDIR_FUNC static inline
#elif defined(__GNUC__)
/* Suppress unused function warning */
# define _TINYDIR_FUNC __attribute__((unused)) static
#else
# define _TINYDIR_FUNC static
#endif

/* readdir_r usage; define TINYDIR_USE_READDIR_R to use it (if supported) */
#ifdef TINYDIR_USE_READDIR_R

/* readdir_r is a POSIX-only function, and may not be available under various
 * environments/settings, e.g. MinGW. Use readdir fallback */
#if _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE ||\
	_POSIX_SOURCE
# define _TINYDIR_HAS_READDIR_R
#endif
#if _POSIX_C_SOURCE >= 200112L
# define _TINYDIR_HAS_FPATHCONF
# include <unistd.h>
#endif
#if _BSD_SOURCE || _SVID_SOURCE || \
	(_POSIX_C_SOURCE >= 200809L || _XOPEN_SOURCE >= 700)
# define _TINYDIR_HAS_DIRFD
# include <sys/types.h>
#endif
#if defined _TINYDIR_HAS_FPATHCONF && defined _TINYDIR_HAS_DIRFD &&\
	defined _PC_NAME_MAX
# define _TINYDIR_USE_FPATHCONF
#endif
#if defined __MINGW32__ || !defined _TINYDIR_HAS_READDIR_R ||\
	!(defined _TINYDIR_USE_FPATHCONF || defined NAME_MAX)
# define _TINYDIR_USE_READDIR
#endif

/* Use readdir by default */
#else
# define _TINYDIR_USE_READDIR
#endif

/* MINGW32 has two versions of dirent, ASCII and UNICODE*/
#ifndef _MSC_VER
#if (defined __MINGW32__) && (defined _UNICODE)
#define _TINYDIR_DIR _WDIR
#define _tinydir_dirent _wdirent
#define _tinydir_opendir _wopendir
#define _tinydir_readdir _wreaddir
#define _tinydir_closedir _wclosedir
#else
#define _TINYDIR_DIR DIR
#define _tinydir_dirent dirent
#define _tinydir_opendir opendir
#define _tinydir_readdir readdir
#define _tinydir_closedir closedir
#endif
#endif

/* Allow user to use a custom allocator by defining _TINYDIR_MALLOC and _TINYDIR_FREE. */
#if    defined(_TINYDIR_MALLOC) &&  defined(_TINYDIR_FREE)
#elif !defined(_TINYDIR_MALLOC) && !defined(_TINYDIR_FREE)
#else
#error "Either define both alloc and free or none of them!"
#endif

#if !defined(_TINYDIR_MALLOC)
	#define _TINYDIR_MALLOC(_size) malloc(_size)
	#define _TINYDIR_FREE(_ptr)    free(_ptr)
#endif /* !defined(_TINYDIR_MALLOC) */

typedef struct tinydir_file
{
	_tinydir_char_t path[_TINYDIR_PATH_MAX];
	_tinydir_char_t name[_TINYDIR_FILENAME_MAX];
	_tinydir_char_t *extension;
	int is_dir;
	int is_reg;

#ifndef _MSC_VER
#ifdef __MINGW32__
	struct _stat _s;
#else
	struct stat _s;
#endif
#endif
} tinydir_file;

typedef struct tinydir_dir
{
	_tinydir_char_t path[_TINYDIR_PATH_MAX];
	int has_next;
	size_t n_files;

	tinydir_file *_files;
#ifdef _MSC_VER
	HANDLE _h;
	WIN32_FIND_DATA _f;
#else
	_TINYDIR_DIR *_d;
	struct _tinydir_dirent *_e;
#ifndef _TINYDIR_USE_READDIR
	struct _tinydir_dirent *_ep;
#endif
#endif
} tinydir_dir;


/* declarations */

_TINYDIR_FUNC
int tinydir_open(tinydir_dir *dir, const _tinydir_char_t *path);
_TINYDIR_FUNC
int tinydir_open_sorted(tinydir_dir *dir, const _tinydir_char_t *path);
_TINYDIR_FUNC
void tinydir_close(tinydir_dir *dir);

_TINYDIR_FUNC
int tinydir_next(tinydir_dir *dir);
_TINYDIR_FUNC
int tinydir_readfile(const tinydir_dir *dir, tinydir_file *file);
_TINYDIR_FUNC
int tinydir_readfile_n(const tinydir_dir *dir, tinydir_file *file, size_t i);
_TINYDIR_FUNC
int tinydir_open_subdir_n(tinydir_dir *dir, size_t i);

_TINYDIR_FUNC
int tinydir_file_open(tinydir_file *file, const _tinydir_char_t *path);
_TINYDIR_FUNC
void _tinydir_get_ext(tinydir_file *file);
_TINYDIR_FUNC
int _tinydir_file_cmp(const void *a, const void *b);
#ifndef _MSC_VER
#ifndef _TINYDIR_USE_READDIR
_TINYDIR_FUNC
size_t _tinydir_dirent_buf_size(_TINYDIR_DIR *dirp);
#endif
#endif


/* definitions*/

_TINYDIR_FUNC
int tinydir_open(tinydir_dir *dir, const _tinydir_char_t *path)
{
#ifndef _MSC_VER
#ifndef _TINYDIR_USE_READDIR
	int error;
	int size;	/* using int size */
#endif
#else
	_tinydir_char_t path_buf[_TINYDIR_PATH_MAX];
#endif
	_tinydir_char_t *pathp;

	if (dir == NULL || path == NULL || _tinydir_strlen(path) == 0)
	{
		errno = EINVAL;
		return -1;
	}
	if (_tinydir_strlen(path) + _TINYDIR_PATH_EXTRA >= _TINYDIR_PATH_MAX)
	{
		errno = ENAMETOOLONG;
		return -1;
	}

	/* initialise dir */
	dir->_files = NULL;
#ifdef _MSC_VER
	dir->_h = INVALID_HANDLE_VALUE;
#else
	dir->_d = NULL;
#ifndef _TINYDIR_USE_READDIR
	dir->_ep = NULL;
#endif
#endif
	tinydir_close(dir);

	_tinydir_strcpy(dir->path, path);
	/* Remove trailing slashes */
	pathp = &dir->path[_tinydir_strlen(dir->path) - 1];
	while (pathp != dir->path && (*pathp == TINYDIR_STRING('\\') || *pathp == TINYDIR_STRING('/')))
	{
		*pathp = TINYDIR_STRING('\0');
		pathp++;
	}
#ifdef _MSC_VER
	_tinydir_strcpy(path_buf, dir->path);
	_tinydir_strcat(path_buf, TINYDIR_STRING("\\*"));
#if (defined WINAPI_FAMILY) && (WINAPI_FAMILY != WINAPI_FAMILY_DESKTOP_APP)
	dir->_h = FindFirstFileEx(path_buf, FindExInfoStandard, &dir->_f, FindExSearchNameMatch, NULL, 0);
#else
	dir->_h = FindFirstFile(path_buf, &dir->_f);
#endif
	if (dir->_h == INVALID_HANDLE_VALUE)
	{
		errno = ENOENT;
#else
	dir->_d = _tinydir_opendir(path);
	if (dir->_d == NULL)
	{
#endif
		goto bail;
	}

	/* read first file */
	dir->has_next = 1;
#ifndef _MSC_VER
#ifdef _TINYDIR_USE_READDIR
	dir->_e = _tinydir_readdir(dir->_d);
#else
	/* allocate dirent buffer for readdir_r */
	size = _tinydir_dirent_buf_size(dir->_d); /* conversion to int */
	if (size == -1) return -1;
	dir->_ep = (struct _tinydir_dirent*)_TINYDIR_MALLOC(size);
	if (dir->_ep == NULL) return -1;

	error = readdir_r(dir->_d, dir->_ep, &dir->_e);
	if (error != 0) return -1;
#endif
	if (dir->_e == NULL)
	{
		dir->has_next = 0;
	}
#endif

	return 0;

bail:
	tinydir_close(dir);
	return -1;
}

_TINYDIR_FUNC
int tinydir_open_sorted(tinydir_dir *dir, const _tinydir_char_t *path)
{
	/* Count the number of files first, to pre-allocate the files array */
	size_t n_files = 0;
	if (tinydir_open(dir, path) == -1)
	{
		return -1;
	}
	while (dir->has_next)
	{
		n_files++;
		if (tinydir_next(dir) == -1)
		{
			goto bail;
		}
	}
	tinydir_close(dir);

	if (n_files == 0 || tinydir_open(dir, path) == -1)
	{
		return -1;
	}

	dir->n_files = 0;
	dir->_files = (tinydir_file *)_TINYDIR_MALLOC(sizeof *dir->_files * n_files);
	if (dir->_files == NULL)
	{
		goto bail;
	}
	while (dir->has_next)
	{
		tinydir_file *p_file;
		dir->n_files++;

		p_file = &dir->_files[dir->n_files - 1];
		if (tinydir_readfile(dir, p_file) == -1)
		{
			goto bail;
		}

		if (tinydir_next(dir) == -1)
		{
			goto bail;
		}

		/* Just in case the number of files has changed between the first and
		second reads, terminate without writing into unallocated memory */
		if (dir->n_files == n_files)
		{
			break;
		}
	}

	qsort(dir->_files, dir->n_files, sizeof(tinydir_file), _tinydir_file_cmp);

	return 0;

bail:
	tinydir_close(dir);
	return -1;
}

_TINYDIR_FUNC
void tinydir_close(tinydir_dir *dir)
{
	if (dir == NULL)
	{
		return;
	}

	memset(dir->path, 0, sizeof(dir->path));
	dir->has_next = 0;
	dir->n_files = 0;
	_TINYDIR_FREE(dir->_files);
	dir->_files = NULL;
#ifdef _MSC_VER
	if (dir->_h != INVALID_HANDLE_VALUE)
	{
		FindClose(dir->_h);
	}
	dir->_h = INVALID_HANDLE_VALUE;
#else
	if (dir->_d)
	{
		_tinydir_closedir(dir->_d);
	}
	dir->_d = NULL;
	dir->_e = NULL;
#ifndef _TINYDIR_USE_READDIR
	_TINYDIR_FREE(dir->_ep);
	dir->_ep = NULL;
#endif
#endif
}

_TINYDIR_FUNC
int tinydir_next(tinydir_dir *dir)
{
	if (dir == NULL)
	{
		errno = EINVAL;
		return -1;
	}
	if (!dir->has_next)
	{
		errno = ENOENT;
		return -1;
	}

#ifdef _MSC_VER
	if (FindNextFile(dir->_h, &dir->_f) == 0)
#else
#ifdef _TINYDIR_USE_READDIR
	dir->_e = _tinydir_readdir(dir->_d);
#else
	if (dir->_ep == NULL)
	{
		return -1;
	}
	if (readdir_r(dir->_d, dir->_ep, &dir->_e) != 0)
	{
		return -1;
	}
#endif
	if (dir->_e == NULL)
#endif
	{
		dir->has_next = 0;
#ifdef _MSC_VER
		if (GetLastError() != ERROR_SUCCESS &&
			GetLastError() != ERROR_NO_MORE_FILES)
		{
			tinydir_close(dir);
			errno = EIO;
			return -1;
		}
#endif
	}

	return 0;
}

_TINYDIR_FUNC
int tinydir_readfile(const tinydir_dir *dir, tinydir_file *file)
{
	const _tinydir_char_t *filename;
	if (dir == NULL || file == NULL)
	{
		errno = EINVAL;
		return -1;
	}
#ifdef _MSC_VER
	if (dir->_h == INVALID_HANDLE_VALUE)
#else
	if (dir->_e == NULL)
#endif
	{
		errno = ENOENT;
		return -1;
	}
	filename =
#ifdef _MSC_VER
		dir->_f.cFileName;
#else
		dir->_e->d_name;
#endif
	if (_tinydir_strlen(dir->path) +
		_tinydir_strlen(filename) + 1 + _TINYDIR_PATH_EXTRA >=
		_TINYDIR_PATH_MAX)
	{
		/* the path for the file will be too long */
		errno = ENAMETOOLONG;
		return -1;
	}
	if (_tinydir_strlen(filename) >= _TINYDIR_FILENAME_MAX)
	{
		errno = ENAMETOOLONG;
		return -1;
	}

	_tinydir_strcpy(file->path, dir->path);
	if (_tinydir_strcmp(dir->path, TINYDIR_STRING("/")) != 0)
		_tinydir_strcat(file->path, TINYDIR_STRING("/"));
	_tinydir_strcpy(file->name, filename);
	_tinydir_strcat(file->path, filename);
#ifndef _MSC_VER
#ifdef __MINGW32__
	if (_tstat(
#elif (defined _BSD_SOURCE) || (defined _DEFAULT_SOURCE)	\
	|| ((defined _XOPEN_SOURCE) && (_XOPEN_SOURCE >= 500))	\
	|| ((defined _POSIX_C_SOURCE) && (_POSIX_C_SOURCE >= 200112L)) \
	|| ((defined __APPLE__) && (defined __MACH__)) \
	|| (defined BSD)
	if (lstat(
#else
	if (stat(
#endif
		file->path, &file->_s) == -1)
	{
		return -1;
	}
#endif
	_tinydir_get_ext(file);

	file->is_dir =
#ifdef _MSC_VER
		!!(dir->_f.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
#else
		S_ISDIR(file->_s.st_mode);
#endif
	file->is_reg =
#ifdef _MSC_VER
		!!(dir->_f.dwFileAttributes & FILE_ATTRIBUTE_NORMAL) ||
		(
			!(dir->_f.dwFileAttributes & FILE_ATTRIBUTE_DEVICE) &&
			!(dir->_f.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
			!(dir->_f.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) &&
#ifdef FILE_ATTRIBUTE_INTEGRITY_STREAM
			!(dir->_f.dwFileAttributes & FILE_ATTRIBUTE_INTEGRITY_STREAM) &&
#endif
#ifdef FILE_ATTRIBUTE_NO_SCRUB_DATA
			!(dir->_f.dwFileAttributes & FILE_ATTRIBUTE_NO_SCRUB_DATA) &&
#endif
			!(dir->_f.dwFileAttributes & FILE_ATTRIBUTE_OFFLINE) &&
			!(dir->_f.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY));
#else
		S_ISREG(file->_s.st_mode);
#endif

	return 0;
}

_TINYDIR_FUNC
int tinydir_readfile_n(const tinydir_dir *dir, tinydir_file *file, size_t i)
{
	if (dir == NULL || file == NULL)
	{
		errno = EINVAL;
		return -1;
	}
	if (i >= dir->n_files)
	{
		errno = ENOENT;
		return -1;
	}

	memcpy(file, &dir->_files[i], sizeof(tinydir_file));
	_tinydir_get_ext(file);

	return 0;
}

_TINYDIR_FUNC
int tinydir_open_subdir_n(tinydir_dir *dir, size_t i)
{
	_tinydir_char_t path[_TINYDIR_PATH_MAX];
	if (dir == NULL)
	{
		errno = EINVAL;
		return -1;
	}
	if (i >= dir->n_files || !dir->_files[i].is_dir)
	{
		errno = ENOENT;
		return -1;
	}

	_tinydir_strcpy(path, dir->_files[i].path);
	tinydir_close(dir);
	if (tinydir_open_sorted(dir, path) == -1)
	{
		return -1;
	}

	return 0;
}

/* Open a single file given its path */
_TINYDIR_FUNC
int tinydir_file_open(tinydir_file *file, const _tinydir_char_t *path)
{
	tinydir_dir dir;
	int result = 0;
	int found = 0;
	_tinydir_char_t dir_name_buf[_TINYDIR_PATH_MAX];
	_tinydir_char_t file_name_buf[_TINYDIR_FILENAME_MAX];
	_tinydir_char_t *dir_name;
	_tinydir_char_t *base_name;
#if (defined _MSC_VER || defined __MINGW32__)
	_tinydir_char_t drive_buf[_TINYDIR_PATH_MAX];
	_tinydir_char_t ext_buf[_TINYDIR_FILENAME_MAX];
#endif

	if (file == NULL || path == NULL || _tinydir_strlen(path) == 0)
	{
		errno = EINVAL;
		return -1;
	}
	if (_tinydir_strlen(path) + _TINYDIR_PATH_EXTRA >= _TINYDIR_PATH_MAX)
	{
		errno = ENAMETOOLONG;
		return -1;
	}

	/* Get the parent path */
#if (defined _MSC_VER || defined __MINGW32__)
#if ((defined _MSC_VER) && (_MSC_VER >= 1400))
	errno = _tsplitpath_s(
		path,
		drive_buf, _TINYDIR_DRIVE_MAX,
		dir_name_buf, _TINYDIR_FILENAME_MAX,
		file_name_buf, _TINYDIR_FILENAME_MAX,
		ext_buf, _TINYDIR_FILENAME_MAX);
#else
	_tsplitpath(
		path,
		drive_buf,
		dir_name_buf,
		file_name_buf,
		ext_buf);
#endif

	if (errno)
	{
		return -1;
	}

/* _splitpath_s not work fine with only filename and widechar support */
#ifdef _UNICODE
	if (drive_buf[0] == L'\xFEFE')
		drive_buf[0] = '\0';
	if (dir_name_buf[0] == L'\xFEFE')
		dir_name_buf[0] = '\0';
#endif

	/* Emulate the behavior of dirname by returning "." for dir name if it's
	empty */
	if (drive_buf[0] == '\0' && dir_name_buf[0] == '\0')
	{
		_tinydir_strcpy(dir_name_buf, TINYDIR_STRING("."));
	}
	/* Concatenate the drive letter and dir name to form full dir name */
	_tinydir_strcat(drive_buf, dir_name_buf);
	dir_name = drive_buf;
	/* Concatenate the file name and extension to form base name */
	_tinydir_strcat(file_name_buf, ext_buf);
	base_name = file_name_buf;
#else
	_tinydir_strcpy(dir_name_buf, path);
	dir_name = dirname(dir_name_buf);
	_tinydir_strcpy(file_name_buf, path);
	base_name = basename(file_name_buf);
#endif

	/* Special case: if the path is a root dir, open the parent dir as the file */
#if (defined _MSC_VER || defined __MINGW32__)
	if (_tinydir_strlen(base_name) == 0)
#else
	if ((_tinydir_strcmp(base_name, TINYDIR_STRING("/"))) == 0)
#endif
	{
		memset(file, 0, sizeof * file);
		file->is_dir = 1;
		file->is_reg = 0;
		_tinydir_strcpy(file->path, dir_name);
		file->extension = file->path + _tinydir_strlen(file->path);
		return 0;
	}

	/* Open the parent directory */
	if (tinydir_open(&dir, dir_name) == -1)
	{
		return -1;
	}

	/* Read through the parent directory and look for the file */
	while (dir.has_next)
	{
		if (tinydir_readfile(&dir, file) == -1)
		{
			result = -1;
			goto bail;
		}
		if (_tinydir_strcmp(file->name, base_name) == 0)
		{
			/* File found */
			found = 1;
			break;
		}
		tinydir_next(&dir);
	}
	if (!found)
	{
		result = -1;
		errno = ENOENT;
	}

bail:
	tinydir_close(&dir);
	return result;
}

_TINYDIR_FUNC
void _tinydir_get_ext(tinydir_file *file)
{
	_tinydir_char_t *period = _tinydir_strrchr(file->name, TINYDIR_STRING('.'));
	if (period == NULL)
	{
		file->extension = &(file->name[_tinydir_strlen(file->name)]);
	}
	else
	{
		file->extension = period + 1;
	}
}

_TINYDIR_FUNC
int _tinydir_file_cmp(const void *a, const void *b)
{
	const tinydir_file *fa = (const tinydir_file *)a;
	const tinydir_file *fb = (const tinydir_file *)b;
	if (fa->is_dir != fb->is_dir)
	{
		return -(fa->is_dir - fb->is_dir);
	}
	return _tinydir_strncmp(fa->name, fb->name, _TINYDIR_FILENAME_MAX);
}

#ifndef _MSC_VER
#ifndef _TINYDIR_USE_READDIR
/*
The following authored by Ben Hutchings <ben@decadent.org.uk>
from https://womble.decadent.org.uk/readdir_r-advisory.html
*/
/* Calculate the required buffer size (in bytes) for directory      *
* entries read from the given directory handle.  Return -1 if this  *
* this cannot be done.                                              *
*                                                                   *
* This code does not trust values of NAME_MAX that are less than    *
* 255, since some systems (including at least HP-UX) incorrectly    *
* define it to be a smaller value.                                  */
_TINYDIR_FUNC
size_t _tinydir_dirent_buf_size(_TINYDIR_DIR *dirp)
{
	long name_max;
	size_t name_end;
	/* parameter may be unused */
	(void)dirp;

#if defined _TINYDIR_USE_FPATHCONF
	name_max = fpathconf(dirfd(dirp), _PC_NAME_MAX);
	if (name_max == -1)
#if defined(NAME_MAX)
		name_max = (NAME_MAX > 255) ? NAME_MAX : 255;
#else
		return (size_t)(-1);
#endif
#elif defined(NAME_MAX)
 	name_max = (NAME_MAX > 255) ? NAME_MAX : 255;
#else
#error "buffer size for readdir_r cannot be determined"
#endif
	name_end = (size_t)offsetof(struct _tinydir_dirent, d_name) + name_max + 1;
	return (name_end > sizeof(struct _tinydir_dirent) ?
		name_end : sizeof(struct _tinydir_dirent));
}
#endif
#endif

#ifdef __cplusplus
}
#endif

# if defined (_MSC_VER)
# pragma warning(pop)
# endif

#endif



#define LITAC_DEFAULT_ALIGNMENT (2*sizeof(void*))

typedef enum litaC_main__ParseStatus {
    litaC_main__ParseStatus_OK,
    litaC_main__ParseStatus_ERROR,
    litaC_main__ParseStatus_TERMINATE
} litaC_main__ParseStatus;
typedef struct litaC_std__builtins__any litaC_std__builtins__any;
typedef struct litaC_std__mem__Allocator litaC_std__mem__Allocator;
typedef enum litaC_std__mem__linear_allocator__ExpandStrategy {
    litaC_std__mem__linear_allocator__ExpandStrategy_NO_ALLOC_MEMORY,
    litaC_std__mem__linear_allocator__ExpandStrategy_DOUBLE_MEMORY
} litaC_std__mem__linear_allocator__ExpandStrategy;
typedef struct litaC_std__mem__linear_allocator__ExpandInfo litaC_std__mem__linear_allocator__ExpandInfo;
typedef struct litaC_std__mem__linear_allocator__LinearAllocator litaC_std__mem__linear_allocator__LinearAllocator;
typedef struct litaC_std__io__File litaC_std__io__File;

typedef enum litaC_std__io__FileStatus {
    litaC_std__io__FileStatus_Ok = 0,
    litaC_std__io__FileStatus_FileNotFoundError,
    litaC_std__io__FileStatus_IOError
} litaC_std__io__FileStatus;
typedef enum litaC_std__io__FileOpenOp {
    litaC_std__io__FileOpenOp_READ_ONLY,
    litaC_std__io__FileOpenOp_READ_ONLY_BINARY,
    litaC_std__io__FileOpenOp_WRITE,
    litaC_std__io__FileOpenOp_WRITE_BINARY,
    litaC_std__io__FileOpenOp_WRITE_APPEND,
    litaC_std__io__FileOpenOp_WRITE_APPEND_BINARY
} litaC_std__io__FileOpenOp;
typedef enum litaC_std__cmdline__CmdParserStatus {
    litaC_std__cmdline__CmdParserStatus_OK,
    litaC_std__cmdline__CmdParserStatus_MISSING_ARGUMENT,
    litaC_std__cmdline__CmdParserStatus_MISSING_REQUIRED
} litaC_std__cmdline__CmdParserStatus;
typedef enum litaC_std__cmdline__OptionFlag {
    litaC_std__cmdline__OptionFlag_HAS_ARGUMENT = (1 << 0),
    litaC_std__cmdline__OptionFlag_IS_REQUIRED = (1 << 1),
    litaC_std__cmdline__OptionFlag_IS_USED = (1 << 2)
} litaC_std__cmdline__OptionFlag;
typedef struct litaC_std__cmdline__Option litaC_std__cmdline__Option;
typedef struct litaC_std__cmdline__CmdParser litaC_std__cmdline__CmdParser;
typedef struct litaC_std__string_buffer__StringBuffer litaC_std__string_buffer__StringBuffer;
typedef struct litaC_std__string_view__StringView litaC_std__string_view__StringView;
typedef struct litaC_std__string__String litaC_std__string__String;
typedef struct litaC_std__system__Process litaC_std__system__Process;
typedef enum litaC_std__map__KeyState {
    litaC_std__map__KeyState_EMPTY = 0,
    litaC_std__map__KeyState_TOMBSTONE
} litaC_std__map__KeyState;

typedef enum litaC_std__profile__ProfileTag {
    litaC_std__profile__ProfileTag_MAX_PROFILE_TAGS
} litaC_std__profile__ProfileTag;
typedef struct litaC_std__profile__ProfileEntry litaC_std__profile__ProfileEntry;
typedef enum litaC_std__http__HttpRequestType {
    litaC_std__http__HttpRequestType_GET,
    litaC_std__http__HttpRequestType_POST,
    litaC_std__http__HttpRequestType_PUT,
    litaC_std__http__HttpRequestType_DELETE
} litaC_std__http__HttpRequestType;
typedef struct litaC_std__http__HttpRequest litaC_std__http__HttpRequest;
typedef struct litaC_std__http__HttpResponse litaC_std__http__HttpResponse;
typedef struct litaC_std__http__HttpOptions litaC_std__http__HttpOptions;
typedef struct litaC_std__http__Http litaC_std__http__Http;

typedef enum litaC_lex__TokenType {
    litaC_lex__TokenType_IMPORT,
    litaC_lex__TokenType_STRUCT,
    litaC_lex__TokenType_UNION,
    litaC_lex__TokenType_TRAIT,
    litaC_lex__TokenType_ENUM,
    litaC_lex__TokenType_FUNC,
    litaC_lex__TokenType_TYPEDEF,
    litaC_lex__TokenType_NOTE,
    litaC_lex__TokenType_VAR,
    litaC_lex__TokenType_CONST,
    litaC_lex__TokenType_NULL,
    litaC_lex__TokenType_VOID,
    litaC_lex__TokenType_TRUE,
    litaC_lex__TokenType_FALSE,
    litaC_lex__TokenType_BOOL,
    litaC_lex__TokenType_CHAR,
    litaC_lex__TokenType_I8,
    litaC_lex__TokenType_U8,
    litaC_lex__TokenType_I16,
    litaC_lex__TokenType_U16,
    litaC_lex__TokenType_I32,
    litaC_lex__TokenType_U32,
    litaC_lex__TokenType_I64,
    litaC_lex__TokenType_U64,
    litaC_lex__TokenType_F32,
    litaC_lex__TokenType_F64,
    litaC_lex__TokenType_USIZE,
    litaC_lex__TokenType_FOR,
    litaC_lex__TokenType_WHILE,
    litaC_lex__TokenType_DO,
    litaC_lex__TokenType_IF,
    litaC_lex__TokenType_ELSE,
    litaC_lex__TokenType_SWITCH,
    litaC_lex__TokenType_CASE,
    litaC_lex__TokenType_DEFAULT,
    litaC_lex__TokenType_DEFER,
    litaC_lex__TokenType_BREAK,
    litaC_lex__TokenType_CONTINUE,
    litaC_lex__TokenType_RETURN,
    litaC_lex__TokenType_GOTO,
    litaC_lex__TokenType_SIZEOF,
    litaC_lex__TokenType_TYPEOF,
    litaC_lex__TokenType_OFFSETOF,
    litaC_lex__TokenType_AS,
    litaC_lex__TokenType_PUBLIC,
    litaC_lex__TokenType_INTERNAL,
    litaC_lex__TokenType_USING,
    litaC_lex__TokenType_PLUS,
    litaC_lex__TokenType_MINUS,
    litaC_lex__TokenType_STAR,
    litaC_lex__TokenType_MOD,
    litaC_lex__TokenType_SLASH,
    litaC_lex__TokenType_BACK_SLASH,
    litaC_lex__TokenType_DOLLAR,
    litaC_lex__TokenType_HASH,
    litaC_lex__TokenType_DOT,
    litaC_lex__TokenType_VAR_ARGS,
    litaC_lex__TokenType_AT,
    litaC_lex__TokenType_QUESTION_MARK,
    litaC_lex__TokenType_COMMA,
    litaC_lex__TokenType_SEMICOLON,
    litaC_lex__TokenType_COLON,
    litaC_lex__TokenType_COLON_COLON,
    litaC_lex__TokenType_DOUBLE_QUOTE,
    litaC_lex__TokenType_LESS_THAN,
    litaC_lex__TokenType_LESS_EQUALS,
    litaC_lex__TokenType_GREATER_THAN,
    litaC_lex__TokenType_GREATER_EQUALS,
    litaC_lex__TokenType_EQUALS_EQUALS,
    litaC_lex__TokenType_EQUALS,
    litaC_lex__TokenType_NOT_EQUALS,
    litaC_lex__TokenType_PLUS_EQ,
    litaC_lex__TokenType_MINUS_EQ,
    litaC_lex__TokenType_DIV_EQ,
    litaC_lex__TokenType_MUL_EQ,
    litaC_lex__TokenType_MOD_EQ,
    litaC_lex__TokenType_LSHIFT_EQ,
    litaC_lex__TokenType_RSHIFT_EQ,
    litaC_lex__TokenType_BNOT_EQ,
    litaC_lex__TokenType_XOR_EQ,
    litaC_lex__TokenType_BAND_EQ,
    litaC_lex__TokenType_BOR_EQ,
    litaC_lex__TokenType_LSHIFT,
    litaC_lex__TokenType_RSHIFT,
    litaC_lex__TokenType_BNOT,
    litaC_lex__TokenType_XOR,
    litaC_lex__TokenType_BAND,
    litaC_lex__TokenType_BOR,
    litaC_lex__TokenType_LEFT_PAREN,
    litaC_lex__TokenType_RIGHT_PAREN,
    litaC_lex__TokenType_LEFT_BRACKET,
    litaC_lex__TokenType_RIGHT_BRACKET,
    litaC_lex__TokenType_LEFT_BRACE,
    litaC_lex__TokenType_RIGHT_BRACE,
    litaC_lex__TokenType_NOT,
    litaC_lex__TokenType_OR,
    litaC_lex__TokenType_AND,
    litaC_lex__TokenType_STRING,
    litaC_lex__TokenType_IDENTIFIER,
    litaC_lex__TokenType_INT_NUMBER,
    litaC_lex__TokenType_FLOAT_NUMBER,
    litaC_lex__TokenType_ERROR,
    litaC_lex__TokenType_END_OF_FILE,
    litaC_lex__TokenType_MAX_TOKEN_TYPES
} litaC_lex__TokenType;
typedef struct litaC_lex__SrcPos litaC_lex__SrcPos;
typedef union litaC_lex__Value litaC_lex__Value;
typedef enum litaC_lex__Mod {
    litaC_lex__Mod_NONE = 0,
    litaC_lex__Mod_MULTISTR
} litaC_lex__Mod;
typedef struct litaC_lex__Token litaC_lex__Token;
typedef struct litaC_lex__Lexer litaC_lex__Lexer;

typedef enum litaC_types__TypeKind {
    litaC_types__TypeKind_BOOL = 1,
    litaC_types__TypeKind_CHAR,
    litaC_types__TypeKind_I8,
    litaC_types__TypeKind_U8,
    litaC_types__TypeKind_I16,
    litaC_types__TypeKind_U16,
    litaC_types__TypeKind_I32,
    litaC_types__TypeKind_U32,
    litaC_types__TypeKind_I64,
    litaC_types__TypeKind_U64,
    litaC_types__TypeKind_F32,
    litaC_types__TypeKind_F64,
    litaC_types__TypeKind_USIZE,
    litaC_types__TypeKind_NULL,
    litaC_types__TypeKind_VOID,
    litaC_types__TypeKind_STR,
    litaC_types__TypeKind_ARRAY,
    litaC_types__TypeKind_PTR,
    litaC_types__TypeKind_FUNC_PTR,
    litaC_types__TypeKind_STRUCT,
    litaC_types__TypeKind_UNION,
    litaC_types__TypeKind_TRAIT,
    litaC_types__TypeKind_ENUM,
    litaC_types__TypeKind_FUNC,
    litaC_types__TypeKind_CONST,
    litaC_types__TypeKind_GENERIC_PARAM,
    litaC_types__TypeKind_POISON,
    litaC_types__TypeKind_MAX_TYPE_KINDS
} litaC_types__TypeKind;
typedef struct litaC_types__FieldPositionResult litaC_types__FieldPositionResult;
typedef struct litaC_types__FieldPath litaC_types__FieldPath;
typedef struct litaC_types__MethodResult litaC_types__MethodResult;
typedef struct litaC_types__anon_1 litaC_types__anon_1;
typedef struct litaC_types__anon_2 litaC_types__anon_2;
typedef struct litaC_types__anon_3 litaC_types__anon_3;
typedef struct litaC_types__anon_4 litaC_types__anon_4;
typedef struct litaC_types__anon_5 litaC_types__anon_5;
typedef struct litaC_types__anon_6 litaC_types__anon_6;
typedef struct litaC_types__anon_7 litaC_types__anon_7;
typedef union litaC_types__anon_0 litaC_types__anon_0;
typedef struct litaC_types__TypeInfo litaC_types__TypeInfo;
typedef struct litaC_ast_new__TypeSpecAllocator litaC_ast_new__TypeSpecAllocator;

typedef enum litaC_ast__StmtKind {
    litaC_ast__StmtKind_IMPORT_DECL,
    litaC_ast__StmtKind_CONST_DECL,
    litaC_ast__StmtKind_VAR_DECL,
    litaC_ast__StmtKind_STRUCT_DECL,
    litaC_ast__StmtKind_UNION_DECL,
    litaC_ast__StmtKind_TRAIT_DECL,
    litaC_ast__StmtKind_ENUM_DECL,
    litaC_ast__StmtKind_FUNC_DECL,
    litaC_ast__StmtKind_TYPEDEF_DECL,
    litaC_ast__StmtKind_NOTE_DECL,
    litaC_ast__StmtKind_PARAM_DECL,
    litaC_ast__StmtKind_NATIVE_DECL,
    litaC_ast__StmtKind_NOTES_DECL,
    litaC_ast__StmtKind_VAR_FIELD_DECL,
    litaC_ast__StmtKind_ENUM_FIELD_ENTRY_DECL,
    litaC_ast__StmtKind_ENUM_FIELD_DECL,
    litaC_ast__StmtKind_STRUCT_FIELD_DECL,
    litaC_ast__StmtKind_UNION_FIELD_DECL,
    litaC_ast__StmtKind_TRAIT_FIELD_DECL,
    litaC_ast__StmtKind_POISON_DECL,
    litaC_ast__StmtKind_BLOCK_STMT,
    litaC_ast__StmtKind_BREAK_STMT,
    litaC_ast__StmtKind_COMP_STMT,
    litaC_ast__StmtKind_CONTINUE_STMT,
    litaC_ast__StmtKind_DEFER_STMT,
    litaC_ast__StmtKind_DO_WHILE_STMT,
    litaC_ast__StmtKind_EMPTY_STMT,
    litaC_ast__StmtKind_FOR_STMT,
    litaC_ast__StmtKind_FUNC_BODY_STMT,
    litaC_ast__StmtKind_GOTO_STMT,
    litaC_ast__StmtKind_IF_STMT,
    litaC_ast__StmtKind_LABEL_STMT,
    litaC_ast__StmtKind_MODULE_STMT,
    litaC_ast__StmtKind_NOTE_STMT,
    litaC_ast__StmtKind_PARAMETERS_STMT,
    litaC_ast__StmtKind_RETURN_STMT,
    litaC_ast__StmtKind_SWITCH_CASE_STMT,
    litaC_ast__StmtKind_SWITCH_STMT,
    litaC_ast__StmtKind_WHILE_STMT,
    litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR,
    litaC_ast__StmtKind_ARRAY_INIT_EXPR,
    litaC_ast__StmtKind_BINARY_EXPR,
    litaC_ast__StmtKind_BOOLEAN_EXPR,
    litaC_ast__StmtKind_CAST_EXPR,
    litaC_ast__StmtKind_CHAR_EXPR,
    litaC_ast__StmtKind_FUNC_CALL_EXPR,
    litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR,
    litaC_ast__StmtKind_GET_EXPR,
    litaC_ast__StmtKind_GROUP_EXPR,
    litaC_ast__StmtKind_IDENTIFIER_EXPR,
    litaC_ast__StmtKind_INIT_EXPR,
    litaC_ast__StmtKind_INIT_ARG_EXPR,
    litaC_ast__StmtKind_NULL_EXPR,
    litaC_ast__StmtKind_NUMBER_EXPR,
    litaC_ast__StmtKind_OFFSET_OF_EXPR,
    litaC_ast__StmtKind_SET_EXPR,
    litaC_ast__StmtKind_SIZE_OF_EXPR,
    litaC_ast__StmtKind_STRING_EXPR,
    litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR,
    litaC_ast__StmtKind_SUBSCRIPT_SET_EXPR,
    litaC_ast__StmtKind_TERNARY_EXPR,
    litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR,
    litaC_ast__StmtKind_TYPE_OF_EXPR,
    litaC_ast__StmtKind_UNARY_EXPR,
    litaC_ast__StmtKind_POISON_EXPR,
    litaC_ast__StmtKind_MAX_STMT_KINDS
} litaC_ast__StmtKind;

typedef enum litaC_ast__TypeSpecKind {
    litaC_ast__TypeSpecKind_NONE,
    litaC_ast__TypeSpecKind_ARRAY,
    litaC_ast__TypeSpecKind_PTR,
    litaC_ast__TypeSpecKind_CONST,
    litaC_ast__TypeSpecKind_NAME,
    litaC_ast__TypeSpecKind_FUNC_PTR,
    litaC_ast__TypeSpecKind_MAX_TYPESPEC_KINDS
} litaC_ast__TypeSpecKind;
typedef enum litaC_ast__FuncFlags {
    litaC_ast__FuncFlags_HAS_VARARGS = (1 << 0),
    litaC_ast__FuncFlags_IS_METHOD = (1 << 1)
} litaC_ast__FuncFlags;
typedef enum litaC_ast__AggregateFlags {
    litaC_ast__AggregateFlags_IS_EMBEDDED = (1 << 0),
    litaC_ast__AggregateFlags_IS_ANONYMOUS = (1 << 1)
} litaC_ast__AggregateFlags;
typedef struct litaC_ast__anon_9 litaC_ast__anon_9;
typedef struct litaC_ast__anon_10 litaC_ast__anon_10;
typedef struct litaC_ast__anon_11 litaC_ast__anon_11;
typedef union litaC_ast__anon_8 litaC_ast__anon_8;
typedef struct litaC_ast__TypeSpec litaC_ast__TypeSpec;
typedef struct litaC_ast__Identifier litaC_ast__Identifier;
typedef struct litaC_ast__GenericParam litaC_ast__GenericParam;
typedef enum litaC_ast__Visibility {
    litaC_ast__Visibility_PRIVATE,
    litaC_ast__Visibility_INTERNAL,
    litaC_ast__Visibility_PUBLIC
} litaC_ast__Visibility;
typedef struct litaC_ast__Attributes litaC_ast__Attributes;
typedef struct litaC_ast__Node litaC_ast__Node;
typedef struct litaC_ast__Decl litaC_ast__Decl;
typedef struct litaC_ast__GenericDecl litaC_ast__GenericDecl;
typedef struct litaC_ast__ImportDecl litaC_ast__ImportDecl;
typedef struct litaC_ast__VarDecl litaC_ast__VarDecl;
typedef struct litaC_ast__ParameterDecl litaC_ast__ParameterDecl;
typedef struct litaC_ast__FuncDecl litaC_ast__FuncDecl;
typedef struct litaC_ast__AggregateDecl litaC_ast__AggregateDecl;
typedef struct litaC_ast__EnumDecl litaC_ast__EnumDecl;
typedef struct litaC_ast__TypedefDecl litaC_ast__TypedefDecl;
typedef struct litaC_ast__NativeDecl litaC_ast__NativeDecl;
typedef struct litaC_ast__NotesDecl litaC_ast__NotesDecl;
typedef struct litaC_ast__PoisonDecl litaC_ast__PoisonDecl;
typedef struct litaC_ast__BlockStmt litaC_ast__BlockStmt;
typedef struct litaC_ast__BreakStmt litaC_ast__BreakStmt;
typedef struct litaC_ast__CompStmt litaC_ast__CompStmt;
typedef struct litaC_ast__ContinueStmt litaC_ast__ContinueStmt;
typedef struct litaC_ast__DeferStmt litaC_ast__DeferStmt;
typedef struct litaC_ast__DoWhileStmt litaC_ast__DoWhileStmt;
typedef struct litaC_ast__EmptyStmt litaC_ast__EmptyStmt;
typedef struct litaC_ast__EnumFieldEntryDecl litaC_ast__EnumFieldEntryDecl;
typedef struct litaC_ast__ForStmt litaC_ast__ForStmt;
typedef struct litaC_ast__FuncBodyStmt litaC_ast__FuncBodyStmt;
typedef struct litaC_ast__GotoStmt litaC_ast__GotoStmt;
typedef struct litaC_ast__IfStmt litaC_ast__IfStmt;
typedef struct litaC_ast__LabelStmt litaC_ast__LabelStmt;
typedef struct litaC_ast__ModuleStmt litaC_ast__ModuleStmt;
typedef struct litaC_ast__NoteStmt litaC_ast__NoteStmt;
typedef struct litaC_ast__ParametersStmt litaC_ast__ParametersStmt;
typedef struct litaC_ast__ReturnStmt litaC_ast__ReturnStmt;
typedef struct litaC_ast__SwitchCaseStmt litaC_ast__SwitchCaseStmt;
typedef struct litaC_ast__SwitchStmt litaC_ast__SwitchStmt;
typedef struct litaC_ast__VarFieldDecl litaC_ast__VarFieldDecl;
typedef struct litaC_ast__TraitFieldDecl litaC_ast__TraitFieldDecl;
typedef union litaC_ast__anon_12 litaC_ast__anon_12;
typedef struct litaC_ast__FieldStmt litaC_ast__FieldStmt;
typedef struct litaC_ast__WhileStmt litaC_ast__WhileStmt;
typedef struct litaC_ast__Stmt litaC_ast__Stmt;
typedef struct litaC_ast__ArrayDesignationExpr litaC_ast__ArrayDesignationExpr;
typedef struct litaC_ast__ArrayInitExpr litaC_ast__ArrayInitExpr;
typedef struct litaC_ast__BinaryExpr litaC_ast__BinaryExpr;
typedef struct litaC_ast__BooleanExpr litaC_ast__BooleanExpr;
typedef struct litaC_ast__CastExpr litaC_ast__CastExpr;
typedef struct litaC_ast__CharExpr litaC_ast__CharExpr;
typedef struct litaC_ast__CallArg litaC_ast__CallArg;
typedef struct litaC_ast__FuncCallExpr litaC_ast__FuncCallExpr;
typedef enum litaC_ast__GetExprFlags {
    litaC_ast__GetExprFlags_IS_NORMAL = 0,
    litaC_ast__GetExprFlags_IS_METHOD_CALL = (1 << 0),
    litaC_ast__GetExprFlags_IS_ENUM = (1 << 1),
    litaC_ast__GetExprFlags_IS_USING = (1 << 2),
    litaC_ast__GetExprFlags_IS_METHOD_ARG = (1 << 3)
} litaC_ast__GetExprFlags;
typedef struct litaC_ast__GetExpr litaC_ast__GetExpr;
typedef struct litaC_ast__GroupExpr litaC_ast__GroupExpr;
typedef struct litaC_ast__IdentifierExpr litaC_ast__IdentifierExpr;
typedef struct litaC_ast__InitArgExpr litaC_ast__InitArgExpr;
typedef struct litaC_ast__InitExpr litaC_ast__InitExpr;
typedef struct litaC_ast__NullExpr litaC_ast__NullExpr;
typedef struct litaC_ast__NumberExpr litaC_ast__NumberExpr;
typedef struct litaC_ast__OffsetOfExpr litaC_ast__OffsetOfExpr;
typedef struct litaC_ast__SetExpr litaC_ast__SetExpr;
typedef struct litaC_ast__SizeOfExpr litaC_ast__SizeOfExpr;
typedef struct litaC_ast__StringExpr litaC_ast__StringExpr;
typedef struct litaC_ast__SubscriptGetExpr litaC_ast__SubscriptGetExpr;
typedef struct litaC_ast__SubscriptSetExpr litaC_ast__SubscriptSetExpr;
typedef struct litaC_ast__TernaryExpr litaC_ast__TernaryExpr;
typedef struct litaC_ast__TypeIdentifierExpr litaC_ast__TypeIdentifierExpr;
typedef struct litaC_ast__TypeOfExpr litaC_ast__TypeOfExpr;
typedef struct litaC_ast__UnaryExpr litaC_ast__UnaryExpr;
typedef struct litaC_ast__PoisonExpr litaC_ast__PoisonExpr;
typedef struct litaC_ast__Expr litaC_ast__Expr;
typedef struct litaC_ast__Operand litaC_ast__Operand;

typedef enum litaC_symbols__SymbolKind {
    litaC_symbols__SymbolKind_TYPE,
    litaC_symbols__SymbolKind_VAR,
    litaC_symbols__SymbolKind_FUNC
} litaC_symbols__SymbolKind;

typedef enum litaC_symbols__SymbolState {
    litaC_symbols__SymbolState_UNRESOLVED = 0,
    litaC_symbols__SymbolState_RESOLVING,
    litaC_symbols__SymbolState_RESOLVED,
    litaC_symbols__SymbolState_ERROR
} litaC_symbols__SymbolState;
typedef enum litaC_symbols__SymbolFlags {
    litaC_symbols__SymbolFlags_IS_LOCAL = (1 << 1),
    litaC_symbols__SymbolFlags_IS_FOREIGN = (1 << 2),
    litaC_symbols__SymbolFlags_IS_CONSTANT = (1 << 3),
    litaC_symbols__SymbolFlags_IS_USING = (1 << 4),
    litaC_symbols__SymbolFlags_IS_TYPE = (1 << 5),
    litaC_symbols__SymbolFlags_IS_INCOMPLETE = (1 << 6),
    litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE = (1 << 7),
    litaC_symbols__SymbolFlags_IS_BUILTIN = (1 << 8),
    litaC_symbols__SymbolFlags_IS_FROM_GENERIC_TEMPLATE = (1 << 9),
    litaC_symbols__SymbolFlags_IS_IMPORTED = (1 << 10),
    litaC_symbols__SymbolFlags_IS_PUBLIC = (1 << 11),
    litaC_symbols__SymbolFlags_IS_INTERNAL = (1 << 12),
    litaC_symbols__SymbolFlags_IS_PRIVATE = (1 << 13),
    litaC_symbols__SymbolFlags_IS_EMITTED = (1 << 14),
    litaC_symbols__SymbolFlags_IS_TEST = (1 << 15),
    litaC_symbols__SymbolFlags_IS_ALIAS = (1 << 16),
    litaC_symbols__SymbolFlags_IS_MAIN = (1 << 17),
    litaC_symbols__SymbolFlags_IS_METHOD = (1 << 18),
    litaC_symbols__SymbolFlags_IS_TRAIT = (1 << 19),
    litaC_symbols__SymbolFlags_IS_TRAIT_METHOD = (1 << 20),
    litaC_symbols__SymbolFlags_IS_TRAIT_GENERATED = (1 << 21),
    litaC_symbols__SymbolFlags_IS_GENERATED = (1 << 22),
    litaC_symbols__SymbolFlags_IS_NOTE = (1 << 23),
    litaC_symbols__SymbolFlags_IS_MARKED_RESET = (1 << 24),
    litaC_symbols__SymbolFlags_IS_HIDDEN = (1 << 25),
    litaC_symbols__SymbolFlags_IS_FROM_PREPROCESSOR = (1 << 26)
} litaC_symbols__SymbolFlags;
typedef struct litaC_symbols__Symbol litaC_symbols__Symbol;
typedef enum litaC_symbols__ScopeKind {
    litaC_symbols__ScopeKind_MODULE,
    litaC_symbols__ScopeKind_FUNC
} litaC_symbols__ScopeKind;
typedef struct litaC_symbols__ProgramSymbols litaC_symbols__ProgramSymbols;
typedef struct litaC_symbols__Scope litaC_symbols__Scope;
typedef enum litaC_module__ModuleFlags {
    litaC_module__ModuleFlags_TYPE_CHECKED = (1 << 0),
    litaC_module__ModuleFlags_TYPE_RESOLVED = (1 << 1),
    litaC_module__ModuleFlags_TYPE_IMPORTED = (1 << 2),
    litaC_module__ModuleFlags_INCREMENTAL_COMPILATION = (1 << 3)
} litaC_module__ModuleFlags;
typedef struct litaC_module__ModuleId litaC_module__ModuleId;
typedef struct litaC_module__ModuleImport litaC_module__ModuleImport;
typedef struct litaC_module__Module litaC_module__Module;
typedef struct litaC_std__mem__arena_allocator__ArenaAllocator litaC_std__mem__arena_allocator__ArenaAllocator;
typedef struct litaC_std__mem__arena_allocator__Arena litaC_std__mem__arena_allocator__Arena;
typedef enum litaC_phase_result__ErrorType {
    litaC_phase_result__ErrorType_WARN,
    litaC_phase_result__ErrorType_ERROR
} litaC_phase_result__ErrorType;
typedef struct litaC_phase_result__PhaseError litaC_phase_result__PhaseError;
typedef struct litaC_phase_result__PhaseResult litaC_phase_result__PhaseResult;
typedef enum litaC_common__LogLevel {
    litaC_common__LogLevel_TRACE,
    litaC_common__LogLevel_INFO,
    litaC_common__LogLevel_DEBUG,
    litaC_common__LogLevel_ERROR,
    litaC_common__LogLevel_FATAL
} litaC_common__LogLevel;
typedef struct litaC_lita__Lita litaC_lita__Lita;

typedef enum litaC_lita__MetricType {
    litaC_lita__MetricType_PARSING,
    litaC_lita__MetricType_TYPE_CHECKING,
    litaC_lita__MetricType_CGEN,
    litaC_lita__MetricType_CCOMPILE,
    litaC_lita__MetricType_MAX_METRIC_TYPES
} litaC_lita__MetricType;
typedef struct litaC_lita__Metric litaC_lita__Metric;

typedef enum litaC_lita__TypeInfoOption {
    litaC_lita__TypeInfoOption_NONE,
    litaC_lita__TypeInfoOption_TAGGED,
    litaC_lita__TypeInfoOption_ALL
} litaC_lita__TypeInfoOption;
typedef struct litaC_lita__CCompilerOption litaC_lita__CCompilerOption;
typedef enum litaC_lita__PkgCommand {
    litaC_lita__PkgCommand_PKG_NONE = 0,
    litaC_lita__PkgCommand_PKG_INSTALL,
    litaC_lita__PkgCommand_PKG_RUN,
    litaC_lita__PkgCommand_PKG_INIT,
    litaC_lita__PkgCommand_PKG_BUILD
} litaC_lita__PkgCommand;
typedef struct litaC_lita__PkgOptions litaC_lita__PkgOptions;
typedef struct litaC_lita__LitaOptions litaC_lita__LitaOptions;
typedef struct litaC_std__mem__bucket_allocator__Bucket litaC_std__mem__bucket_allocator__Bucket;
typedef struct litaC_std__mem__bucket_allocator__BucketAllocator litaC_std__mem__bucket_allocator__BucketAllocator;
typedef struct litaC_preprocessor__Preprocessor litaC_preprocessor__Preprocessor;
typedef struct litaC_preprocessor__CallContext litaC_preprocessor__CallContext;
typedef struct litaC_preprocessor__CheckerContext litaC_preprocessor__CheckerContext;
typedef struct litaC_preprocessor__DeclContext litaC_preprocessor__DeclContext;
typedef struct litaC_preprocessor__ScriptDecl litaC_preprocessor__ScriptDecl;
typedef struct litaC_std__regex__Regex litaC_std__regex__Regex;
typedef struct litaC_checker__LabelInfo litaC_checker__LabelInfo;
typedef struct litaC_checker__GenericContext litaC_checker__GenericContext;
typedef enum litaC_checker__TypeCheckerFlags {
    litaC_checker__TypeCheckerFlags_DISABLE_TRAIT_WRAPPERS = (1 << 0)
} litaC_checker__TypeCheckerFlags;
typedef struct litaC_checker__TypeChecker litaC_checker__TypeChecker;
typedef enum litaC_checker__SearchType {
    litaC_checker__SearchType_TYPE,
    litaC_checker__SearchType_FUNC,
    litaC_checker__SearchType_NOTE
} litaC_checker__SearchType;
typedef struct litaC_types_new__TypeCache litaC_types_new__TypeCache;
typedef struct litaC_types_new__ArrayEntry litaC_types_new__ArrayEntry;
typedef struct litaC_intern__anon_13 litaC_intern__anon_13;
typedef struct litaC_intern__anon_14 litaC_intern__anon_14;
typedef union litaC_intern__InternedString litaC_intern__InternedString;
typedef struct litaC_intern__Strings litaC_intern__Strings;
typedef struct litaC_intern__X litaC_intern__X;
typedef struct litaC_generics__Template litaC_generics__Template;
typedef struct litaC_introspection__Introspect litaC_introspection__Introspect;
typedef enum litaC_error_codes__ErrorCode {
    litaC_error_codes__ErrorCode_INVALID_ASSIGNMENT,
    litaC_error_codes__ErrorCode_INVALID_CONST_EXPR,
    litaC_error_codes__ErrorCode_INVALID_ARRAY_DIMENSION_EXPR,
    litaC_error_codes__ErrorCode_INVALID_CHARACTER,
    litaC_error_codes__ErrorCode_INVALID_NUMBER,
    litaC_error_codes__ErrorCode_INVALID_FIELD,
    litaC_error_codes__ErrorCode_INVALID_IMPORT_ACCESS,
    litaC_error_codes__ErrorCode_INVALID_CONTINUE,
    litaC_error_codes__ErrorCode_INVALID_BREAK,
    litaC_error_codes__ErrorCode_INVALID_OBJECT_INIT,
    litaC_error_codes__ErrorCode_INVALID_MODULE_ACCESS,
    litaC_error_codes__ErrorCode_INVALID_VARARG_POSITION,
    litaC_error_codes__ErrorCode_INVALID_NOTE_DECL,
    litaC_error_codes__ErrorCode_INVALID_LABEL_STMT,
    litaC_error_codes__ErrorCode_INVALID_COMP_STMT,
    litaC_error_codes__ErrorCode_INVALID_DEFAULT_ASSIGNMENT,
    litaC_error_codes__ErrorCode_INVALID_TRAIT_MEMBER,
    litaC_error_codes__ErrorCode_INVALID_TYPE_IDENTIFIER,
    litaC_error_codes__ErrorCode_MISSING_COMMA,
    litaC_error_codes__ErrorCode_MISSING_SEMICOLON,
    litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACE,
    litaC_error_codes__ErrorCode_MISSING_EQUALS,
    litaC_error_codes__ErrorCode_MISSING_IDENTIFIER,
    litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACKET,
    litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN,
    litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN,
    litaC_error_codes__ErrorCode_MISSING_LEFT_BRACE,
    litaC_error_codes__ErrorCode_MISSING_ARRAY_BRACKETS,
    litaC_error_codes__ErrorCode_MISSING_COLON,
    litaC_error_codes__ErrorCode_MISSING_WHILE,
    litaC_error_codes__ErrorCode_MISSING_AS,
    litaC_error_codes__ErrorCode_MISSING_GENERIC_END,
    litaC_error_codes__ErrorCode_MISSING_COMP_STMT_END,
    litaC_error_codes__ErrorCode_MISSING_ERROR_MESSAGE,
    litaC_error_codes__ErrorCode_RANGE_INTEGER,
    litaC_error_codes__ErrorCode_RANGE_LONG,
    litaC_error_codes__ErrorCode_RANGE_REAL,
    litaC_error_codes__ErrorCode_UNEXPECTED_EOF,
    litaC_error_codes__ErrorCode_UNEXPECTED_TOKEN,
    litaC_error_codes__ErrorCode_UNIMPLEMENTED,
    litaC_error_codes__ErrorCode_UNKNOWN_ERROR,
    litaC_error_codes__ErrorCode_TOO_MANY_ERRORS,
    litaC_error_codes__ErrorCode_MAX_NUM_ERROR_CODES
} litaC_error_codes__ErrorCode;
typedef struct litaC_lsp__references__Reference litaC_lsp__references__Reference;
typedef struct litaC_lsp__references__FieldReference litaC_lsp__references__FieldReference;
typedef struct litaC_lsp__references__ReferenceDatabase litaC_lsp__references__ReferenceDatabase;
typedef struct litaC_std__json__JsonContext litaC_std__json__JsonContext;

typedef enum litaC_std__json__JsonType {
    litaC_std__json__JsonType_NULL,
    litaC_std__json__JsonType_BOOLEAN,
    litaC_std__json__JsonType_INT_NUMBER,
    litaC_std__json__JsonType_FLOAT_NUMBER,
    litaC_std__json__JsonType_STRING,
    litaC_std__json__JsonType_OBJECT,
    litaC_std__json__JsonType_ARRAY
} litaC_std__json__JsonType;
typedef struct litaC_std__json__JsonEntry litaC_std__json__JsonEntry;
typedef struct litaC_std__json__JsonObject litaC_std__json__JsonObject;
typedef union litaC_std__json__JsonValue litaC_std__json__JsonValue;
typedef struct litaC_std__json__JsonNode litaC_std__json__JsonNode;
typedef struct litaC_std__json__JsonIterator litaC_std__json__JsonIterator;
typedef enum litaC_std__json__TokenKind {
    litaC_std__json__TokenKind_EOF,
    litaC_std__json__TokenKind_ERROR,
    litaC_std__json__TokenKind_COMMA,
    litaC_std__json__TokenKind_COLON,
    litaC_std__json__TokenKind_LEFT_BRACE,
    litaC_std__json__TokenKind_RIGHT_BRACE,
    litaC_std__json__TokenKind_LEFT_BRACKET,
    litaC_std__json__TokenKind_RIGHT_BRACKET,
    litaC_std__json__TokenKind_NULL,
    litaC_std__json__TokenKind_INT_NUMBER,
    litaC_std__json__TokenKind_REAL_NUMBER,
    litaC_std__json__TokenKind_TRUE,
    litaC_std__json__TokenKind_FALSE,
    litaC_std__json__TokenKind_STRING
} litaC_std__json__TokenKind;
typedef struct litaC_std__json__SrcPos litaC_std__json__SrcPos;
typedef union litaC_std__json__anon_15 litaC_std__json__anon_15;
typedef struct litaC_std__json__Token litaC_std__json__Token;
typedef enum litaC_std__json__JsonParserStatus {
    litaC_std__json__JsonParserStatus_OK = 0,
    litaC_std__json__JsonParserStatus_WARNING,
    litaC_std__json__JsonParserStatus_ERROR
} litaC_std__json__JsonParserStatus;
typedef struct litaC_std__json__JsonParser litaC_std__json__JsonParser;
typedef struct litaC_parser__Parser litaC_parser__Parser;
typedef struct litaC_lsp__workspace__Workspace litaC_lsp__workspace__Workspace;
typedef struct litaC_lsp__lsp__LspServer litaC_lsp__lsp__LspServer;
typedef struct litaC_lsp__protocol__Position litaC_lsp__protocol__Position;
typedef struct litaC_lsp__protocol__Range litaC_lsp__protocol__Range;
typedef struct litaC_lsp__protocol__Location litaC_lsp__protocol__Location;
typedef struct litaC_lsp__protocol__TextDocument litaC_lsp__protocol__TextDocument;
typedef struct litaC_lsp__protocol__TextDocumentDidChange litaC_lsp__protocol__TextDocumentDidChange;
typedef struct litaC_lsp__protocol__TextDocumentChangeEvent litaC_lsp__protocol__TextDocumentChangeEvent;
typedef enum litaC_lsp__protocol__ErrorCodes {
    litaC_lsp__protocol__ErrorCodes_ParseError = -(32700),
    litaC_lsp__protocol__ErrorCodes_InvalidRequest = -(32600),
    litaC_lsp__protocol__ErrorCodes_MethodNotFound = -(32601),
    litaC_lsp__protocol__ErrorCodes_InvalidParams = -(32602),
    litaC_lsp__protocol__ErrorCodes_InternalError = -(32603),
    litaC_lsp__protocol__ErrorCodes_jsonrpcReservedErrorRangeStart = -(32099),
    litaC_lsp__protocol__ErrorCodes_serverErrorStart = litaC_lsp__protocol__ErrorCodes_jsonrpcReservedErrorRangeStart,
    litaC_lsp__protocol__ErrorCodes_ServerNotInitialized = -(32002),
    litaC_lsp__protocol__ErrorCodes_UnknownErrorCode = -(32001),
    litaC_lsp__protocol__ErrorCodes_jsonrpcReservedErrorRangeEnd = -(32000),
    litaC_lsp__protocol__ErrorCodes_serverErrorEnd = litaC_lsp__protocol__ErrorCodes_jsonrpcReservedErrorRangeEnd,
    litaC_lsp__protocol__ErrorCodes_lspReservedErrorRangeStart = -(32899),
    litaC_lsp__protocol__ErrorCodes_ContentModified = -(32801),
    litaC_lsp__protocol__ErrorCodes_RequestCancelled = -(32800),
    litaC_lsp__protocol__ErrorCodes_lspReservedErrorRangeEnd = -(32800)
} litaC_lsp__protocol__ErrorCodes;

typedef enum litaC_lsp__protocol__SymbolInfoKind {
    litaC_lsp__protocol__SymbolInfoKind_File = 1,
    litaC_lsp__protocol__SymbolInfoKind_Module = 2,
    litaC_lsp__protocol__SymbolInfoKind_Namespace = 3,
    litaC_lsp__protocol__SymbolInfoKind_Package = 4,
    litaC_lsp__protocol__SymbolInfoKind_Class = 5,
    litaC_lsp__protocol__SymbolInfoKind_Method = 6,
    litaC_lsp__protocol__SymbolInfoKind_Property = 7,
    litaC_lsp__protocol__SymbolInfoKind_Field = 8,
    litaC_lsp__protocol__SymbolInfoKind_Constructor = 9,
    litaC_lsp__protocol__SymbolInfoKind_Enum = 10,
    litaC_lsp__protocol__SymbolInfoKind_Interface = 11,
    litaC_lsp__protocol__SymbolInfoKind_Function = 12,
    litaC_lsp__protocol__SymbolInfoKind_Variable = 13,
    litaC_lsp__protocol__SymbolInfoKind_Constant = 14,
    litaC_lsp__protocol__SymbolInfoKind_String = 15,
    litaC_lsp__protocol__SymbolInfoKind_Number = 16,
    litaC_lsp__protocol__SymbolInfoKind_Boolean = 17,
    litaC_lsp__protocol__SymbolInfoKind_Array = 18,
    litaC_lsp__protocol__SymbolInfoKind_Object = 19,
    litaC_lsp__protocol__SymbolInfoKind_Key = 20,
    litaC_lsp__protocol__SymbolInfoKind_Null = 21,
    litaC_lsp__protocol__SymbolInfoKind_EnumMember = 22,
    litaC_lsp__protocol__SymbolInfoKind_Struct = 23,
    litaC_lsp__protocol__SymbolInfoKind_Event = 24,
    litaC_lsp__protocol__SymbolInfoKind_Operator = 25,
    litaC_lsp__protocol__SymbolInfoKind_TypeParameter = 26
} litaC_lsp__protocol__SymbolInfoKind;
typedef enum litaC_lsp__util__SourceLocationKind {
    litaC_lsp__util__SourceLocationKind_NONE,
    litaC_lsp__util__SourceLocationKind_AST,
    litaC_lsp__util__SourceLocationKind_TYPE
} litaC_lsp__util__SourceLocationKind;
typedef union litaC_lsp__util__anon_16 litaC_lsp__util__anon_16;
typedef struct litaC_lsp__util__SourceLocation litaC_lsp__util__SourceLocation;
typedef struct litaC_lsp__util__SourceLookup litaC_lsp__util__SourceLookup;
typedef struct litaC_lsp__document__Document litaC_lsp__document__Document;
typedef struct litaC_preprocessor__api__ScriptRuntime litaC_preprocessor__api__ScriptRuntime;
typedef struct litaC_cgen__CGen litaC_cgen__CGen;
typedef struct litaC_cgen__CGenScope litaC_cgen__CGenScope;
typedef struct litaC_cgen__CompilationUnit litaC_cgen__CompilationUnit;
typedef struct litaC_dependency_graph__DependencyGraph litaC_dependency_graph__DependencyGraph;
typedef enum litaC_dependency_graph__State {
    litaC_dependency_graph__State_EMPTY = 0,
    litaC_dependency_graph__State_PENDING = 1,
    litaC_dependency_graph__State_RESOLVED = 2
} litaC_dependency_graph__State;
typedef struct litaC_dependency_graph__Dependency litaC_dependency_graph__Dependency;
typedef struct litaC_build__BuildFile litaC_build__BuildFile;
typedef struct litaC_pkg_mgr__PackageOptions litaC_pkg_mgr__PackageOptions;
typedef struct litaC_pkg_mgr__PackageInitOptions litaC_pkg_mgr__PackageInitOptions;
typedef struct litaC_pkg_mgr__PackageBuildOptions litaC_pkg_mgr__PackageBuildOptions;
typedef struct litaC_pkg_mgr__PackageInstallOptions litaC_pkg_mgr__PackageInstallOptions;

typedef enum litaC_pkg_mgr__PkgStatus {
    litaC_pkg_mgr__PkgStatus_OK = 0,
    litaC_pkg_mgr__PkgStatus_ERROR_NO_PROJECT_PKG_FOUND,
    litaC_pkg_mgr__PkgStatus_ERROR_COMMAND_NOT_DEFINED,
    litaC_pkg_mgr__PkgStatus_ERROR_RUNNING_COMMAND,
    litaC_pkg_mgr__PkgStatus_ERROR_CREATING_PKG_DIR,
    litaC_pkg_mgr__PkgStatus_ERROR_CLEANING_PKG,
    litaC_pkg_mgr__PkgStatus_ERROR_UNABLE_TO_OPEN_FILE,
    litaC_pkg_mgr__PkgStatus_ERROR_UNABLE_TO_OPEN_PKG_FILE,
    litaC_pkg_mgr__PkgStatus_ERROR_UNABLE_TO_EXTRACT_PKG_FILE,
    litaC_pkg_mgr__PkgStatus_ERROR_UNABLE_TO_PROCESS_PKG_FILE,
    litaC_pkg_mgr__PkgStatus_ERROR_OPENING_LOCAL_FILE_PKG,
    litaC_pkg_mgr__PkgStatus_ERROR_READING_LOCAL_FILE_PKG,
    litaC_pkg_mgr__PkgStatus_ERROR_WRITING_LOCAL_FILE_PKG,
    litaC_pkg_mgr__PkgStatus_ERROR_FINALIZING_LOCAL_FILE_PKG,
    litaC_pkg_mgr__PkgStatus_ERROR_PARSING_PKG_JSON,
    litaC_pkg_mgr__PkgStatus_ERROR_READING_PKG_FILE,
    litaC_pkg_mgr__PkgStatus_ERROR_HTTP_STATUS,
    litaC_pkg_mgr__PkgStatus_ERROR_INVALID_DIRECTORY,
    litaC_pkg_mgr__PkgStatus_ERROR_INVALID_REPO,
    litaC_pkg_mgr__PkgStatus_ERROR_INIT_PACKAGE,
    litaC_pkg_mgr__PkgStatus_ERROR_PARSING_BUILD_OPTIONS,
    litaC_pkg_mgr__PkgStatus_ERROR_INVALID_BUILD_TARGET,
    litaC_pkg_mgr__PkgStatus_ERROR_INVALID_BUILD_OS,
    litaC_pkg_mgr__PkgStatus_ERROR_INVALID_BUILD_ARCH
} litaC_pkg_mgr__PkgStatus;
typedef struct litaC_pkg_mgr__PackageManager litaC_pkg_mgr__PackageManager;
typedef enum litaC_pkg_mgr__pkg__PackageType {
    litaC_pkg_mgr__pkg__PackageType_EXECUTABLE,
    litaC_pkg_mgr__pkg__PackageType_STATIC_LIBRARY,
    litaC_pkg_mgr__pkg__PackageType_DYNAMIC_LIBRARY,
    litaC_pkg_mgr__pkg__PackageType_SOURCE_LIBRARY
} litaC_pkg_mgr__pkg__PackageType;
typedef struct litaC_pkg_mgr__pkg__PackageDef litaC_pkg_mgr__pkg__PackageDef;
typedef struct litaC_pkg_mgr__pkg__PackageId litaC_pkg_mgr__pkg__PackageId;

typedef enum litaC_std__zip__ZipOpen {
    litaC_std__zip__ZipOpen_READ,
    litaC_std__zip__ZipOpen_WRITE
} litaC_std__zip__ZipOpen;
typedef enum litaC_std__zip__ZipFlags {
    litaC_std__zip__ZipFlags_INCLUDE_ZIPFILE_NAME_ON_UNZIP = (1 << 0)
} litaC_std__zip__ZipFlags;
typedef enum litaC_std__zip__ZipStatus {
    litaC_std__zip__ZipStatus_OK = 0,
    litaC_std__zip__ZipStatus_ERROR_UNABLE_TO_OPEN_FILE,
    litaC_std__zip__ZipStatus_ERROR_UNABLE_TO_STAT,
    litaC_std__zip__ZipStatus_ERROR_UNABLE_CREATE_DIR,
    litaC_std__zip__ZipStatus_ERROR_UNABLE_WRITE_FILE,
    litaC_std__zip__ZipStatus_ERROR_ADDING_FILE,
    litaC_std__zip__ZipStatus_ERROR_CLOSING,
    litaC_std__zip__ZipStatus_ERROR_FINALIZING
} litaC_std__zip__ZipStatus;
typedef enum litaC_std__zip__ZipCompressionLevel {
    litaC_std__zip__ZipCompressionLevel_NO_COMPRESSION = 0,
    litaC_std__zip__ZipCompressionLevel_BEST_SPEED = 1,
    litaC_std__zip__ZipCompressionLevel_BEST_COMPRESSION = 9,
    litaC_std__zip__ZipCompressionLevel_UBER_COMPRESSION = 10,
    litaC_std__zip__ZipCompressionLevel_DEFAULT_LEVEL = 6
} litaC_std__zip__ZipCompressionLevel;
typedef struct litaC_std__zip__ZipFile litaC_std__zip__ZipFile;
typedef enum litaC_std__zip__miniz__CompressionStrategy {
    litaC_std__zip__miniz__CompressionStrategy_MZ_DEFAULT_STRATEGY = 0,
    litaC_std__zip__miniz__CompressionStrategy_MZ_FILTERED = 1,
    litaC_std__zip__miniz__CompressionStrategy_MZ_HUFFMAN_ONLY = 2,
    litaC_std__zip__miniz__CompressionStrategy_MZ_RLE = 3,
    litaC_std__zip__miniz__CompressionStrategy_MZ_FIXED = 4
} litaC_std__zip__miniz__CompressionStrategy;
typedef struct litaC_std__fs__FileHandle litaC_std__fs__FileHandle;
typedef struct litaC_pkg_mgr__pkg_build__CommandArgs litaC_pkg_mgr__pkg_build__CommandArgs;
typedef struct litaC_std__array__Array_cb__ptr_JsonNode_ce_ litaC_std__array__Array_cb__ptr_JsonNode_ce_;
typedef struct litaC_std__array__Array_cb_Option_ce_ litaC_std__array__Array_cb_Option_ce_;
typedef struct litaC_std__array__Array_cb__ptr_const_char_ce_ litaC_std__array__Array_cb__ptr_const_char_ce_;
typedef struct litaC_std__map__Map_cb__ptr_const_char_c__ptr_const_char_ce_ litaC_std__map__Map_cb__ptr_const_char_c__ptr_const_char_ce_;
typedef struct litaC_std__map__Key_cb__ptr_const_char_ce_ litaC_std__map__Key_cb__ptr_const_char_ce_;
typedef struct litaC_std__array__Array_cb_GenericParam_ce_ litaC_std__array__Array_cb_GenericParam_ce_;
typedef struct litaC_std__array__Array_cb__ptr_TypeInfo_ce_ litaC_std__array__Array_cb__ptr_TypeInfo_ce_;
typedef struct litaC_std__bucket_list__BucketList_cb_TypeSpec_ce_ litaC_std__bucket_list__BucketList_cb_TypeSpec_ce_;
typedef struct litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_ litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_;
typedef struct litaC_std__array__Array_cb__ptr_TypeSpec_ce_ litaC_std__array__Array_cb__ptr_TypeSpec_ce_;
typedef struct litaC_std__array__Array_cb__ptr_NoteStmt_ce_ litaC_std__array__Array_cb__ptr_NoteStmt_ce_;
typedef struct litaC_std__array__Array_cb_FieldStmt_ce_ litaC_std__array__Array_cb_FieldStmt_ce_;
typedef struct litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_ litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_;
typedef struct litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_std__array__Array_cb__ptr_Stmt_ce_;
typedef struct litaC_std__array__Array_cb__ptr_ImportDecl_ce_ litaC_std__array__Array_cb__ptr_ImportDecl_ce_;
typedef struct litaC_std__array__Array_cb__ptr_Decl_ce_ litaC_std__array__Array_cb__ptr_Decl_ce_;
typedef struct litaC_std__array__Array_cb_CallArg_ce_ litaC_std__array__Array_cb_CallArg_ce_;
typedef struct litaC_std__array__Array_cb__ptr_ParameterDecl_ce_ litaC_std__array__Array_cb__ptr_ParameterDecl_ce_;
typedef struct litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_ litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_;
typedef struct litaC_std__array__Array_cb__ptr_Expr_ce_ litaC_std__array__Array_cb__ptr_Expr_ce_;
typedef struct litaC_std__array__Array_cb__ptr_InitArgExpr_ce_ litaC_std__array__Array_cb__ptr_InitArgExpr_ce_;
typedef struct litaC_std__array__Array_cb__ptr_Symbol_ce_ litaC_std__array__Array_cb__ptr_Symbol_ce_;
typedef struct litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_ litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_;
typedef struct litaC_std__array__Array_cb_i64_ce_ litaC_std__array__Array_cb_i64_ce_;
typedef struct litaC_std__map__Key_cb_i64_ce_ litaC_std__map__Key_cb_i64_ce_;
typedef struct litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_ litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_;
typedef struct litaC_std__map__Key_cb_InternedString_ce_ litaC_std__map__Key_cb_InternedString_ce_;
typedef struct litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_ litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_;
typedef struct litaC_std__array__Array_cb_PhaseError_ce_ litaC_std__array__Array_cb_PhaseError_ce_;
typedef struct litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_ litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_;
typedef struct litaC_std__array__Array_cb_CCompilerOption_ce_ litaC_std__array__Array_cb_CCompilerOption_ce_;
typedef struct litaC_std__array__Array_cb_CheckerContext_ce_ litaC_std__array__Array_cb_CheckerContext_ce_;
typedef struct litaC_std__array__Array_cb_ScriptDecl_ce_ litaC_std__array__Array_cb_ScriptDecl_ce_;
typedef struct litaC_std__array__Array_cb__ptr_Module_ce_ litaC_std__array__Array_cb__ptr_Module_ce_;
typedef struct litaC_std__array__Array_cb_Array_cb_GenericParam_ce__ce_ litaC_std__array__Array_cb_Array_cb_GenericParam_ce__ce_;
typedef struct litaC_std__bucket_list__BucketList_cb_TypeInfo_ce_ litaC_std__bucket_list__BucketList_cb_TypeInfo_ce_;
typedef struct litaC_std__bucket_list__Bucket_cb_TypeInfo_ce_ litaC_std__bucket_list__Bucket_cb_TypeInfo_ce_;
typedef struct litaC_std__map__Map_cb_i64_c__ptr_TypeInfo_ce_ litaC_std__map__Map_cb_i64_c__ptr_TypeInfo_ce_;
typedef struct litaC_std__map__Map_cb_ArrayEntry_c__ptr_TypeInfo_ce_ litaC_std__map__Map_cb_ArrayEntry_c__ptr_TypeInfo_ce_;
typedef struct litaC_std__map__Key_cb_ArrayEntry_ce_ litaC_std__map__Key_cb_ArrayEntry_ce_;
typedef struct litaC_std__map__Map_cb_InternedString_c__ptr_TypeInfo_ce_ litaC_std__map__Map_cb_InternedString_c__ptr_TypeInfo_ce_;
typedef struct litaC_std__array__Array_cb_Reference_ce_ litaC_std__array__Array_cb_Reference_ce_;
typedef struct litaC_std__array__Array_cb_FieldReference_ce_ litaC_std__array__Array_cb_FieldReference_ce_;
typedef struct litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_ litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_;
typedef struct litaC_std__array__Array_cb_SrcPos_ce_ litaC_std__array__Array_cb_SrcPos_ce_;
typedef struct litaC_std__map__Key_cb_usize_ce_ litaC_std__map__Key_cb_usize_ce_;
typedef struct litaC_std__map__Map_cb__ptr_const_char_c_i32_ce_ litaC_std__map__Map_cb__ptr_const_char_c_i32_ce_;
typedef struct litaC_std__array__Array_cb_JsonEntry_ce_ litaC_std__array__Array_cb_JsonEntry_ce_;
typedef struct litaC_std__array__Array_cb_Token_ce_ litaC_std__array__Array_cb_Token_ce_;
typedef struct litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_ litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_;
typedef struct litaC_std__array__Array_cb_TextDocumentChangeEvent_ce_ litaC_std__array__Array_cb_TextDocumentChangeEvent_ce_;
typedef struct litaC_std__array__Array_cb_u32_ce_ litaC_std__array__Array_cb_u32_ce_;
typedef struct litaC_std__map__Map_cb__ptr_Symbol_c_Dependency_ce_ litaC_std__map__Map_cb__ptr_Symbol_c_Dependency_ce_;
typedef struct litaC_std__map__Key_cb__ptr_Symbol_ce_ litaC_std__map__Key_cb__ptr_Symbol_ce_;
typedef struct litaC_std__array__Array_cb__ptr_Dependency_ce_ litaC_std__array__Array_cb__ptr_Dependency_ce_;
typedef struct litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_ litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_;
typedef struct litaC_std__array__Array_cb_PackageId_ce_ litaC_std__array__Array_cb_PackageId_ce_;
typedef struct litaC_std__map__Key_cb_StringView_ce_ litaC_std__map__Key_cb_StringView_ce_;
typedef struct litaC_std__map__Map_cb_i32_c_i32_ce_ litaC_std__map__Map_cb_i32_c_i32_ce_;
typedef struct litaC_std__map__Key_cb_i32_ce_ litaC_std__map__Key_cb_i32_ce_;
typedef struct litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_ litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_;
typedef struct litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_ litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_;
typedef struct litaC_std__map__MapIterator_cb__ptr_const_char_c_ModuleImport_ce_ litaC_std__map__MapIterator_cb__ptr_const_char_c_ModuleImport_ce_;
typedef struct litaC_std__map__MapEntry_cb__ptr_const_char_c_ModuleImport_ce_ litaC_std__map__MapEntry_cb__ptr_const_char_c_ModuleImport_ce_;
typedef struct litaC_std__map__MapIterator_cb_ArrayEntry_c__ptr_TypeInfo_ce_ litaC_std__map__MapIterator_cb_ArrayEntry_c__ptr_TypeInfo_ce_;
typedef struct litaC_std__map__MapEntry_cb_ArrayEntry_c__ptr_TypeInfo_ce_ litaC_std__map__MapEntry_cb_ArrayEntry_c__ptr_TypeInfo_ce_;
typedef struct litaC_std__map__MapIterator_cb_i64_c__ptr_TypeInfo_ce_ litaC_std__map__MapIterator_cb_i64_c__ptr_TypeInfo_ce_;
typedef struct litaC_std__map__MapEntry_cb_i64_c__ptr_TypeInfo_ce_ litaC_std__map__MapEntry_cb_i64_c__ptr_TypeInfo_ce_;
typedef struct litaC_std__map__MapIterator_cb_usize_c_Array_cb_SrcPos_ce__ce_ litaC_std__map__MapIterator_cb_usize_c_Array_cb_SrcPos_ce__ce_;
typedef struct litaC_std__map__MapEntry_cb_usize_c_Array_cb_SrcPos_ce__ce_ litaC_std__map__MapEntry_cb_usize_c_Array_cb_SrcPos_ce__ce_;
typedef struct litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_ litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_;
typedef struct litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_Module_ce_ litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_Module_ce_;
typedef struct litaC_std__map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_ litaC_std__map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_;
typedef struct litaC_std__map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_ litaC_std__map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_;
typedef struct litaC_std__map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_ litaC_std__map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_;
typedef struct litaC_std__map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_ litaC_std__map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_;
typedef struct litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_PackageDef_ce_ litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_PackageDef_ce_;
typedef struct litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_PackageDef_ce_ litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_PackageDef_ce_;
litaC_i32 litaC_main__main(litaC_i32 litaC_len,litaC_char** litaC_args);
litaC_i32 litaC_main__RunLitac(litaC_lita__LitaOptions* litaC_options);
litaC_main__ParseStatus litaC_main__ParseArgs(litaC_i32 litaC_n,litaC_char** litaC_args,litaC_lita__LitaOptions* litaC_options);
litaC_void litaC_main__TrimPath(litaC_char* litaC_path);
litaC_i32 litaC_main__HandlePkgCommand(litaC_lita__LitaOptions* litaC_options);
litaC_i32 litaC_main__RunPkgInstall(litaC_lita__LitaOptions* litaC_options,litaC_pkg_mgr__PackageManager* litaC_pm);
litaC_i32 litaC_main__RunPkgCommand(litaC_lita__LitaOptions* litaC_options,litaC_pkg_mgr__PackageManager* litaC_pm);
litaC_i32 litaC_main__RunPkgInit(litaC_lita__LitaOptions* litaC_options,litaC_pkg_mgr__PackageManager* litaC_pm);
litaC_i32 litaC_main__RunPkgBuild(litaC_lita__LitaOptions* litaC_options,litaC_pkg_mgr__PackageManager* litaC_pm);
litaC_void* litaC_std__mem__memduplicate(const litaC_void* litaC_p,litaC_usize litaC_len,const litaC_std__mem__Allocator* litaC_a);
litaC_bool litaC_std__mem__isPowerOfTwo(litaC_usize litaC_x);
litaC_usize litaC_std__mem__alignForward(litaC_usize litaC_ptr,litaC_usize litaC_align);
LITAC_INLINE 
litaC_void* litaC_std__mem__Allocator_alloc(const litaC_std__mem__Allocator* litaC_a,litaC_usize litaC_size);
LITAC_INLINE 
litaC_void* litaC_std__mem__Allocator_calloc(const litaC_std__mem__Allocator* litaC_a,litaC_usize litaC_num,litaC_usize litaC_size);
LITAC_INLINE 
litaC_void* litaC_std__mem__Allocator_realloc(const litaC_std__mem__Allocator* litaC_a,litaC_void* litaC_ptr,litaC_usize litaC_oldsize,litaC_usize litaC_newsize);
LITAC_INLINE 
litaC_void litaC_std__mem__Allocator_free(const litaC_std__mem__Allocator* litaC_a,litaC_void* litaC_ptr);
litaC_void* litaC_std__mem__libc_allocator__cMalloc(const litaC_std__mem__Allocator* litaC_a,litaC_usize litaC_size);
litaC_void* litaC_std__mem__libc_allocator__cCalloc(const litaC_std__mem__Allocator* litaC_a,litaC_usize litaC_num,litaC_usize litaC_size);
litaC_void* litaC_std__mem__libc_allocator__cRealloc(const litaC_std__mem__Allocator* litaC_a,litaC_void* litaC_ptr,litaC_usize litaC_oldSize,litaC_usize litaC_size);
litaC_void litaC_std__mem__libc_allocator__cFree(const litaC_std__mem__Allocator* litaC_a,litaC_void* litaC_ptr);
litaC_void litaC_std__mem__linear_allocator__LinearAllocator_init(litaC_std__mem__linear_allocator__LinearAllocator* litaC_this,litaC_void* litaC_mem,litaC_usize litaC_size,litaC_usize litaC_align,litaC_std__mem__linear_allocator__ExpandInfo litaC_expandInfo);

litaC_void litaC_std__mem__linear_allocator__LinearAllocator_clear(litaC_std__mem__linear_allocator__LinearAllocator* litaC_this);
litaC_void* litaC_std__mem__linear_allocator__LinearAllocator_malloc(litaC_std__mem__linear_allocator__LinearAllocator* litaC_this,litaC_usize litaC_size);
litaC_void* litaC_std__mem__linear_allocator__LinearMalloc(const litaC_std__mem__Allocator* litaC_alloc,litaC_usize litaC_size);
litaC_void* litaC_std__mem__linear_allocator__LinearCalloc(const litaC_std__mem__Allocator* litaC_alloc,litaC_usize litaC_num,litaC_usize litaC_size);
litaC_void* litaC_std__mem__linear_allocator__LinearRealloc(const litaC_std__mem__Allocator* litaC_alloc,litaC_void* litaC_ptr,litaC_usize litaC_oldSize,litaC_usize litaC_size);
litaC_void litaC_std__mem__linear_allocator__LinearFree(const litaC_std__mem__Allocator* litaC_alloc,litaC_void* litaC_ptr);
litaC_std__io__FileStatus litaC_std__io__File_open(litaC_std__io__File* litaC_file,const litaC_char* litaC_filename,litaC_std__io__FileOpenOp litaC_op);
litaC_usize litaC_std__io__File_length(litaC_std__io__File* litaC_file);
litaC_i32 litaC_std__io__File_handle(litaC_std__io__File* litaC_file);
litaC_void litaC_std__io__File_close(litaC_std__io__File* litaC_file);
litaC_i64 litaC_std__io__FileLength(const litaC_char* litaC_fileName);
litaC_std__io__FileStatus litaC_std__io__ReadFile(const litaC_char* litaC_fileName,litaC_char** litaC_data,litaC_usize* litaC_length,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__io__FileStatus litaC_std__io__WriteFile(const litaC_char* litaC_fileName,const litaC_char* litaC_buffer,litaC_usize litaC_len);
litaC_std__io__FileStatus litaC_std__io__File_writeBytes(litaC_std__io__File* litaC_file,const litaC_char* litaC_buffer,litaC_usize litaC_len);
litaC_std__cmdline__CmdParser litaC_std__cmdline__CmdParserInit(const litaC_std__mem__Allocator* litaC_allocator);
litaC_void litaC_std__cmdline__CmdParser_init(litaC_std__cmdline__CmdParser* litaC_p,const litaC_std__mem__Allocator* litaC_allocator);
litaC_void litaC_std__cmdline__CmdParser_free(litaC_std__cmdline__CmdParser* litaC_p);
litaC_void litaC_std__cmdline__CmdParser_addOption(litaC_std__cmdline__CmdParser* litaC_p,const litaC_char* litaC_longName,litaC_char litaC_shortName,const litaC_char* litaC_description,litaC_i32 litaC_flags,const litaC_char* litaC_defaultValue);
litaC_std__cmdline__Option* litaC_std__cmdline__CmdParser_getOption(litaC_std__cmdline__CmdParser* litaC_p,const litaC_char* litaC_longName);
litaC_std__cmdline__Option* litaC_std__cmdline__CmdParser_getOptionShort(litaC_std__cmdline__CmdParser* litaC_p,litaC_char litaC_shortName);
litaC_bool litaC_std__cmdline__CmdParser_hasOption(litaC_std__cmdline__CmdParser* litaC_p,const litaC_char* litaC_longName);
litaC_bool litaC_std__cmdline__CmdParser_hasOptionShort(litaC_std__cmdline__CmdParser* litaC_p,litaC_char litaC_shortName);
litaC_std__cmdline__CmdParserStatus litaC_std__cmdline__CmdParser_parse(litaC_std__cmdline__CmdParser* litaC_p,litaC_i32 litaC_argc,litaC_char** litaC_argv);
litaC_void litaC_std__cmdline__CmdParser_printHelp(litaC_std__cmdline__CmdParser* litaC_p,litaC_std__string_buffer__StringBuffer* litaC_sb);
litaC_std__string_buffer__StringBuffer litaC_std__string_buffer__StringBufferInit(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__string_buffer__StringBuffer_init(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__string_buffer__StringBuffer_free(litaC_std__string_buffer__StringBuffer* litaC_b);
litaC_void litaC_std__string_buffer__StringBuffer_appendStr(litaC_std__string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_str);
litaC_void litaC_std__string_buffer__StringBuffer_appendStrn(litaC_std__string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_i32 litaC_std__string_buffer__StringBuffer_appendFloat(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_f64 litaC_f);
litaC_i32 litaC_std__string_buffer__StringBuffer_appendI32(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_i);
litaC_i32 litaC_std__string_buffer__StringBuffer_appendI64(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_i64 litaC_i);
litaC_i32 litaC_std__string_buffer__StringBuffer_appendU32(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_u32 litaC_i);
litaC_i32 litaC_std__string_buffer__StringBuffer_appendU64(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_u64 litaC_i);
litaC_i32 litaC_std__string_buffer__StringBuffer_appendChar(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_char litaC_c);
litaC_i32 litaC_std__string_buffer__StringBuffer_append(litaC_std__string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_format,...);
litaC_i32 litaC_std__string_buffer__StringBuffer_appendArgs(litaC_std__string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_format,va_list litaC_args);
litaC_void litaC_std__string_buffer__StringBuffer_delete(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_start,litaC_i32 litaC_end);
litaC_bool litaC_std__string_buffer__StringBuffer_contains(litaC_std__string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_i32 litaC_std__string_buffer__StringBuffer_indexOf(litaC_std__string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_i32 litaC_std__string_buffer__StringBuffer_indexOfAt(litaC_std__string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len,litaC_i32 litaC_fromIndex);
litaC_i32 litaC_std__string_buffer__StringBuffer_replace(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_start,litaC_i32 litaC_end,const litaC_char* litaC_str);
litaC_i32 litaC_std__string_buffer__StringBuffer_insert(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_index,const litaC_char* litaC_format,...);
litaC_void litaC_std__string_buffer__StringBuffer_trim(litaC_std__string_buffer__StringBuffer* litaC_b);
litaC_i32 litaC_std__string_buffer__StringBuffer_copyTo(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_char* litaC_buf,litaC_i32 litaC_len,litaC_bool litaC_addZero);
litaC_void litaC_std__string_buffer__StringBuffer_forEach(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_bool (*litaC_fn)(litaC_char));
LITAC_INLINE 
litaC_bool litaC_std__string_buffer__StringBuffer_empty(litaC_std__string_buffer__StringBuffer* litaC_b);
LITAC_INLINE 
litaC_i32 litaC_std__string_buffer__StringBuffer_size(litaC_std__string_buffer__StringBuffer* litaC_b);
LITAC_INLINE 
litaC_std__string_buffer__StringBuffer* litaC_std__string_buffer__StringBuffer_clear(litaC_std__string_buffer__StringBuffer* litaC_b);
const litaC_char* litaC_std__string_buffer__StringBuffer_cStrConst(litaC_std__string_buffer__StringBuffer* litaC_b);
litaC_char* litaC_std__string_buffer__StringBuffer_cStr(litaC_std__string_buffer__StringBuffer* litaC_b);
LITAC_INLINE 
litaC_std__string_view__StringView litaC_std__string_buffer__StringBuffer_asStringView(litaC_std__string_buffer__StringBuffer* litaC_b);
litaC_char litaC_std__string_buffer__StringBuffer_get(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_index);
litaC_void litaC_std__string_buffer__StringBuffer_reserve(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_length);
litaC_void litaC_std__string_buffer__BufferGrow(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_increment);
litaC_std__string_view__StringView litaC_std__string_view__StringViewInit(const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_u32 litaC_std__string_view__StringView_hash(litaC_std__string_view__StringView litaC_b);
litaC_std__string_view__StringView litaC_std__string_view__StringView_substring(litaC_std__string_view__StringView litaC_b,litaC_i32 litaC_start,litaC_i32 litaC_end);
litaC_bool litaC_std__string_view__StringView_startsWith(litaC_std__string_view__StringView litaC_b,const litaC_char* litaC_prefix,litaC_i32 litaC_len,litaC_i32 litaC_fromIndex);
litaC_bool litaC_std__string_view__StringView_endsWith(litaC_std__string_view__StringView litaC_b,const litaC_char* litaC_suffix,litaC_i32 litaC_len);
litaC_bool litaC_std__string_view__StringView_equals(litaC_std__string_view__StringView litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_bool litaC_std__string_view__StringView_equalsStringView(litaC_std__string_view__StringView litaC_b,litaC_std__string_view__StringView litaC_other);
litaC_bool litaC_std__string_view__StringView_contains(litaC_std__string_view__StringView litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_i32 litaC_std__string_view__StringView_indexOf(litaC_std__string_view__StringView litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_i32 litaC_std__string_view__StringView_indexOfAt(litaC_std__string_view__StringView litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len,litaC_i32 litaC_fromIndex);
litaC_i32 litaC_std__string_view__StringView_lastIndexOfAt(litaC_std__string_view__StringView litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len,litaC_i32 litaC_fromIndex);
litaC_i32 litaC_std__string_view__StringView_copyTo(litaC_std__string_view__StringView litaC_b,litaC_char* litaC_buf,litaC_i32 litaC_len,litaC_bool litaC_addZero);
litaC_std__string_view__StringView litaC_std__string_view__StringView_copy(litaC_std__string_view__StringView litaC_s,const litaC_std__mem__Allocator* litaC_allocator);
litaC_void litaC_std__string_view__StringView_forEach(litaC_std__string_view__StringView litaC_b,litaC_bool (*litaC_fn)(litaC_char));
litaC_bool litaC_std__string_view__StringView_empty(litaC_std__string_view__StringView litaC_b);
litaC_i32 litaC_std__string_view__StringView_size(litaC_std__string_view__StringView litaC_b);
litaC_void litaC_std__string_view__StringView_clear(litaC_std__string_view__StringView litaC_b);
litaC_char litaC_std__string_view__StringView_get(litaC_std__string_view__StringView litaC_b,litaC_i32 litaC_index);
litaC_bool litaC_std__ascii__char_isWhitespace(litaC_char litaC_this);
litaC_bool litaC_std__ascii__char_isNumeric(litaC_char litaC_this);
litaC_bool litaC_std__ascii__char_isAlphabetic(litaC_char litaC_this);
litaC_bool litaC_std__ascii__char_isAlphanumeric(litaC_char litaC_this);
litaC_std__string__String litaC_std__string__CString(litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_std__string__String litaC_std__string__StringInit(litaC_char* litaC_str,litaC_i32 litaC_capacity,litaC_i32 litaC_len);
litaC_i32 litaC_std__string__String_format(litaC_std__string__String* litaC_s,const litaC_char* litaC_format,...);
litaC_i32 litaC_std__string__String_append(litaC_std__string__String* litaC_s,const litaC_char* litaC_format,...);
litaC_void litaC_std__string__String_appendStr(litaC_std__string__String* litaC_b,const litaC_char* litaC_str);
litaC_void litaC_std__string__String_appendStrn(litaC_std__string__String* litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_void litaC_std__string__String_setStrn(litaC_std__string__String* litaC_s,const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_void litaC_std__string__String_appendChar(litaC_std__string__String* litaC_s,litaC_char litaC_c);
litaC_std__string_view__StringView litaC_std__string__String_substring(litaC_std__string__String litaC_s,litaC_i32 litaC_start,litaC_i32 litaC_end);
litaC_std__string_view__StringView litaC_std__string__String_asView(litaC_std__string__String litaC_s);
litaC_void litaC_std__string__String_memset(litaC_std__string__String litaC_s,litaC_i32 litaC_value);
litaC_void litaC_std__string__String_toLower(litaC_std__string__String litaC_s);
litaC_void litaC_std__string__String_toUpper(litaC_std__string__String litaC_s);
litaC_std__string__String litaC_std__string__String_copy(litaC_std__string__String litaC_s,const litaC_std__mem__Allocator* litaC_allocator);
litaC_void litaC_std__string__String_adjust(litaC_std__string__String* litaC_s);
litaC_void litaC_std__string__String_clear(litaC_std__string__String* litaC_s);
litaC_bool litaC_std__string__String_empty(litaC_std__string__String litaC_s);
litaC_i32 litaC_std__string__String_size(litaC_std__string__String litaC_s);
litaC_i32 litaC_std__string__String_remaining(litaC_std__string__String litaC_s);
litaC_char* litaC_std__string__String_cStr(litaC_std__string__String litaC_s);
const litaC_char* litaC_std__string__String_cStrConst(litaC_std__string__String litaC_s);
litaC_char* litaC_std__string__StringClone(const litaC_char* litaC_original,litaC_i32 litaC_len,const litaC_std__mem__Allocator* litaC_allocator);
litaC_char* litaC_std__string__StringCopy(const litaC_char* litaC_src,litaC_char* litaC_dest,litaC_usize litaC_size);
const litaC_char* litaC_std__system__ArchAsStr(Lita_ArchType litaC_type);
Lita_ArchType litaC_std__system__ArchFromStr(const litaC_char* litaC_str,litaC_usize litaC_len);
const litaC_char* litaC_std__system__OSAsStr(Lita_OSType litaC_type);
Lita_OSType litaC_std__system__OSFromStr(const litaC_char* litaC_str,litaC_usize litaC_len);


litaC_bool litaC_std__system__SystemInit();
Lita_OSType litaC_std__system__GetOS();
Lita_ArchType litaC_std__system__GetArch();
litaC_char* litaC_std__system__GetEnv(const litaC_char* litaC_varName);
const litaC_char* litaC_std__system__CurrentWorkingPath();
litaC_bool litaC_std__system__FileTruncate(const litaC_char* litaC_filename,litaC_usize litaC_newLength);
litaC_bool litaC_std__system__FileTruncateFile(FILE* litaC_file,litaC_usize litaC_newLength);
litaC_bool litaC_std__system__FileDelete(const litaC_char* litaC_filename);
litaC_bool litaC_std__system__FileExists(const litaC_char* litaC_filename);
litaC_bool litaC_std__system__FileMove(const litaC_char* litaC_srcFilename,const litaC_char* litaC_destFilename);
litaC_bool litaC_std__system__FileIsDir(const litaC_char* litaC_filename);
litaC_bool litaC_std__system__Mkdir(const litaC_char* litaC_dir);
litaC_bool litaC_std__system__Mkdirs(const litaC_char* litaC_dir);
litaC_char* litaC_std__system__FilePath(const litaC_char* litaC_filename,litaC_char* litaC_out);
litaC_char* litaC_std__system__FileParent(const litaC_char* litaC_filename,litaC_char* litaC_out,litaC_i32* litaC_length);
litaC_char* litaC_std__system__PathNormalize(const litaC_char* litaC_filename,litaC_char* litaC_out);
litaC_i32 litaC_std__system__strcicmp(const litaC_char* litaC_a,const litaC_char* litaC_b,litaC_usize litaC_size);
litaC_char* litaC_std__system__GetAbsolutePath(const litaC_char* litaC_pwd,const litaC_char* litaC_path,litaC_char* litaC_output);
litaC_bool litaC_std__system__PathEquals(const litaC_char* litaC_a,const litaC_char* litaC_b);
litaC_char* litaC_std__system__FilePathToUri(const litaC_char* litaC_path,litaC_char* litaC_output);
litaC_char* litaC_std__system__UriToFilePath(const litaC_char* litaC_uri,litaC_char* litaC_output);

litaC_f64 litaC_std__system__SystemTimeMSec();
const litaC_char* litaC_std__system__CurrentDateTime();
litaC_std__system__Process litaC_std__system__SystemExec(const litaC_char* litaC_command);
litaC_i64 litaC_std__system__Process_readOutput(litaC_std__system__Process* litaC_this,litaC_char* litaC_buffer,litaC_usize litaC_length);
litaC_u64 litaC_std__system__Process_writeInput(litaC_std__system__Process* litaC_this,litaC_char* litaC_buffer,litaC_usize litaC_length);
litaC_void litaC_std__system__Process_close(litaC_std__system__Process* litaC_this);

LITAC_INLINE 
litaC_bool litaC_std__system__system_win___SystemInit();
LITAC_INLINE 
const litaC_char* litaC_std__system__system_win___CurrentWorkingPath();
LITAC_INLINE 
litaC_char* litaC_std__system__system_win___GetFullPathName(const litaC_char* litaC_fileName,litaC_char* litaC_output);
LITAC_INLINE 
litaC_bool litaC_std__system__system_win___Mkdir(const litaC_char* litaC_dir);
LITAC_INLINE 
litaC_bool litaC_std__system__system_win___FileIsDir(const litaC_char* litaC_filename);
LITAC_INLINE 
litaC_bool litaC_std__system__system_win___FileTruncate(const litaC_char* litaC_filename,litaC_usize litaC_newLength);
LITAC_INLINE 
litaC_bool litaC_std__system__system_win___FileTruncateFile(FILE* litaC_file,litaC_usize litaC_newLength);
LITAC_INLINE 
litaC_bool litaC_std__system__system_win___FileDelete(const litaC_char* litaC_filename);
LITAC_INLINE 

litaC_f64 litaC_std__system__system_win___SystemTimeMSec();
litaC_u32 litaC_std__map__StrHashFn(const litaC_char* litaC_str);
litaC_bool litaC_std__map__StrEqualFn(const litaC_char* litaC_a,const litaC_char* litaC_b);
litaC_u32 litaC_std__map__nextPowerOf2(litaC_u32 litaC_n);
litaC_u32 litaC_std__map__BlahHash(litaC_i32 litaC_a);
litaC_bool litaC_std__map__BlahEq(litaC_i32 litaC_a,litaC_i32 litaC_b);
litaC_void litaC_std__map__Print(litaC_std__map__Map_cb_i32_c_i32_ce_* litaC_m);

litaC_void litaC_std__profile__StartWatch(litaC_std__profile__ProfileTag litaC_tag);

litaC_void litaC_std__profile__StopWatch(litaC_std__profile__ProfileTag litaC_tag);

litaC_void litaC_std__profile__ExportTimings(const litaC_char* litaC_filename);
litaC_bool litaC_std__http__Http_init(litaC_std__http__Http* litaC_this,litaC_std__http__HttpOptions* litaC_options,const litaC_std__mem__Allocator* litaC_allocator);
litaC_void litaC_std__http__Http_free(litaC_std__http__Http* litaC_this);
litaC_void litaC_std__http__Http_setProxy(litaC_std__http__Http* litaC_this,const litaC_char* litaC_proxy);
litaC_bool litaC_std__http__Http_get(litaC_std__http__Http* litaC_this,const litaC_char* litaC_url,litaC_std__http__HttpResponse* litaC_resp);
litaC_bool litaC_std__http__Http_makeRequest(litaC_std__http__Http* litaC_this,litaC_std__http__HttpRequest* litaC_req,litaC_std__http__HttpResponse* litaC_resp);
litaC_usize litaC_std__http__HttpWriteCallback(litaC_void* litaC_data,litaC_usize litaC_size,litaC_usize litaC_n,litaC_void* litaC_userdata);
litaC_bool litaC_lex__Token_nameEquals(litaC_lex__Token* litaC_token,const litaC_char* litaC_str);
litaC_i32 litaC_lex__SrcPos_getLineLength(litaC_lex__SrcPos* litaC_p);

const litaC_char* litaC_lex__Token_asString(litaC_lex__Token* litaC_t);
litaC_void litaC_lex__Token_print(litaC_lex__Token* litaC_token);
litaC_lex__Lexer litaC_lex__LexerInit(const litaC_char* litaC_filename,const litaC_char* litaC_text,litaC_i64 litaC_length,const litaC_std__mem__Allocator* litaC_allocator);
litaC_bool litaC_lex__Lexer_hasError(litaC_lex__Lexer* litaC_l);
litaC_void litaC_lex__Lexer_error(litaC_lex__Lexer* litaC_l,const litaC_char* litaC_format,...);
litaC_i32 litaC_lex__Lexer_nextChar(litaC_lex__Lexer* litaC_l);
litaC_lex__Token litaC_lex__Lexer_eofToken(litaC_lex__Lexer* litaC_l);
litaC_lex__Token litaC_lex__Lexer_errorToken(litaC_lex__Lexer* litaC_l);
litaC_void litaC_lex__Lexer_skipWhitespace(litaC_lex__Lexer* litaC_l);
litaC_void litaC_lex__Lexer_skipComments(litaC_lex__Lexer* litaC_l);
litaC_bool litaC_lex__Lexer_isValidIdentifierStart(litaC_lex__Lexer* litaC_l,litaC_char litaC_c);
litaC_bool litaC_lex__Lexer_isValidIdentifierChar(litaC_lex__Lexer* litaC_l,litaC_char litaC_c);
litaC_bool litaC_lex__Lexer_isSymbolStart(litaC_lex__Lexer* litaC_l,litaC_char litaC_c);
litaC_bool litaC_lex__Lexer_checkKeyword(litaC_lex__Lexer* litaC_l);
litaC_lex__Token litaC_lex__Lexer_scanWord(litaC_lex__Lexer* litaC_l);
litaC_void litaC_lex__Lexer_scanInt(litaC_lex__Lexer* litaC_l,litaC_char* litaC_stream);
litaC_void litaC_lex__Lexer_scanFloat(litaC_lex__Lexer* litaC_l,litaC_char* litaC_stream);
litaC_void litaC_lex__Lexer_scanTypeInfo(litaC_lex__Lexer* litaC_l);
litaC_bool litaC_lex__IsHex(litaC_i32 litaC_c);
litaC_bool litaC_lex__IsHexChar(litaC_char litaC_c);
litaC_lex__Token litaC_lex__Lexer_scanNumber(litaC_lex__Lexer* litaC_l);
litaC_lex__Token litaC_lex__Lexer_scanChar(litaC_lex__Lexer* litaC_l);
litaC_bool litaC_lex__Lexer_validateCodepoint(litaC_lex__Lexer* litaC_l,const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_lex__Token litaC_lex__Lexer_scanString(litaC_lex__Lexer* litaC_l);
litaC_lex__Token litaC_lex__Lexer_scanSymbol(litaC_lex__Lexer* litaC_l);
litaC_bool litaC_lex__Lexer_eof(litaC_lex__Lexer* litaC_l);
litaC_lex__Token litaC_lex__Lexer_nextToken(litaC_lex__Lexer* litaC_l);

litaC_i32 litaC_std__unicode__utf8__Utf8Decode(const litaC_u8* litaC_str,litaC_i32 litaC_len,litaC_i32* litaC_codepoint);
litaC_i32 litaC_std__unicode__utf8__Utf8HexDecode(const litaC_char* litaC_str,litaC_i32 litaC_len);

litaC_i32 litaC_std__unicode__utf8__Utf8Encode(litaC_i32 litaC_codepoint,litaC_u8* litaC_dst);

litaC_i32 litaC_std__unicode__utf8__Utf8CharWidth(litaC_i32 litaC_codepoint);
litaC_bool litaC_std__unicode__utf8__Utf8CodepointValid(litaC_i32 litaC_codepoint);
litaC_types__TypeKind litaC_types__TypeKindFromString(const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_bool litaC_types__IsPtr(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsPtrLike(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsPtrOf(litaC_types__TypeInfo* litaC_type,litaC_types__TypeKind litaC_kind);
litaC_bool litaC_types__IsFuncLike(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsPrimitive(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsNumberLike(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsInteger(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsBooleanable(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsStringLike(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsCharLike(litaC_types__TypeInfo* litaC_type);
litaC_types__TypeInfo* litaC_types__AsTraitFuncPtr(litaC_types__TypeInfo* litaC_type,litaC_intern__InternedString litaC_name,litaC_types_new__TypeCache* litaC_typeCache);
litaC_types__TypeInfo* litaC_types__AsAggregate(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsAggregateLike(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsAggregate(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsPtrAggregate(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsTrait(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsPtrTrait(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsTraitLike(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsFieldAccessible(litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_types__IsGenericCapable(litaC_types__TypeInfo* litaC_type);
litaC_types__TypeInfo* litaC_types__TypeInfo_getBaseType(litaC_types__TypeInfo* litaC_this);
litaC_types__TypeInfo* litaC_types__TypeInfo_getTypeOf(litaC_types__TypeInfo* litaC_this);
const litaC_char* litaC_types__TypeInfo_toStringDebug(litaC_types__TypeInfo* litaC_this);
litaC_void litaC_types__TypeInfo_toString(litaC_types__TypeInfo* litaC_this,litaC_std__string_buffer__StringBuffer* litaC_sb,litaC_bool litaC_fullyQualify);
litaC_bool litaC_types__TypeInfo_strictEquals(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_other);
litaC_bool litaC_types__TypeInfo_isAssignable(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_other,litaC_checker__TypeChecker* litaC_checker,litaC_bool litaC_allowDecay,litaC_bool litaC_allowPtrArithmetic);
litaC_bool litaC_types__TypeInfo_isDeclarable(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_other,litaC_checker__TypeChecker* litaC_checker);
litaC_bool litaC_types__TypeInfo_canCastTo(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_castTo,litaC_checker__TypeChecker* litaC_checker);
litaC_bool litaC_types__IsFuncImpl(litaC_types__TypeInfo* litaC_traitFn,litaC_types__TypeInfo* litaC_fn,litaC_checker__TypeChecker* litaC_checker);
litaC_ast__TypeSpec* litaC_types__TypeInfo_asTypeSpec(litaC_types__TypeInfo* litaC_this,litaC_module__Module* litaC_module);
litaC_types__TypeInfo* litaC_types__TypeInfo_asPtr(litaC_types__TypeInfo* litaC_this,litaC_types_new__TypeCache* litaC_typeCache);
litaC_ast__EnumFieldEntryDecl* litaC_types__TypeInfo_getEnumField(litaC_types__TypeInfo* litaC_this,litaC_intern__InternedString litaC_name);
litaC_i32 litaC_types__TypeInfo_getEnumFieldIndex(litaC_types__TypeInfo* litaC_this,litaC_intern__InternedString litaC_name);
const litaC_char* litaC_types__TypeInfo_getBaseName(litaC_types__TypeInfo* litaC_this,litaC_char* litaC_name,litaC_intern__InternedString* litaC_alias);
litaC_ast__FieldStmt litaC_types__TypeInfo_getFieldByPosition(litaC_types__TypeInfo* litaC_this,litaC_i32 litaC_position);
litaC_ast__FieldStmt litaC_types__TypeInfo_getField(litaC_types__TypeInfo* litaC_this,litaC_intern__InternedString litaC_name);

litaC_i32 litaC_types__TypeInfo_getFieldIndex(litaC_types__TypeInfo* litaC_this,litaC_intern__InternedString litaC_name);

litaC_types__FieldPositionResult litaC_types__TypeInfo_getFieldPosition(litaC_types__TypeInfo* litaC_this,litaC_intern__InternedString litaC_name);

litaC_ast__FieldStmt litaC_types__TypeInfo_getFieldByType(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_bool litaC_isParent);
litaC_ast__FieldStmt litaC_types__TypeInfo_getFieldWithUsing(litaC_types__TypeInfo* litaC_this,litaC_intern__InternedString litaC_name);
litaC_void litaC_types__FieldPath_add(litaC_types__FieldPath* litaC_this,litaC_ast__FieldStmt litaC_field);
litaC_void litaC_types__FieldPath_pop(litaC_types__FieldPath* litaC_this);
litaC_bool litaC_types__TypeInfo_getFieldPath(litaC_types__TypeInfo* litaC_this,litaC_intern__InternedString litaC_name,litaC_types__FieldPath* litaC_path);
litaC_bool litaC_types__TypeInfo_getFieldPathByType(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_types__FieldPath* litaC_path);

const litaC_char* litaC_types__TypeInfo_getFunctionName(litaC_types__TypeInfo* litaC_this,litaC_char* litaC_result,litaC_intern__InternedString litaC_methodName,litaC_intern__InternedString* litaC_alias);
litaC_types__MethodResult litaC_types__TypeInfo_getMethod(litaC_types__TypeInfo* litaC_this,litaC_intern__Strings* litaC_strings,litaC_module__Module* litaC_module,litaC_intern__InternedString litaC_methodName);
litaC_bool litaC_types__TypeInfo_implementsTrait(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_iface,litaC_checker__TypeChecker* litaC_checker);
litaC_i64 litaC_types__NextTypeId();

litaC_void litaC_types__TypesInit(litaC_intern__Strings* litaC_strings);
litaC_void litaC_ast_new__TypeSpecAllocator_init(litaC_ast_new__TypeSpecAllocator* litaC_this,const litaC_std__mem__Allocator* litaC_allocator);
litaC_void litaC_ast_new__TypeSpecAllocator_free(litaC_ast_new__TypeSpecAllocator* litaC_this);
litaC_void litaC_ast_new__TypeSpecAllocator_clear(litaC_ast_new__TypeSpecAllocator* litaC_this);
litaC_ast__TypeSpec* litaC_ast_new__TypeSpecAllocator_alloc(litaC_ast_new__TypeSpecAllocator* litaC_this);
litaC_ast__TypeSpec* litaC_ast_new__NewVoidTypeSpec(litaC_lex__SrcPos litaC_pos,litaC_ast_new__TypeSpecAllocator* litaC_typeAllocator);
litaC_ast__TypeSpec* litaC_ast_new__NewNameTypeSpecIntern(litaC_lex__SrcPos litaC_pos,litaC_intern__InternedString litaC_name,litaC_ast_new__TypeSpecAllocator* litaC_typeAllocator);
litaC_ast__TypeSpec* litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind litaC_kind,litaC_lex__SrcPos litaC_pos,litaC_ast_new__TypeSpecAllocator* litaC_typeAllocator);
litaC_ast__Decl* litaC_ast_new__NewImportDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_name,litaC_ast__Identifier litaC_alias,litaC_bool litaC_isUsing,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewVarDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_name,litaC_ast__TypeSpec* litaC_type,litaC_ast__Expr* litaC_expr,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewFuncDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_name,litaC_std__array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_ast__ParametersStmt* litaC_params,litaC_ast__Stmt* litaC_body,litaC_ast__TypeSpec* litaC_returnType,litaC_i32 litaC_flags,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewAggregateDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__StmtKind litaC_kind,litaC_ast__Identifier litaC_name,litaC_std__array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_std__array__Array_cb_FieldStmt_ce_ litaC_fields,litaC_i32 litaC_flags,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewStructDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_name,litaC_std__array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_std__array__Array_cb_FieldStmt_ce_ litaC_fields,litaC_i32 litaC_flags,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewUnionDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_name,litaC_std__array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_std__array__Array_cb_FieldStmt_ce_ litaC_fields,litaC_i32 litaC_flags,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewTraitDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_name,litaC_std__array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_std__array__Array_cb_FieldStmt_ce_ litaC_fields,litaC_i32 litaC_flags,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewEnumDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_name,litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_ litaC_fields,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewTypedefDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_name,litaC_std__array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_ast__TypeSpec* litaC_type,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewNoteDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_name,litaC_std__array__Array_cb_FieldStmt_ce_ litaC_fields,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewParameterDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_name,litaC_ast__TypeSpec* litaC_type,litaC_ast__Expr* litaC_defaultExpr,litaC_bool litaC_isUsing,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewNotesDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_std__array__Array_cb__ptr_NoteStmt_ce_ litaC_notes,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewBuiltinDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_types__TypeInfo* litaC_type,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Decl* litaC_ast_new__NewPoisonDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewTernaryExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_ast__Expr* litaC_then,litaC_ast__Expr* litaC_other,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewBinaryExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_left,litaC_lex__TokenType litaC_operator,litaC_ast__Expr* litaC_right,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewUnaryExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__TokenType litaC_operator,litaC_ast__Expr* litaC_expr,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewInitExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__TypeSpec* litaC_type,litaC_std__array__Array_cb__ptr_InitArgExpr_ce_ litaC_arguments,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewFuncCallExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_object,litaC_std__array__Array_cb_CallArg_ce_ litaC_arguments,litaC_std__array__Array_cb__ptr_TypeSpec_ce_ litaC_genericArgs,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewSubscriptGetExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_object,litaC_ast__Expr* litaC_index,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewSubscriptSetExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_object,litaC_ast__Expr* litaC_index,litaC_lex__TokenType litaC_operator,litaC_ast__Expr* litaC_value,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewGetExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_object,litaC_ast__IdentifierExpr* litaC_field,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewSetExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_object,litaC_ast__IdentifierExpr* litaC_field,litaC_lex__TokenType litaC_operator,litaC_ast__Expr* litaC_value,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewIdentifierExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__TypeSpec* litaC_type,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewTypeIdentifierExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__TypeSpec* litaC_type,litaC_bool litaC_isBased,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewCastExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_castExpr,litaC_ast__TypeSpec* litaC_castTo,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewArrayDesignationExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_index,litaC_ast__Expr* litaC_value,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewInitArgExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_fieldName,litaC_i32 litaC_position,litaC_ast__Expr* litaC_value,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewBooleanExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_bool litaC_boolean,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewNullExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewNumberExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_number,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewStringExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_string,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewCharExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_character,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewGroupExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_groupedExpr,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewArrayInitExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__TypeSpec* litaC_type,litaC_std__array__Array_cb__ptr_Expr_ce_ litaC_values,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewSizeOfExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_sizeOfExpr,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewTypeOfExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_typeOfExpr,litaC_ast__TypeSpec* litaC_type,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewOffsetOfExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__TypeSpec* litaC_type,litaC_ast__Identifier litaC_field,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Expr* litaC_ast_new__NewPoisonExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewModuleStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_std__array__Array_cb__ptr_ImportDecl_ce_ litaC_imports,litaC_std__array__Array_cb__ptr_NoteStmt_ce_ litaC_notes,litaC_std__array__Array_cb__ptr_Decl_ce_ litaC_declarations,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewCompStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_intern__InternedString litaC_type,litaC_std__string_view__StringView litaC_expr,litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_body,litaC_ast__CompStmt* litaC_end,litaC_bool litaC_isScriptLoad,litaC_bool litaC_isStatic,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewFuncBodyStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_stmts,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewBlockStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_stmts,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewIfStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_ast__Stmt* litaC_then,litaC_ast__Stmt* litaC_other,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewWhileStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_ast__Stmt* litaC_body,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewDoWhileStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_ast__Stmt* litaC_body,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewForStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Stmt* litaC_init,litaC_ast__Expr* litaC_cond,litaC_ast__Stmt* litaC_post,litaC_ast__Stmt* litaC_body,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewSwitchCaseStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_ast__Stmt* litaC_body,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewSwitchStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_ litaC_cases,litaC_ast__Stmt* litaC_defaultStmt,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewBreakStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewContinueStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewReturnStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_expr,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewDeferStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Stmt* litaC_defered,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewGotoStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_label,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewLabelStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_label,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewNoteStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__TypeSpec* litaC_type,litaC_std__array__Array_cb_CallArg_ce_ litaC_arguments,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewEmptyStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewParametersStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_std__array__Array_cb__ptr_ParameterDecl_ce_ litaC_params,litaC_bool litaC_isVararg,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewVarFieldDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_fieldName,litaC_ast__TypeSpec* litaC_type,litaC_ast__Attributes litaC_attributes,litaC_ast__Expr* litaC_defaultExpr,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewTraitFieldDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_fieldName,litaC_ast__TypeSpec* litaC_type,litaC_ast__Attributes litaC_attributes,const litaC_std__mem__Allocator* litaC_allocator);
litaC_ast__Stmt* litaC_ast_new__NewEnumFieldEntryDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_fieldName,litaC_ast__Expr* litaC_value,litaC_ast__Attributes litaC_attributes,const litaC_std__mem__Allocator* litaC_allocator);
litaC_void litaC_ast__Node_setSrcPos(litaC_ast__Node* litaC_n,litaC_lex__SrcPos litaC_start,litaC_lex__SrcPos litaC_end);
litaC_std__array__Array_cb_CallArg_ce_* litaC_ast__Node_becomeParentOfChildrenCallArgs(litaC_ast__Node* litaC_n,litaC_std__array__Array_cb_CallArg_ce_* litaC_children);
litaC_bool litaC_ast__IsExpr(litaC_ast__Node* litaC_node);
litaC_bool litaC_ast__IsDecl(litaC_ast__Node* litaC_node);
litaC_bool litaC_ast__Decl_hasNotes(litaC_ast__Decl* litaC_d);
litaC_bool litaC_ast__Decl_hasNote(litaC_ast__Decl* litaC_d,const litaC_char* litaC_name);
litaC_ast__NoteStmt* litaC_ast__Decl_getNote(litaC_ast__Decl* litaC_d,const litaC_char* litaC_name);
litaC_ast__CallArg* litaC_ast__Decl_getNoteArgument(litaC_ast__Decl* litaC_d,const litaC_char* litaC_name,const litaC_char* litaC_arg);
litaC_ast__TypeSpec* litaC_ast__TypeSpec_getBaseType(litaC_ast__TypeSpec* litaC_this);
litaC_bool litaC_ast__FuncDecl_getName(litaC_ast__FuncDecl* litaC_f,litaC_char* litaC_name);
litaC_bool litaC_ast__Expr_isIdentifier(litaC_ast__Expr* litaC_expr);
litaC_bool litaC_ast__Expr_isConstNumberExpr(litaC_ast__Expr* litaC_expr);
litaC_bool litaC_ast__Expr_isConstExpr(litaC_ast__Expr* litaC_expr);
litaC_i32 litaC_ast__CallArgSort(litaC_ast__CallArg litaC_a,litaC_ast__CallArg litaC_b);
litaC_bool litaC_symbols__Symbol_isGenericCapable(litaC_symbols__Symbol* litaC_this);
litaC_bool litaC_symbols__Symbol_isVisibleTo(litaC_symbols__Symbol* litaC_this,litaC_module__Module* litaC_module);
litaC_symbols__Scope* litaC_symbols__NewScope(litaC_symbols__ScopeKind litaC_kind,litaC_symbols__Scope* litaC_parent,litaC_phase_result__PhaseResult* litaC_result,litaC_module__Module* litaC_module,const litaC_std__mem__Allocator* litaC_allocator);
litaC_void litaC_symbols__Scope_init(litaC_symbols__Scope* litaC_scope,litaC_symbols__ScopeKind litaC_kind,litaC_symbols__Scope* litaC_parent,litaC_phase_result__PhaseResult* litaC_result,litaC_module__Module* litaC_module,const litaC_std__mem__Allocator* litaC_allocator);
litaC_void litaC_symbols__Scope_initIncrementalBuild(litaC_symbols__Scope* litaC_scope);
litaC_void litaC_symbols__Scope_postIncrementalBuild(litaC_symbols__Scope* litaC_scope);
litaC_symbols__Symbol* litaC_symbols__Scope_lookupFunc(litaC_symbols__Scope* litaC_s,litaC_intern__InternedString litaC_name);
litaC_symbols__Symbol* litaC_symbols__Scope_lookupNote(litaC_symbols__Scope* litaC_s,litaC_intern__InternedString litaC_name);
litaC_symbols__Symbol* litaC_symbols__Scope_lookup(litaC_symbols__Scope* litaC_s,litaC_intern__InternedString litaC_name,litaC_bool litaC_includeFuncs);
litaC_void litaC_symbols__Scope_importSymbolWithAlias(litaC_symbols__Scope* litaC_this,litaC_lex__SrcPos litaC_importSrcPos,litaC_intern__InternedString litaC_name,litaC_intern__InternedString litaC_alias,litaC_symbols__Symbol* litaC_symbol);
litaC_void litaC_symbols__Scope_importSymbol(litaC_symbols__Scope* litaC_this,litaC_lex__SrcPos litaC_importSrcPos,litaC_intern__InternedString litaC_name,litaC_symbols__Symbol* litaC_symbol);
litaC_void litaC_symbols__Scope_removeSymbol(litaC_symbols__Scope* litaC_this,litaC_symbols__Symbol* litaC_symbol);
litaC_symbols__Symbol* litaC_symbols__Scope_addSymbol(litaC_symbols__Scope* litaC_this,litaC_intern__InternedString litaC_name,litaC_module__Module* litaC_module,litaC_ast__Decl* litaC_decl,litaC_i32 litaC_flags);
litaC_void litaC_symbols__Scope_print(litaC_symbols__Scope* litaC_this,const litaC_char* litaC_header);
litaC_void litaC_symbols__Scope_markReset(litaC_symbols__Scope* litaC_this,litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_symbols);
litaC_void litaC_symbols__Scope_cleanMarked(litaC_symbols__Scope* litaC_this,litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_symbols,litaC_bool litaC_remove);
litaC_void litaC_symbols__Scope_removeSymbolFromModules(litaC_symbols__Scope* litaC_this,litaC_symbols__Symbol* litaC_symbol);
litaC_module__Module* litaC_module__BuiltinsInit(litaC_lita__Lita* litaC_lita);
litaC_void litaC_module__AddBuiltin(litaC_lita__Lita* litaC_lita,litaC_types__TypeInfo* litaC_type);
litaC_symbols__Symbol* litaC_module__GetBuiltinSymbol(litaC_i64 litaC_typeid);
litaC_module__Module* litaC_module__NewModule(litaC_lita__Lita* litaC_lita,litaC_std__string_view__StringView litaC_packageName,const litaC_char* litaC_filename);
litaC_void litaC_module__Module_init(litaC_module__Module* litaC_this,litaC_lita__Lita* litaC_lita);
litaC_void litaC_module__Module_initIncrementalBuild(litaC_module__Module* litaC_this);
litaC_bool litaC_module__Module_isBuiltin(litaC_module__Module* litaC_this);
litaC_void litaC_module__Module_postIncrementalBuild(litaC_module__Module* litaC_this);
litaC_symbols__Symbol* litaC_module__Module_getType(litaC_module__Module* litaC_this,litaC_intern__InternedString litaC_type);
litaC_symbols__Symbol* litaC_module__Module_getFuncType(litaC_module__Module* litaC_this,litaC_intern__InternedString litaC_type);
litaC_symbols__Symbol* litaC_module__Module_getNoteType(litaC_module__Module* litaC_this,litaC_intern__InternedString litaC_type);
litaC_bool litaC_module__Module_isMethodForType(litaC_module__Module* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_symbols__Symbol* litaC_sym);
litaC_i32 litaC_module__Module_getMethodsForType(litaC_module__Module* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_symbols__Symbol** litaC_result);

litaC_intern__InternedString* litaC_module__Module_getImportAlias(litaC_module__Module* litaC_this,litaC_module__Module* litaC_module);
litaC_void litaC_module__Module_importModule(litaC_module__Module* litaC_this,litaC_ast__ImportDecl* litaC_importDecl,litaC_module__Module* litaC_moduleToImport);
litaC_void litaC_module__Module_importModuleSymbols(litaC_module__Module* litaC_this,litaC_lex__SrcPos litaC_importSrcPos,litaC_module__Module* litaC_moduleToImport,litaC_intern__InternedString* litaC_moduleName,litaC_bool litaC_isUsing);
litaC_void litaC_module__Module_importModuleSymbol(litaC_module__Module* litaC_this,litaC_lex__SrcPos litaC_importSrcPos,litaC_module__Module* litaC_moduleToImport,litaC_intern__InternedString* litaC_moduleName,litaC_symbols__Symbol* litaC_symbol,litaC_intern__InternedString litaC_symName,litaC_bool litaC_isUsing);
litaC_char* litaC_module__GetFilenameKey(const litaC_char* litaC_filename,litaC_char* litaC_output);
LITAC_INLINE 
litaC_bool litaC_module__Module_equals(litaC_module__Module* litaC_this,litaC_module__Module* litaC_other);

litaC_bool litaC_module__Module_isInPackage(litaC_module__Module* litaC_this,litaC_module__Module* litaC_other);
litaC_void litaC_module__Module_print(litaC_module__Module* litaC_this,const litaC_char* litaC_header);
litaC_void litaC_module__ModuleId_fromFile(litaC_module__ModuleId* litaC_moduleId,litaC_lita__Lita* litaC_lita,litaC_std__string_view__StringView litaC_packageName,const litaC_char* litaC_filename);
litaC_std__string_view__StringView litaC_module__ToModulePath(litaC_std__string_view__StringView litaC_moduleName);
litaC_std__string_view__StringView litaC_module__ToModuleName(litaC_std__string_view__StringView litaC_modulePath);
litaC_std__string_view__StringView litaC_module__GetModuleName(litaC_std__string_view__StringView litaC_pathStr);
litaC_void litaC_std__mem__arena_allocator__ArenaAllocator_init(litaC_std__mem__arena_allocator__ArenaAllocator* litaC_this,litaC_usize litaC_size,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__mem__arena_allocator__ArenaAllocator_free(litaC_std__mem__arena_allocator__ArenaAllocator* litaC_this);
litaC_void litaC_std__mem__arena_allocator__ArenaAllocator_clear(litaC_std__mem__arena_allocator__ArenaAllocator* litaC_this);
litaC_usize litaC_std__mem__arena_allocator__ArenaAllocator_unusedBytes(litaC_std__mem__arena_allocator__ArenaAllocator* litaC_this);
litaC_void* litaC_std__mem__arena_allocator__ArenaAllocator_malloc(litaC_std__mem__arena_allocator__ArenaAllocator* litaC_this,litaC_usize litaC_size);
litaC_void* litaC_std__mem__arena_allocator__ArenaMalloc(const litaC_std__mem__Allocator* litaC_alloc,litaC_usize litaC_size);
litaC_void* litaC_std__mem__arena_allocator__ArenaCalloc(const litaC_std__mem__Allocator* litaC_alloc,litaC_usize litaC_num,litaC_usize litaC_size);
litaC_void* litaC_std__mem__arena_allocator__ArenaRealloc(const litaC_std__mem__Allocator* litaC_alloc,litaC_void* litaC_ptr,litaC_usize litaC_oldSize,litaC_usize litaC_size);
litaC_void litaC_std__mem__arena_allocator__ArenaFree(const litaC_std__mem__Allocator* litaC_alloc,litaC_void* litaC_ptr);
litaC_phase_result__PhaseResult litaC_phase_result__PhaseResultInit(const litaC_std__mem__Allocator* litaC_allocator);
litaC_void litaC_phase_result__PhaseResult_addError(litaC_phase_result__PhaseResult* litaC_r,litaC_lex__SrcPos litaC_pos,const litaC_char* litaC_format,...);
litaC_void litaC_phase_result__PhaseResult_addErrorStr(litaC_phase_result__PhaseResult* litaC_r,litaC_lex__SrcPos litaC_pos,litaC_std__string_buffer__StringBuffer* litaC_sb);
litaC_bool litaC_phase_result__PhaseResult_hasErrors(litaC_phase_result__PhaseResult* litaC_r);
litaC_void litaC_phase_result__PhaseResult_clear(litaC_phase_result__PhaseResult* litaC_r);
litaC_void litaC_common__Log(litaC_common__LogLevel litaC_level,const litaC_char* litaC_format,...);
litaC_void litaC_common__Logv(litaC_common__LogLevel litaC_level,const litaC_char* litaC_format,va_list litaC_args);
litaC_void litaC_common__Info(const litaC_char* litaC_format,...);
litaC_void litaC_common__Debug(const litaC_char* litaC_format,...);
litaC_void litaC_common__Error(const litaC_char* litaC_format,...);
litaC_void litaC_common__Panic(const litaC_char* litaC_format,...);
litaC_char* litaC_common__EscapeName(const litaC_char* litaC_name,litaC_i32 litaC_len,litaC_std__string_buffer__StringBuffer* litaC_sb);
litaC_void litaC_lita__Lita_init(litaC_lita__Lita* litaC_this,litaC_lita__LitaOptions* litaC_options);

litaC_void litaC_lita__Lita_reset(litaC_lita__Lita* litaC_this);
litaC_void litaC_lita__Lita_free(litaC_lita__Lita* litaC_lita);
litaC_void litaC_lita__Lita_addModule(litaC_lita__Lita* litaC_lita,litaC_module__Module* litaC_module);
litaC_module__Module* litaC_lita__Lita_getModule(litaC_lita__Lita* litaC_lita,const litaC_char* litaC_filename);
litaC_void litaC_lita__Lita_startCapture(litaC_lita__Lita* litaC_lita,litaC_lita__MetricType litaC_type);
litaC_void litaC_lita__Lita_endCapture(litaC_lita__Lita* litaC_lita,litaC_lita__MetricType litaC_type);
litaC_void litaC_lita__Lita_incrementalBuild(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module);
litaC_void litaC_lita__Lita_syncSymbols(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module,litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_moduleSymbols,litaC_std__array__Array_cb__ptr_Symbol_ce_* litaC_symbols,litaC_symbols__SymbolKind litaC_kind);
litaC_module__Module* litaC_lita__Lita_parse(litaC_lita__Lita* litaC_this);
litaC_bool litaC_lita__Lita_typeCheck(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module,litaC_i32 litaC_flags);
litaC_bool litaC_lita__Lita_transpile(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module);
litaC_void litaC_lita__LibtccErrorFunc(litaC_void* litaC_data,const litaC_char* litaC_msg);
litaC_bool litaC_lita__Lita_compileWithLibtcc(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module,const litaC_char* litaC_binaryFilename);
litaC_bool litaC_lita__Lita_emitC(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module,const litaC_char* litaC_cFilename);
litaC_bool litaC_lita__Lita_compileC(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module,const litaC_char* litaC_sourceFilename,const litaC_char* litaC_binaryFilename);
litaC_void litaC_lita__Lita_applyCompilerOptions(litaC_lita__Lita* litaC_this,litaC_std__string_buffer__StringBuffer* litaC_commandStr);
litaC_i32 litaC_lita__Lita_run(litaC_lita__Lita* litaC_this);
litaC_bool litaC_lita__FindModulePath(litaC_lita__Lita* litaC_lita,litaC_std__string_view__StringView litaC_moduleName,litaC_char* litaC_filename);
litaC_bool litaC_lita__ParseModule(litaC_lita__Lita* litaC_lita,litaC_module__Module* litaC_module,litaC_lex__SrcPos litaC_pos);
litaC_std__string_view__StringView litaC_lita__GetPackageName(const litaC_char* litaC_srcPath,const litaC_char* litaC_inputFile);
litaC_void litaC_std__mem__bucket_allocator__BucketAllocator_init(litaC_std__mem__bucket_allocator__BucketAllocator* litaC_this,const litaC_std__mem__Allocator* litaC_decorated,litaC_usize litaC_bucketSize);
litaC_void litaC_std__mem__bucket_allocator__BucketAllocator_clear(litaC_std__mem__bucket_allocator__BucketAllocator* litaC_this);

litaC_void litaC_std__mem__bucket_allocator__BucketAllocator_free(litaC_std__mem__bucket_allocator__BucketAllocator* litaC_this);
litaC_void* litaC_std__mem__bucket_allocator__BucketAllocator_malloc(litaC_std__mem__bucket_allocator__BucketAllocator* litaC_this,litaC_usize litaC_size);
litaC_void litaC_std__mem__bucket_allocator__BucketFree(const litaC_std__mem__Allocator* litaC_alloc,litaC_void* litaC_ptr);
litaC_preprocessor__Preprocessor litaC_preprocessor__PreprocessorInit(litaC_lita__Lita* litaC_lita);
litaC_void litaC_preprocessor__Preprocessor_init(litaC_preprocessor__Preprocessor* litaC_this,litaC_lita__Lita* litaC_lita);
litaC_void litaC_preprocessor__Preprocessor_free(litaC_preprocessor__Preprocessor* litaC_this);

litaC_bool litaC_preprocessor__Preprocessor_eval(litaC_preprocessor__Preprocessor* litaC_this,litaC_ast__CompStmt* litaC_comp);

litaC_void litaC_preprocessor__Preprocessor_evaluateForModule(litaC_preprocessor__Preprocessor* litaC_this,litaC_module__Module* litaC_module,litaC_ast__ModuleStmt* litaC_moduleStmt,litaC_ast__CompStmt* litaC_comp);

litaC_ast__Stmt* litaC_preprocessor__Preprocessor_evaluateForFunction(litaC_preprocessor__Preprocessor* litaC_this,litaC_checker__TypeChecker* litaC_checker,litaC_ast__CompStmt* litaC_comp,litaC_bool litaC_isFirst);
litaC_void litaC_preprocessor__Preprocessor_preResolveSymbols(litaC_preprocessor__Preprocessor* litaC_this,litaC_checker__TypeChecker* litaC_checker,litaC_bool litaC_isIncrementalBuild);
litaC_void litaC_preprocessor__Preprocessor_postResolveSymbols(litaC_preprocessor__Preprocessor* litaC_this,litaC_checker__TypeChecker* litaC_checker,litaC_bool litaC_isIncrementalBuild);
litaC_void litaC_preprocessor__Preprocessor_drainQueue(litaC_preprocessor__Preprocessor* litaC_this);
litaC_std__regex__Regex litaC_std__regex__RegexCompile(const litaC_char* litaC_pattern);
litaC_i32 litaC_std__regex__Regex_match(litaC_std__regex__Regex* litaC_this,const litaC_char* litaC_text,litaC_i32* litaC_matchlength);
litaC_i32 litaC_std__regex__RegexMatch(const litaC_char* litaC_pattern,const litaC_char* litaC_text,litaC_i32* litaC_matchlength);
litaC_intern__InternedString litaC_ast_copy__NewTokenNameIntern(litaC_lex__Token litaC_token,litaC_intern__Strings* litaC_strings);
litaC_std__array__Array_cb__ptr_TypeSpec_ce_ litaC_ast_copy__CopyTypeSpecs(litaC_std__array__Array_cb__ptr_TypeSpec_ce_ litaC_specs,litaC_module__Module* litaC_module);
litaC_ast__TypeSpec* litaC_ast_copy__CopyTypeSpec(litaC_ast__TypeSpec* litaC_spec,litaC_module__Module* litaC_module);
litaC_ast__Decl* litaC_ast_copy__CopyDecl(litaC_ast__Decl* litaC_decl,litaC_module__Module* litaC_module);
litaC_std__array__Array_cb_CallArg_ce_ litaC_ast_copy__CopyCallArgs(litaC_std__array__Array_cb_CallArg_ce_* litaC_args,litaC_module__Module* litaC_module);
litaC_std__array__Array_cb__ptr_Expr_ce_ litaC_ast_copy__CopyExprs(litaC_std__array__Array_cb__ptr_Expr_ce_* litaC_exprs,litaC_module__Module* litaC_module);
litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_ast_copy__CopyStmts(litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_stmts,litaC_module__Module* litaC_module);
litaC_ast__Expr* litaC_ast_copy__CopyExpr(litaC_ast__Expr* litaC_expr,litaC_module__Module* litaC_module);
litaC_ast__Stmt* litaC_ast_copy__CopyStmt(litaC_ast__Stmt* litaC_stmt,litaC_module__Module* litaC_module);
litaC_ast__AggregateDecl* litaC_ast_copy__CopyAggregateDecl(litaC_ast__AggregateDecl* litaC_decl,litaC_module__Module* litaC_module);
litaC_ast__FuncDecl* litaC_ast_copy__CopyFuncDecl(litaC_ast__FuncDecl* litaC_decl,litaC_module__Module* litaC_module);
litaC_ast__ParametersStmt* litaC_ast_copy__CopyParameters(litaC_ast__ParametersStmt litaC_params,litaC_module__Module* litaC_module);
litaC_ast__TypedefDecl* litaC_ast_copy__CopyTypedefDecl(litaC_ast__TypedefDecl* litaC_decl,litaC_module__Module* litaC_module);
litaC_void litaC_ast_copy__AstInsertText(litaC_ast__Node* litaC_node,const litaC_char* litaC_text,litaC_i32 litaC_index,litaC_module__Module* litaC_module,litaC_lita__Lita* litaC_lita);

litaC_void litaC_ast_copy__AstInsert(litaC_ast__Node* litaC_node,litaC_ast__Stmt* litaC_stmt,litaC_i32 litaC_index,litaC_module__Module* litaC_module,litaC_lita__Lita* litaC_lita);
const litaC_char* litaC_ast_copy__AstAddImport(litaC_lita__Lita* litaC_lita,litaC_checker__TypeChecker* litaC_checker,litaC_module__Module* litaC_module,litaC_module__Module* litaC_importModule);
litaC_void litaC_checker__TypeChecker_init(litaC_checker__TypeChecker* litaC_this,litaC_lita__Lita* litaC_lita);

litaC_symbols__ProgramSymbols litaC_checker__TypeChecker_typeCheck(litaC_checker__TypeChecker* litaC_this,litaC_module__Module* litaC_root,litaC_i32 litaC_flags);
LITAC_INLINE 
litaC_i32 litaC_checker__TypeChecker_errors(litaC_checker__TypeChecker* litaC_this);
litaC_bool litaC_checker__TypeChecker_checkTrait(litaC_checker__TypeChecker* litaC_this,litaC_std__string_buffer__StringBuffer* litaC_sb,litaC_types__TypeInfo* litaC_a,litaC_types__TypeInfo* litaC_b,const litaC_char* litaC_description);
litaC_bool litaC_checker__TypeChecker_checkCastability(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_src,litaC_types__TypeInfo* litaC_a,litaC_types__TypeInfo* litaC_b);
litaC_bool litaC_checker__TypeChecker_checkAssignability(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_src,litaC_types__TypeInfo* litaC_a,litaC_types__TypeInfo* litaC_b,litaC_bool litaC_allowDecay);
litaC_bool litaC_checker__TypeChecker_checkDeclarability(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_src,litaC_types__TypeInfo* litaC_a,litaC_types__TypeInfo* litaC_b);
litaC_bool litaC_checker__TypeChecker_checkTypeCompatibility(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_src,litaC_types__TypeInfo* litaC_a,litaC_types__TypeInfo* litaC_b,litaC_bool litaC_allowPtrArithmetic);
litaC_bool litaC_checker__TypeChecker_checkNote(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_src,litaC_types__TypeInfo* litaC_a);
litaC_void litaC_checker__TypeChecker_createModuleSymbols(litaC_checker__TypeChecker* litaC_this,litaC_module__Module* litaC_module);
litaC_symbols__Symbol* litaC_checker__TypeChecker_createDeclSymbol(litaC_checker__TypeChecker* litaC_this,litaC_ast__Decl* litaC_decl);
litaC_void litaC_checker__TypeChecker_enterModule(litaC_checker__TypeChecker* litaC_this,litaC_module__Module* litaC_module);
litaC_void litaC_checker__TypeChecker_leaveModule(litaC_checker__TypeChecker* litaC_this);
litaC_symbols__Scope* litaC_checker__TypeChecker_currentScope(litaC_checker__TypeChecker* litaC_this);
litaC_void litaC_checker__TypeChecker_pushScope(litaC_checker__TypeChecker* litaC_this,litaC_symbols__Scope* litaC_scope);
litaC_void litaC_checker__TypeChecker_popScope(litaC_checker__TypeChecker* litaC_this);
litaC_bool litaC_checker__TypeChecker_isGenericParamType(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypeSpec* litaC_name);
litaC_void litaC_checker__TypeChecker_createImportSymbols(litaC_checker__TypeChecker* litaC_this,litaC_ast__ImportDecl* litaC_imp);
litaC_void litaC_checker__TypeChecker_resolveSymbols(litaC_checker__TypeChecker* litaC_this);
litaC_void litaC_checker__TypeChecker_resolveSymbol(litaC_checker__TypeChecker* litaC_this,litaC_symbols__Symbol* litaC_sym);
litaC_void litaC_checker__TypeChecker_finishResolveSymbol(litaC_checker__TypeChecker* litaC_this,litaC_symbols__Symbol* litaC_sym);
litaC_symbols__Symbol* litaC_checker__TypeChecker_getType(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypeSpec* litaC_spec,litaC_checker__SearchType litaC_searchType);
litaC_symbols__Symbol* litaC_checker__TypeChecker_getTypeByName(litaC_checker__TypeChecker* litaC_this,litaC_intern__InternedString litaC_typeName,litaC_checker__SearchType litaC_searchType);
litaC_symbols__Symbol* litaC_checker__GetTypeFromModule(litaC_module__Module* litaC_module,litaC_intern__InternedString litaC_typeName,litaC_checker__SearchType litaC_searchType);
litaC_bool litaC_checker__TypeChecker_implementsTrait(litaC_checker__TypeChecker* litaC_this,litaC_types__TypeInfo* litaC_agg,litaC_types__TypeInfo* litaC_iface);
litaC_types__TypeInfo* litaC_checker__TypeChecker_resolveNoteTypeSpec(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypeSpec* litaC_spec);
litaC_types__TypeInfo* litaC_checker__TypeChecker_resolveTypeSpec(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypeSpec* litaC_spec,litaC_checker__SearchType litaC_searchType);
litaC_symbols__Symbol* litaC_checker__TypeChecker_addSymbol(litaC_checker__TypeChecker* litaC_this,litaC_ast__Decl* litaC_decl,litaC_types__TypeInfo* litaC_typeInfo);
litaC_void litaC_checker__TypeChecker_addTypeToScope(litaC_checker__TypeChecker* litaC_this,litaC_ast__Decl* litaC_decl,litaC_symbols__Scope* litaC_scope,litaC_types__TypeInfo* litaC_baseType,litaC_types__TypeInfo* litaC_currentType);
litaC_bool litaC_checker__TypeChecker_resolveNotes(litaC_checker__TypeChecker* litaC_this,litaC_std__array__Array_cb__ptr_NoteStmt_ce_* litaC_notes);
litaC_bool litaC_checker__TypeChecker_resolveStmt(litaC_checker__TypeChecker* litaC_this,litaC_ast__Stmt* litaC_stmt);
litaC_u32 litaC_types_new__Hash(litaC_types_new__ArrayEntry litaC_a);
litaC_bool litaC_types_new__Equals(litaC_types_new__ArrayEntry litaC_a,litaC_types_new__ArrayEntry litaC_b);
litaC_void litaC_types_new__TypeCache_init(litaC_types_new__TypeCache* litaC_this,const litaC_std__mem__Allocator* litaC_allocator);
litaC_types__TypeInfo* litaC_types_new__TypeCache_newTypeInfo(litaC_types_new__TypeCache* litaC_this);
litaC_types__TypeInfo* litaC_types_new__TypeCache_newGenericParamTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_intern__InternedString litaC_name);
litaC_types__TypeInfo* litaC_types_new__TypeCache_newFuncTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_symbols__Symbol* litaC_sym,litaC_ast__FuncDecl* litaC_funcDecl);
litaC_types__TypeInfo* litaC_types_new__TypeCache_newArrayTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_types__TypeInfo* litaC_arrayOf,litaC_usize litaC_length,litaC_ast__Expr* litaC_numOfElements,litaC_bool litaC_isLengthDefined);
litaC_types__TypeInfo* litaC_types_new__TypeCache_newFuncPtrTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_std__array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_types__TypeInfo* litaC_returnType,litaC_std__array__Array_cb__ptr_TypeInfo_ce_ litaC_paramDecls,litaC_bool litaC_hasVarargs);
litaC_types__TypeInfo* litaC_types_new__TypeCache_newAggregateTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_symbols__Symbol* litaC_sym,litaC_ast__AggregateDecl* litaC_decl);
litaC_types__TypeInfo* litaC_types_new__TypeCache_newEnumTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_symbols__Symbol* litaC_sym,litaC_ast__EnumDecl* litaC_enumDecl);
litaC_types__TypeInfo* litaC_types_new__TypeCache_newForeignTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_symbols__Symbol* litaC_sym);
litaC_types__TypeInfo* litaC_types_new__TypeCache_newConstTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_types__TypeInfo* litaC_base);
litaC_types__TypeInfo* litaC_types_new__TypeCache_newPtrTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_types__TypeInfo* litaC_base);
litaC_types__TypeInfo* litaC_types_new__TypeCache_typeDecay(litaC_types_new__TypeCache* litaC_this,litaC_types__TypeInfo* litaC_type);
litaC_u32 litaC_intern__InternHashFn(litaC_intern__InternedString litaC_a);
litaC_bool litaC_intern__InternEqualFn(litaC_intern__InternedString litaC_a,litaC_intern__InternedString litaC_b);
litaC_void litaC_intern__Strings_init(litaC_intern__Strings* litaC_this,const litaC_std__mem__Allocator* litaC_allocator);
litaC_void litaC_intern__Strings_free(litaC_intern__Strings* litaC_this);
litaC_void litaC_intern__Strings_internConstant(litaC_intern__Strings* litaC_this,const litaC_char* litaC_string,litaC_i32 litaC_length,litaC_intern__InternedString* litaC_intern);
litaC_intern__InternedString litaC_intern__Strings_internStringView(litaC_intern__Strings* litaC_this,litaC_std__string_view__StringView* litaC_string);

litaC_intern__InternedString litaC_intern__Strings_intern(litaC_intern__Strings* litaC_this,const litaC_char* litaC_string,litaC_i32 litaC_length);

litaC_intern__InternedString litaC_intern__Strings_internCopy(litaC_intern__Strings* litaC_this,const litaC_char* litaC_string,litaC_i32 litaC_length);
litaC_void litaC_intern__Strings_put(litaC_intern__Strings* litaC_this,litaC_std__string_view__StringView litaC_key,litaC_intern__InternedString litaC_value);
litaC_i32 litaC_intern__Strings_size(litaC_intern__Strings* litaC_this);
litaC_intern__InternedString litaC_intern__Strings_get(litaC_intern__Strings* litaC_this,litaC_std__string_view__StringView* litaC_key);
litaC_void litaC_intern__Strings_grow(litaC_intern__Strings* litaC_this,litaC_i32 litaC_newlength);
LITAC_INLINE 
litaC_bool litaC_intern__InternedString_equalsStr(litaC_intern__InternedString* litaC_this,const litaC_char* litaC_other);
LITAC_INLINE 
litaC_bool litaC_intern__InternedString_equals(litaC_intern__InternedString* litaC_this,litaC_intern__InternedString* litaC_other);
LITAC_INLINE 
litaC_bool litaC_intern__InternedString_empty(litaC_intern__InternedString* litaC_this);
litaC_std__string_view__StringView litaC_intern__InternedString_asStringView(litaC_intern__InternedString* litaC_this);
litaC_void litaC_ast_print__PrintTypeSpec(litaC_ast__TypeSpec* litaC_spec);
litaC_void litaC_ast_print__PrintName(litaC_lex__Token litaC_tok);
litaC_void litaC_ast_print__Printf(litaC_i32 litaC_indent,const litaC_char* litaC_format,...);
litaC_void litaC_ast_print__PrintStmt(litaC_ast__Stmt* litaC_s,litaC_i32 litaC_indent);
litaC_void litaC_generics__GetGenericName(litaC_checker__TypeChecker* litaC_checker,litaC_ast__TypeSpec* litaC_type,litaC_std__string__String* litaC_str);
litaC_symbols__Symbol* litaC_generics__CreateTypeFromGenericTemplate(litaC_checker__TypeChecker* litaC_checker,litaC_symbols__Symbol* litaC_sym,litaC_ast__TypeSpec* litaC_name);
litaC_ast__GenericDecl* litaC_generics__CreateDecl(litaC_symbols__Symbol* litaC_sym,litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_genericArgs,litaC_module__Module* litaC_module);
litaC_ast__GenericDecl* litaC_generics__CreateAggregateDecl(litaC_ast__AggregateDecl* litaC_aggDecl,litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_genericArgs,litaC_module__Module* litaC_module);
litaC_ast__GenericDecl* litaC_generics__CreateFuncDecl(litaC_ast__FuncDecl* litaC_funcDecl,litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_genericArgs,litaC_module__Module* litaC_module);
litaC_ast__GenericDecl* litaC_generics__CreateTypedefDecl(litaC_ast__TypedefDecl* litaC_typedefDecl,litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_genericArgs,litaC_module__Module* litaC_module);
litaC_ast__TypeSpec* litaC_generics__Template_replaceTypeSpec(litaC_generics__Template* litaC_this,litaC_ast__TypeSpec* litaC_type);
litaC_bool litaC_generics__ReplaceTypes(litaC_generics__Template* litaC_template,litaC_ast__Node* litaC_ast);
litaC_bool litaC_generics__HasGenericParam(litaC_checker__TypeChecker* litaC_checker,litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_genericArgs);
litaC_void litaC_introspection__Introspect_generate(litaC_introspection__Introspect* litaC_this,litaC_checker__TypeChecker* litaC_checker);
litaC_void litaC_introspection__Introspect_emitFunc(litaC_introspection__Introspect* litaC_this,litaC_std__string_buffer__StringBuffer* litaC_sb,litaC_std__string_buffer__StringBuffer* litaC_scratch,litaC_symbols__Symbol* litaC_sym);
litaC_void litaC_introspection__Introspect_emitType(litaC_introspection__Introspect* litaC_this,litaC_std__string_buffer__StringBuffer* litaC_sb,litaC_std__string_buffer__StringBuffer* litaC_scratch,litaC_symbols__Symbol* litaC_sym);
litaC_void litaC_introspection__Introspect_emitPrimitiveType(litaC_introspection__Introspect* litaC_this,litaC_std__string_buffer__StringBuffer* litaC_sb,litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_checker_decl__TypeChecker_resolveDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__Decl* litaC_decl);
litaC_types__TypeInfo* litaC_checker_decl__TypeChecker_resolveValueDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__VarDecl* litaC_decl);
litaC_bool litaC_checker_decl__TypeChecker_checkAnonAggregateFieldDuplicate(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_ast__FieldStmt litaC_field,litaC_i32 litaC_index);
litaC_void litaC_checker_decl__TypeChecker_errorInvalidMemberForTrait(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_intern__InternedString litaC_fieldName,litaC_lex__SrcPos litaC_pos);
litaC_void litaC_checker_decl__TypeChecker_errorUsingMember(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_intern__InternedString litaC_fieldName,litaC_lex__SrcPos litaC_pos);
litaC_void litaC_checker_decl__TypeChecker_errorUsingParameter(litaC_checker__TypeChecker* litaC_this,litaC_ast__ParameterDecl* litaC_paramDecl);
litaC_void litaC_checker_decl__TypeChecker_errorDuplicateMember(litaC_checker__TypeChecker* litaC_this,litaC_ast__Decl* litaC_aggDecl,litaC_intern__InternedString litaC_fieldName,litaC_lex__SrcPos litaC_pos);
litaC_bool litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_intern__InternedString litaC_fieldName,litaC_i32 litaC_index);
litaC_bool litaC_checker_decl__TypeChecker_resolveNoteDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_noteDecl);
litaC_bool litaC_checker_decl__TypeChecker_resolveAggregateDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl);
litaC_i32 litaC_checker_decl__TypeChecker_addFieldReferences(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_types__TypeInfo* litaC_parentTypeInfo,litaC_i32 litaC_position);
litaC_bool litaC_checker_decl__TypeChecker_checkEnumFieldDuplicate(litaC_checker__TypeChecker* litaC_this,litaC_ast__EnumDecl* litaC_enumDecl,litaC_ast__EnumFieldEntryDecl* litaC_field,litaC_i32 litaC_index);
litaC_bool litaC_checker_decl__TypeChecker_resolveEnumDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__EnumDecl* litaC_enumDecl);
litaC_void litaC_checker_decl__TypeChecker_checkLabels(litaC_checker__TypeChecker* litaC_this);
litaC_bool litaC_checker_decl__TypeChecker_resolveFuncDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncDecl* litaC_funcDecl);
litaC_bool litaC_checker_decl__TypeChecker_resolveParamDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__ParameterDecl* litaC_paramDecl);
litaC_bool litaC_checker_decl__TypeChecker_resolveTypedefDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypedefDecl* litaC_typedefDecl);
litaC_bool litaC_checker_expr__TypeChecker_resolveConstExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveFuncIdentifierExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__IdentifierExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_isMethodSyntax(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_std__array__Array_cb_CallArg_ce_* litaC_suppliedArgs);
litaC_ast__Expr* litaC_checker_expr__TypeChecker_coerceTypeWithUsing(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_sourceType,litaC_types__TypeInfo* litaC_targetType);
litaC_bool litaC_checker_expr__TypeChecker_coerceFuncArgs(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_types__TypeInfo* litaC_funcType,litaC_std__array__Array_cb_CallArg_ce_* litaC_suppliedArgs);
litaC_bool litaC_checker_expr__TypeChecker_coerceFuncArg(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_i32 litaC_index,litaC_ast__Expr* litaC_argExpr,litaC_types__TypeInfo* litaC_paramInfo,litaC_std__array__Array_cb_CallArg_ce_* litaC_suppliedArgs);
litaC_bool litaC_checker_expr__TypeChecker_checkNumberOfArgs(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_intern__InternedString litaC_funcName,litaC_i32 litaC_maxNumOfArgs,litaC_bool litaC_hasVarargs,litaC_i32 litaC_numberOfSuppliedArgs,litaC_i32 litaC_numberOfDefaultArgs);
litaC_types__TypeInfo* litaC_checker_expr__TypeChecker_inferredType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Identifier litaC_name,litaC_types__TypeInfo* litaC_paramType,litaC_types__TypeInfo* litaC_expectedType);
litaC_bool litaC_checker_expr__TypeChecker_checkInferrability(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type);
litaC_types__TypeInfo* litaC_checker_expr__TypeChecker_inferFuncCallExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_types__TypeInfo* litaC_funcType,litaC_std__array__Array_cb_CallArg_ce_* litaC_suppliedArgs,litaC_bool litaC_isMethodCall);
litaC_bool litaC_checker_expr__TypeChecker_checkFuncCallArgs(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_types__TypeInfo* litaC_funcType,litaC_std__array__Array_cb_CallArg_ce_* litaC_suppliedArgs);
litaC_bool litaC_checker_expr__TypeChecker_resolveFuncCallExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveBooleanExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__BooleanExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveCharExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__CharExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveNullExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__NullExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveNumberExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__NumberExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveStringExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__StringExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveSubscriptSetExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__SubscriptSetExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveSubscriptGetExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__SubscriptGetExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveInitArgExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__InitArgExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_addDefaultArguments(litaC_checker__TypeChecker* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_ast__InitExpr* litaC_expr);
litaC_void litaC_checker_expr__TypeChecker_addInitArgumentsReferences(litaC_checker__TypeChecker* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_ast__InitExpr* litaC_expr);
litaC_bool litaC_checker_expr__IsDecayable(litaC_ast__InitArgExpr* litaC_arg);
litaC_bool litaC_checker_expr__TypeChecker_checkInitArguments(litaC_checker__TypeChecker* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_ast__InitExpr* litaC_expr);
litaC_types__TypeInfo* litaC_checker_expr__TypeChecker_inferInitExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__InitExpr* litaC_expr,litaC_types__TypeInfo* litaC_aggInfo);
litaC_bool litaC_checker_expr__TypeChecker_resolveInitExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__InitExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveSetExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__SetExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveTernaryExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__TernaryExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveTypeIdentifierExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypeIdentifierExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveTypeOfExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypeOfExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveOffsetOfExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__OffsetOfExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveSizeOfExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__SizeOfExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_checkMethodExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__GetExpr* litaC_expr,litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_checker_expr__TypeChecker_resolveGetExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__GetExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveGroupExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__GroupExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveUnaryExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__UnaryExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveCastExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__CastExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveArrayDesignationExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__ArrayDesignationExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveArrayInitExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__ArrayInitExpr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveBinaryExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__BinaryExpr* litaC_expr);
litaC_void litaC_checker_expr__TypeChecker_errorRvalueAssignmentToTrait(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,litaC_types__TypeInfo* litaC_typeTrait);
litaC_void litaC_checker_expr__TypeChecker_errorNonIndexableType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type);
litaC_void litaC_checker_expr__TypeChecker_errorSetIndexingConstType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type);
litaC_void litaC_checker_expr__TypeChecker_errorIndexType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type);
litaC_void litaC_checker_expr__TypeChecker_errorNonAggregateType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type);
litaC_void litaC_checker_expr__TypeChecker_errorNonFuncType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type);
litaC_void litaC_checker_expr__TypeChecker_errorOperand(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,const litaC_char* litaC_side);
litaC_void litaC_checker_expr__TypeChecker_errorEnumFieldSet(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,litaC_intern__InternedString litaC_field);
litaC_void litaC_checker_expr__TypeChecker_errorNoField(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,litaC_intern__InternedString litaC_field);
litaC_void litaC_checker_expr__TypeChecker_errorNoFieldAt(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,litaC_i32 litaC_position);
litaC_void litaC_checker_expr__TypeChecker_errorNoFieldAccess(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,litaC_intern__InternedString litaC_field);
litaC_void litaC_checker_expr__TypeChecker_errorInferGenericParameter(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_ast__GenericParam* litaC_param);
litaC_void litaC_checker_expr__TypeChecker_errorInferGenericParameters(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_std__array__Array_cb_GenericParam_ce_* litaC_params,const litaC_char* litaC_details);
litaC_void litaC_checker_expr__TypeChecker_errorMissingGenericArguments(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_intern__InternedString litaC_typeName,litaC_std__array__Array_cb_GenericParam_ce_* litaC_genericParams);
litaC_void litaC_checker_expr__TypeChecker_errorFixedArgumentAfterNamed(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_arg);
litaC_void litaC_checker_expr__TypeChecker_errorNamedArgumentsForFuncPtr(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr);
litaC_void litaC_checker_expr__TypeChecker_errorInvalidNamedArgument(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_pos,litaC_intern__InternedString* litaC_name,litaC_types__TypeInfo* litaC_funcInfo);
litaC_bool litaC_checker_expr__TypeChecker_checkConstant(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_checkTruthyness(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type);
litaC_bool litaC_checker_expr__TypeChecker_checkRightValue(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr);
litaC_bool litaC_checker_expr__TypeChecker_resolveIdentiferExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__IdentifierExpr* litaC_expr);
litaC_void litaC_error_codes__PrintError(litaC_std__string_buffer__StringBuffer* litaC_sb,litaC_phase_result__PhaseError litaC_error);
litaC_void litaC_lsp__references__ReferenceDatabase_init(litaC_lsp__references__ReferenceDatabase* litaC_this,const litaC_std__mem__Allocator* litaC_allocator);
litaC_void litaC_lsp__references__ReferenceDatabase_addSymbolReference(litaC_lsp__references__ReferenceDatabase* litaC_this,litaC_symbols__Symbol* litaC_symbol,litaC_lex__SrcPos litaC_pos);
litaC_void litaC_lsp__references__ReferenceDatabase_addTypeReference(litaC_lsp__references__ReferenceDatabase* litaC_this,litaC_ast__TypeSpec* litaC_type);
litaC_void litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(litaC_lsp__references__ReferenceDatabase* litaC_this,litaC_lex__SrcPos litaC_srcPos,litaC_symbols__Symbol* litaC_sym);
litaC_void litaC_lsp__references__ReferenceDatabase_addTypeReferenceByTypeInfo(litaC_lsp__references__ReferenceDatabase* litaC_this,litaC_lex__SrcPos litaC_srcPos,litaC_types__TypeInfo* litaC_typeInfo);
litaC_void litaC_lsp__references__ReferenceDatabase_addFieldReference(litaC_lsp__references__ReferenceDatabase* litaC_this,litaC_lex__SrcPos litaC_srcPos,litaC_types__TypeInfo* litaC_parent,litaC_i32 litaC_offset);
litaC_std__array__Array_cb_SrcPos_ce_ litaC_lsp__references__ReferenceDatabase_getSymbolReferences(litaC_lsp__references__ReferenceDatabase* litaC_this,litaC_symbols__Symbol* litaC_symbol);
litaC_void litaC_lsp__references__ReferenceDatabase_removeLocalSymbolReferences(litaC_lsp__references__ReferenceDatabase* litaC_this,litaC_module__Module* litaC_module);
litaC_void litaC_lsp__references__ReferenceDatabase_getTypeReferences(litaC_lsp__references__ReferenceDatabase* litaC_this,litaC_i64 litaC_typeid,litaC_std__array__Array_cb_SrcPos_ce_* litaC_results);
litaC_void litaC_lsp__references__ReferenceDatabase_getFieldReferences(litaC_lsp__references__ReferenceDatabase* litaC_this,litaC_i64 litaC_typeid,litaC_i32 litaC_offset,litaC_std__array__Array_cb_SrcPos_ce_* litaC_results);
litaC_void* litaC_std__json__DefaultMakePtrFn(litaC_u64 litaC_type,litaC_std__json__JsonContext* litaC_context,litaC_std__json__JsonNode* litaC_json);
litaC_void litaC_std__json__DefaultMakeFn(litaC_u64 litaC_type,litaC_std__json__JsonContext* litaC_context,litaC_std__json__JsonNode* litaC_json,litaC_void* litaC_result);
litaC_std__json__JsonContext litaC_std__json__JsonContextInit(litaC_void (*litaC_maker)(litaC_u64,litaC_std__json__JsonContext*,litaC_std__json__JsonNode*,litaC_void*),litaC_void* (*litaC_makerPtr)(litaC_u64,litaC_std__json__JsonContext*,litaC_std__json__JsonNode*),const litaC_std__mem__Allocator* litaC_allocator);
litaC_void litaC_std__json__JsonContext_init(litaC_std__json__JsonContext* litaC_this,litaC_void (*litaC_maker)(litaC_u64,litaC_std__json__JsonContext*,litaC_std__json__JsonNode*,litaC_void*),litaC_void* (*litaC_makerPtr)(litaC_u64,litaC_std__json__JsonContext*,litaC_std__json__JsonNode*),const litaC_std__mem__Allocator* litaC_allocator);
LITAC_INLINE 
litaC_bool litaC_std__json__JsonNode_isNull(litaC_std__json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_bool litaC_std__json__JsonNode_isBool(litaC_std__json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_bool litaC_std__json__JsonNode_isTrue(litaC_std__json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_bool litaC_std__json__JsonNode_isFalse(litaC_std__json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_bool litaC_std__json__JsonNode_isNumber(litaC_std__json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_bool litaC_std__json__JsonNode_isString(litaC_std__json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_bool litaC_std__json__JsonNode_isArray(litaC_std__json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_bool litaC_std__json__JsonNode_isObject(litaC_std__json__JsonNode* litaC_node);
LITAC_INLINE 
const litaC_char* litaC_std__json__JsonNode_asString(litaC_std__json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_bool litaC_std__json__JsonNode_asBool(litaC_std__json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_f64 litaC_std__json__JsonNode_asNumber(litaC_std__json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_f64 litaC_std__json__JsonNode_asFloat(litaC_std__json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_i32 litaC_std__json__JsonNode_asInt(litaC_std__json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_i64 litaC_std__json__JsonNode_asLong(litaC_std__json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_std__array__Array_cb__ptr_JsonNode_ce_* litaC_std__json__JsonNode_asArray(litaC_std__json__JsonNode* litaC_node);
LITAC_INLINE 
litaC_std__json__JsonObject* litaC_std__json__JsonNode_asObject(litaC_std__json__JsonNode* litaC_node);
litaC_std__json__JsonNode* litaC_std__json__CreateJsonNumber(litaC_f64 litaC_value,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__json__JsonNode* litaC_std__json__CreateJsonIntNumber(litaC_i64 litaC_value,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__json__JsonNode* litaC_std__json__CreateJsonFloatNumber(litaC_f64 litaC_value,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__json__JsonNode* litaC_std__json__CreateJsonString(const litaC_char* litaC_str,litaC_i32 litaC_len,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__json__EscapeString(litaC_std__string_buffer__StringBuffer* litaC_buf,const litaC_char* litaC_string,litaC_i32 litaC_length);
litaC_std__json__JsonNode* litaC_std__json__CreateJsonStringNoDup(const litaC_char* litaC_str,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__json__JsonNode* litaC_std__json__CreateJsonArray(const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__json__JsonNode* litaC_std__json__CreateJsonObject(const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__json__JsonNode_put(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_std__json__JsonNode* litaC_n);
litaC_void litaC_std__json__JsonNode_putNoDup(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_std__json__JsonNode* litaC_n);
litaC_void litaC_std__json__JsonNode_putStr(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_void litaC_std__json__JsonNode_putNumber(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_f64 litaC_number);
litaC_void litaC_std__json__JsonNode_putIntNumber(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_i64 litaC_number);
litaC_void litaC_std__json__JsonNode_putFloatNumber(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_f64 litaC_number);
litaC_void litaC_std__json__JsonNode_putBool(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_bool litaC_b);
litaC_bool litaC_std__json__JsonNode_contains(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key);
litaC_std__json__JsonNode* litaC_std__json__JsonNode_get(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key);
litaC_bool litaC_std__json__JsonNode_getBool(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_bool litaC_defaultValue);
litaC_i32 litaC_std__json__JsonNode_getInt(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_i32 litaC_defaultValue);
litaC_i64 litaC_std__json__JsonNode_getLong(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_i64 litaC_defaultValue);
litaC_f64 litaC_std__json__JsonNode_getFloat(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_f64 litaC_defaultValue);
const litaC_char* litaC_std__json__JsonNode_getStr(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,const litaC_char* litaC_defaultValue);
litaC_char* litaC_std__json__JsonNode_getStrCopy(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_std__json__JsonNode* litaC_std__json__JsonNode_getArray(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key);
litaC_std__json__JsonNode* litaC_std__json__JsonNode_getObject(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key);
litaC_void litaC_std__json__JsonNode_add(litaC_std__json__JsonNode* litaC_node,litaC_std__json__JsonNode* litaC_n);
litaC_std__json__JsonNode* litaC_std__json__JsonNode_at(litaC_std__json__JsonNode* litaC_node,litaC_i32 litaC_index);
litaC_i32 litaC_std__json__JsonNode_size(litaC_std__json__JsonNode* litaC_node);
litaC_bool litaC_std__json__JsonNode_empty(litaC_std__json__JsonNode* litaC_node);
litaC_std__json__JsonIterator litaC_std__json__JsonNode_iter(litaC_std__json__JsonNode* litaC_node);
litaC_bool litaC_std__json__JsonIterator_hasNext(litaC_std__json__JsonIterator* litaC_this);
litaC_std__json__JsonEntry litaC_std__json__JsonIterator_next(litaC_std__json__JsonIterator* litaC_this);
litaC_bool litaC_std__json__JsonNode_equals(litaC_std__json__JsonNode* litaC_node,litaC_std__json__JsonNode* litaC_other);
const litaC_char* litaC_std__json__JsonNode_print(litaC_std__json__JsonNode* litaC_node,litaC_std__string_buffer__StringBuffer* litaC_buf);
litaC_void litaC_std__json__JsonNode_free(litaC_std__json__JsonNode* litaC_node);
litaC_std__json__JsonParser litaC_std__json__JsonParserInit(const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__json__JsonParser_init(litaC_std__json__JsonParser* litaC_p,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__json__JsonParser_free(litaC_std__json__JsonParser* litaC_p);
litaC_std__json__JsonNode* litaC_std__json__JsonParser_parseJson(litaC_std__json__JsonParser* litaC_p,const litaC_char* litaC_buffer);
litaC_bool litaC_std__json__JsonParser_hasError(litaC_std__json__JsonParser* litaC_p);
litaC_void litaC_std__json__PrintJson(litaC_std__json__JsonNode* litaC_node,litaC_std__string_buffer__StringBuffer* litaC_buf);
litaC_std__json__JsonNode* litaC_std__json__JsonParser_parseJsonNode(litaC_std__json__JsonParser* litaC_p);
litaC_std__json__JsonNode* litaC_std__json__JsonParser_parseJsonIntNumber(litaC_std__json__JsonParser* litaC_p);
litaC_std__json__JsonNode* litaC_std__json__JsonParser_parseJsonRealNumber(litaC_std__json__JsonParser* litaC_p);
litaC_std__json__JsonNode* litaC_std__json__JsonParser_parseJsonStr(litaC_std__json__JsonParser* litaC_p);
litaC_std__json__JsonNode* litaC_std__json__JsonParser_parseJsonArray(litaC_std__json__JsonParser* litaC_p);
litaC_std__json__JsonNode* litaC_std__json__JsonParser_parseJsonObject(litaC_std__json__JsonParser* litaC_p);
const litaC_char* litaC_std__json__TokenName(litaC_std__json__TokenKind litaC_t);
litaC_void litaC_std__json__JsonParser_error(litaC_std__json__JsonParser* litaC_p,const litaC_char* litaC_format,...);
litaC_void litaC_std__json__JsonParser_scanInt(litaC_std__json__JsonParser* litaC_p);
litaC_void litaC_std__json__JsonParser_scanFloat(litaC_std__json__JsonParser* litaC_p);
litaC_void litaC_std__json__JsonParser_scanStr(litaC_std__json__JsonParser* litaC_p);
litaC_void litaC_std__json__JsonParser_scanMultiStr(litaC_std__json__JsonParser* litaC_p);
litaC_void litaC_std__json__JsonParser_skipComments(litaC_std__json__JsonParser* litaC_l);
litaC_void litaC_std__json__JsonParser_nextToken(litaC_std__json__JsonParser* litaC_p);
litaC_bool litaC_std__json__JsonParser_check(litaC_std__json__JsonParser* litaC_p,litaC_std__json__TokenKind litaC_kind);
litaC_bool litaC_std__json__JsonParser_match(litaC_std__json__JsonParser* litaC_p,litaC_std__json__TokenKind litaC_kind);
litaC_bool litaC_std__json__JsonParser_expect(litaC_std__json__JsonParser* litaC_p,litaC_std__json__TokenKind litaC_kind);
litaC_parser__Parser litaC_parser__ParserInit(const litaC_char* litaC_filename,const litaC_char* litaC_text,litaC_i64 litaC_length,litaC_module__Module* litaC_module,litaC_lita__Lita* litaC_lita);
litaC_ast__ModuleStmt* litaC_parser__Parser_parseModule(litaC_parser__Parser* litaC_p);
litaC_void litaC_parser__Parser_parseModuleDeclaration(litaC_parser__Parser* litaC_p,litaC_ast__ModuleStmt* litaC_moduleStmt);
litaC_ast__Stmt* litaC_parser__Parser_parseCompileTimeBody(litaC_parser__Parser* litaC_p);
litaC_ast__ImportDecl* litaC_parser__Parser_importDeclaration(litaC_parser__Parser* litaC_p);
litaC_bool litaC_parser__Parser_notes(litaC_parser__Parser* litaC_p,litaC_std__array__Array_cb__ptr_NoteStmt_ce_* litaC_notes);
litaC_ast__Decl* litaC_parser__Parser_varDeclaration(litaC_parser__Parser* litaC_p);
litaC_ast__Decl* litaC_parser__Parser_constDeclaration(litaC_parser__Parser* litaC_p);
litaC_ast__Decl* litaC_parser__Parser_funcDeclaration(litaC_parser__Parser* litaC_p);
litaC_ast__Decl* litaC_parser__Parser_structDeclaration(litaC_parser__Parser* litaC_p);
litaC_ast__Decl* litaC_parser__Parser_unionDeclaration(litaC_parser__Parser* litaC_p);
litaC_ast__Decl* litaC_parser__Parser_traitDeclaration(litaC_parser__Parser* litaC_p);
litaC_ast__Decl* litaC_parser__Parser_aggregateDeclaration(litaC_parser__Parser* litaC_p,litaC_ast__StmtKind litaC_kind);
litaC_ast__Decl* litaC_parser__Parser_enumDeclaration(litaC_parser__Parser* litaC_p);
litaC_ast__Decl* litaC_parser__Parser_typedefDeclaration(litaC_parser__Parser* litaC_p);
litaC_ast__Decl* litaC_parser__Parser_noteDeclaration(litaC_parser__Parser* litaC_p);
litaC_ast__ParameterDecl* litaC_parser__Parser_paramDeclaration(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_expression(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_constExpression(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_group(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_arrayInit(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_aggregateInit(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_sizeOf(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_typeOf(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_offsetOf(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_assignment(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_ternary(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_or(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_and(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_bitOr(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_bitXor(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_bitAnd(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_equality(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_comparison(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_bitShift(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_term(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_factor(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_unary(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_functionCall(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_primary(litaC_parser__Parser* litaC_p);
litaC_ast__Expr* litaC_parser__Parser_finishFunctionCall(litaC_parser__Parser* litaC_p,litaC_ast__Expr* litaC_expr);
litaC_ast__Expr* litaC_parser__Parser_cast(litaC_parser__Parser* litaC_p,litaC_ast__Expr* litaC_expr);
litaC_ast__Stmt* litaC_parser__Parser_statement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_tryStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_compStatement(litaC_parser__Parser* litaC_p,litaC_bool litaC_isStaticIf);
litaC_ast__Stmt* litaC_parser__Parser_blockStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_ifStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_whileStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_doWhileStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_forStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_switchCaseStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_switchDefaultStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_switchStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_breakStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_continueStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_returnStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_deferStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_gotoStatement(litaC_parser__Parser* litaC_p);
litaC_ast__Stmt* litaC_parser__Parser_tryLabelStatement(litaC_parser__Parser* litaC_p);
litaC_ast__TypeSpec* litaC_parser__Parser_type(litaC_parser__Parser* litaC_p,litaC_bool litaC_disambiguate);
litaC_ast__TypeSpec* litaC_parser__Parser_identifierType(litaC_parser__Parser* litaC_p,litaC_bool litaC_disambiguate);
litaC_ast__TypeSpec* litaC_parser__Parser_qualifiedIdentifierType(litaC_parser__Parser* litaC_p,litaC_bool litaC_disambiguate);
litaC_ast__TypeSpec* litaC_parser__Parser_arrayType(litaC_parser__Parser* litaC_p);
litaC_ast__TypeSpec* litaC_parser__Parser_funcPtrType(litaC_parser__Parser* litaC_p);
litaC_ast__ParametersStmt* litaC_parser__Parser_parametersStatement(litaC_parser__Parser* litaC_p);
litaC_bool litaC_parser__Parser_structArguments(litaC_parser__Parser* litaC_p,litaC_std__array__Array_cb__ptr_InitArgExpr_ce_* litaC_arguments);
litaC_bool litaC_parser__Parser_arguments(litaC_parser__Parser* litaC_p,litaC_std__array__Array_cb_CallArg_ce_* litaC_arguments);
litaC_bool litaC_parser__Parser_genericParameters(litaC_parser__Parser* litaC_p,litaC_std__array__Array_cb_GenericParam_ce_* litaC_arguments);
litaC_std__array__Array_cb__ptr_TypeSpec_ce_ litaC_parser__Parser_genericArguments(litaC_parser__Parser* litaC_p);
litaC_std__array__Array_cb__ptr_TypeSpec_ce_ litaC_parser__Parser_tryGenericArguments(litaC_parser__Parser* litaC_p,litaC_bool litaC_disambiguate);
litaC_bool litaC_parser__Parser_arrayArguments(litaC_parser__Parser* litaC_p,litaC_std__array__Array_cb__ptr_Expr_ce_* litaC_arguments);
litaC_ast__Expr* litaC_parser__Parser_tryArrayDesignationExpr(litaC_parser__Parser* litaC_p);
litaC_ast__FieldStmt litaC_parser__Parser_fieldStatement(litaC_parser__Parser* litaC_p,litaC_ast__StmtKind litaC_aggKind);
litaC_ast__FieldStmt litaC_parser__Parser_noteFieldStatement(litaC_parser__Parser* litaC_p);
litaC_ast__EnumFieldEntryDecl* litaC_parser__Parser_enumFieldEntryDecl(litaC_parser__Parser* litaC_p);
litaC_void litaC_parser__Parser_rewindTo(litaC_parser__Parser* litaC_p,litaC_i32 litaC_backtrack,litaC_u64 litaC_numOfErrors);
litaC_ast__Expr* litaC_parser__Parser_tryBitShiftRight(litaC_parser__Parser* litaC_p,litaC_ast__Expr* litaC_expr);
litaC_void litaC_parser__Parser_eatSemicolon(litaC_parser__Parser* litaC_p);
litaC_lex__Token litaC_parser__Parser_identifier(litaC_parser__Parser* litaC_p);
litaC_bool litaC_parser__Parser_checkConstExpr(litaC_parser__Parser* litaC_p,litaC_ast__Expr* litaC_expr);
litaC_ast__Stmt* litaC_parser__Parser_poisonStatement(litaC_parser__Parser* litaC_p,litaC_lex__SrcPos litaC_pos);
litaC_ast__Expr* litaC_parser__Parser_poisonExpr(litaC_parser__Parser* litaC_p,litaC_lex__SrcPos litaC_pos);
litaC_ast__Decl* litaC_parser__Parser_poisonDecl(litaC_parser__Parser* litaC_p,litaC_lex__SrcPos litaC_pos);
LITAC_INLINE 
litaC_lex__SrcPos litaC_parser__Parser_pos(litaC_parser__Parser* litaC_p);
litaC_lex__SrcPos litaC_parser__Parser_prevPos(litaC_parser__Parser* litaC_p);
LITAC_INLINE 
litaC_lex__Token* litaC_parser__Parser_peek(litaC_parser__Parser* litaC_p);
litaC_void litaC_parser__Parser_rewind(litaC_parser__Parser* litaC_p);
litaC_lex__Token* litaC_parser__Parser_previous(litaC_parser__Parser* litaC_p);
litaC_bool litaC_parser__Parser_atEnd(litaC_parser__Parser* litaC_p);
litaC_void litaC_parser__Parser_advance(litaC_parser__Parser* litaC_p);
litaC_lex__Token* litaC_parser__Parser_advancep(litaC_parser__Parser* litaC_p);
LITAC_INLINE 
litaC_bool litaC_parser__Parser_check(litaC_parser__Parser* litaC_p,litaC_lex__TokenType litaC_type);
litaC_bool litaC_parser__Parser_match(litaC_parser__Parser* litaC_p,litaC_lex__TokenType litaC_type);
litaC_bool litaC_parser__Parser_matches(litaC_parser__Parser* litaC_p,litaC_lex__TokenType* litaC_types,litaC_i32 litaC_len);
litaC_lex__Token* litaC_parser__Parser_consume(litaC_parser__Parser* litaC_p,litaC_lex__TokenType litaC_type,litaC_error_codes__ErrorCode litaC_errorCode);
litaC_void litaC_parser__Parser_adjust(litaC_parser__Parser* litaC_p,litaC_lex__TokenType* litaC_types,litaC_i32 litaC_len);
litaC_void litaC_parser__Parser_errorAtToken(litaC_parser__Parser* litaC_p,litaC_lex__Token* litaC_token,litaC_error_codes__ErrorCode litaC_errorCode);
litaC_void litaC_parser__Parser_errorAtPos(litaC_parser__Parser* litaC_p,litaC_lex__SrcPos litaC_pos,litaC_error_codes__ErrorCode litaC_errorCode);
litaC_void litaC_parser__Parser_errorUnexpectedToken(litaC_parser__Parser* litaC_p,litaC_lex__Token* litaC_token,litaC_error_codes__ErrorCode litaC_errorCode);
litaC_i32 litaC_parser__Parser_numOfErrors(litaC_parser__Parser* litaC_p);
litaC_void litaC_lsp__workspace__Workspace_init(litaC_lsp__workspace__Workspace* litaC_this,litaC_lsp__lsp__LspServer* litaC_lsp,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_lsp__workspace__Workspace_setup(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_rootPath,const litaC_char* litaC_rootUri);
litaC_bool litaC_lsp__workspace__Workspace_isDocumentOpen(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_uri);
litaC_void litaC_lsp__workspace__Workspace_openDocument(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_uri,const litaC_char* litaC_text);
litaC_void litaC_lsp__workspace__Workspace_closeDocument(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_uri);
litaC_void litaC_lsp__workspace__Workspace_saveDocument(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_uri);
litaC_void litaC_lsp__workspace__Workspace_changeDocument(litaC_lsp__workspace__Workspace* litaC_this,litaC_lsp__protocol__TextDocumentDidChange* litaC_change);
litaC_std__json__JsonNode* litaC_lsp__workspace__Workspace_documentSymbols(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_uri,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_lsp__workspace__Workspace_addDocumentSymbols(litaC_lsp__workspace__Workspace* litaC_this,litaC_std__json__JsonNode* litaC_results,litaC_module__Module* litaC_module,litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_ litaC_symbols,const litaC_char* litaC_docFilename,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__json__JsonNode* litaC_lsp__workspace__Workspace_references(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_uri,litaC_std__json__JsonNode* litaC_position,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__json__JsonNode* litaC_lsp__workspace__Workspace_findTypeReferences(litaC_lsp__workspace__Workspace* litaC_this,litaC_i64 litaC_typeid,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__json__JsonNode* litaC_lsp__workspace__Workspace_findFieldReferences(litaC_lsp__workspace__Workspace* litaC_this,litaC_i64 litaC_typeid,litaC_i32 litaC_offset,const litaC_std__mem__Allocator* litaC_alloc);
litaC_lsp__util__SourceLocation litaC_lsp__workspace__Workspace_getNodeAtSourcePos(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_uri,litaC_std__json__JsonNode* litaC_position);
litaC_std__json__JsonNode* litaC_lsp__workspace__Workspace_goToDefinition(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_uri,litaC_std__json__JsonNode* litaC_position,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__json__JsonNode* litaC_lsp__workspace__Workspace_autoComplete(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_uri,litaC_std__json__JsonNode* litaC_position,litaC_std__json__JsonNode* litaC_context,const litaC_std__mem__Allocator* litaC_alloc);
litaC_phase_result__PhaseResult* litaC_lsp__workspace__Workspace_runDiagnostics(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_docUri,litaC_bool litaC_isFullBuild);
litaC_void litaC_lsp__lsp__LspServer_init(litaC_lsp__lsp__LspServer* litaC_this,litaC_lita__Lita* litaC_lita);
const litaC_std__mem__Allocator* litaC_lsp__lsp__LspServer_requestAlloc(litaC_lsp__lsp__LspServer* litaC_this);
const litaC_std__mem__Allocator* litaC_lsp__lsp__LspServer_appAlloc(litaC_lsp__lsp__LspServer* litaC_this);
litaC_void litaC_lsp__lsp__LspServer_free(litaC_lsp__lsp__LspServer* litaC_this);
litaC_void litaC_lsp__lsp__LspServer_start(litaC_lsp__lsp__LspServer* litaC_this);
litaC_void litaC_lsp__lsp__LspServer_log(litaC_lsp__lsp__LspServer* litaC_this,const litaC_char* litaC_format,...);
litaC_void litaC_lsp__lsp__LspServer_readMessage(litaC_lsp__lsp__LspServer* litaC_this);
litaC_i32 litaC_lsp__lsp__LspServer_readHeader(litaC_lsp__lsp__LspServer* litaC_this);
litaC_void litaC_lsp__lsp__LspServer_handleMessage(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg);
litaC_void litaC_lsp__lsp__LspServer_handleInitializeMessage(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg,litaC_std__json__JsonNode* litaC_params);
litaC_void litaC_lsp__lsp__LspServer_handleTextDocumentOpenMessage(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg,litaC_std__json__JsonNode* litaC_params);
litaC_void litaC_lsp__lsp__LspServer_handleTextDocumentCloseMessage(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg,litaC_std__json__JsonNode* litaC_params);
litaC_void litaC_lsp__lsp__LspServer_handleTextDocumentSymbolMessage(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg,litaC_std__json__JsonNode* litaC_params);
litaC_void litaC_lsp__lsp__LspServer_handleTextDocumentSaveMessage(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg,litaC_std__json__JsonNode* litaC_params);
litaC_void litaC_lsp__lsp__LspServer_handleTextDocumentChangeMessage(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg,litaC_std__json__JsonNode* litaC_params);
litaC_void litaC_lsp__lsp__LspServer_handleTextDocumentReferencesMessage(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg,litaC_std__json__JsonNode* litaC_params);
litaC_void litaC_lsp__lsp__LspServer_handleTextDocumentDefinitionMessage(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg,litaC_std__json__JsonNode* litaC_params);
litaC_void litaC_lsp__lsp__LspServer_handleTextDocumentCompletionMessage(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg,litaC_std__json__JsonNode* litaC_params);
litaC_void litaC_lsp__lsp__LspServer_writeDiagnostic(litaC_lsp__lsp__LspServer* litaC_this,const litaC_char* litaC_docUri,litaC_bool litaC_fullBuild);
litaC_void litaC_lsp__lsp__LspServer_writeErrorResponse(litaC_lsp__lsp__LspServer* litaC_this,litaC_i64 litaC_id,litaC_i32 litaC_code,const litaC_char* litaC_format,...);
litaC_void litaC_lsp__lsp__LspServer_writeResponse(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg);
litaC_std__json__JsonNode* litaC_lsp__lsp__LspServer_createResponse(litaC_lsp__lsp__LspServer* litaC_this,litaC_i64 litaC_id);
litaC_lsp__protocol__SymbolInfoKind litaC_lsp__protocol__SymbolKindFromSymbol(litaC_symbols__Symbol* litaC_sym);
litaC_std__json__JsonNode* litaC_lsp__protocol__SymbolToSymbolInformation(litaC_symbols__Symbol* litaC_sym,const litaC_char* litaC_rootPath,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__json__JsonNode* litaC_lsp__protocol__SrcPosToLocation(litaC_lex__SrcPos litaC_pos,const litaC_char* litaC_rootPath,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__json__JsonNode* litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_char* litaC_rootPath,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__json__JsonNode* litaC_lsp__protocol__SrcPosToRange(litaC_lex__SrcPos litaC_pos,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__json__JsonNode* litaC_lsp__protocol__SrcPosWithEndToRange(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__json__JsonNode* litaC_lsp__protocol__SrcPosToLocations(const litaC_char* litaC_rootPath,litaC_std__array__Array_cb_SrcPos_ce_* litaC_results,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__json__JsonNode* litaC_lsp__protocol__SymbolToCompletionItem(litaC_symbols__Symbol* litaC_symbol,const litaC_std__mem__Allocator* litaC_alloc);
litaC_lsp__protocol__TextDocumentDidChange* litaC_lsp__protocol__JsonNodeToTextDocumentChangeEvent(litaC_std__json__JsonNode* litaC_params,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_lsp__util__PosToRange(litaC_lex__SrcPos litaC_srcPos,litaC_lsp__protocol__Range* litaC_range);
litaC_bool litaC_lsp__util__IsSrcPosAtPosition(litaC_lex__SrcPos* litaC_srcPos,litaC_lsp__protocol__Position litaC_pos);
litaC_lsp__util__SourceLocation litaC_lsp__util__SourceLookup_findAstNodeByPosition(litaC_lsp__util__SourceLookup* litaC_this,litaC_ast__ModuleStmt* litaC_moduleAst,litaC_lsp__protocol__Position litaC_pos);
litaC_bool litaC_lsp__util__SourceLookup_isNodeAtPos(litaC_lsp__util__SourceLookup* litaC_this,litaC_ast__Node* litaC_node);
litaC_bool litaC_lsp__util__SourceLookup_isSrcAtPos(litaC_lsp__util__SourceLookup* litaC_this,litaC_lex__SrcPos* litaC_srcPos);
litaC_bool litaC_lsp__util__SourceLookup_isTokenAtPos(litaC_lsp__util__SourceLookup* litaC_this,litaC_lex__Token litaC_token);
litaC_bool litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_lsp__util__SourceLookup* litaC_this,litaC_ast__TypeSpec* litaC_type);
litaC_bool litaC_lsp__util__SourceLookup_isDeclAtPos(litaC_lsp__util__SourceLookup* litaC_this,litaC_ast__Decl* litaC_decl);
litaC_bool litaC_lsp__util__SourceLookup_visitDecl(litaC_lsp__util__SourceLookup* litaC_this,litaC_ast__Decl* litaC_node);
litaC_bool litaC_lsp__util__SourceLookup_visitStmt(litaC_lsp__util__SourceLookup* litaC_this,litaC_ast__Stmt* litaC_node);
litaC_bool litaC_lsp__util__SourceLookup_visitExpr(litaC_lsp__util__SourceLookup* litaC_this,litaC_ast__Expr* litaC_node);
litaC_void litaC_lsp__document__Document_refreshLineMap(litaC_lsp__document__Document* litaC_this);
LITAC_INLINE 
litaC_u32 litaC_lsp__document__Document_getLineStart(litaC_lsp__document__Document* litaC_this,litaC_i32 litaC_lineNumber);
litaC_void litaC_lsp__document__Document_insert(litaC_lsp__document__Document* litaC_this,litaC_lsp__protocol__Range litaC_range,const litaC_char* litaC_text);
litaC_void litaC_lsp__document__Document_setText(litaC_lsp__document__Document* litaC_this,const litaC_char* litaC_text);
litaC_void litaC_instrument__Instrument(litaC_lita__Lita* litaC_lita,litaC_checker__TypeChecker* litaC_checker);
litaC_std__array__Array_cb__ptr_Decl_ce_ litaC_traits__CreateTraitWrappers(litaC_checker__TypeChecker* litaC_checker);
litaC_void litaC_traits__GenerateVTable(litaC_symbols__Symbol* litaC_traitSym,litaC_ast__AggregateDecl* litaC_traitDecl,litaC_std__string_view__StringView litaC_traitName,litaC_std__string_buffer__StringBuffer* litaC_sb);
litaC_void litaC_traits__GenerateWrapperFunctions(litaC_checker__TypeChecker* litaC_checker,litaC_symbols__Symbol* litaC_traitSym,litaC_ast__AggregateDecl* litaC_traitDecl,litaC_std__string_view__StringView litaC_traitName,litaC_std__string_buffer__StringBuffer* litaC_sb,litaC_std__string_buffer__StringBuffer* litaC_traitFieldBuffer,litaC_std__array__Array_cb_i64_ce_* litaC_impls);
litaC_void litaC_traits__GenerateVTableEntries(litaC_checker__TypeChecker* litaC_checker,litaC_ast__AggregateDecl* litaC_traitDecl,litaC_std__string_view__StringView litaC_traitName,litaC_std__string_buffer__StringBuffer* litaC_sb,litaC_std__string_buffer__StringBuffer* litaC_traitFieldBuffer,litaC_std__array__Array_cb_i64_ce_* litaC_impls);
litaC_void litaC_traits__PrintGenerics(litaC_std__array__Array_cb_GenericParam_ce_* litaC_genericParams,litaC_std__string_buffer__StringBuffer* litaC_sb);
litaC_void litaC_traits__PrintGenericArgs(litaC_std__array__Array_cb__ptr_TypeInfo_ce_* litaC_genericArgs,litaC_std__string_buffer__StringBuffer* litaC_sb);
litaC_symbols__Symbol* litaC_traits__FindSymbolByTypeid(litaC_std__array__Array_cb__ptr_Symbol_ce_ litaC_symbols,litaC_i64 litaC_id);
litaC_std__string_view__StringView litaC_traits__GetTraitName(litaC_symbols__Symbol* litaC_traitSym,litaC_std__string_buffer__StringBuffer* litaC_sb);
litaC_void litaC_traits__Parse(litaC_std__string_buffer__StringBuffer* litaC_sb,litaC_checker__TypeChecker* litaC_checker,litaC_std__array__Array_cb__ptr_Decl_ce_* litaC_decls);
litaC_void litaC_preprocessor__api__Preprocessor_registerApi(litaC_preprocessor__Preprocessor* litaC_this);
litaC_void litaC_preprocessor__api__Preprocessor_deregisterApi(litaC_preprocessor__Preprocessor* litaC_this);
litaC_bool litaC_preprocessor__api__Preprocessor_execute(litaC_preprocessor__Preprocessor* litaC_this,litaC_ast__CompStmt* litaC_comp,litaC_std__string_view__StringView litaC_code);
litaC_void litaC_preprocessor__api__noOpFree(litaC_void* litaC_ctx,litaC_void* litaC_mem);
litaC_void* litaC_preprocessor__api__litaMalloc(litaC_void* litaC_ctx,litaC_usize litaC_len);
ape_object_t litaC_preprocessor__api__ApeGetTypeKind(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__api__ApeIsPrimitive(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__api__ApeGetSymbol(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__api__ApeGetSymbolByTypeInfo(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__api__ApeGetTypeInfo(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
litaC_bool litaC_preprocessor__api__CallContext_logErrors(litaC_preprocessor__CallContext* litaC_this);
litaC_void litaC_preprocessor__api__Preprocessor_addNotes(litaC_preprocessor__Preprocessor* litaC_this,ape_object_t litaC_obj,litaC_module__Module* litaC_module,litaC_ast__Attributes* litaC_attributes);
ape_object_t litaC_preprocessor__api__Preprocessor_typeInfoToApe(litaC_preprocessor__Preprocessor* litaC_this,litaC_types__TypeInfo* litaC_typeInfo);
ape_object_t litaC_preprocessor__api__Preprocessor_declToApe(litaC_preprocessor__Preprocessor* litaC_this,litaC_symbols__Symbol* litaC_sym);

litaC_void litaC_preprocessor__api__CallContext_postParse(litaC_preprocessor__CallContext* litaC_this,litaC_module__Module* litaC_module,litaC_ast__ModuleStmt* litaC_moduleStmt,litaC_ast__CompStmt* litaC_comp);
ape_object_t litaC_preprocessor__api__ApeEmit(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__api__ApeEmitClear(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__api__ApeEmitStr(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__api__ApeError(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__api__FormatStr(litaC_preprocessor__CallContext* litaC_context,litaC_std__string_buffer__StringBuffer* litaC_buffer,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__api__ApeGetSymbolsWithNote(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__api__ApeAddDeclaration(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__api__ApeReplaceDeclaration(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__api__QueueDeclaration(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args,litaC_bool litaC_replacement);
ape_object_t litaC_preprocessor__api__ApeGetInputModuleFilename(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__api__ApeGetCurrentModuleFilename(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__api__ApeFlushDeclarations(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__api__ApeGetMainSymbol(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__api__ApeAstInsert(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__api__ApeAddImport(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__api__ApeSetMainSymbol(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__api__ApeGetSymbolsToTest(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
ape_object_t litaC_preprocessor__api__ApeAssert(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args);
litaC_bool litaC_preprocessor__api__Preprocessor_loadScript(litaC_preprocessor__Preprocessor* litaC_this,litaC_ast__CompStmt* litaC_comp,litaC_std__string_view__StringView* litaC_filename,litaC_std__string_view__StringView* litaC_code);
litaC_void litaC_cgen__CGen_init(litaC_cgen__CGen* litaC_this,litaC_lita__Lita* litaC_lita,litaC_std__io__File* litaC_output);
litaC_void litaC_cgen__CGen_emitProgram(litaC_cgen__CGen* litaC_this,litaC_module__Module* litaC_module);
litaC_void litaC_cgen__CGen_emitMain(litaC_cgen__CGen* litaC_this,litaC_symbols__Symbol* litaC_sym);
litaC_void litaC_cgen__CGen_emitForward(litaC_cgen__CGen* litaC_this);
litaC_void litaC_cgen__CGen_emitPrimitiveConstDecls(litaC_cgen__CGen* litaC_this);
litaC_void litaC_cgen__CGen_emitModuleNotes(litaC_cgen__CGen* litaC_this);
litaC_symbols__Symbol* litaC_cgen__CGen_findSymbolByTypeid(litaC_cgen__CGen* litaC_this,litaC_i64 litaC_id);
litaC_void litaC_cgen__CGen_emitTraitForwardDecls(litaC_cgen__CGen* litaC_this);
litaC_void litaC_cgen__CGen_emitTraitDecls(litaC_cgen__CGen* litaC_this);
litaC_bool litaC_cgen__CGen_emitTraitCast(litaC_cgen__CGen* litaC_this,litaC_ast__Expr* litaC_expr);
litaC_void litaC_cgen__CGen_emitForwardDecls(litaC_cgen__CGen* litaC_this);
litaC_void litaC_cgen__CGen_emitTypeForwardDecl(litaC_cgen__CGen* litaC_this,litaC_symbols__Symbol* litaC_sym);
const litaC_char* litaC_cgen__CGen_allocTemp(litaC_cgen__CGen* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_char* litaC_buffer);
litaC_std__string_view__StringView litaC_cgen__CGen_escapeNameStr(litaC_cgen__CGen* litaC_this,litaC_intern__InternedString litaC_name);
litaC_std__string_view__StringView litaC_cgen__CGen_escapeNameChars(litaC_cgen__CGen* litaC_this,const litaC_char* litaC_name);
litaC_std__string_view__StringView litaC_cgen__CGen_escapeName(litaC_cgen__CGen* litaC_this,litaC_types__TypeInfo* litaC_type);
litaC_std__string_view__StringView litaC_cgen__CGen_baseTypeName(litaC_cgen__CGen* litaC_this,litaC_std__string_view__StringView litaC_name);
litaC_void litaC_cgen__CGen_pushScope(litaC_cgen__CGen* litaC_this,litaC_cgen__CGenScope* litaC_scope);
litaC_cgen__CGenScope* litaC_cgen__CGen_popScope(litaC_cgen__CGen* litaC_this);
litaC_void litaC_cgen__CGen_popLoopScope(litaC_cgen__CGen* litaC_this,litaC_bool litaC_checkSwitch);
litaC_void litaC_cgen__CGen_leaveScope(litaC_cgen__CGen* litaC_this,litaC_cgen__CGenScope* litaC_scope,litaC_bool litaC_includeConst);
litaC_bool litaC_cgen__CGen_hasPendingDefers(litaC_cgen__CGen* litaC_this);
litaC_void litaC_cgen__CGen_emitDefers(litaC_cgen__CGen* litaC_this);
litaC_void litaC_cgen__CGen_emitLineInfo(litaC_cgen__CGen* litaC_this,litaC_ast__Stmt* litaC_stmt);
const litaC_char* litaC_cgen__CGen_cType(litaC_cgen__CGen* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_bool litaC_isCast,litaC_bool litaC_decay);
const litaC_char* litaC_cgen__CGen_cTypeDecl(litaC_cgen__CGen* litaC_this,litaC_types__TypeInfo* litaC_type,const litaC_char* litaC_name,litaC_bool litaC_decay);
litaC_std__string_view__StringView litaC_cgen__CGen_foreignName(litaC_cgen__CGen* litaC_this,litaC_ast__Decl* litaC_decl,litaC_std__string_view__StringView litaC_defaultName);
const litaC_char* litaC_cgen__CGen_cName(litaC_cgen__CGen* litaC_this,litaC_symbols__Symbol* litaC_sym);
const litaC_char* litaC_cgen__CGen_cTypeName(litaC_cgen__CGen* litaC_this,litaC_types__TypeInfo* litaC_type);
const litaC_char* litaC_cgen__CGen_prefix(litaC_cgen__CGen* litaC_this,litaC_std__string_view__StringView litaC_name,litaC_std__string_buffer__StringBuffer* litaC_sb);
litaC_void litaC_cgen__CGen_emitTypeSpec(litaC_cgen__CGen* litaC_this,litaC_ast__TypeSpec* litaC_spec);
litaC_void litaC_cgen__CGen_flush(litaC_cgen__CGen* litaC_this);
litaC_void litaC_cgen__CGen_emitNameStr(litaC_cgen__CGen* litaC_this,litaC_std__string_view__StringView litaC_name);
litaC_void litaC_cgen__CGen_emitName(litaC_cgen__CGen* litaC_this,litaC_ast__Identifier litaC_id);
litaC_void litaC_cgen__CGen_emitln(litaC_cgen__CGen* litaC_this);
litaC_void litaC_cgen__CGen_emit(litaC_cgen__CGen* litaC_this,const litaC_char* litaC_strFormat,...);
litaC_void litaC_cgen__CGen_emitStr(litaC_cgen__CGen* litaC_this,const litaC_char* litaC_str);
litaC_void litaC_cgen__CGen_emitStrn(litaC_cgen__CGen* litaC_this,const litaC_char* litaC_str,litaC_i32 litaC_len);
litaC_void litaC_cgen__CGen_emitNotes(litaC_cgen__CGen* litaC_this,litaC_ast__Attributes* litaC_attributes,litaC_bool litaC_isPrelude);
litaC_void litaC_cgen__CGen_emitPreludeNote(litaC_cgen__CGen* litaC_this,litaC_ast__NoteStmt* litaC_note);
litaC_void litaC_cgen__CGen_emitPostludeNote(litaC_cgen__CGen* litaC_this,litaC_ast__NoteStmt* litaC_note);
litaC_void litaC_cgen__CGen_emitFieldName(litaC_cgen__CGen* litaC_this,litaC_ast__FieldStmt litaC_field);
litaC_void litaC_cgen__CGen_emitSymbol(litaC_cgen__CGen* litaC_this,litaC_symbols__Symbol* litaC_sym);
litaC_void litaC_cgen__CGen_emitTraitFuncCall(litaC_cgen__CGen* litaC_this,litaC_ast__FuncCallExpr* litaC_expr);
litaC_void litaC_cgen__CGen_emitStaticCompStmt(litaC_cgen__CGen* litaC_this,litaC_ast__CompStmt* litaC_s);
litaC_void litaC_cgen__CGen_emitStmt(litaC_cgen__CGen* litaC_this,litaC_ast__Stmt* litaC_s);
litaC_void litaC_dependency_graph__DependencyGraph_init(litaC_dependency_graph__DependencyGraph* litaC_this,litaC_lita__Lita* litaC_lita);
litaC_void litaC_dependency_graph__DependencyGraph_markDependencies(litaC_dependency_graph__DependencyGraph* litaC_this,litaC_dependency_graph__Dependency* litaC_dependency);
litaC_void litaC_dependency_graph__DependencyGraph_buildGraph(litaC_dependency_graph__DependencyGraph* litaC_this,litaC_symbols__ProgramSymbols* litaC_program);
litaC_dependency_graph__Dependency* litaC_dependency_graph__DependencyGraph_resolveDependency(litaC_dependency_graph__DependencyGraph* litaC_this,litaC_dependency_graph__Dependency* litaC_dependency);
litaC_void litaC_dependency_graph__DependencyGraph_sortAggregates(litaC_dependency_graph__DependencyGraph* litaC_this);
litaC_std__array__Array_cb__ptr_Dependency_ce_ litaC_dependency_graph__DependencyGraph_sortAggregatesDependencies(litaC_dependency_graph__DependencyGraph* litaC_this,litaC_std__array__Array_cb__ptr_Dependency_ce_* litaC_deps);
litaC_std__array__Array_cb__ptr_Symbol_ce_ litaC_dependency_graph__DependencyGraph_sort(litaC_dependency_graph__DependencyGraph* litaC_this);
litaC_void litaC_cgen_decl__CGen_emitVarDecl(litaC_cgen__CGen* litaC_this,litaC_ast__VarDecl* litaC_decl);
litaC_void litaC_cgen_decl__CGen_emitDefaultInitValue(litaC_cgen__CGen* litaC_this,litaC_symbols__Symbol* litaC_sym);
litaC_void litaC_cgen_decl__CGen_emitFuncDeclSignature(litaC_cgen__CGen* litaC_this,litaC_ast__FuncDecl* litaC_decl,const litaC_char* litaC_name);
litaC_void litaC_cgen_decl__CGen_emitFuncDecl(litaC_cgen__CGen* litaC_this,litaC_ast__FuncDecl* litaC_decl);
litaC_void litaC_cgen_decl__CGen_emitAggregateDecl(litaC_cgen__CGen* litaC_this,litaC_ast__AggregateDecl* litaC_decl);
litaC_void litaC_cgen_decl__CGen_emitEnumDecl(litaC_cgen__CGen* litaC_this,litaC_ast__EnumDecl* litaC_decl);
litaC_void litaC_build__BuildFile_init(litaC_build__BuildFile* litaC_this,const litaC_std__mem__Allocator* litaC_allocator);
litaC_void litaC_build__BuildFile_free(litaC_build__BuildFile* litaC_this);
litaC_void litaC_build__FreeArray(litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_array,const litaC_std__mem__Allocator* litaC_allocator);
litaC_bool litaC_build__BuildFile_writeTo(litaC_build__BuildFile* litaC_this,litaC_std__io__File* litaC_file);
litaC_bool litaC_build__BuildFileFromFile(const litaC_char* litaC_filename,litaC_build__BuildFile* litaC_buildFile,const litaC_std__mem__Allocator* litaC_allocator);
litaC_bool litaC_build__BuildFileFromJson(litaC_std__json__JsonNode* litaC_json,litaC_build__BuildFile* litaC_buildFile,const litaC_std__mem__Allocator* litaC_allocator);
litaC_void litaC_build__AddStrings(litaC_std__json__JsonNode* litaC_json,const litaC_char* litaC_key,litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_array,const litaC_std__mem__Allocator* litaC_allocator);
litaC_std__json__JsonNode* litaC_build__CreateArray(litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_array,const litaC_std__mem__Allocator* litaC_allocator);
litaC_bool litaC_tcc__libtcc__IsLibtccAvailable();
litaC_void litaC_pkg_mgr__PackageManager_init(litaC_pkg_mgr__PackageManager* litaC_this,litaC_pkg_mgr__PackageOptions litaC_options,const litaC_std__mem__Allocator* litaC_allocator);
litaC_void litaC_pkg_mgr__PackageManager_free(litaC_pkg_mgr__PackageManager* litaC_this);
litaC_void litaC_pkg_mgr__PackageManager_printMessages(litaC_pkg_mgr__PackageManager* litaC_this);

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__PackageManager_initCommand(litaC_pkg_mgr__PackageManager* litaC_this,litaC_pkg_mgr__PackageInitOptions litaC_options);

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__PackageManager_buildCommand(litaC_pkg_mgr__PackageManager* litaC_this,litaC_pkg_mgr__PackageBuildOptions litaC_options);

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__PackageManager_installCommand(litaC_pkg_mgr__PackageManager* litaC_this,litaC_pkg_mgr__PackageInstallOptions litaC_options);

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__PackageManager_createBuildFile(litaC_pkg_mgr__PackageManager* litaC_this,litaC_build__BuildFile* litaC_buildFile);

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__PackageManager_runCommand(litaC_pkg_mgr__PackageManager* litaC_this,const litaC_char* litaC_cmd);
litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__PackageManager_readProjectPkg(litaC_pkg_mgr__PackageManager* litaC_this);
litaC_void litaC_pkg_mgr__pkg__PackageDef_free(litaC_pkg_mgr__pkg__PackageDef* litaC_this);
litaC_std__string_view__StringView litaC_pkg_mgr__pkg__PackageId_repo(litaC_pkg_mgr__pkg__PackageId* litaC_this);
litaC_std__string_view__StringView litaC_pkg_mgr__pkg__PackageId_name(litaC_pkg_mgr__pkg__PackageId* litaC_this);
litaC_std__string_view__StringView litaC_pkg_mgr__pkg__PackageId_version(litaC_pkg_mgr__pkg__PackageId* litaC_this);
litaC_bool litaC_pkg_mgr__pkg__PackageIdFromString(const litaC_char* litaC_id,litaC_pkg_mgr__pkg__PackageId* litaC_pkgId);
litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg__ParsePackageFile(litaC_pkg_mgr__PackageManager* litaC_pm,const litaC_char* litaC_pkgFile,litaC_pkg_mgr__pkg__PackageDef** litaC_result);
litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg__ParsePackage(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_std__json__JsonNode* litaC_json,litaC_pkg_mgr__pkg__PackageDef** litaC_result);
litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg__ParsePackageId(litaC_std__json__JsonNode* litaC_json,litaC_pkg_mgr__pkg__PackageId* litaC_pkgId,const litaC_std__mem__Allocator* litaC_allocator);
litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_install__PackageInstall(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_pkg_mgr__PackageInstallOptions litaC_options);
litaC_bool litaC_pkg_mgr__pkg_install__isPackageInstalled(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_pkg_mgr__pkg__PackageId* litaC_pkgId,const litaC_char* litaC_pkgDir);
litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_install__cleanPackageDirectory(litaC_pkg_mgr__PackageManager* litaC_pm,const litaC_char* litaC_pkgPath);
litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_install__deleteDir(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_std__string__String* litaC_path);
litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_install__findPackagesToInstall(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_std__array__Array_cb_PackageId_ce_* litaC_pkgsToInstall);
litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_install__makePackageDirectory(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_pkg_mgr__pkg__PackageId* litaC_pkgId,litaC_char* litaC_output);
litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_install__downloadPackage(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_std__http__Http* litaC_http,litaC_pkg_mgr__pkg__PackageId* litaC_pkgId,const litaC_char* litaC_pkgFile);
litaC_usize litaC_pkg_mgr__pkg_install__httpCallback(litaC_void* litaC_data,litaC_usize litaC_size,litaC_usize litaC_n,litaC_void* litaC_userdata);
const litaC_char* litaC_pkg_mgr__pkg_install__getRepoTemplate(litaC_pkg_mgr__pkg__PackageId* litaC_pkgId);
litaC_char* litaC_pkg_mgr__pkg_install__sanitizeFilename(const litaC_char* litaC_filename,litaC_char* litaC_out);
litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_install__installPackage(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_pkg_mgr__pkg__PackageId* litaC_pkgId,const litaC_char* litaC_pkgFile,litaC_std__array__Array_cb_PackageId_ce_* litaC_pkgsToInstall);
litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_install__readPackage(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_pkg_mgr__pkg__PackageId* litaC_pkgId,const litaC_char* litaC_pkgPath,litaC_pkg_mgr__pkg__PackageDef** litaC_resultPkg,litaC_std__array__Array_cb_PackageId_ce_* litaC_pkgsToInstall);
litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_install__dealWithGithubBS(const litaC_char* litaC_pkgPath,litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_extractedFiles);
litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_install__zipLocalPackage(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_pkg_mgr__pkg__PackageId* litaC_pkgId,const litaC_char* litaC_pkgFile);
litaC_void* litaC_std__zip__ZipFileAlloc(litaC_void* litaC_opaque,litaC_usize litaC_items,litaC_usize litaC_size);
litaC_void* litaC_std__zip__ZipFileReAlloc(litaC_void* litaC_opaque,litaC_void* litaC_address,litaC_usize litaC_old_items,litaC_usize litaC_old_size,litaC_usize litaC_items,litaC_usize litaC_size);
litaC_void litaC_std__zip__ZipFileFree(litaC_void* litaC_opaque,litaC_void* litaC_address);
litaC_std__zip__ZipStatus litaC_std__zip__ZipFile_open(litaC_std__zip__ZipFile* litaC_this,const litaC_char* litaC_filename,litaC_std__zip__ZipOpen litaC_type,const litaC_std__mem__Allocator* litaC_allocator);
litaC_std__zip__ZipStatus litaC_std__zip__ZipFile_close(litaC_std__zip__ZipFile* litaC_this);

litaC_std__zip__ZipStatus litaC_std__zip__ZipFile_finalize(litaC_std__zip__ZipFile* litaC_this);
litaC_bool litaC_std__zip__ZipFile_isValid(litaC_std__zip__ZipFile* litaC_this);
const litaC_char* litaC_std__zip__ZipFile_getLastError(litaC_std__zip__ZipFile* litaC_this);
litaC_std__zip__ZipStatus litaC_std__zip__ZipFile_zipDir(litaC_std__zip__ZipFile* litaC_this,const litaC_char* litaC_pathToZip,litaC_i32 litaC_len,const litaC_char* litaC_baseName,litaC_std__zip__ZipCompressionLevel litaC_level);
litaC_std__zip__ZipStatus litaC_std__zip__ZipFile_zipFolder(litaC_std__zip__ZipFile* litaC_this,const litaC_char* litaC_baseName,litaC_std__string_view__StringView* litaC_basePath,litaC_std__string__String* litaC_archiveName,litaC_std__string__String* litaC_path,litaC_std__zip__ZipCompressionLevel litaC_level);
litaC_std__zip__ZipStatus litaC_std__zip__ZipFile_addFile(litaC_std__zip__ZipFile* litaC_this,const litaC_char* litaC_archiveName,const litaC_char* litaC_filename,litaC_std__zip__ZipCompressionLevel litaC_level);

litaC_std__zip__ZipStatus litaC_std__zip__ZipFile_unzip(litaC_std__zip__ZipFile* litaC_this,const litaC_char* litaC_dest,litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_extractedFiles,litaC_i32 litaC_flags);
litaC_bool litaC_std__fs__FileHandle_openEx(litaC_std__fs__FileHandle* litaC_this,const litaC_char* litaC_path,litaC_i32 litaC_len);
litaC_bool litaC_std__fs__FileHandle_open(litaC_std__fs__FileHandle* litaC_this,const litaC_char* litaC_path);
litaC_bool litaC_std__fs__FileHandle_isFile(litaC_std__fs__FileHandle* litaC_this);
litaC_bool litaC_std__fs__FileHandle_isDirectory(litaC_std__fs__FileHandle* litaC_this);
const litaC_char* litaC_std__fs__FileHandle_name(litaC_std__fs__FileHandle* litaC_this);
litaC_bool litaC_std__fs__FileHandle_hasNext(litaC_std__fs__FileHandle* litaC_this);
litaC_bool litaC_std__fs__FileHandle_next(litaC_std__fs__FileHandle* litaC_this);
litaC_bool litaC_std__fs__FileHandle_close(litaC_std__fs__FileHandle* litaC_this);
litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_build__PackageBuild(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_pkg_mgr__PackageBuildOptions litaC_options);
litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_build__PackageManager_buildCommandArgs(litaC_pkg_mgr__PackageManager* litaC_this,litaC_std__json__JsonNode* litaC_buildCommand,litaC_pkg_mgr__PackageBuildOptions litaC_options,litaC_pkg_mgr__pkg_build__CommandArgs* litaC_args);
litaC_bool litaC_pkg_mgr__pkg_build__ContainsOption(const litaC_char* litaC_option,litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_programArgs);
litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_build__PackageManager_buildWithScript(litaC_pkg_mgr__PackageManager* litaC_this,litaC_std__json__JsonNode* litaC_script);
litaC_std__json__JsonNode* litaC_pkg_mgr__pkg_build__GetTarget(litaC_std__json__JsonNode* litaC_buildCommand,litaC_std__json__JsonNode* litaC_defaultTarget,litaC_pkg_mgr__PackageBuildOptions litaC_options);
litaC_std__json__JsonNode* litaC_pkg_mgr__pkg_build__GetOS(litaC_std__json__JsonNode* litaC_target,litaC_std__json__JsonNode* litaC_defaultTarget);
litaC_std__json__JsonNode* litaC_pkg_mgr__pkg_build__GetArch(litaC_std__json__JsonNode* litaC_os,litaC_std__json__JsonNode* litaC_defaultOS);
litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_run__PackageRun(litaC_pkg_mgr__PackageManager* litaC_pm,const litaC_char* litaC_cmd);
litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_init__PackageInit(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_pkg_mgr__PackageInitOptions litaC_options);
const litaC_char* litaC_pkg_mgr__PkgStatusAsStr(litaC_pkg_mgr__PkgStatus litaC_enumType);
const litaC_char* litaC_lsp__protocol__SymbolInfoKindAsStr(litaC_lsp__protocol__SymbolInfoKind litaC_enumType);
const litaC_char* litaC_std__json__JsonTypeAsStr(litaC_std__json__JsonType litaC_enumType);
const litaC_char* litaC_lita__TypeInfoOptionAsStr(litaC_lita__TypeInfoOption litaC_enumType);
const litaC_char* litaC_lita__MetricTypeAsStr(litaC_lita__MetricType litaC_enumType);
const litaC_char* litaC_symbols__SymbolStateAsStr(litaC_symbols__SymbolState litaC_enumType);
const litaC_char* litaC_symbols__SymbolKindAsStr(litaC_symbols__SymbolKind litaC_enumType);
const litaC_char* litaC_ast__TypeSpecKindAsStr(litaC_ast__TypeSpecKind litaC_enumType);
const litaC_char* litaC_ast__StmtKindAsStr(litaC_ast__StmtKind litaC_enumType);
const litaC_char* litaC_types__TypeKindAsStr(litaC_types__TypeKind litaC_enumType);
const litaC_char* litaC_lex__TokenTypeAsStr(litaC_lex__TokenType litaC_enumType);
const litaC_char* litaC_std__io__FileStatusAsStr(litaC_std__io__FileStatus litaC_enumType);
litaC_lita__LitaOptions* litaC_std__mem__new_cb_LitaOptions_ce_(const litaC_std__mem__Allocator* litaC_a);
LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb_PhaseError_ce_(litaC_std__array__Array_cb_PhaseError_ce_* litaC_a);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_PhaseError_ce_(litaC_std__array__Array_cb_PhaseError_ce_* litaC_a);
litaC_phase_result__PhaseError litaC_std__array__Array_get_cb_PhaseError_ce_(litaC_std__array__Array_cb_PhaseError_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_const_char_ce_(litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_a);
const litaC_char* litaC_std__array__Array_get_cb__ptr_const_char_ce_(litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_a,litaC_i32 litaC_index);
litaC_std__array__Array_cb_Option_ce_ litaC_std__array__ArrayInit_cb_Option_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_init_cb_Option_ce_(litaC_std__array__Array_cb_Option_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__array__Array_cb__ptr_const_char_ce_ litaC_std__array__ArrayInit_cb__ptr_const_char_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_init_cb__ptr_const_char_ce_(litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_free_cb_Option_ce_(litaC_std__array__Array_cb_Option_ce_* litaC_a);
litaC_void litaC_std__array__Array_free_cb__ptr_const_char_ce_(litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_a);
litaC_void litaC_std__array__Array_add_cb_Option_ce_(litaC_std__array__Array_cb_Option_ce_* litaC_a,litaC_std__cmdline__Option litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb_Option_ce_(litaC_std__array__Array_cb_Option_ce_* litaC_a,litaC_i32 litaC_increment);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_Option_ce_(litaC_std__array__Array_cb_Option_ce_* litaC_a);
litaC_void litaC_std__array__Array_add_cb__ptr_const_char_ce_(litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_a,const litaC_char* litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb__ptr_const_char_ce_(litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_std__array__Array_cb__ptr_TypeInfo_ce_ litaC_std__array__ArrayInit_cb__ptr_TypeInfo_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_init_cb__ptr_TypeInfo_ce_(litaC_std__array__Array_cb__ptr_TypeInfo_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(litaC_std__array__Array_cb__ptr_TypeInfo_ce_* litaC_a);
litaC_void litaC_std__array__Array_add_cb__ptr_TypeInfo_ce_(litaC_std__array__Array_cb__ptr_TypeInfo_ce_* litaC_a,litaC_types__TypeInfo* litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb__ptr_TypeInfo_ce_(litaC_std__array__Array_cb__ptr_TypeInfo_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_types__TypeInfo* litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(litaC_std__array__Array_cb__ptr_TypeInfo_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb_GenericParam_ce_(litaC_std__array__Array_cb_GenericParam_ce_* litaC_a);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_GenericParam_ce_(litaC_std__array__Array_cb_GenericParam_ce_* litaC_a);
litaC_ast__GenericParam litaC_std__array__Array_get_cb_GenericParam_ce_(litaC_std__array__Array_cb_GenericParam_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_a);
litaC_ast__ParameterDecl* litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb_FieldStmt_ce_(litaC_std__array__Array_cb_FieldStmt_ce_* litaC_a);
litaC_void litaC_std__array__Array_init_cb__ptr_TypeSpec_ce_(litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_add_cb__ptr_TypeSpec_ce_(litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_a,litaC_ast__TypeSpec* litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb__ptr_TypeSpec_ce_(litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_std__array__Array_cb_GenericParam_ce_ litaC_std__array__ArrayInit_cb_GenericParam_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_init_cb_GenericParam_ce_(litaC_std__array__Array_cb_GenericParam_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_addAll_cb_GenericParam_ce_(litaC_std__array__Array_cb_GenericParam_ce_* litaC_a,litaC_std__array__Array_cb_GenericParam_ce_* litaC_other);
litaC_void litaC_std__array__ArrayGrow_cb_GenericParam_ce_(litaC_std__array__Array_cb_GenericParam_ce_* litaC_a,litaC_i32 litaC_increment);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_a);
litaC_ast__EnumFieldEntryDecl* litaC_std__array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_FieldStmt_ce_(litaC_std__array__Array_cb_FieldStmt_ce_* litaC_a);
litaC_ast__FieldStmt litaC_std__array__Array_get_cb_FieldStmt_ce_(litaC_std__array__Array_cb_FieldStmt_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb__ptr_ParameterDecl_ce_(litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_a);
litaC_ast__ParameterDecl* litaC_std__array__Array_first_cb__ptr_ParameterDecl_ce_(litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_a);
litaC_void litaC_std__bucket_list__BucketList_init_cb_TypeSpec_ce_(litaC_std__bucket_list__BucketList_cb_TypeSpec_ce_* litaC_this,litaC_i32 litaC_bucketSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_* litaC_std__bucket_list__BucketList_allocBucket_cb_TypeSpec_ce_(litaC_std__bucket_list__BucketList_cb_TypeSpec_ce_* litaC_this);
litaC_void litaC_std__bucket_list__BucketList_free_cb_TypeSpec_ce_(litaC_std__bucket_list__BucketList_cb_TypeSpec_ce_* litaC_this);
litaC_void litaC_std__bucket_list__BucketList_clear_cb_TypeSpec_ce_(litaC_std__bucket_list__BucketList_cb_TypeSpec_ce_* litaC_this);
litaC_void litaC_std__bucket_list__BucketList_add_cb_TypeSpec_ce_(litaC_std__bucket_list__BucketList_cb_TypeSpec_ce_* litaC_this,litaC_ast__TypeSpec litaC_element);
litaC_ast__TypeSpec* litaC_std__bucket_list__BucketList_lastPtr_cb_TypeSpec_ce_(litaC_std__bucket_list__BucketList_cb_TypeSpec_ce_* litaC_this);
litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_* litaC_std__bucket_list__BucketList_getBucketAt_cb_TypeSpec_ce_(litaC_std__bucket_list__BucketList_cb_TypeSpec_ce_* litaC_this,litaC_usize litaC_index,litaC_i32* litaC_iterations);
litaC_ast__ImportDecl* litaC_std__mem__new_cb_ImportDecl_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__VarDecl* litaC_std__mem__new_cb_VarDecl_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__FuncDecl* litaC_std__mem__new_cb_FuncDecl_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__ParametersStmt* litaC_ast__Node_becomeParentOf_cb_ParametersStmt_ce_(litaC_ast__Node* litaC_n,litaC_ast__ParametersStmt* litaC_child);
litaC_ast__Stmt* litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(litaC_ast__Node* litaC_n,litaC_ast__Stmt* litaC_child);
litaC_ast__AggregateDecl* litaC_std__mem__new_cb_AggregateDecl_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__EnumDecl* litaC_ast__Node_becomeParentOf_cb_EnumDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__EnumDecl* litaC_child);
litaC_ast__AggregateDecl* litaC_ast__Node_becomeParentOf_cb_AggregateDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__AggregateDecl* litaC_child);
litaC_ast__TraitFieldDecl* litaC_ast__Node_becomeParentOf_cb_TraitFieldDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__TraitFieldDecl* litaC_child);
litaC_ast__VarFieldDecl* litaC_ast__Node_becomeParentOf_cb_VarFieldDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__VarFieldDecl* litaC_child);
litaC_ast__Expr* litaC_ast__Node_becomeParentOf_cb_Expr_ce_(litaC_ast__Node* litaC_n,litaC_ast__Expr* litaC_child);
litaC_ast__EnumDecl* litaC_std__mem__new_cb_EnumDecl_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_EnumFieldEntryDecl_ce_(litaC_ast__Node* litaC_n,litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_children);
litaC_ast__EnumFieldEntryDecl* litaC_ast__Node_becomeParentOf_cb_EnumFieldEntryDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__EnumFieldEntryDecl* litaC_child);
litaC_ast__TypedefDecl* litaC_std__mem__new_cb_TypedefDecl_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__ParameterDecl* litaC_std__mem__new_cb_ParameterDecl_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__NotesDecl* litaC_std__mem__new_cb_NotesDecl_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__NativeDecl* litaC_std__mem__new_cb_NativeDecl_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__PoisonDecl* litaC_std__mem__new_cb_PoisonDecl_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__TernaryExpr* litaC_std__mem__new_cb_TernaryExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__BinaryExpr* litaC_std__mem__new_cb_BinaryExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__UnaryExpr* litaC_std__mem__new_cb_UnaryExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__InitExpr* litaC_std__mem__new_cb_InitExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_std__array__Array_cb__ptr_InitArgExpr_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_InitArgExpr_ce_(litaC_ast__Node* litaC_n,litaC_std__array__Array_cb__ptr_InitArgExpr_ce_* litaC_children);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_InitArgExpr_ce_(litaC_std__array__Array_cb__ptr_InitArgExpr_ce_* litaC_a);
litaC_ast__InitArgExpr* litaC_std__array__Array_get_cb__ptr_InitArgExpr_ce_(litaC_std__array__Array_cb__ptr_InitArgExpr_ce_* litaC_a,litaC_i32 litaC_index);
litaC_ast__InitArgExpr* litaC_ast__Node_becomeParentOf_cb_InitArgExpr_ce_(litaC_ast__Node* litaC_n,litaC_ast__InitArgExpr* litaC_child);
litaC_ast__FuncCallExpr* litaC_std__mem__new_cb_FuncCallExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a);
litaC_ast__CallArg litaC_std__array__Array_get_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_index);
litaC_ast__SubscriptGetExpr* litaC_std__mem__new_cb_SubscriptGetExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__SubscriptSetExpr* litaC_std__mem__new_cb_SubscriptSetExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__GetExpr* litaC_std__mem__new_cb_GetExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__IdentifierExpr* litaC_ast__Node_becomeParentOf_cb_IdentifierExpr_ce_(litaC_ast__Node* litaC_n,litaC_ast__IdentifierExpr* litaC_child);
litaC_ast__SetExpr* litaC_std__mem__new_cb_SetExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__IdentifierExpr* litaC_std__mem__new_cb_IdentifierExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__TypeIdentifierExpr* litaC_std__mem__new_cb_TypeIdentifierExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__CastExpr* litaC_std__mem__new_cb_CastExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__ArrayDesignationExpr* litaC_std__mem__new_cb_ArrayDesignationExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__InitArgExpr* litaC_std__mem__new_cb_InitArgExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__BooleanExpr* litaC_std__mem__new_cb_BooleanExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__NullExpr* litaC_std__mem__new_cb_NullExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__NumberExpr* litaC_std__mem__new_cb_NumberExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__StringExpr* litaC_std__mem__new_cb_StringExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__CharExpr* litaC_std__mem__new_cb_CharExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__GroupExpr* litaC_std__mem__new_cb_GroupExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__ArrayInitExpr* litaC_std__mem__new_cb_ArrayInitExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_std__array__Array_cb__ptr_Expr_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_Expr_ce_(litaC_ast__Node* litaC_n,litaC_std__array__Array_cb__ptr_Expr_ce_* litaC_children);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_Expr_ce_(litaC_std__array__Array_cb__ptr_Expr_ce_* litaC_a);
litaC_ast__Expr* litaC_std__array__Array_get_cb__ptr_Expr_ce_(litaC_std__array__Array_cb__ptr_Expr_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb__ptr_Expr_ce_(litaC_std__array__Array_cb__ptr_Expr_ce_* litaC_a);
litaC_ast__SizeOfExpr* litaC_std__mem__new_cb_SizeOfExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__TypeOfExpr* litaC_std__mem__new_cb_TypeOfExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__OffsetOfExpr* litaC_std__mem__new_cb_OffsetOfExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__PoisonExpr* litaC_std__mem__new_cb_PoisonExpr_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__ModuleStmt* litaC_std__mem__new_cb_ModuleStmt_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__CompStmt* litaC_std__mem__new_cb_CompStmt_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__BlockStmt* litaC_std__mem__new_cb_BlockStmt_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_Stmt_ce_(litaC_ast__Node* litaC_n,litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_children);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_Stmt_ce_(litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_a);
litaC_ast__Stmt* litaC_std__array__Array_get_cb__ptr_Stmt_ce_(litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_i32 litaC_index);
litaC_ast__IfStmt* litaC_std__mem__new_cb_IfStmt_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__WhileStmt* litaC_std__mem__new_cb_WhileStmt_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__DoWhileStmt* litaC_std__mem__new_cb_DoWhileStmt_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__ForStmt* litaC_std__mem__new_cb_ForStmt_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__SwitchCaseStmt* litaC_std__mem__new_cb_SwitchCaseStmt_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__SwitchStmt* litaC_std__mem__new_cb_SwitchStmt_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_SwitchCaseStmt_ce_(litaC_ast__Node* litaC_n,litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_children);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_SwitchCaseStmt_ce_(litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a);
litaC_ast__SwitchCaseStmt* litaC_std__array__Array_get_cb__ptr_SwitchCaseStmt_ce_(litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a,litaC_i32 litaC_index);
litaC_ast__SwitchCaseStmt* litaC_ast__Node_becomeParentOf_cb_SwitchCaseStmt_ce_(litaC_ast__Node* litaC_n,litaC_ast__SwitchCaseStmt* litaC_child);
litaC_ast__BreakStmt* litaC_std__mem__new_cb_BreakStmt_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__ContinueStmt* litaC_std__mem__new_cb_ContinueStmt_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__ReturnStmt* litaC_std__mem__new_cb_ReturnStmt_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__DeferStmt* litaC_std__mem__new_cb_DeferStmt_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__GotoStmt* litaC_std__mem__new_cb_GotoStmt_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__LabelStmt* litaC_std__mem__new_cb_LabelStmt_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__NoteStmt* litaC_std__mem__new_cb_NoteStmt_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__EmptyStmt* litaC_std__mem__new_cb_EmptyStmt_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__ParametersStmt* litaC_std__mem__new_cb_ParametersStmt_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_ParameterDecl_ce_(litaC_ast__Node* litaC_n,litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_children);
litaC_ast__ParameterDecl* litaC_ast__Node_becomeParentOf_cb_ParameterDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__ParameterDecl* litaC_child);
litaC_ast__VarFieldDecl* litaC_std__mem__new_cb_VarFieldDecl_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__TraitFieldDecl* litaC_std__mem__new_cb_TraitFieldDecl_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_ast__EnumFieldEntryDecl* litaC_std__mem__new_cb_EnumFieldEntryDecl_ce_(const litaC_std__mem__Allocator* litaC_a);
LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb__ptr_NoteStmt_ce_(litaC_std__array__Array_cb__ptr_NoteStmt_ce_* litaC_a);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(litaC_std__array__Array_cb__ptr_NoteStmt_ce_* litaC_a);
litaC_ast__NoteStmt* litaC_std__array__Array_get_cb__ptr_NoteStmt_ce_(litaC_std__array__Array_cb__ptr_NoteStmt_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a);
litaC_ast__CallArg* litaC_std__array__Array_getPtr_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_index);
litaC_symbols__Scope* litaC_std__mem__new_cb_Scope_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_ litaC_intern__InternMap_cb__ptr_Symbol_ce_(litaC_symbols__Symbol* litaC_emptyValue,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_allocator);
litaC_void litaC_std__map__Map_init_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_m,litaC_symbols__Symbol* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_intern__InternedString),litaC_bool (*litaC_equalFn)(litaC_intern__InternedString,litaC_intern__InternedString),const litaC_std__mem__Allocator* litaC_alloc,litaC_intern__InternedString litaC_emptyKey);
litaC_void litaC_std__map__MapGrow_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_std__map__Map_put_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_m,litaC_intern__InternedString litaC_key,litaC_symbols__Symbol* litaC_value);
litaC_void litaC_std__map__Map_free_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_m);
litaC_symbols__Symbol* litaC_std__map__Map_get_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_m,litaC_intern__InternedString litaC_key);
litaC_bool litaC_std__map__Map_contains_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_m,litaC_intern__InternedString litaC_key);
litaC_symbols__Symbol* litaC_std__map__Map_remove_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_m,litaC_intern__InternedString litaC_key);
litaC_symbols__Symbol* litaC_std__mem__new_cb_Symbol_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_ litaC_std__map__Map_iter_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_m);
litaC_bool litaC_std__map__MapIterator_hasNext_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_* litaC_iter);
litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_ litaC_std__map__MapIterator_next_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_* litaC_iter);
litaC_void litaC_std__map__MapIterator_remove_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_* litaC_iter);
litaC_std__map__MapIterator_cb__ptr_const_char_c_ModuleImport_ce_ litaC_std__map__Map_iter_cb__ptr_const_char_c_ModuleImport_ce_(litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_* litaC_m);
litaC_bool litaC_std__map__MapIterator_hasNext_cb__ptr_const_char_c_ModuleImport_ce_(litaC_std__map__MapIterator_cb__ptr_const_char_c_ModuleImport_ce_* litaC_iter);
litaC_std__map__MapEntry_cb__ptr_const_char_c_ModuleImport_ce_ litaC_std__map__MapIterator_next_cb__ptr_const_char_c_ModuleImport_ce_(litaC_std__map__MapIterator_cb__ptr_const_char_c_ModuleImport_ce_* litaC_iter);
litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_ litaC_std__map__StrMap_cb_ModuleImport_ce_(litaC_module__ModuleImport litaC_emptyValue,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__map__Map_init_cb__ptr_const_char_c_ModuleImport_ce_(litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_* litaC_m,litaC_module__ModuleImport litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(const litaC_char*),litaC_bool (*litaC_equalFn)(const litaC_char*,const litaC_char*),const litaC_std__mem__Allocator* litaC_alloc,const litaC_char* litaC_emptyKey);
litaC_void litaC_std__map__MapGrow_cb__ptr_const_char_c_ModuleImport_ce_(litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_std__map__Map_put_cb__ptr_const_char_c_ModuleImport_ce_(litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_* litaC_m,const litaC_char* litaC_key,litaC_module__ModuleImport litaC_value);
litaC_void litaC_std__map__Map_free_cb__ptr_const_char_c_ModuleImport_ce_(litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_* litaC_m);
litaC_module__Module* litaC_std__mem__new_cb_Module_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_module__ModuleImport litaC_std__map__Map_get_cb__ptr_const_char_c_ModuleImport_ce_(litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_* litaC_m,const litaC_char* litaC_key);
litaC_void litaC_std__array__Array_init_cb_PhaseError_ce_(litaC_std__array__Array_cb_PhaseError_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_add_cb_PhaseError_ce_(litaC_std__array__Array_cb_PhaseError_ce_* litaC_a,litaC_phase_result__PhaseError litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb_PhaseError_ce_(litaC_std__array__Array_cb_PhaseError_ce_* litaC_a,litaC_i32 litaC_increment);
LITAC_INLINE 
litaC_void litaC_std__array__Array_clear_cb_PhaseError_ce_(litaC_std__array__Array_cb_PhaseError_ce_* litaC_a);
litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_ litaC_std__map__StrMap_cb__ptr_Module_ce_(litaC_module__Module* litaC_emptyValue,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__map__Map_init_cb__ptr_const_char_c__ptr_Module_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m,litaC_module__Module* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(const litaC_char*),litaC_bool (*litaC_equalFn)(const litaC_char*,const litaC_char*),const litaC_std__mem__Allocator* litaC_alloc,const litaC_char* litaC_emptyKey);
litaC_void litaC_std__map__MapGrow_cb__ptr_const_char_c__ptr_Module_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_std__map__Map_put_cb__ptr_const_char_c__ptr_Module_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m,const litaC_char* litaC_key,litaC_module__Module* litaC_value);
litaC_void litaC_std__map__Map_free_cb__ptr_const_char_c__ptr_Module_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m);
litaC_void litaC_std__array__Array_init_cb_CCompilerOption_ce_(litaC_std__array__Array_cb_CCompilerOption_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_module__Module* litaC_std__map__Map_get_cb__ptr_const_char_c__ptr_Module_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m,const litaC_char* litaC_key);
litaC_void litaC_std__array__Array_insertAt_cb__ptr_ImportDecl_ce_(litaC_std__array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__ImportDecl* litaC_element);
litaC_void litaC_std__array__Array_add_cb__ptr_ImportDecl_ce_(litaC_std__array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_ast__ImportDecl* litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb__ptr_ImportDecl_ce_(litaC_std__array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_void litaC_std__array__Array_set_cb__ptr_ImportDecl_ce_(litaC_std__array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__ImportDecl* litaC_element);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_Symbol_ce_(litaC_std__array__Array_cb__ptr_Symbol_ce_* litaC_a);
litaC_symbols__Symbol* litaC_std__array__Array_get_cb__ptr_Symbol_ce_(litaC_std__array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_i32 litaC_index);
litaC_symbols__Symbol* litaC_std__array__Array_removeAt_cb__ptr_Symbol_ce_(litaC_std__array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_i32 litaC_index);
litaC_void litaC_std__array__Array_add_cb__ptr_Symbol_ce_(litaC_std__array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_symbols__Symbol* litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb__ptr_Symbol_ce_(litaC_std__array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_i32 litaC_increment);
LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb_CCompilerOption_ce_(litaC_std__array__Array_cb_CCompilerOption_ce_* litaC_a);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_CCompilerOption_ce_(litaC_std__array__Array_cb_CCompilerOption_ce_* litaC_a);
litaC_lita__CCompilerOption* litaC_std__array__Array_getPtr_cb_CCompilerOption_ce_(litaC_std__array__Array_cb_CCompilerOption_ce_* litaC_a,litaC_i32 litaC_index);
litaC_lsp__document__Document* litaC_std__map__Map_get_cb__ptr_const_char_c__ptr_Document_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_* litaC_m,const litaC_char* litaC_key);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_ImportDecl_ce_(litaC_std__array__Array_cb__ptr_ImportDecl_ce_* litaC_a);
litaC_ast__ImportDecl* litaC_std__array__Array_get_cb__ptr_ImportDecl_ce_(litaC_std__array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_i32 litaC_index);
litaC_void* litaC_std__mem__GenericMalloc_cb_BucketAllocator_ce_(const litaC_std__mem__Allocator* litaC_alloc,litaC_usize litaC_size);
litaC_void* litaC_std__mem__GenericCalloc_cb_BucketAllocator_ce_(const litaC_std__mem__Allocator* litaC_alloc,litaC_usize litaC_num,litaC_usize litaC_size);
litaC_void* litaC_std__mem__GenericRealloc_cb_BucketAllocator_ce_(const litaC_std__mem__Allocator* litaC_alloc,litaC_void* litaC_ptr,litaC_usize litaC_oldSize,litaC_usize litaC_size);
litaC_void litaC_std__array__Array_init_cb_CheckerContext_ce_(litaC_std__array__Array_cb_CheckerContext_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_init_cb_ScriptDecl_ce_(litaC_std__array__Array_cb_ScriptDecl_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_add_cb_CheckerContext_ce_(litaC_std__array__Array_cb_CheckerContext_ce_* litaC_a,litaC_preprocessor__CheckerContext litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb_CheckerContext_ce_(litaC_std__array__Array_cb_CheckerContext_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_void litaC_std__array__Array_add_cb__ptr_NoteStmt_ce_(litaC_std__array__Array_cb__ptr_NoteStmt_ce_* litaC_a,litaC_ast__NoteStmt* litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb__ptr_NoteStmt_ce_(litaC_std__array__Array_cb__ptr_NoteStmt_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_void litaC_std__array__Array_addAll_cb__ptr_NoteStmt_ce_(litaC_std__array__Array_cb__ptr_NoteStmt_ce_* litaC_a,litaC_std__array__Array_cb__ptr_NoteStmt_ce_* litaC_other);
litaC_void litaC_std__array__Array_add_cb__ptr_Decl_ce_(litaC_std__array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_ast__Decl* litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb__ptr_Decl_ce_(litaC_std__array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_i32 litaC_increment);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_CheckerContext_ce_(litaC_std__array__Array_cb_CheckerContext_ce_* litaC_a);
litaC_preprocessor__CheckerContext litaC_std__array__Array_get_cb_CheckerContext_ce_(litaC_std__array__Array_cb_CheckerContext_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb_ScriptDecl_ce_(litaC_std__array__Array_cb_ScriptDecl_ce_* litaC_a);
litaC_preprocessor__ScriptDecl litaC_std__array__Array_pop_cb_ScriptDecl_ce_(litaC_std__array__Array_cb_ScriptDecl_ce_* litaC_a);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_Decl_ce_(litaC_std__array__Array_cb__ptr_Decl_ce_* litaC_a);
litaC_void litaC_std__array__Array_addAll_cb__ptr_Decl_ce_(litaC_std__array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_std__array__Array_cb__ptr_Decl_ce_* litaC_other);
litaC_ast__Decl* litaC_std__array__Array_get_cb__ptr_Decl_ce_(litaC_std__array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_i32 litaC_index);
litaC_void litaC_std__array__Array_addAll_cb__ptr_ImportDecl_ce_(litaC_std__array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_std__array__Array_cb__ptr_ImportDecl_ce_* litaC_other);
LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb__ptr_TypeSpec_ce_(litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_a);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_a);
litaC_ast__TypeSpec* litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_a,litaC_i32 litaC_index);
litaC_void litaC_std__array__Array_add_cb_GenericParam_ce_(litaC_std__array__Array_cb_GenericParam_ce_* litaC_a,litaC_ast__GenericParam litaC_element);
litaC_std__array__Array_cb_CallArg_ce_ litaC_std__array__ArrayInit_cb_CallArg_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_init_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_add_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a,litaC_ast__CallArg litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_std__array__Array_cb__ptr_Expr_ce_ litaC_std__array__ArrayInit_cb__ptr_Expr_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_init_cb__ptr_Expr_ce_(litaC_std__array__Array_cb__ptr_Expr_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_add_cb__ptr_Expr_ce_(litaC_std__array__Array_cb__ptr_Expr_ce_* litaC_a,litaC_ast__Expr* litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb__ptr_Expr_ce_(litaC_std__array__Array_cb__ptr_Expr_ce_* litaC_a,litaC_i32 litaC_increment);
LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb__ptr_Stmt_ce_(litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_a);
litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_std__array__ArrayInit_cb__ptr_Stmt_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_init_cb__ptr_Stmt_ce_(litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_add_cb__ptr_Stmt_ce_(litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_ast__Stmt* litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb__ptr_Stmt_ce_(litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_i32 litaC_increment);
LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb__ptr_InitArgExpr_ce_(litaC_std__array__Array_cb__ptr_InitArgExpr_ce_* litaC_a);
litaC_void litaC_std__array__Array_init_cb__ptr_InitArgExpr_ce_(litaC_std__array__Array_cb__ptr_InitArgExpr_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_add_cb__ptr_InitArgExpr_ce_(litaC_std__array__Array_cb__ptr_InitArgExpr_ce_* litaC_a,litaC_ast__InitArgExpr* litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb__ptr_InitArgExpr_ce_(litaC_std__array__Array_cb__ptr_InitArgExpr_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_void litaC_std__array__Array_init_cb__ptr_ParameterDecl_ce_(litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_add_cb__ptr_ParameterDecl_ce_(litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_ast__ParameterDecl* litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb__ptr_ParameterDecl_ce_(litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_i32 litaC_increment);
LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb__ptr_SwitchCaseStmt_ce_(litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a);
litaC_void litaC_std__array__Array_init_cb__ptr_SwitchCaseStmt_ce_(litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_add_cb__ptr_SwitchCaseStmt_ce_(litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a,litaC_ast__SwitchCaseStmt* litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb__ptr_SwitchCaseStmt_ce_(litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_std__array__Array_cb_GenericParam_ce_ litaC_std__array__Array_copy_cb_GenericParam_ce_(litaC_std__array__Array_cb_GenericParam_ce_* litaC_a,const litaC_std__mem__Allocator* litaC_allocator);
litaC_std__array__Array_cb_FieldStmt_ce_ litaC_std__array__ArrayInit_cb_FieldStmt_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_init_cb_FieldStmt_ce_(litaC_std__array__Array_cb_FieldStmt_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_add_cb_FieldStmt_ce_(litaC_std__array__Array_cb_FieldStmt_ce_* litaC_a,litaC_ast__FieldStmt litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb_FieldStmt_ce_(litaC_std__array__Array_cb_FieldStmt_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_void litaC_std__array__Array_insertAt_cb__ptr_Stmt_ce_(litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__Stmt* litaC_element);
litaC_void litaC_std__array__Array_set_cb__ptr_Stmt_ce_(litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__Stmt* litaC_element);
litaC_void litaC_std__array__Array_init_cb__ptr_Module_ce_(litaC_std__array__Array_cb__ptr_Module_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_init_cb__ptr_Symbol_ce_(litaC_std__array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_init_cb_Array_cb_GenericParam_ce__ce_(litaC_std__array__Array_cb_Array_cb_GenericParam_ce__ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_u32 litaC_std__map__PtrHashFn_cb_i64_ce_(litaC_i64 litaC_a);
litaC_bool litaC_std__map__PtrEqualFn_cb_i64_ce_(litaC_i64 litaC_a,litaC_i64 litaC_b);
litaC_void litaC_std__map__Map_init_cb_i64_c_Array_cb_i64_ce__ce_(litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m,litaC_std__array__Array_cb_i64_ce_ litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_i64),litaC_bool (*litaC_equalFn)(litaC_i64,litaC_i64),const litaC_std__mem__Allocator* litaC_alloc,litaC_i64 litaC_emptyKey);
litaC_void litaC_std__map__MapGrow_cb_i64_c_Array_cb_i64_ce__ce_(litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_std__map__Map_put_cb_i64_c_Array_cb_i64_ce__ce_(litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m,litaC_i64 litaC_key,litaC_std__array__Array_cb_i64_ce_ litaC_value);
litaC_void litaC_std__map__Map_free_cb_i64_c_Array_cb_i64_ce__ce_(litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m);
litaC_ast__Decl* litaC_std__array__Array_removeAt_cb__ptr_Decl_ce_(litaC_std__array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_i32 litaC_index);
litaC_void litaC_std__array__Array_push_cb__ptr_Module_ce_(litaC_std__array__Array_cb__ptr_Module_ce_* litaC_a,litaC_module__Module* litaC_element);
litaC_void litaC_std__array__Array_add_cb__ptr_Module_ce_(litaC_std__array__Array_cb__ptr_Module_ce_* litaC_a,litaC_module__Module* litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb__ptr_Module_ce_(litaC_std__array__Array_cb__ptr_Module_ce_* litaC_a,litaC_i32 litaC_increment);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_Module_ce_(litaC_std__array__Array_cb__ptr_Module_ce_* litaC_a);
litaC_module__Module* litaC_std__array__Array_pop_cb__ptr_Module_ce_(litaC_std__array__Array_cb__ptr_Module_ce_* litaC_a);
litaC_module__Module* litaC_std__array__Array_last_cb__ptr_Module_ce_(litaC_std__array__Array_cb__ptr_Module_ce_* litaC_a);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_Array_cb_GenericParam_ce__ce_(litaC_std__array__Array_cb_Array_cb_GenericParam_ce__ce_* litaC_a);
litaC_void litaC_std__array__Array_add_cb_Array_cb_GenericParam_ce__ce_(litaC_std__array__Array_cb_Array_cb_GenericParam_ce__ce_* litaC_a,litaC_std__array__Array_cb_GenericParam_ce_ litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb_Array_cb_GenericParam_ce__ce_(litaC_std__array__Array_cb_Array_cb_GenericParam_ce__ce_* litaC_a,litaC_i32 litaC_increment);
litaC_std__array__Array_cb_GenericParam_ce_ litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(litaC_std__array__Array_cb_Array_cb_GenericParam_ce__ce_* litaC_a);
litaC_bool litaC_std__map__Map_contains_cb_i64_c_Array_cb_i64_ce__ce_(litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m,litaC_i64 litaC_key);
litaC_std__array__Array_cb_i64_ce_* litaC_std__map__Map_getPtr_cb_i64_c_Array_cb_i64_ce__ce_(litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m,litaC_i64 litaC_key);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_i64_ce_(litaC_std__array__Array_cb_i64_ce_* litaC_a);
litaC_i64 litaC_std__array__Array_get_cb_i64_ce_(litaC_std__array__Array_cb_i64_ce_* litaC_a,litaC_i32 litaC_index);
litaC_std__array__Array_cb_i64_ce_ litaC_std__array__ArrayInit_cb_i64_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_init_cb_i64_ce_(litaC_std__array__Array_cb_i64_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_add_cb_i64_ce_(litaC_std__array__Array_cb_i64_ce_* litaC_a,litaC_i64 litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb_i64_ce_(litaC_std__array__Array_cb_i64_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_types__TypeInfo* litaC_std__array__Array_last_cb__ptr_TypeInfo_ce_(litaC_std__array__Array_cb__ptr_TypeInfo_ce_* litaC_a);
litaC_void litaC_std__bucket_list__BucketList_init_cb_TypeInfo_ce_(litaC_std__bucket_list__BucketList_cb_TypeInfo_ce_* litaC_this,litaC_i32 litaC_bucketSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__bucket_list__Bucket_cb_TypeInfo_ce_* litaC_std__bucket_list__BucketList_allocBucket_cb_TypeInfo_ce_(litaC_std__bucket_list__BucketList_cb_TypeInfo_ce_* litaC_this);
litaC_void litaC_std__map__Map_init_cb_i64_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_i64_c__ptr_TypeInfo_ce_* litaC_m,litaC_types__TypeInfo* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_i64),litaC_bool (*litaC_equalFn)(litaC_i64,litaC_i64),const litaC_std__mem__Allocator* litaC_alloc,litaC_i64 litaC_emptyKey);
litaC_void litaC_std__map__MapGrow_cb_i64_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_i64_c__ptr_TypeInfo_ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_std__map__Map_put_cb_i64_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_i64_c__ptr_TypeInfo_ce_* litaC_m,litaC_i64 litaC_key,litaC_types__TypeInfo* litaC_value);
litaC_void litaC_std__map__Map_free_cb_i64_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_i64_c__ptr_TypeInfo_ce_* litaC_m);
litaC_void litaC_std__map__Map_init_cb_ArrayEntry_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_ArrayEntry_c__ptr_TypeInfo_ce_* litaC_m,litaC_types__TypeInfo* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_types_new__ArrayEntry),litaC_bool (*litaC_equalFn)(litaC_types_new__ArrayEntry,litaC_types_new__ArrayEntry),const litaC_std__mem__Allocator* litaC_alloc,litaC_types_new__ArrayEntry litaC_emptyKey);
litaC_void litaC_std__map__MapGrow_cb_ArrayEntry_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_ArrayEntry_c__ptr_TypeInfo_ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_std__map__Map_put_cb_ArrayEntry_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_ArrayEntry_c__ptr_TypeInfo_ce_* litaC_m,litaC_types_new__ArrayEntry litaC_key,litaC_types__TypeInfo* litaC_value);
litaC_void litaC_std__map__Map_free_cb_ArrayEntry_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_ArrayEntry_c__ptr_TypeInfo_ce_* litaC_m);
litaC_std__map__Map_cb_InternedString_c__ptr_TypeInfo_ce_ litaC_intern__InternMap_cb__ptr_TypeInfo_ce_(litaC_types__TypeInfo* litaC_emptyValue,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_allocator);
litaC_void litaC_std__map__Map_init_cb_InternedString_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_TypeInfo_ce_* litaC_m,litaC_types__TypeInfo* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_intern__InternedString),litaC_bool (*litaC_equalFn)(litaC_intern__InternedString,litaC_intern__InternedString),const litaC_std__mem__Allocator* litaC_alloc,litaC_intern__InternedString litaC_emptyKey);
litaC_void litaC_std__map__MapGrow_cb_InternedString_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_TypeInfo_ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_std__map__Map_put_cb_InternedString_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_TypeInfo_ce_* litaC_m,litaC_intern__InternedString litaC_key,litaC_types__TypeInfo* litaC_value);
litaC_void litaC_std__map__Map_free_cb_InternedString_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_TypeInfo_ce_* litaC_m);
litaC_void litaC_std__bucket_list__BucketList_add_cb_TypeInfo_ce_(litaC_std__bucket_list__BucketList_cb_TypeInfo_ce_* litaC_this,litaC_types__TypeInfo litaC_element);
litaC_types__TypeInfo* litaC_std__bucket_list__BucketList_lastPtr_cb_TypeInfo_ce_(litaC_std__bucket_list__BucketList_cb_TypeInfo_ce_* litaC_this);
litaC_std__bucket_list__Bucket_cb_TypeInfo_ce_* litaC_std__bucket_list__BucketList_getBucketAt_cb_TypeInfo_ce_(litaC_std__bucket_list__BucketList_cb_TypeInfo_ce_* litaC_this,litaC_usize litaC_index,litaC_i32* litaC_iterations);
litaC_types__TypeInfo* litaC_std__map__Map_get_cb_InternedString_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_TypeInfo_ce_* litaC_m,litaC_intern__InternedString litaC_key);
litaC_types__TypeInfo* litaC_std__map__Map_get_cb_ArrayEntry_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_ArrayEntry_c__ptr_TypeInfo_ce_* litaC_m,litaC_types_new__ArrayEntry litaC_key);
litaC_types__TypeInfo* litaC_std__map__Map_get_cb_i64_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_i64_c__ptr_TypeInfo_ce_* litaC_m,litaC_i64 litaC_key);
litaC_ast__GenericParam litaC_std__array__Array_removeAt_cb_GenericParam_ce_(litaC_std__array__Array_cb_GenericParam_ce_* litaC_a,litaC_i32 litaC_index);
litaC_void litaC_std__array__Array_set_cb__ptr_TypeSpec_ce_(litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__TypeSpec* litaC_element);
litaC_std__map__MapIterator_cb_ArrayEntry_c__ptr_TypeInfo_ce_ litaC_std__map__Map_iter_cb_ArrayEntry_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_ArrayEntry_c__ptr_TypeInfo_ce_* litaC_m);
litaC_bool litaC_std__map__MapIterator_hasNext_cb_ArrayEntry_c__ptr_TypeInfo_ce_(litaC_std__map__MapIterator_cb_ArrayEntry_c__ptr_TypeInfo_ce_* litaC_iter);
litaC_std__map__MapEntry_cb_ArrayEntry_c__ptr_TypeInfo_ce_ litaC_std__map__MapIterator_next_cb_ArrayEntry_c__ptr_TypeInfo_ce_(litaC_std__map__MapIterator_cb_ArrayEntry_c__ptr_TypeInfo_ce_* litaC_iter);
litaC_std__map__MapIterator_cb_i64_c__ptr_TypeInfo_ce_ litaC_std__map__Map_iter_cb_i64_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_i64_c__ptr_TypeInfo_ce_* litaC_m);
litaC_bool litaC_std__map__MapIterator_hasNext_cb_i64_c__ptr_TypeInfo_ce_(litaC_std__map__MapIterator_cb_i64_c__ptr_TypeInfo_ce_* litaC_iter);
litaC_std__map__MapEntry_cb_i64_c__ptr_TypeInfo_ce_ litaC_std__map__MapIterator_next_cb_i64_c__ptr_TypeInfo_ce_(litaC_std__map__MapIterator_cb_i64_c__ptr_TypeInfo_ce_* litaC_iter);
litaC_types__TypeInfo* litaC_std__array__Array_pop_cb__ptr_TypeInfo_ce_(litaC_std__array__Array_cb__ptr_TypeInfo_ce_* litaC_a);
litaC_void litaC_std__array__Array_insertAt_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__CallArg litaC_element);
litaC_void litaC_std__array__Array_set_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__CallArg litaC_element);
litaC_void litaC_std__array__Array_addAll_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a,litaC_std__array__Array_cb_CallArg_ce_* litaC_other);
litaC_void litaC_std__array__Array_sort_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 (*litaC_sorter)(litaC_ast__CallArg,litaC_ast__CallArg));
litaC_void litaC_std__array__QuickSort_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_array,litaC_i32 (*litaC_comp)(litaC_ast__CallArg,litaC_ast__CallArg));
litaC_void litaC_std__array__Array_init_cb_Reference_ce_(litaC_std__array__Array_cb_Reference_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_init_cb_FieldReference_ce_(litaC_std__array__Array_cb_FieldReference_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_u32 litaC_std__map__PtrHashFn_cb_usize_ce_(litaC_usize litaC_a);
litaC_bool litaC_std__map__PtrEqualFn_cb_usize_ce_(litaC_usize litaC_a,litaC_usize litaC_b);
litaC_void litaC_std__map__Map_init_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_std__array__Array_cb_SrcPos_ce_ litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_usize),litaC_bool (*litaC_equalFn)(litaC_usize,litaC_usize),const litaC_std__mem__Allocator* litaC_alloc,litaC_usize litaC_emptyKey);
litaC_void litaC_std__map__MapGrow_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_std__map__Map_put_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_usize litaC_key,litaC_std__array__Array_cb_SrcPos_ce_ litaC_value);
litaC_void litaC_std__map__Map_free_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m);
litaC_bool litaC_std__map__Map_contains_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_usize litaC_key);
litaC_std__array__Array_cb_SrcPos_ce_ litaC_std__array__ArrayInit_cb_SrcPos_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_init_cb_SrcPos_ce_(litaC_std__array__Array_cb_SrcPos_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__array__Array_cb_SrcPos_ce_* litaC_std__map__Map_getPtr_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_usize litaC_key);
litaC_void litaC_std__array__Array_add_cb_SrcPos_ce_(litaC_std__array__Array_cb_SrcPos_ce_* litaC_a,litaC_lex__SrcPos litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb_SrcPos_ce_(litaC_std__array__Array_cb_SrcPos_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_void litaC_std__array__Array_add_cb_Reference_ce_(litaC_std__array__Array_cb_Reference_ce_* litaC_a,litaC_lsp__references__Reference litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb_Reference_ce_(litaC_std__array__Array_cb_Reference_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_void litaC_std__array__Array_add_cb_FieldReference_ce_(litaC_std__array__Array_cb_FieldReference_ce_* litaC_a,litaC_lsp__references__FieldReference litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb_FieldReference_ce_(litaC_std__array__Array_cb_FieldReference_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_std__array__Array_cb_SrcPos_ce_ litaC_std__map__Map_get_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_usize litaC_key);
litaC_std__map__MapIterator_cb_usize_c_Array_cb_SrcPos_ce__ce_ litaC_std__map__Map_iter_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m);
litaC_bool litaC_std__map__MapIterator_hasNext_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__MapIterator_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_iter);
litaC_std__map__MapEntry_cb_usize_c_Array_cb_SrcPos_ce__ce_ litaC_std__map__MapIterator_next_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__MapIterator_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_iter);
litaC_void litaC_std__map__MapIterator_remove_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__MapIterator_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_iter);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_Reference_ce_(litaC_std__array__Array_cb_Reference_ce_* litaC_a);
litaC_lsp__references__Reference* litaC_std__array__Array_getPtr_cb_Reference_ce_(litaC_std__array__Array_cb_Reference_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_FieldReference_ce_(litaC_std__array__Array_cb_FieldReference_ce_* litaC_a);
litaC_lsp__references__FieldReference* litaC_std__array__Array_getPtr_cb_FieldReference_ce_(litaC_std__array__Array_cb_FieldReference_ce_* litaC_a,litaC_i32 litaC_index);
litaC_std__json__JsonNode* litaC_std__mem__new_cb_JsonNode_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_std__array__Array_cb__ptr_JsonNode_ce_* litaC_std__mem__new_cb_Array_cb__ptr_JsonNode_ce__ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_void litaC_std__array__Array_init_cb__ptr_JsonNode_ce_(litaC_std__array__Array_cb__ptr_JsonNode_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__json__JsonObject* litaC_std__mem__new_cb_JsonObject_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_void litaC_std__map__Map_init_cb__ptr_const_char_c_i32_ce_(litaC_std__map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m,litaC_i32 litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(const litaC_char*),litaC_bool (*litaC_equalFn)(const litaC_char*,const litaC_char*),const litaC_std__mem__Allocator* litaC_alloc,const litaC_char* litaC_emptyKey);
litaC_void litaC_std__map__MapGrow_cb__ptr_const_char_c_i32_ce_(litaC_std__map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_std__map__Map_put_cb__ptr_const_char_c_i32_ce_(litaC_std__map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m,const litaC_char* litaC_key,litaC_i32 litaC_value);
litaC_void litaC_std__map__Map_free_cb__ptr_const_char_c_i32_ce_(litaC_std__map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m);
litaC_void litaC_std__array__Array_init_cb_JsonEntry_ce_(litaC_std__array__Array_cb_JsonEntry_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_add_cb_JsonEntry_ce_(litaC_std__array__Array_cb_JsonEntry_ce_* litaC_a,litaC_std__json__JsonEntry litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb_JsonEntry_ce_(litaC_std__array__Array_cb_JsonEntry_ce_* litaC_a,litaC_i32 litaC_increment);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_JsonEntry_ce_(litaC_std__array__Array_cb_JsonEntry_ce_* litaC_a);
litaC_bool litaC_std__map__Map_contains_cb__ptr_const_char_c_i32_ce_(litaC_std__map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m,const litaC_char* litaC_key);
litaC_i32 litaC_std__map__Map_get_cb__ptr_const_char_c_i32_ce_(litaC_std__map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m,const litaC_char* litaC_key);
litaC_std__json__JsonEntry litaC_std__array__Array_get_cb_JsonEntry_ce_(litaC_std__array__Array_cb_JsonEntry_ce_* litaC_a,litaC_i32 litaC_index);
litaC_void litaC_std__array__Array_add_cb__ptr_JsonNode_ce_(litaC_std__array__Array_cb__ptr_JsonNode_ce_* litaC_a,litaC_std__json__JsonNode* litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb__ptr_JsonNode_ce_(litaC_std__array__Array_cb__ptr_JsonNode_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_std__json__JsonNode* litaC_std__array__Array_get_cb__ptr_JsonNode_ce_(litaC_std__array__Array_cb__ptr_JsonNode_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_JsonNode_ce_(litaC_std__array__Array_cb__ptr_JsonNode_ce_* litaC_a);
LITAC_INLINE 
litaC_i32 litaC_std__map__Map_size_cb__ptr_const_char_c_i32_ce_(litaC_std__map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m);
litaC_void litaC_std__array__Array_free_cb__ptr_JsonNode_ce_(litaC_std__array__Array_cb__ptr_JsonNode_ce_* litaC_a);
litaC_void litaC_std__array__Array_free_cb_JsonEntry_ce_(litaC_std__array__Array_cb_JsonEntry_ce_* litaC_a);
litaC_void litaC_std__array__Array_init_cb_Token_ce_(litaC_std__array__Array_cb_Token_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_add_cb_Token_ce_(litaC_std__array__Array_cb_Token_ce_* litaC_a,litaC_lex__Token litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb_Token_ce_(litaC_std__array__Array_cb_Token_ce_* litaC_a,litaC_i32 litaC_increment);
LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb_Token_ce_(litaC_std__array__Array_cb_Token_ce_* litaC_a);
litaC_void litaC_std__array__Array_init_cb__ptr_ImportDecl_ce_(litaC_std__array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_init_cb__ptr_NoteStmt_ce_(litaC_std__array__Array_cb__ptr_NoteStmt_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_init_cb__ptr_Decl_ce_(litaC_std__array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_ast__Decl* litaC_std__array__Array_last_cb__ptr_Decl_ce_(litaC_std__array__Array_cb__ptr_Decl_ce_* litaC_a);
litaC_void litaC_std__array__Array_insertAt_cb__ptr_ParameterDecl_ce_(litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__ParameterDecl* litaC_element);
litaC_void litaC_std__array__Array_set_cb__ptr_ParameterDecl_ce_(litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__ParameterDecl* litaC_element);
litaC_void litaC_std__array__Array_init_cb__ptr_EnumFieldEntryDecl_ce_(litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_add_cb__ptr_EnumFieldEntryDecl_ce_(litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_a,litaC_ast__EnumFieldEntryDecl* litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb__ptr_EnumFieldEntryDecl_ce_(litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_void litaC_std__array__Array_free_cb__ptr_TypeSpec_ce_(litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_a);
LITAC_INLINE 
litaC_void litaC_std__array__Array_clear_cb__ptr_TypeSpec_ce_(litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_a);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_Token_ce_(litaC_std__array__Array_cb_Token_ce_* litaC_a);
litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_ litaC_std__map__StrMap_cb__ptr_Document_ce_(litaC_lsp__document__Document* litaC_emptyValue,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__map__Map_init_cb__ptr_const_char_c__ptr_Document_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_* litaC_m,litaC_lsp__document__Document* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(const litaC_char*),litaC_bool (*litaC_equalFn)(const litaC_char*,const litaC_char*),const litaC_std__mem__Allocator* litaC_alloc,const litaC_char* litaC_emptyKey);
litaC_void litaC_std__map__MapGrow_cb__ptr_const_char_c__ptr_Document_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_std__map__Map_put_cb__ptr_const_char_c__ptr_Document_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_* litaC_m,const litaC_char* litaC_key,litaC_lsp__document__Document* litaC_value);
litaC_void litaC_std__map__Map_free_cb__ptr_const_char_c__ptr_Document_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_* litaC_m);
litaC_bool litaC_std__map__Map_contains_cb__ptr_const_char_c__ptr_Document_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_* litaC_m,const litaC_char* litaC_key);
litaC_lsp__document__Document* litaC_std__mem__new_cb_Document_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_void litaC_std__array__Array_init_cb_u32_ce_(litaC_std__array__Array_cb_u32_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_lsp__document__Document* litaC_std__map__Map_remove_cb__ptr_const_char_c__ptr_Document_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_* litaC_m,const litaC_char* litaC_key);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_TextDocumentChangeEvent_ce_(litaC_std__array__Array_cb_TextDocumentChangeEvent_ce_* litaC_a);
litaC_lsp__protocol__TextDocumentChangeEvent* litaC_std__array__Array_getPtr_cb_TextDocumentChangeEvent_ce_(litaC_std__array__Array_cb_TextDocumentChangeEvent_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb_SrcPos_ce_(litaC_std__array__Array_cb_SrcPos_ce_* litaC_a);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_SrcPos_ce_(litaC_std__array__Array_cb_SrcPos_ce_* litaC_a);
litaC_lex__SrcPos* litaC_std__array__Array_getPtr_cb_SrcPos_ce_(litaC_std__array__Array_cb_SrcPos_ce_* litaC_a,litaC_i32 litaC_index);
litaC_lsp__protocol__TextDocumentDidChange* litaC_std__mem__new_cb_TextDocumentDidChange_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_void litaC_std__array__Array_init_cb_TextDocumentChangeEvent_ce_(litaC_std__array__Array_cb_TextDocumentChangeEvent_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_add_cb_TextDocumentChangeEvent_ce_(litaC_std__array__Array_cb_TextDocumentChangeEvent_ce_* litaC_a,litaC_lsp__protocol__TextDocumentChangeEvent litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb_TextDocumentChangeEvent_ce_(litaC_std__array__Array_cb_TextDocumentChangeEvent_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_ast__GenericParam* litaC_std__array__Array_getPtr_cb_GenericParam_ce_(litaC_std__array__Array_cb_GenericParam_ce_* litaC_a,litaC_i32 litaC_index);
litaC_ast__FieldStmt* litaC_std__array__Array_getPtr_cb_FieldStmt_ce_(litaC_std__array__Array_cb_FieldStmt_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_void litaC_std__array__Array_clear_cb_u32_ce_(litaC_std__array__Array_cb_u32_ce_* litaC_a);
litaC_void litaC_std__array__Array_add_cb_u32_ce_(litaC_std__array__Array_cb_u32_ce_* litaC_a,litaC_u32 litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb_u32_ce_(litaC_std__array__Array_cb_u32_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_u32 litaC_std__array__Array_get_cb_u32_ce_(litaC_std__array__Array_cb_u32_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb__ptr_TypeInfo_ce_(litaC_std__array__Array_cb__ptr_TypeInfo_ce_* litaC_a);
litaC_void litaC_std__array__Array_add_cb_ScriptDecl_ce_(litaC_std__array__Array_cb_ScriptDecl_ce_* litaC_a,litaC_preprocessor__ScriptDecl litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb_ScriptDecl_ce_(litaC_std__array__Array_cb_ScriptDecl_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_ litaC_std__map__Map_iter_cb__ptr_const_char_c__ptr_Module_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m);
litaC_bool litaC_std__map__MapIterator_hasNext_cb__ptr_const_char_c__ptr_Module_ce_(litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_* litaC_iter);
litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_Module_ce_ litaC_std__map__MapIterator_next_cb__ptr_const_char_c__ptr_Module_ce_(litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_* litaC_iter);
litaC_std__map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_ litaC_std__map__Map_iter_cb_i64_c_Array_cb_i64_ce__ce_(litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m);
litaC_bool litaC_std__map__MapIterator_hasNext_cb_i64_c_Array_cb_i64_ce__ce_(litaC_std__map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_* litaC_iter);
litaC_std__map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_ litaC_std__map__MapIterator_next_cb_i64_c_Array_cb_i64_ce__ce_(litaC_std__map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_* litaC_iter);
litaC_void litaC_std__array__Array_add_cb_CCompilerOption_ce_(litaC_std__array__Array_cb_CCompilerOption_ce_* litaC_a,litaC_lita__CCompilerOption litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb_CCompilerOption_ce_(litaC_std__array__Array_cb_CCompilerOption_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_u32 litaC_std__map__PtrHashFn_cb__ptr_Symbol_ce_(litaC_symbols__Symbol* litaC_a);
litaC_bool litaC_std__map__PtrEqualFn_cb__ptr_Symbol_ce_(litaC_symbols__Symbol* litaC_a,litaC_symbols__Symbol* litaC_b);
litaC_void litaC_std__map__Map_init_cb__ptr_Symbol_c_Dependency_ce_(litaC_std__map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m,litaC_dependency_graph__Dependency litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_symbols__Symbol*),litaC_bool (*litaC_equalFn)(litaC_symbols__Symbol*,litaC_symbols__Symbol*),const litaC_std__mem__Allocator* litaC_alloc,litaC_symbols__Symbol* litaC_emptyKey);
litaC_void litaC_std__map__MapGrow_cb__ptr_Symbol_c_Dependency_ce_(litaC_std__map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_std__map__Map_put_cb__ptr_Symbol_c_Dependency_ce_(litaC_std__map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m,litaC_symbols__Symbol* litaC_key,litaC_dependency_graph__Dependency litaC_value);
litaC_void litaC_std__map__Map_free_cb__ptr_Symbol_c_Dependency_ce_(litaC_std__map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m);
litaC_dependency_graph__Dependency* litaC_std__map__Map_getPtr_cb__ptr_Symbol_c_Dependency_ce_(litaC_std__map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m,litaC_symbols__Symbol* litaC_key);
litaC_void litaC_std__array__Array_add_cb__ptr_Dependency_ce_(litaC_std__array__Array_cb__ptr_Dependency_ce_* litaC_a,litaC_dependency_graph__Dependency* litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb__ptr_Dependency_ce_(litaC_std__array__Array_cb__ptr_Dependency_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_void litaC_std__array__Array_init_cb__ptr_Dependency_ce_(litaC_std__array__Array_cb__ptr_Dependency_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_std__map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_ litaC_std__map__Map_iter_cb__ptr_Symbol_c_Dependency_ce_(litaC_std__map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m);
litaC_bool litaC_std__map__MapIterator_hasNext_cb__ptr_Symbol_c_Dependency_ce_(litaC_std__map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_* litaC_iter);
litaC_std__map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_ litaC_std__map__MapIterator_next_cb__ptr_Symbol_c_Dependency_ce_(litaC_std__map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_* litaC_iter);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_Dependency_ce_(litaC_std__array__Array_cb__ptr_Dependency_ce_* litaC_a);
litaC_dependency_graph__Dependency* litaC_std__array__Array_get_cb__ptr_Dependency_ce_(litaC_std__array__Array_cb__ptr_Dependency_ce_* litaC_a,litaC_i32 litaC_index);
LITAC_INLINE 
litaC_i32 litaC_std__map__Map_size_cb__ptr_Symbol_c_Dependency_ce_(litaC_std__map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m);
LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb__ptr_Dependency_ce_(litaC_std__array__Array_cb__ptr_Dependency_ce_* litaC_a);
litaC_void litaC_std__array__Array_addAll_cb__ptr_Dependency_ce_(litaC_std__array__Array_cb__ptr_Dependency_ce_* litaC_a,litaC_std__array__Array_cb__ptr_Dependency_ce_* litaC_other);
LITAC_INLINE 
litaC_void litaC_std__array__Array_clear_cb__ptr_Symbol_ce_(litaC_std__array__Array_cb__ptr_Symbol_ce_* litaC_a);
litaC_void litaC_std__array__Array_addAll_cb__ptr_Symbol_ce_(litaC_std__array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_std__array__Array_cb__ptr_Symbol_ce_* litaC_other);
LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb__ptr_const_char_ce_(litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_a);
litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_ litaC_std__map__StrMap_cb__ptr_PackageDef_ce_(litaC_pkg_mgr__pkg__PackageDef* litaC_emptyValue,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__map__Map_init_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_* litaC_m,litaC_pkg_mgr__pkg__PackageDef* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(const litaC_char*),litaC_bool (*litaC_equalFn)(const litaC_char*,const litaC_char*),const litaC_std__mem__Allocator* litaC_alloc,const litaC_char* litaC_emptyKey);
litaC_void litaC_std__map__MapGrow_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_* litaC_m,litaC_i32 litaC_newlength);
litaC_void litaC_std__map__Map_put_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_* litaC_m,const litaC_char* litaC_key,litaC_pkg_mgr__pkg__PackageDef* litaC_value);
litaC_void litaC_std__map__Map_free_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_* litaC_m);
litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_PackageDef_ce_ litaC_std__map__Map_iter_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_* litaC_m);
litaC_bool litaC_std__map__MapIterator_hasNext_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_PackageDef_ce_* litaC_iter);
litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_PackageDef_ce_ litaC_std__map__MapIterator_next_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_PackageDef_ce_* litaC_iter);
LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_PackageId_ce_(litaC_std__array__Array_cb_PackageId_ce_* litaC_a);
LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb_PackageId_ce_(litaC_std__array__Array_cb_PackageId_ce_* litaC_a);
litaC_pkg_mgr__pkg__PackageId litaC_std__array__Array_get_cb_PackageId_ce_(litaC_std__array__Array_cb_PackageId_ce_* litaC_a,litaC_i32 litaC_index);
litaC_void litaC_std__array__Array_free_cb_PackageId_ce_(litaC_std__array__Array_cb_PackageId_ce_* litaC_a);
litaC_bool litaC_std__map__Map_contains_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_* litaC_m,const litaC_char* litaC_key);
litaC_pkg_mgr__pkg__PackageDef* litaC_std__map__Map_get_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_* litaC_m,const litaC_char* litaC_key);
litaC_pkg_mgr__pkg__PackageDef* litaC_std__mem__new_cb_PackageDef_ce_(const litaC_std__mem__Allocator* litaC_a);
litaC_void litaC_std__array__Array_init_cb_PackageId_ce_(litaC_std__array__Array_cb_PackageId_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_add_cb_PackageId_ce_(litaC_std__array__Array_cb_PackageId_ce_* litaC_a,litaC_pkg_mgr__pkg__PackageId litaC_element);
litaC_void litaC_std__array__ArrayGrow_cb_PackageId_ce_(litaC_std__array__Array_cb_PackageId_ce_* litaC_a,litaC_i32 litaC_increment);
litaC_pkg_mgr__pkg__PackageId* litaC_std__array__Array_getPtr_cb_PackageId_ce_(litaC_std__array__Array_cb_PackageId_ce_* litaC_a,litaC_i32 litaC_index);
litaC_std__array__Array_cb_PackageId_ce_ litaC_std__array__ArrayInit_cb_PackageId_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc);
litaC_void litaC_std__array__Array_addAll_cb_PackageId_ce_(litaC_std__array__Array_cb_PackageId_ce_* litaC_a,litaC_std__array__Array_cb_PackageId_ce_* litaC_other);


// Generated code for interfaces

#endif /* _LITAC_HEADER_H */


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// translated code begins
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


struct litaC_std__builtins__any {
    litaC_void* value;
    litaC_u64 id;
    
};

struct litaC_std__mem__linear_allocator__ExpandInfo {
    const litaC_std__mem__Allocator* allocator;
    litaC_std__mem__linear_allocator__ExpandStrategy strategy;
    
};

struct litaC_std__cmdline__Option {
    const litaC_char* name;
    litaC_char shortName;
    const litaC_char* description;
    const litaC_char* value;
    const litaC_char* defaultValue;
    litaC_i32 flags;
    
};

struct litaC_std__string__String {
    litaC_char* buffer;
    litaC_i32 length;
    litaC_i32 capacity;
    
};

struct litaC_preprocessor__DeclContext {
    litaC_checker__TypeChecker* checker;
    litaC_ast__CompStmt* comp;
    litaC_bool resolveSymbols;
    
};

struct litaC_std__array__Array_cb_SrcPos_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_lex__SrcPos* elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__array__Array_cb_PackageId_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_pkg_mgr__pkg__PackageId* elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(const litaC_char*);
    litaC_bool (*equalFn)(const litaC_char*,const litaC_char*);
    const litaC_std__mem__Allocator* alloc;
    litaC_std__map__Key_cb__ptr_const_char_ce_* keys;
    litaC_module__Module** values;
    litaC_module__Module* emptyValue;
    const litaC_char* emptyKey;
    
};

struct litaC_std__array__Array_cb_CCompilerOption_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_lita__CCompilerOption* elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__array__Array_cb_Reference_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_lsp__references__Reference* elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__array__Array_cb_CallArg_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__CallArg* elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__bucket_list__Bucket_cb_TypeInfo_ce_ {
    litaC_i32 length;
    litaC_std__bucket_list__Bucket_cb_TypeInfo_ce_* next;
    litaC_types__TypeInfo* elements;
    
};

struct litaC_std__array__Array_cb__ptr_TypeInfo_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_types__TypeInfo** elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__profile__ProfileEntry {
    const litaC_char* functionName;
    litaC_u64 count;
    litaC_f64 startTime;
    litaC_f64 totalTime;
    
};

struct litaC_cgen__CompilationUnit {
    litaC_module__Module* module;
    litaC_char filename[_MAX_PATH];
    FILE* file;
    
};

struct litaC_std__array__Array_cb_u32_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32* elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__mem__arena_allocator__Arena {
    litaC_usize size;
    litaC_usize current;
    litaC_std__mem__arena_allocator__Arena* next;
    litaC_u8* region;
    
};

struct litaC_lsp__protocol__Position {
    litaC_i32 line;
    litaC_i32 character;
    
};

struct litaC_std__map__Key_cb_i64_ce_ {
    litaC_i64 key;
    litaC_std__map__KeyState state;
    
};

struct litaC_std__map__MapEntry_cb_usize_c_Array_cb_SrcPos_ce__ce_ {
    litaC_usize key;
    litaC_std__array__Array_cb_SrcPos_ce_ value;
    litaC_std__array__Array_cb_SrcPos_ce_* valuePtr;
    
};

struct litaC_preprocessor__ScriptDecl {
    litaC_preprocessor__DeclContext ctx;
    litaC_module__Module* module;
    litaC_ast__ModuleStmt* declarations;
    litaC_bool replacement;
    
};

struct litaC_std__array__Array_cb__ptr_Stmt_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__Stmt** elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_lita__PkgOptions {
    litaC_lita__PkgCommand pkgCmd;
    const litaC_char* pkgRunCmdArg;
    litaC_bool forceClean;
    litaC_bool isRelease;
    const litaC_char* pkgName;
    
};



struct litaC_std__array__Array_cb__ptr_const_char_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    const litaC_char** elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__array__Array_cb_TextDocumentChangeEvent_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_lsp__protocol__TextDocumentChangeEvent* elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_ {
    litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_* m;
    litaC_i32 it;
    litaC_i32 prevIt;
    litaC_i32 count;
    
};


struct litaC_checker__GenericContext {
    litaC_module__Module* callsite;
    
};

struct litaC_pkg_mgr__PackageOptions {
    const litaC_char* projectPath;
    const litaC_char* pkgDir;
    litaC_lita__LitaOptions* litaOptions;
    
};

struct litaC_std__array__Array_cb_i64_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_i64* elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__map__Map_cb__ptr_const_char_c_i32_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(const litaC_char*);
    litaC_bool (*equalFn)(const litaC_char*,const litaC_char*);
    const litaC_std__mem__Allocator* alloc;
    litaC_std__map__Key_cb__ptr_const_char_ce_* keys;
    litaC_i32* values;
    litaC_i32 emptyValue;
    const litaC_char* emptyKey;
    
};

struct litaC_std__map__MapIterator_cb_usize_c_Array_cb_SrcPos_ce__ce_ {
    litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* m;
    litaC_i32 it;
    litaC_i32 prevIt;
    litaC_i32 count;
    
};

struct litaC_introspection__Introspect {
    litaC_lita__Lita* lita;
    
};

struct litaC_build__BuildFile {
    const litaC_std__mem__Allocator* allocator;
    const litaC_char* compileCmdTemplate;
    const litaC_char* projectSrcDir;
    litaC_std__array__Array_cb__ptr_const_char_ce_ pkgPaths;
    litaC_std__array__Array_cb__ptr_const_char_ce_ includePaths;
    litaC_std__array__Array_cb__ptr_const_char_ce_ libraryPaths;
    litaC_std__array__Array_cb__ptr_const_char_ce_ staticLibs;
    
};

struct litaC_std__array__Array_cb__ptr_InitArgExpr_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__InitArgExpr** elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__array__Array_cb_ScriptDecl_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_preprocessor__ScriptDecl* elements;
    const litaC_std__mem__Allocator* alloc;
    
};


struct litaC_lsp__protocol__Range {
    litaC_lsp__protocol__Position start;
    litaC_lsp__protocol__Position end;
    
};

struct litaC_std__array__Array_cb__ptr_NoteStmt_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__NoteStmt** elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_ {
    litaC_std__map__Map_cb__ptr_Symbol_c_Dependency_ce_* m;
    litaC_i32 it;
    litaC_i32 prevIt;
    litaC_i32 count;
    
};

struct litaC_ast__Attributes {
    litaC_ast__Visibility visibility;
    litaC_bool isGlobal;
    litaC_bool isUsing;
    litaC_std__array__Array_cb__ptr_NoteStmt_ce_ notes;
    
};

struct litaC_std__mem__bucket_allocator__Bucket {
    litaC_std__mem__bucket_allocator__Bucket* prev;
    litaC_u8* mem;
    litaC_usize size;
    litaC_void* padding;
    
};

struct litaC_std__array__Array_cb__ptr_JsonNode_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_std__json__JsonNode** elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__array__Array_cb_FieldReference_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_lsp__references__FieldReference* elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__array__Array_cb__ptr_Dependency_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_dependency_graph__Dependency** elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__http__HttpOptions {
    const litaC_char* proxy;
    
};

struct litaC_lita__LitaOptions {
    litaC_char projectPath[_MAX_PATH];
    litaC_char srcPath[_MAX_PATH];
    litaC_char libPath[_MAX_PATH];
    litaC_char litaPath[_MAX_PATH];
    litaC_char inputFile[_MAX_PATH];
    litaC_char outputFile[_MAX_PATH];
    litaC_char outputPath[_MAX_PATH];
    const litaC_char* compileCmd;
    litaC_bool isStrict;
    litaC_bool isTcc;
    litaC_bool checkerOnly;
    litaC_bool cOutputOnly;
    litaC_bool run;
    litaC_bool showProfileInfo;
    litaC_bool languageServer;
    litaC_bool isDebug;
    litaC_bool instrument;
    litaC_bool isVerbose;
    litaC_bool testsOnly;
    const litaC_char* testsRegex;
    litaC_bool testFileOnly;
    litaC_char testPath[_MAX_PATH];
    litaC_lita__TypeInfoOption typeOption;
    litaC_char cPrefix[32];
    litaC_bool cFormat;
    litaC_bool disableLineSync;
    litaC_usize maxMemory;
    const litaC_char* proxy;
    litaC_lita__PkgOptions pkgOptions;
    
};

struct litaC_std__json__JsonEntry {
    const litaC_char* key;
    litaC_std__json__JsonNode* value;
    
};

struct litaC_std__array__Array_cb__ptr_TypeSpec_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__TypeSpec** elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__array__Array_cb__ptr_ParameterDecl_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__ParameterDecl** elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__map__Map_cb_i64_c__ptr_TypeInfo_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(litaC_i64);
    litaC_bool (*equalFn)(litaC_i64,litaC_i64);
    const litaC_std__mem__Allocator* alloc;
    litaC_std__map__Key_cb_i64_ce_* keys;
    litaC_types__TypeInfo** values;
    litaC_types__TypeInfo* emptyValue;
    litaC_i64 emptyKey;
    
};

struct litaC_pkg_mgr__PackageInitOptions {
    const litaC_char* name;
    const litaC_char* version;
    const litaC_char* type;
    const litaC_char* repo;
    
};

struct litaC_std__bucket_list__BucketList_cb_TypeSpec_ce_ {
    const litaC_std__mem__Allocator* allocator;
    litaC_i32 bucketSize;
    litaC_usize length;
    litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_* buckets;
    litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_* top;
    
};


struct litaC_std__map__Key_cb__ptr_Symbol_ce_ {
    litaC_symbols__Symbol* key;
    litaC_std__map__KeyState state;
    
};

struct litaC_lsp__protocol__Location {
    const litaC_char* uri;
    litaC_lsp__protocol__Range range;
    
};


struct litaC_std__json__JsonIterator {
    litaC_i32 index;
    litaC_std__json__JsonNode* json;
    
};

struct litaC_std__array__Array_cb__ptr_ImportDecl_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__ImportDecl** elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__mem__Allocator {
    litaC_void* (*allocFn)(const litaC_std__mem__Allocator*,litaC_usize);
    litaC_void* (*callocFn)(const litaC_std__mem__Allocator*,litaC_usize,litaC_usize);
    litaC_void* (*reallocFn)(const litaC_std__mem__Allocator*,litaC_void*,litaC_usize,litaC_usize);
    litaC_void (*freeFn)(const litaC_std__mem__Allocator*,litaC_void*);
    
};

struct litaC_std__http__Http {
    litaC_std__http__HttpOptions options;
    const litaC_std__mem__Allocator* alloc;
    
};


struct litaC_preprocessor__api__ScriptRuntime {
    ape_t* ape;
    
};

struct litaC_dependency_graph__Dependency {
    litaC_dependency_graph__State state;
    litaC_symbols__Symbol* sym;
    litaC_std__array__Array_cb__ptr_Dependency_ce_ dependsOn;
    
};

struct litaC_std__array__Array_cb_Token_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_lex__Token* elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__map__MapIterator_cb__ptr_const_char_c_ModuleImport_ce_ {
    litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_* m;
    litaC_i32 it;
    litaC_i32 prevIt;
    litaC_i32 count;
    
};

struct litaC_std__json__JsonContext {
    const litaC_std__mem__Allocator* allocator;
    litaC_void (*maker)(litaC_u64,litaC_std__json__JsonContext*,litaC_std__json__JsonNode*,litaC_void*);
    litaC_void* (*makerPtr)(litaC_u64,litaC_std__json__JsonContext*,litaC_std__json__JsonNode*);
    
};

struct litaC_pkg_mgr__PackageBuildOptions {
    litaC_bool isRelease;
    
};

struct litaC_std__array__Array_cb__ptr_Symbol_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_symbols__Symbol** elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__array__Array_cb__ptr_Module_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_module__Module** elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__map__MapEntry_cb_i64_c__ptr_TypeInfo_ce_ {
    litaC_i64 key;
    litaC_types__TypeInfo* value;
    litaC_types__TypeInfo** valuePtr;
    
};

struct litaC_lita__Metric {
    litaC_usize bytesAllocated;
    litaC_u32 allocationCount;
    litaC_f64 executionTime;
    litaC_f64 startTime;
    
};

struct litaC_std__array__Array_cb_FieldStmt_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__FieldStmt* elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_module__ModuleImport {
    litaC_module__Module* module;
    litaC_intern__InternedString* alias;
    litaC_bool isUsing;
    
};

struct litaC_generics__Template {
    litaC_std__array__Array_cb_GenericParam_ce_* genericParams;
    litaC_std__array__Array_cb__ptr_TypeSpec_ce_* genericArgs;
    
};

struct litaC_lsp__protocol__TextDocument {
    const litaC_char* uri;
    litaC_u32 version;
    
};

struct litaC_std__array__Array_cb_JsonEntry_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_std__json__JsonEntry* elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__map__Map_cb_i32_c_i32_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(litaC_i32);
    litaC_bool (*equalFn)(litaC_i32,litaC_i32);
    const litaC_std__mem__Allocator* alloc;
    litaC_std__map__Key_cb_i32_ce_* keys;
    litaC_i32* values;
    litaC_i32 emptyValue;
    litaC_i32 emptyKey;
    
};

struct litaC_std__map__Key_cb_i32_ce_ {
    litaC_i32 key;
    litaC_std__map__KeyState state;
    
};

struct litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(litaC_usize);
    litaC_bool (*equalFn)(litaC_usize,litaC_usize);
    const litaC_std__mem__Allocator* alloc;
    litaC_std__map__Key_cb_usize_ce_* keys;
    litaC_std__array__Array_cb_SrcPos_ce_* values;
    litaC_std__array__Array_cb_SrcPos_ce_ emptyValue;
    litaC_usize emptyKey;
    
};

struct litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(const litaC_char*);
    litaC_bool (*equalFn)(const litaC_char*,const litaC_char*);
    const litaC_std__mem__Allocator* alloc;
    litaC_std__map__Key_cb__ptr_const_char_ce_* keys;
    litaC_pkg_mgr__pkg__PackageDef** values;
    litaC_pkg_mgr__pkg__PackageDef* emptyValue;
    const litaC_char* emptyKey;
    
};

struct litaC_std__map__MapIterator_cb_i64_c__ptr_TypeInfo_ce_ {
    litaC_std__map__Map_cb_i64_c__ptr_TypeInfo_ce_* m;
    litaC_i32 it;
    litaC_i32 prevIt;
    litaC_i32 count;
    
};

struct litaC_std__io__File {
    FILE* file;
    
};


union litaC_std__json__JsonValue {
    litaC_bool boolValue;
    litaC_f64 doubleValue;
    litaC_i64 intValue;
    const litaC_char* strValue;
    litaC_std__json__JsonObject* objValue;
    litaC_std__array__Array_cb__ptr_JsonNode_ce_* arrayValue;
    
};

struct litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__SwitchCaseStmt** elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_ {
    litaC_i32 length;
    litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_* next;
    litaC_ast__TypeSpec* elements;
    
};

struct litaC_std__string_view__StringView {
    const litaC_char* buffer;
    litaC_i32 length;
    
};


struct litaC_pkg_mgr__PackageInstallOptions {
    litaC_bool fullSync;
    litaC_std__http__HttpOptions httpOptions;
    
};

struct litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_PackageDef_ce_ {
    const litaC_char* key;
    litaC_pkg_mgr__pkg__PackageDef* value;
    litaC_pkg_mgr__pkg__PackageDef** valuePtr;
    
};

struct litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_Module_ce_ {
    const litaC_char* key;
    litaC_module__Module* value;
    litaC_module__Module** valuePtr;
    
};

struct litaC_std__system__Process {
    FILE* pipe;
    
};


struct litaC_intern__X {
    litaC_i32 v[litaC_intern__MAX_SOMETHING];
    
};

struct litaC_lsp__references__ReferenceDatabase {
    const litaC_std__mem__Allocator* allocator;
    litaC_std__array__Array_cb_Reference_ce_ typeReferences;
    litaC_std__array__Array_cb_FieldReference_ce_ fieldReferences;
    litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_ symbols;
    
};


struct litaC_pkg_mgr__pkg__PackageId {
    litaC_char id[_MAX_PATH];
    litaC_i32 repoOffset;
    litaC_i32 repoLength;
    litaC_i32 nameOffset;
    litaC_i32 nameLength;
    litaC_i32 versionOffset;
    litaC_i32 versionLength;
    
};

struct litaC_std__array__Array_cb_PhaseError_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_phase_result__PhaseError* elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_lsp__protocol__TextDocumentDidChange {
    litaC_lsp__protocol__TextDocument textDocument;
    litaC_std__array__Array_cb_TextDocumentChangeEvent_ce_ contentChanges;
    
};

struct litaC_pkg_mgr__pkg_build__CommandArgs {
    litaC_i32 n;
    litaC_char** args;
    
};

struct litaC_std__array__Array_cb__ptr_Decl_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__Decl** elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__bucket_list__BucketList_cb_TypeInfo_ce_ {
    const litaC_std__mem__Allocator* allocator;
    litaC_i32 bucketSize;
    litaC_usize length;
    litaC_std__bucket_list__Bucket_cb_TypeInfo_ce_* buckets;
    litaC_std__bucket_list__Bucket_cb_TypeInfo_ce_* top;
    
};

struct litaC_std__string_buffer__StringBuffer {
    litaC_char* buffer;
    litaC_i32 length;
    litaC_i32 capacity;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_types__FieldPositionResult {
    litaC_types__TypeInfo* aggInfo;
    litaC_i32 position;
    
};

struct litaC_types_new__ArrayEntry {
    litaC_types__TypeInfo* arrayOf;
    litaC_ast__Expr* expr;
    litaC_usize length;
    
};

struct litaC_intern__Strings {
    const litaC_std__mem__Allocator* allocator;
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_std__string_view__StringView* keys;
    litaC_intern__InternedString* values;
    
};

struct litaC_cgen__CGenScope {
    litaC_cgen__CGenScope* parent;
    litaC_std__array__Array_cb__ptr_Stmt_ce_ defers;
    litaC_std__array__Array_cb__ptr_const_char_ce_ constDefs;
    litaC_bool isLoop;
    litaC_bool isSwitch;
    
};

struct litaC_std__fs__FileHandle {
    tinydir_dir dir;
    tinydir_file file;
    
};

struct litaC_std__array__Array_cb_GenericParam_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__GenericParam* elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_PackageDef_ce_ {
    litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_* m;
    litaC_i32 it;
    litaC_i32 prevIt;
    litaC_i32 count;
    
};

struct litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_ {
    litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_* m;
    litaC_i32 it;
    litaC_i32 prevIt;
    litaC_i32 count;
    
};

struct litaC_std__json__JsonNode {
    const litaC_std__mem__Allocator* alloc;
    litaC_std__json__JsonType type;
    litaC_std__json__JsonValue value;
    
};

struct litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(const litaC_char*);
    litaC_bool (*equalFn)(const litaC_char*,const litaC_char*);
    const litaC_std__mem__Allocator* alloc;
    litaC_std__map__Key_cb__ptr_const_char_ce_* keys;
    litaC_lsp__document__Document** values;
    litaC_lsp__document__Document* emptyValue;
    const litaC_char* emptyKey;
    
};

struct litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_ {
    litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* m;
    litaC_i32 it;
    litaC_i32 prevIt;
    litaC_i32 count;
    
};


struct litaC_preprocessor__CheckerContext {
    litaC_module__Module* module;
    litaC_ast__CompStmt* stmt;
    
};

struct litaC_std__json__SrcPos {
    const litaC_char* name;
    litaC_i32 line;
    
};

struct litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(litaC_i64);
    litaC_bool (*equalFn)(litaC_i64,litaC_i64);
    const litaC_std__mem__Allocator* alloc;
    litaC_std__map__Key_cb_i64_ce_* keys;
    litaC_std__array__Array_cb_i64_ce_* values;
    litaC_std__array__Array_cb_i64_ce_ emptyValue;
    litaC_i64 emptyKey;
    
};

struct litaC_std__array__Array_cb_Array_cb_GenericParam_ce__ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_std__array__Array_cb_GenericParam_ce_* elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__map__Map_cb__ptr_const_char_c__ptr_const_char_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(const litaC_char*);
    litaC_bool (*equalFn)(const litaC_char*,const litaC_char*);
    const litaC_std__mem__Allocator* alloc;
    litaC_std__map__Key_cb__ptr_const_char_ce_* keys;
    const litaC_char** values;
    const litaC_char* emptyValue;
    const litaC_char* emptyKey;
    
};

struct litaC_std__map__Key_cb__ptr_const_char_ce_ {
    const litaC_char* key;
    litaC_std__map__KeyState state;
    
};

struct litaC_lex__SrcPos {
    const litaC_char* filename;
    const litaC_char* lineStart;
    const litaC_char* start;
    const litaC_char* end;
    litaC_i32 lineNumber;
    litaC_i32 position;
    
};

struct litaC_lita__CCompilerOption {
    Lita_OSType os;
    Lita_ArchType arch;
    litaC_std__string_view__StringView options;
    
};


struct litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__EnumFieldEntryDecl** elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__array__Array_cb_Option_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_std__cmdline__Option* elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_lsp__protocol__TextDocumentChangeEvent {
    litaC_bool hasRange;
    litaC_lsp__protocol__Range range;
    litaC_u32 rangeLength;
    const litaC_char* text;
    
};

struct litaC_std__map__MapEntry_cb_ArrayEntry_c__ptr_TypeInfo_ce_ {
    litaC_types_new__ArrayEntry key;
    litaC_types__TypeInfo* value;
    litaC_types__TypeInfo** valuePtr;
    
};

struct litaC_std__map__Key_cb_usize_ce_ {
    litaC_usize key;
    litaC_std__map__KeyState state;
    
};

struct litaC_std__array__Array_cb__ptr_Expr_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_ast__Expr** elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__array__Array_cb_CheckerContext_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_preprocessor__CheckerContext* elements;
    const litaC_std__mem__Allocator* alloc;
    
};

struct litaC_std__mem__arena_allocator__ArenaAllocator {
    litaC_std__mem__Allocator allocator;
    const litaC_std__mem__Allocator* decorated;
    litaC_std__mem__arena_allocator__Arena* arena;
    litaC_usize pageSize;
    litaC_u32 numberOfArenas;
    litaC_usize numberOfBytesAllocated;
    
};

struct litaC_std__regex__Regex {
    re_t reg;
    
};

struct litaC_std__map__MapIterator_cb_ArrayEntry_c__ptr_TypeInfo_ce_ {
    litaC_std__map__Map_cb_ArrayEntry_c__ptr_TypeInfo_ce_* m;
    litaC_i32 it;
    litaC_i32 prevIt;
    litaC_i32 count;
    
};

union litaC_intern__InternedString {
    struct  {
        const litaC_char* buffer;
        litaC_i32 length;
        
    };
    struct  {
        litaC_usize addr;
        litaC_i32 size;
        
    };
    litaC_std__string_view__StringView view;
    
};

union litaC_lex__Value {
    litaC_f64 floatValue;
    litaC_i64 intValue;
    litaC_u64 uintValue;
    litaC_std__string_view__StringView str;
    
};

struct litaC_lex__Token {
    litaC_lex__TokenType type;
    litaC_lex__Mod mod;
    litaC_types__TypeInfo* typeInfo;
    litaC_lex__SrcPos pos;
    litaC_lex__Value value;
    
};

struct litaC_ast__Identifier {
    litaC_intern__InternedString str;
    litaC_lex__Token token;
    
};

struct litaC_ast__GenericParam {
    litaC_ast__Identifier name;
    
};

struct litaC_ast__Node {
    litaC_ast__StmtKind kind;
    litaC_ast__Node* parent;
    litaC_lex__SrcPos startPos;
    litaC_lex__SrcPos endPos;
    
};

struct litaC_ast__Stmt {
    litaC_ast__Node node;
    
};

struct litaC_ast__Decl {
    litaC_ast__Stmt stmt;
    litaC_symbols__Symbol* sym;
    litaC_ast__Identifier name;
    litaC_ast__Attributes attributes;
    
};

struct litaC_ast__ParameterDecl {
    litaC_ast__Decl decl;
    litaC_ast__TypeSpec* type;
    litaC_ast__Expr* defaultExpr;
    litaC_types__TypeInfo* typeInfo;
    
};

struct litaC_ast__Operand {
    litaC_types__TypeInfo* typeInfo;
    litaC_bool isRightValue;
    litaC_bool isConst;
    litaC_lex__Value val;
    
};

struct litaC_ast__Expr {
    litaC_ast__Stmt stmt;
    litaC_ast__Operand operand;
    litaC_types__TypeInfo* expectedType;
    
};

struct litaC_ast__SizeOfExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* sizeOfExpr;
    
};

struct litaC_std__json__Token {
    litaC_std__json__TokenKind kind;
    litaC_std__json__SrcPos pos;
    const litaC_char* start;
    const litaC_char* end;
    union  {
        litaC_i64 intNumValue;
        litaC_f64 realNumValue;
        const litaC_char* strValue;
        const litaC_char* name;
        
    };
    
};

struct litaC_pkg_mgr__PackageManager {
    litaC_pkg_mgr__PackageOptions options;
    const litaC_std__mem__Allocator* allocator;
    litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_ packages;
    litaC_pkg_mgr__pkg__PackageDef* pkg;
    litaC_std__string_buffer__StringBuffer errors;
    litaC_std__string_buffer__StringBuffer warnings;
    
};

struct litaC_std__http__HttpRequest {
    const litaC_char* url;
    litaC_std__map__Map_cb__ptr_const_char_c__ptr_const_char_ce_ headers;
    litaC_std__http__HttpRequestType type;
    litaC_char* body;
    
};


struct litaC_ast__DoWhileStmt {
    litaC_ast__Stmt stmt;
    litaC_ast__Expr* cond;
    litaC_ast__Stmt* body;
    
};

struct litaC_lsp__document__Document {
    litaC_char filename[_MAX_PATH];
    litaC_std__string_buffer__StringBuffer text;
    litaC_std__array__Array_cb_u32_ce_ lineMap;
    
};

struct litaC_std__zip__ZipFile {
    mz_zip_archive archive;
    litaC_std__zip__ZipOpen type;
    const litaC_std__mem__Allocator* allocator;
    
};

struct litaC_std__map__Map_cb_InternedString_c__ptr_TypeInfo_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(litaC_intern__InternedString);
    litaC_bool (*equalFn)(litaC_intern__InternedString,litaC_intern__InternedString);
    const litaC_std__mem__Allocator* alloc;
    litaC_std__map__Key_cb_InternedString_ce_* keys;
    litaC_types__TypeInfo** values;
    litaC_types__TypeInfo* emptyValue;
    litaC_intern__InternedString emptyKey;
    
};

struct litaC_ast__SwitchStmt {
    litaC_ast__Stmt stmt;
    litaC_ast__Expr* cond;
    litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_ cases;
    litaC_ast__Stmt* defaultStmt;
    
};

struct litaC_ast__InitArgExpr {
    litaC_ast__Expr expr;
    litaC_ast__Identifier fieldName;
    litaC_i32 argPosition;
    litaC_ast__Expr* value;
    
};

struct litaC_checker__LabelInfo {
    litaC_intern__InternedString name;
    litaC_bool defined;
    litaC_ast__Stmt* stmt;
    
};


struct litaC_ast__PoisonDecl {
    litaC_ast__Decl decl;
    
};

struct litaC_ast__UnaryExpr {
    litaC_ast__Expr expr;
    litaC_lex__TokenType operator;
    litaC_ast__Expr* unaryExpr;
    
};




struct litaC_ast__LabelStmt {
    litaC_ast__Stmt stmt;
    litaC_ast__Identifier label;
    
};

struct litaC_ast__CallArg {
    litaC_ast__Expr* argExpr;
    litaC_ast__Identifier argName;
    litaC_i32 index;
    litaC_bool isDefault;
    
};

struct litaC_std__map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_ {
    litaC_i64 key;
    litaC_std__array__Array_cb_i64_ce_ value;
    litaC_std__array__Array_cb_i64_ce_* valuePtr;
    
};

struct litaC_std__cmdline__CmdParser {
    litaC_std__array__Array_cb_Option_ce_ options;
    litaC_std__array__Array_cb__ptr_const_char_ce_ args;
    litaC_char errors[256];
    litaC_std__cmdline__CmdParserStatus status;
    const litaC_char* header;
    
};

struct litaC_ast__GenericDecl {
    litaC_ast__Decl declaration;
    litaC_std__array__Array_cb_GenericParam_ce_ genericParams;
    
};

struct litaC_ast__FuncDecl {
    litaC_ast__GenericDecl decl;
    litaC_ast__ParametersStmt* params;
    litaC_ast__Stmt* body;
    litaC_ast__TypeSpec* returnType;
    litaC_i32 flags;
    
};

struct litaC_ast__StringExpr {
    litaC_ast__Expr expr;
    litaC_lex__Token string;
    
};

struct litaC_phase_result__PhaseError {
    litaC_phase_result__ErrorType type;
    const litaC_char* message;
    litaC_lex__SrcPos pos;
    
};

struct litaC_std__http__HttpResponse {
    litaC_i32 statusCode;
    litaC_std__map__Map_cb__ptr_const_char_c__ptr_const_char_ce_ headers;
    litaC_std__string_buffer__StringBuffer body;
    litaC_void* userdata;
    litaC_usize (*bodyFn)(litaC_void*,litaC_usize,litaC_usize,litaC_void*);
    
};

struct litaC_ast__EmptyStmt {
    litaC_ast__Stmt stmt;
    
};

struct litaC_ast__ArrayDesignationExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* index;
    litaC_ast__Expr* value;
    
};

struct litaC_symbols__ProgramSymbols {
    litaC_module__Module* root;
    litaC_std__array__Array_cb__ptr_Symbol_ce_ values;
    litaC_std__array__Array_cb__ptr_Symbol_ce_ symbolTypes;
    litaC_std__array__Array_cb__ptr_Symbol_ce_ symbolFuncs;
    litaC_symbols__Symbol* mainEntry;
    litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_ interfaceImpls;
    
};


struct litaC_lsp__util__SourceLocation {
    litaC_lsp__util__SourceLocationKind kind;
    litaC_module__Module* module;
    litaC_lsp__protocol__Location location;
    union  {
        litaC_ast__Node* node;
        litaC_ast__TypeSpec* type;
        
    };
    
};


struct litaC_lsp__util__SourceLookup {
    litaC_lsp__lsp__LspServer* lsp;
    litaC_lsp__protocol__Position lookupPos;
    litaC_lsp__util__SourceLocation result;
    
};

struct litaC_std__map__Map_cb__ptr_Symbol_c_Dependency_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(litaC_symbols__Symbol*);
    litaC_bool (*equalFn)(litaC_symbols__Symbol*,litaC_symbols__Symbol*);
    const litaC_std__mem__Allocator* alloc;
    litaC_std__map__Key_cb__ptr_Symbol_ce_* keys;
    litaC_dependency_graph__Dependency* values;
    litaC_dependency_graph__Dependency emptyValue;
    litaC_symbols__Symbol* emptyKey;
    
};


struct litaC_dependency_graph__DependencyGraph {
    litaC_std__array__Array_cb__ptr_Symbol_ce_ sortedPrimitives;
    litaC_std__array__Array_cb__ptr_Symbol_ce_ sortedGlobals;
    litaC_std__array__Array_cb__ptr_Symbol_ce_ sortedAggregates;
    litaC_std__array__Array_cb__ptr_Symbol_ce_ sortedFuncs;
    litaC_std__array__Array_cb__ptr_Symbol_ce_ sortedSymbols;
    litaC_std__map__Map_cb__ptr_Symbol_c_Dependency_ce_ dependencies;
    litaC_lita__Lita* lita;
    
};


struct litaC_std__map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_ {
    litaC_symbols__Symbol* key;
    litaC_dependency_graph__Dependency value;
    litaC_dependency_graph__Dependency* valuePtr;
    
};

struct litaC_ast__VarFieldDecl {
    litaC_ast__Decl decl;
    litaC_ast__TypeSpec* type;
    litaC_ast__Expr* defaultExpr;
    
};

struct litaC_ast__InitExpr {
    litaC_ast__Expr expr;
    litaC_std__array__Array_cb__ptr_TypeSpec_ce_ genericArgs;
    litaC_ast__TypeSpec* type;
    litaC_std__array__Array_cb__ptr_InitArgExpr_ce_ arguments;
    
};

struct litaC_std__map__Key_cb_StringView_ce_ {
    litaC_std__string_view__StringView key;
    litaC_std__map__KeyState state;
    
};

struct litaC_lex__Lexer {
    const litaC_std__mem__Allocator* allocator;
    const litaC_char* filename;
    litaC_lex__Token token;
    const litaC_char* stream;
    litaC_i64 length;
    const litaC_char* lineStart;
    litaC_i32 lineNumber;
    litaC_i32 position;
    const litaC_char* errorMsg;
    
};

struct litaC_ast__BlockStmt {
    litaC_ast__Stmt stmt;
    litaC_std__array__Array_cb__ptr_Stmt_ce_ stmts;
    
};

struct litaC_ast__PoisonExpr {
    litaC_ast__Expr expr;
    
};

struct litaC_std__mem__bucket_allocator__BucketAllocator {
    litaC_std__mem__Allocator allocator;
    const litaC_std__mem__Allocator* decorated;
    litaC_std__mem__bucket_allocator__Bucket* buckets;
    litaC_std__mem__bucket_allocator__Bucket* head;
    litaC_usize bucketSize;
    litaC_usize currentOffset;
    litaC_u32 totalAllocations;
    litaC_usize totalBytesAllocated;
    litaC_usize totalGrossBytesAllocated;
    litaC_u32 totalBuckets;
    
};

struct litaC_preprocessor__CallContext {
    litaC_preprocessor__Preprocessor* pp;
    litaC_checker__TypeChecker* checker;
    litaC_ast__CompStmt* comp;
    litaC_std__string_buffer__StringBuffer buffer;
    litaC_bool resolveSymbols;
    
};

struct litaC_preprocessor__Preprocessor {
    litaC_lita__Lita* lita;
    litaC_preprocessor__api__ScriptRuntime runtime;
    litaC_preprocessor__CallContext callContext;
    litaC_std__array__Array_cb_CheckerContext_ce_ preCheckers;
    litaC_std__array__Array_cb_CheckerContext_ce_ postCheckers;
    litaC_std__array__Array_cb_ScriptDecl_ce_ declQueue;
    
};

struct litaC_phase_result__PhaseResult {
    const litaC_std__mem__Allocator* allocator;
    litaC_std__array__Array_cb_PhaseError_ce_ errors;
    litaC_bool enabled;
    litaC_bool isReadable;
    
};

struct litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(litaC_intern__InternedString);
    litaC_bool (*equalFn)(litaC_intern__InternedString,litaC_intern__InternedString);
    const litaC_std__mem__Allocator* alloc;
    litaC_std__map__Key_cb_InternedString_ce_* keys;
    litaC_symbols__Symbol** values;
    litaC_symbols__Symbol* emptyValue;
    litaC_intern__InternedString emptyKey;
    
};

struct litaC_std__map__Map_cb_ArrayEntry_c__ptr_TypeInfo_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(litaC_types_new__ArrayEntry);
    litaC_bool (*equalFn)(litaC_types_new__ArrayEntry,litaC_types_new__ArrayEntry);
    const litaC_std__mem__Allocator* alloc;
    litaC_std__map__Key_cb_ArrayEntry_ce_* keys;
    litaC_types__TypeInfo** values;
    litaC_types__TypeInfo* emptyValue;
    litaC_types_new__ArrayEntry emptyKey;
    
};

struct litaC_types_new__TypeCache {
    const litaC_std__mem__Allocator* allocator;
    litaC_std__bucket_list__BucketList_cb_TypeInfo_ce_ typeInfos;
    litaC_std__map__Map_cb_i64_c__ptr_TypeInfo_ce_ constCache;
    litaC_std__map__Map_cb_i64_c__ptr_TypeInfo_ce_ ptrCache;
    litaC_std__map__Map_cb_ArrayEntry_c__ptr_TypeInfo_ce_ arrayCache;
    litaC_std__map__Map_cb_InternedString_c__ptr_TypeInfo_ce_ genericCache;
    
};

struct litaC_lita__Lita {
    const litaC_std__mem__Allocator* allocator;
    litaC_std__mem__bucket_allocator__BucketAllocator globalAllocator;
    litaC_std__mem__bucket_allocator__BucketAllocator stringsAllocator;
    litaC_preprocessor__Preprocessor preprocessor;
    litaC_phase_result__PhaseResult result;
    litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_ modules;
    litaC_lita__Metric metrics[litaC_lita__MetricType_MAX_METRIC_TYPES];
    litaC_u32 totalSourceLines;
    litaC_u32 totalAllocations;
    litaC_lita__LitaOptions* options;
    litaC_char binaryFilename[_MAX_PATH];
    litaC_char sourceFilename[_MAX_PATH];
    litaC_build__BuildFile buildFile;
    litaC_std__array__Array_cb_CCompilerOption_ce_ compilerOptions;
    litaC_symbols__ProgramSymbols programSymbols;
    litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_ genericSymbols;
    litaC_types_new__TypeCache typeCache;
    litaC_intern__Strings strings;
    litaC_lsp__references__ReferenceDatabase references;
    litaC_lsp__workspace__Workspace* workspace;
    
};

struct litaC_ast__ModuleStmt {
    litaC_ast__Stmt stmt;
    litaC_std__array__Array_cb__ptr_ImportDecl_ce_ imports;
    litaC_std__array__Array_cb__ptr_NoteStmt_ce_ notes;
    litaC_std__array__Array_cb__ptr_Decl_ce_ declarations;
    
};

struct litaC_ast__FuncCallExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* object;
    litaC_std__array__Array_cb__ptr_TypeSpec_ce_ genericArgs;
    litaC_std__array__Array_cb_CallArg_ce_ arguments;
    
};

struct litaC_std__mem__linear_allocator__LinearAllocator {
    litaC_std__mem__Allocator allocator;
    litaC_void* mem;
    litaC_usize size;
    litaC_usize currentOffset;
    litaC_usize alignment;
    litaC_u32 totalAllocations;
    litaC_usize totalBytesAllocated;
    litaC_std__mem__linear_allocator__ExpandInfo expandInfo;
    
};

struct litaC_ast__AggregateDecl {
    litaC_ast__GenericDecl decl;
    litaC_std__array__Array_cb_FieldStmt_ce_ fields;
    litaC_i32 flags;
    
};

struct litaC_ast__SubscriptGetExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* object;
    litaC_ast__Expr* index;
    
};

struct litaC_pkg_mgr__pkg__PackageDef {
    litaC_pkg_mgr__pkg__PackageId id;
    litaC_char path[_MAX_PATH];
    litaC_pkg_mgr__pkg__PackageType type;
    litaC_std__array__Array_cb__ptr_const_char_ce_ dynamicLibraries;
    litaC_std__array__Array_cb_PackageId_ce_ dependencies;
    litaC_std__json__JsonNode* json;
    
};

struct litaC_ast__EnumFieldEntryDecl {
    litaC_ast__Decl decl;
    litaC_ast__Expr* value;
    
};

struct litaC_ast__ArrayInitExpr {
    litaC_ast__Expr expr;
    litaC_ast__TypeSpec* type;
    litaC_std__array__Array_cb__ptr_Expr_ce_ values;
    
};

struct litaC_symbols__Scope {
    litaC_symbols__ScopeKind kind;
    const litaC_std__mem__Allocator* allocator;
    litaC_phase_result__PhaseResult* result;
    litaC_symbols__Scope* parent;
    litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_ symbolNotes;
    litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_ symbolTypes;
    litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_ symbolFuncs;
    litaC_module__Module* module;
    
};

struct litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_ {
    litaC_i32 length;
    litaC_i32 capacity;
    litaC_u32 (*hashFn)(const litaC_char*);
    litaC_bool (*equalFn)(const litaC_char*,const litaC_char*);
    const litaC_std__mem__Allocator* alloc;
    litaC_std__map__Key_cb__ptr_const_char_ce_* keys;
    litaC_module__ModuleImport* values;
    litaC_module__ModuleImport emptyValue;
    const litaC_char* emptyKey;
    
};

struct litaC_ast_new__TypeSpecAllocator {
    const litaC_std__mem__Allocator* allocator;
    litaC_std__bucket_list__BucketList_cb_TypeSpec_ce_ typeSpecs;
    
};

struct litaC_ast__TraitFieldDecl {
    litaC_ast__Decl decl;
    litaC_ast__TypeSpec* type;
    
};

struct litaC_ast__NullExpr {
    litaC_ast__Expr expr;
    
};

struct litaC_lsp__workspace__Workspace {
    const litaC_std__mem__Allocator* allocator;
    litaC_lsp__lsp__LspServer* lsp;
    const litaC_char* rootPath;
    litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_ openedDocuments;
    
};

struct litaC_ast__BreakStmt {
    litaC_ast__Stmt stmt;
    
};

struct litaC_lsp__references__Reference {
    litaC_i64 type;
    litaC_lex__SrcPos pos;
    
};

struct litaC_std__map__MapEntry_cb__ptr_const_char_c_ModuleImport_ce_ {
    const litaC_char* key;
    litaC_module__ModuleImport value;
    litaC_module__ModuleImport* valuePtr;
    
};

struct litaC_ast__NoteStmt {
    litaC_ast__Stmt stmt;
    litaC_ast__TypeSpec* type;
    litaC_std__array__Array_cb_CallArg_ce_ arguments;
    
};

struct litaC_module__ModuleId {
    litaC_char filename[_MAX_PATH];
    litaC_char filenameKey[_MAX_PATH];
    litaC_intern__InternedString packageName;
    litaC_intern__InternedString name;
    
};

struct litaC_std__map__Key_cb_InternedString_ce_ {
    litaC_intern__InternedString key;
    litaC_std__map__KeyState state;
    
};

struct litaC_ast__EnumDecl {
    litaC_ast__Decl decl;
    litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_ fields;
    
};

struct litaC_ast__SubscriptSetExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* object;
    litaC_ast__Expr* index;
    litaC_lex__TokenType operator;
    litaC_ast__Expr* value;
    
};

struct litaC_ast__ForStmt {
    litaC_ast__Stmt stmt;
    litaC_ast__Stmt* init;
    litaC_ast__Expr* cond;
    litaC_ast__Stmt* post;
    litaC_ast__Stmt* body;
    
};

struct litaC_ast__BinaryExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* left;
    litaC_lex__TokenType operator;
    litaC_ast__Expr* right;
    
};

struct litaC_symbols__Symbol {
    litaC_symbols__SymbolKind kind;
    litaC_intern__InternedString name;
    litaC_symbols__SymbolState state;
    litaC_ast__Decl* decl;
    litaC_types__TypeInfo* type;
    litaC_symbols__Symbol* usingParent;
    litaC_module__Module* declared;
    litaC_module__Module* usingModule;
    litaC_i32 flags;
    litaC_lex__Value val;
    litaC_module__Module* genericCallsiteModule;
    litaC_std__array__Array_cb__ptr_TypeInfo_ce_ genericArgs;
    litaC_std__array__Array_cb_GenericParam_ce_ genericParams;
    
};

struct litaC_std__json__JsonObject {
    litaC_std__map__Map_cb__ptr_const_char_c_i32_ce_ indexes;
    litaC_std__array__Array_cb_JsonEntry_ce_ values;
    
};

struct litaC_parser__Parser {
    const litaC_std__mem__Allocator* allocator;
    litaC_ast_new__TypeSpecAllocator* typeAllocator;
    litaC_module__Module* module;
    litaC_phase_result__PhaseResult* result;
    litaC_lita__Lita* lita;
    litaC_intern__Strings* strings;
    const litaC_char* filename;
    litaC_i32 totalLines;
    litaC_std__array__Array_cb_Token_ce_ tokens;
    litaC_i32 current;
    litaC_lex__SrcPos currentPos;
    litaC_i32 breakLevel;
    litaC_i32 loopLevel;
    litaC_i32 switchLevel;
    litaC_i32 funcLevel;
    litaC_i32 aggregateLevel;
    litaC_u32 tryLevel;
    litaC_u64 tryErrorCounter;
    litaC_bool panicMode;
    litaC_i32 preprocessorLevel;
    
};

struct litaC_ast__FieldStmt {
    litaC_ast__StmtKind kind;
    litaC_types__TypeInfo* typeInfo;
    union  {
        litaC_ast__EnumDecl* enumField;
        litaC_ast__AggregateDecl* aggregateField;
        litaC_ast__VarFieldDecl* varField;
        litaC_ast__TraitFieldDecl* traitField;
        litaC_ast__Expr* poisonField;
        
    };
    
};

struct litaC_ast__NumberExpr {
    litaC_ast__Expr expr;
    litaC_lex__Token number;
    
};

struct litaC_checker__TypeChecker {
    litaC_lita__Lita* lita;
    litaC_module__Module* current;
    litaC_std__array__Array_cb__ptr_Module_ce_ moduleStack;
    litaC_std__array__Array_cb__ptr_TypeInfo_ce_ funcDeclStack;
    litaC_std__array__Array_cb__ptr_Symbol_ce_ pendingValues;
    litaC_std__array__Array_cb__ptr_Symbol_ce_ symbolTypes;
    litaC_std__array__Array_cb__ptr_Symbol_ce_ symbolFuncs;
    litaC_std__array__Array_cb__ptr_Symbol_ce_ symbolTraits;
    litaC_symbols__Symbol* mainEntry;
    litaC_std__array__Array_cb__ptr_Symbol_ce_ symbolNotes;
    litaC_checker__GenericContext genericContext;
    litaC_std__array__Array_cb_Array_cb_GenericParam_ce__ce_ genericParamStack;
    litaC_std__array__Array_cb__ptr_Symbol_ce_ genericTemplates;
    litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_ interfaceImpls;
    litaC_checker__LabelInfo labels[256];
    litaC_i32 numOfLabels;
    litaC_types_new__TypeCache* typeCache;
    litaC_u32 randomNameIndex;
    litaC_bool bypassing;
    
};

struct litaC_ast__CompStmt {
    litaC_ast__Stmt stmt;
    litaC_intern__InternedString type;
    litaC_std__string_view__StringView expr;
    litaC_ast__CompStmt* end;
    litaC_ast__Stmt* evaluatedStmt;
    litaC_std__array__Array_cb__ptr_Stmt_ce_ body;
    litaC_bool isScriptLoad;
    litaC_bool isStatic;
    
};

struct litaC_lsp__references__FieldReference {
    litaC_i64 parent;
    litaC_i32 offset;
    litaC_lex__SrcPos pos;
    
};

struct litaC_ast__ParametersStmt {
    litaC_ast__Stmt stmt;
    litaC_std__array__Array_cb__ptr_ParameterDecl_ce_ params;
    litaC_bool isVararg;
    
};

struct litaC_ast__GetExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* object;
    litaC_ast__IdentifierExpr* field;
    litaC_i32 flags;
    
};

struct litaC_ast__TypedefDecl {
    litaC_ast__GenericDecl decl;
    litaC_ast__TypeSpec* type;
    
};

struct litaC_ast__TernaryExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* cond;
    litaC_ast__Expr* then;
    litaC_ast__Expr* other;
    
};

struct litaC_cgen__CGen {
    litaC_lita__Lita* lita;
    litaC_std__string_buffer__StringBuffer buf;
    litaC_std__string_buffer__StringBuffer line;
    litaC_bool format;
    litaC_i32 indent;
    litaC_i32 aggregateLevel;
    litaC_i32 currentLine;
    const litaC_char* currentFile;
    litaC_bool bufferFlush;
    litaC_i32 funcIndex;
    litaC_i32 tmpVar;
    litaC_i32 deferStack;
    litaC_bool inTextBlock;
    litaC_types__TypeInfo* currentFunc;
    litaC_cgen__CGenScope* currentScope;
    litaC_std__io__File* output;
    
};

struct litaC_types__FieldPath {
    litaC_ast__FieldStmt fields[256];
    litaC_i32 numOfFields;
    
};

struct litaC_ast__FuncBodyStmt {
    litaC_ast__Stmt stmt;
    litaC_std__array__Array_cb__ptr_Stmt_ce_ stmts;
    
};

struct litaC_ast__BooleanExpr {
    litaC_ast__Expr expr;
    litaC_bool boolean;
    
};

struct litaC_std__json__JsonParser {
    const litaC_std__mem__Allocator* alloc;
    litaC_std__json__JsonParserStatus status;
    litaC_char errorMsg[256];
    litaC_std__json__Token token;
    litaC_std__string_buffer__StringBuffer buffer;
    const litaC_char* stream;
    const litaC_char* lineStart;
    
};

struct litaC_ast__ImportDecl {
    litaC_ast__Decl decl;
    litaC_ast__Identifier alias;
    litaC_bool isUsing;
    litaC_module__ModuleId* moduleId;
    
};

struct litaC_ast__OffsetOfExpr {
    litaC_ast__Expr expr;
    litaC_ast__TypeSpec* type;
    litaC_ast__Identifier field;
    
};

struct litaC_ast__ContinueStmt {
    litaC_ast__Stmt stmt;
    
};

struct litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_ {
    litaC_intern__InternedString key;
    litaC_symbols__Symbol* value;
    litaC_symbols__Symbol** valuePtr;
    
};

struct litaC_std__map__Key_cb_ArrayEntry_ce_ {
    litaC_types_new__ArrayEntry key;
    litaC_std__map__KeyState state;
    
};

struct litaC_types__MethodResult {
    litaC_symbols__Symbol* symbol;
    litaC_intern__InternedString name;
    
};

struct litaC_ast__ReturnStmt {
    litaC_ast__Stmt stmt;
    litaC_ast__Expr* expr;
    
};

struct litaC_ast__GroupExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* groupedExpr;
    
};

struct litaC_module__Module {
    litaC_module__ModuleId id;
    litaC_std__string__String text;
    litaC_ast__ModuleStmt* ast;
    litaC_symbols__Scope symbols;
    litaC_symbols__Scope* currentScope;
    litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* genericSymbols;
    litaC_i32 flags;
    litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_ importedBy;
    litaC_ast_new__TypeSpecAllocator typeSpecAllocator;
    litaC_std__mem__arena_allocator__ArenaAllocator arena;
    const litaC_std__mem__Allocator* allocator;
    litaC_lita__Lita* lita;
    
};

struct litaC_ast__NativeDecl {
    litaC_ast__Decl decl;
    litaC_types__TypeInfo* typeInfo;
    
};

struct litaC_ast__TypeIdentifierExpr {
    litaC_ast__Expr expr;
    litaC_ast__TypeSpec* type;
    litaC_symbols__Symbol* sym;
    litaC_bool isBased;
    
};

struct litaC_ast__GotoStmt {
    litaC_ast__Stmt stmt;
    litaC_ast__Identifier label;
    
};

struct litaC_ast__CastExpr {
    litaC_ast__Expr expr;
    litaC_ast__TypeSpec* castTo;
    litaC_ast__Expr* exprToCast;
    
};

struct litaC_ast__VarDecl {
    litaC_ast__Decl decl;
    litaC_ast__TypeSpec* typeSpec;
    litaC_ast__Expr* expr;
    
};

struct litaC_ast__SetExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* object;
    litaC_ast__IdentifierExpr* field;
    litaC_lex__TokenType operator;
    litaC_ast__Expr* value;
    litaC_i32 flags;
    
};

struct litaC_lsp__lsp__LspServer {
    litaC_std__mem__linear_allocator__LinearAllocator requestAllocator;
    litaC_std__mem__linear_allocator__LinearAllocator applicationAllocator;
    litaC_lita__Lita* lita;
    litaC_std__string_buffer__StringBuffer message;
    litaC_std__string_buffer__StringBuffer output;
    litaC_std__string_buffer__StringBuffer outbound;
    litaC_bool isInitialized;
    litaC_bool isRunning;
    litaC_lsp__workspace__Workspace workspace;
    FILE* logFile;
    
};

struct litaC_ast__DeferStmt {
    litaC_ast__Stmt stmt;
    litaC_ast__Stmt* deferedStmt;
    
};

struct litaC_ast__WhileStmt {
    litaC_ast__Stmt stmt;
    litaC_ast__Expr* cond;
    litaC_ast__Stmt* body;
    
};

struct litaC_types__TypeInfo {
    litaC_types__TypeKind kind;
    litaC_i64 typeid;
    litaC_intern__InternedString name;
    litaC_symbols__Symbol* sym;
    litaC_i64 genericTypeid;
    litaC_types__TypeInfo* returnType;
    union  {
        struct  {
            litaC_ast__FuncDecl* funcDecl;
            
        };
        struct  {
            litaC_types__TypeInfo* constOf;
            
        };
        struct  {
            litaC_types__TypeInfo* ptrOf;
            
        };
        struct  {
            litaC_types__TypeInfo* arrayOf;
            litaC_usize length;
            litaC_ast__Expr* numOfElements;
            litaC_bool isLengthDefined;
            
        };
        struct  {
            litaC_std__array__Array_cb_GenericParam_ce_ genericParams;
            litaC_std__array__Array_cb__ptr_TypeInfo_ce_ paramDecls;
            litaC_bool hasVarargs;
            litaC_bool isTrait;
            
        };
        struct  {
            litaC_ast__EnumDecl* enumDecl;
            
        };
        struct  {
            litaC_ast__AggregateDecl* aggDecl;
            
        };
        
    };
    
};

struct litaC_ast__SwitchCaseStmt {
    litaC_ast__Stmt stmt;
    litaC_ast__Expr* cond;
    litaC_ast__Stmt* body;
    
};

struct litaC_ast__IdentifierExpr {
    litaC_ast__Expr expr;
    litaC_ast__TypeSpec* type;
    litaC_symbols__Symbol* sym;
    
};

struct litaC_ast__TypeSpec {
    litaC_ast__TypeSpecKind kind;
    litaC_lex__SrcPos pos;
    litaC_ast__TypeSpec* base;
    litaC_types__TypeInfo* typeInfo;
    union  {
        struct  {
            litaC_intern__InternedString name;
            litaC_std__array__Array_cb__ptr_TypeSpec_ce_ genericArgs;
            
        };
        struct  {
            litaC_ast__Expr* numElements;
            
        };
        struct  {
            litaC_std__array__Array_cb__ptr_TypeSpec_ce_ args;
            litaC_ast__TypeSpec* ret;
            litaC_bool hasVarargs;
            litaC_std__array__Array_cb_GenericParam_ce_ genericParams;
            
        };
        
    };
    
};

struct litaC_ast__NotesDecl {
    litaC_ast__Decl decl;
    litaC_std__array__Array_cb__ptr_NoteStmt_ce_ notes;
    
};

struct litaC_ast__TypeOfExpr {
    litaC_ast__Expr expr;
    litaC_ast__Expr* typeOfExpr;
    litaC_ast__TypeSpec* type;
    
};

struct litaC_ast__IfStmt {
    litaC_ast__Stmt stmt;
    litaC_ast__Expr* cond;
    litaC_ast__Stmt* then;
    litaC_ast__Stmt* elseStmt;
    
};

struct litaC_ast__CharExpr {
    litaC_ast__Expr expr;
    litaC_lex__Token character;
    
};

LITAC_THREADLOCAL 
const litaC_std__mem__Allocator* litaC_std__mem__defaultAllocator = (const litaC_std__mem__Allocator*)(&((litaC_std__mem__Allocator) {
    .allocFn = &(litaC_std__mem__libc_allocator__cMalloc),
    .callocFn = &(litaC_std__mem__libc_allocator__cCalloc),
    .reallocFn = &(litaC_std__mem__libc_allocator__cRealloc),
    .freeFn = &(litaC_std__mem__libc_allocator__cFree)
}));
const litaC_std__mem__Allocator* litaC_std__mem__libc_allocator__cAllocator = (const litaC_std__mem__Allocator*)(&((litaC_std__mem__Allocator) {
    .allocFn = &(litaC_std__mem__libc_allocator__cMalloc),
    .callocFn = &(litaC_std__mem__libc_allocator__cCalloc),
    .reallocFn = &(litaC_std__mem__libc_allocator__cRealloc),
    .freeFn = &(litaC_std__mem__libc_allocator__cFree)
}));
litaC_std__mem__linear_allocator__ExpandInfo litaC_std__mem__linear_allocator__DEFAULT_EXPAND_INFO =  {
    .allocator = NULL,
    .strategy = litaC_std__mem__linear_allocator__ExpandStrategy_NO_ALLOC_MEMORY
};
litaC_bool litaC_std__ascii__WHITESPACE[256] =  {
    [9] = litaC_true,
    [10] = litaC_true,
    [11] = litaC_true,
    [12] = litaC_true,
    [13] = litaC_true,
    [32] = litaC_true
};

#define litaC_std__system__OPEN_MODE ("rt")

#define litaC_std__system__PATH_SEPARATOR ("\\")
const litaC_char* litaC_std__system__uriEscapeChars[256] =  {
    [' '] = "%20",
    ['!'] = "%21",
    ['#'] = "%23",
    ['$'] = "%24",
    ['%'] = "%25",
    ['&'] = "%26",
    ['\''] = "%27",
    ['('] = "%28",
    [')'] = "%29",
    ['*'] = "%2A",
    ['+'] = "%2B",
    [','] = "%2C",
    [':'] = "%3A",
    [';'] = "%3B",
    ['='] = "%3D",
    ['?'] = "%3F",
    ['@'] = "%40",
    ['['] = "%5B",
    [']'] = "%5D"
};
litaC_f64 litaC_std__system__system_win__systemFreq = {0};
litaC_u64 litaC_std__system__system_win__systemStart = 0;
litaC_char litaC_std__system__system_win__pwd[_MAX_PATH] =  {
    0
};

litaC_std__profile__ProfileEntry litaC_std__profile__profileEntries[1] =  {
    
};
const litaC_char* litaC_lex__tokenText[litaC_lex__TokenType_MAX_TOKEN_TYPES] =  {
    [litaC_lex__TokenType_IMPORT] = "import",
    [litaC_lex__TokenType_STRUCT] = "struct",
    [litaC_lex__TokenType_UNION] = "union",
    [litaC_lex__TokenType_TRAIT] = "trait",
    [litaC_lex__TokenType_ENUM] = "enum",
    [litaC_lex__TokenType_FUNC] = "func",
    [litaC_lex__TokenType_TYPEDEF] = "typedef",
    [litaC_lex__TokenType_NOTE] = "@note",
    [litaC_lex__TokenType_VAR] = "var",
    [litaC_lex__TokenType_CONST] = "const",
    [litaC_lex__TokenType_NULL] = "null",
    [litaC_lex__TokenType_VOID] = "void",
    [litaC_lex__TokenType_TRUE] = "true",
    [litaC_lex__TokenType_FALSE] = "false",
    [litaC_lex__TokenType_BOOL] = "bool",
    [litaC_lex__TokenType_CHAR] = "char",
    [litaC_lex__TokenType_I8] = "i8",
    [litaC_lex__TokenType_U8] = "u8",
    [litaC_lex__TokenType_I16] = "i16",
    [litaC_lex__TokenType_U16] = "u16",
    [litaC_lex__TokenType_I32] = "i32",
    [litaC_lex__TokenType_U32] = "u32",
    [litaC_lex__TokenType_I64] = "i64",
    [litaC_lex__TokenType_U64] = "u64",
    [litaC_lex__TokenType_F32] = "f32",
    [litaC_lex__TokenType_F64] = "f64",
    [litaC_lex__TokenType_USIZE] = "usize",
    [litaC_lex__TokenType_FOR] = "for",
    [litaC_lex__TokenType_WHILE] = "while",
    [litaC_lex__TokenType_DO] = "do",
    [litaC_lex__TokenType_IF] = "if",
    [litaC_lex__TokenType_ELSE] = "else",
    [litaC_lex__TokenType_SWITCH] = "switch",
    [litaC_lex__TokenType_CASE] = "case",
    [litaC_lex__TokenType_DEFAULT] = "default",
    [litaC_lex__TokenType_DEFER] = "defer",
    [litaC_lex__TokenType_BREAK] = "break",
    [litaC_lex__TokenType_CONTINUE] = "continue",
    [litaC_lex__TokenType_RETURN] = "return",
    [litaC_lex__TokenType_GOTO] = "goto",
    [litaC_lex__TokenType_SIZEOF] = "sizeof",
    [litaC_lex__TokenType_TYPEOF] = "typeof",
    [litaC_lex__TokenType_OFFSETOF] = "offsetof",
    [litaC_lex__TokenType_AS] = "as",
    [litaC_lex__TokenType_PUBLIC] = "public",
    [litaC_lex__TokenType_INTERNAL] = "internal",
    [litaC_lex__TokenType_USING] = "using",
    [litaC_lex__TokenType_PLUS] = "+",
    [litaC_lex__TokenType_MINUS] = "-",
    [litaC_lex__TokenType_STAR] = "*",
    [litaC_lex__TokenType_MOD] = "%",
    [litaC_lex__TokenType_SLASH] = "/",
    [litaC_lex__TokenType_BACK_SLASH] = "\\",
    [litaC_lex__TokenType_DOLLAR] = "$",
    [litaC_lex__TokenType_HASH] = "#",
    [litaC_lex__TokenType_DOT] = ".",
    [litaC_lex__TokenType_VAR_ARGS] = "...",
    [litaC_lex__TokenType_AT] = "@",
    [litaC_lex__TokenType_QUESTION_MARK] = "?",
    [litaC_lex__TokenType_COMMA] = ",",
    [litaC_lex__TokenType_SEMICOLON] = ";",
    [litaC_lex__TokenType_COLON] = ":",
    [litaC_lex__TokenType_COLON_COLON] = "::",
    [litaC_lex__TokenType_DOUBLE_QUOTE] = "\"",
    [litaC_lex__TokenType_LESS_THAN] = "<",
    [litaC_lex__TokenType_LESS_EQUALS] = "<=",
    [litaC_lex__TokenType_GREATER_THAN] = ">",
    [litaC_lex__TokenType_GREATER_EQUALS] = ">=",
    [litaC_lex__TokenType_EQUALS_EQUALS] = "==",
    [litaC_lex__TokenType_EQUALS] = "=",
    [litaC_lex__TokenType_NOT_EQUALS] = "!=",
    [litaC_lex__TokenType_PLUS_EQ] = "+=",
    [litaC_lex__TokenType_MINUS_EQ] = "-=",
    [litaC_lex__TokenType_DIV_EQ] = "/=",
    [litaC_lex__TokenType_MUL_EQ] = "*=",
    [litaC_lex__TokenType_MOD_EQ] = "%=",
    [litaC_lex__TokenType_LSHIFT_EQ] = "<<=",
    [litaC_lex__TokenType_RSHIFT_EQ] = ">>=",
    [litaC_lex__TokenType_BNOT_EQ] = "~=",
    [litaC_lex__TokenType_XOR_EQ] = "^=",
    [litaC_lex__TokenType_BAND_EQ] = "&=",
    [litaC_lex__TokenType_BOR_EQ] = "|=",
    [litaC_lex__TokenType_LSHIFT] = "<<",
    [litaC_lex__TokenType_RSHIFT] = ">>",
    [litaC_lex__TokenType_BNOT] = "~",
    [litaC_lex__TokenType_XOR] = "^",
    [litaC_lex__TokenType_BAND] = "&",
    [litaC_lex__TokenType_BOR] = "|",
    [litaC_lex__TokenType_LEFT_PAREN] = "(",
    [litaC_lex__TokenType_RIGHT_PAREN] = ")",
    [litaC_lex__TokenType_LEFT_BRACKET] = "[",
    [litaC_lex__TokenType_RIGHT_BRACKET] = "]",
    [litaC_lex__TokenType_LEFT_BRACE] = "{",
    [litaC_lex__TokenType_RIGHT_BRACE] = "}",
    [litaC_lex__TokenType_NOT] = "!",
    [litaC_lex__TokenType_OR] = "||",
    [litaC_lex__TokenType_AND] = "&&",
    [litaC_lex__TokenType_STRING] = "STRING",
    [litaC_lex__TokenType_IDENTIFIER] = "IDENTIFER",
    [litaC_lex__TokenType_INT_NUMBER] = "INT_NUMBER",
    [litaC_lex__TokenType_FLOAT_NUMBER] = "FLOAT_NUMBER",
    [litaC_lex__TokenType_ERROR] = "ERROR",
    [litaC_lex__TokenType_END_OF_FILE] = "EOF"
};
litaC_i32 litaC_lex__charToDigit[256] =  {
    ['0'] = 0,
    ['1'] = 1,
    ['2'] = 2,
    ['3'] = 3,
    ['4'] = 4,
    ['5'] = 5,
    ['6'] = 6,
    ['7'] = 7,
    ['8'] = 8,
    ['9'] = 9,
    ['a'] = 10,
    ['A'] = 10,
    ['b'] = 11,
    ['B'] = 11,
    ['c'] = 12,
    ['C'] = 12,
    ['d'] = 13,
    ['D'] = 13,
    ['e'] = 14,
    ['E'] = 14,
    ['f'] = 15,
    ['F'] = 15
};
litaC_char litaC_lex__escapeToChar[256] =  {
    ['b'] = '\b',
    ['f'] = '\f',
    ['n'] = '\n',
    ['r'] = '\r',
    ['t'] = '\t',
    ['\\'] = '\\',
    ['\''] = '\'',
    ['"'] = '"',
    ['0'] = '\0',
    ['/'] = '/'
};
const litaC_char** litaC_lex__keywordCache[9] =  {
    [0] = (const litaC_char*[1]) {
        NULL
    },
    [1] = (const litaC_char*[1]) {
        NULL
    },
    [2] = (const litaC_char*[6]) {
        "i8",
        "u8",
        "do",
        "if",
        "as",
        NULL
    },
    [3] = (const litaC_char*[11]) {
        "var",
        "i16",
        "u16",
        "i32",
        "u32",
        "i64",
        "u64",
        "f32",
        "f64",
        "for",
        NULL
    },
    [4] = (const litaC_char*[11]) {
        "enum",
        "func",
        "null",
        "void",
        "true",
        "bool",
        "char",
        "else",
        "case",
        "goto",
        NULL
    },
    [5] = (const litaC_char*[11]) {
        "trait",
        "union",
        "const",
        "false",
        "usize",
        "defer",
        "while",
        "break",
        "using",
        "@note",
        NULL
    },
    [6] = (const litaC_char*[8]) {
        "import",
        "struct",
        "switch",
        "return",
        "sizeof",
        "typeof",
        "public",
        NULL
    },
    [7] = (const litaC_char*[3]) {
        "typedef",
        "default",
        NULL
    },
    [8] = (const litaC_char*[4]) {
        "continue",
        "offsetof",
        "internal",
        NULL
    }
};
litaC_lex__TokenType* litaC_lex__keywordCacheIndex[9] =  {
    [2] = (litaC_lex__TokenType[5]) {
        litaC_lex__TokenType_I8,
        litaC_lex__TokenType_U8,
        litaC_lex__TokenType_DO,
        litaC_lex__TokenType_IF,
        litaC_lex__TokenType_AS
    },
    [3] = (litaC_lex__TokenType[10]) {
        litaC_lex__TokenType_VAR,
        litaC_lex__TokenType_I16,
        litaC_lex__TokenType_U16,
        litaC_lex__TokenType_I32,
        litaC_lex__TokenType_U32,
        litaC_lex__TokenType_I64,
        litaC_lex__TokenType_U64,
        litaC_lex__TokenType_F32,
        litaC_lex__TokenType_F64,
        litaC_lex__TokenType_FOR
    },
    [4] = (litaC_lex__TokenType[10]) {
        litaC_lex__TokenType_ENUM,
        litaC_lex__TokenType_FUNC,
        litaC_lex__TokenType_NULL,
        litaC_lex__TokenType_VOID,
        litaC_lex__TokenType_TRUE,
        litaC_lex__TokenType_BOOL,
        litaC_lex__TokenType_CHAR,
        litaC_lex__TokenType_ELSE,
        litaC_lex__TokenType_CASE,
        litaC_lex__TokenType_GOTO
    },
    [5] = (litaC_lex__TokenType[10]) {
        litaC_lex__TokenType_TRAIT,
        litaC_lex__TokenType_UNION,
        litaC_lex__TokenType_CONST,
        litaC_lex__TokenType_FALSE,
        litaC_lex__TokenType_USIZE,
        litaC_lex__TokenType_DEFER,
        litaC_lex__TokenType_WHILE,
        litaC_lex__TokenType_BREAK,
        litaC_lex__TokenType_USING,
        litaC_lex__TokenType_NOTE
    },
    [6] = (litaC_lex__TokenType[7]) {
        litaC_lex__TokenType_IMPORT,
        litaC_lex__TokenType_STRUCT,
        litaC_lex__TokenType_SWITCH,
        litaC_lex__TokenType_RETURN,
        litaC_lex__TokenType_SIZEOF,
        litaC_lex__TokenType_TYPEOF,
        litaC_lex__TokenType_PUBLIC
    },
    [7] = (litaC_lex__TokenType[2]) {
        litaC_lex__TokenType_TYPEDEF,
        litaC_lex__TokenType_DEFAULT
    },
    [8] = (litaC_lex__TokenType[3]) {
        litaC_lex__TokenType_CONTINUE,
        litaC_lex__TokenType_OFFSETOF,
        litaC_lex__TokenType_INTERNAL
    }
};

#define litaC_lex__commentEnd ("*/1234567890123456")
litaC_bool litaC_lex__VALID_TYPE_INFO_CHAR[256] =  {
    ['0'] = litaC_true,
    ['1'] = litaC_true,
    ['2'] = litaC_true,
    ['3'] = litaC_true,
    ['4'] = litaC_true,
    ['5'] = litaC_true,
    ['6'] = litaC_true,
    ['7'] = litaC_true,
    ['8'] = litaC_true,
    ['9'] = litaC_true,
    ['u'] = litaC_true,
    ['s'] = litaC_true,
    ['i'] = litaC_true,
    ['z'] = litaC_true,
    ['e'] = litaC_true
};
const litaC_char* litaC_types__typeKindText[litaC_types__TypeKind_MAX_TYPE_KINDS + 1] =  {
    [litaC_types__TypeKind_BOOL] = "bool",
    [litaC_types__TypeKind_CHAR] = "char",
    [litaC_types__TypeKind_I8] = "i8",
    [litaC_types__TypeKind_U8] = "u8",
    [litaC_types__TypeKind_I16] = "i16",
    [litaC_types__TypeKind_U16] = "u16",
    [litaC_types__TypeKind_I32] = "i32",
    [litaC_types__TypeKind_U32] = "u32",
    [litaC_types__TypeKind_I64] = "i64",
    [litaC_types__TypeKind_U64] = "u64",
    [litaC_types__TypeKind_F32] = "f32",
    [litaC_types__TypeKind_F64] = "f64",
    [litaC_types__TypeKind_USIZE] = "usize",
    [litaC_types__TypeKind_NULL] = "null",
    [litaC_types__TypeKind_VOID] = "void",
    [litaC_types__TypeKind_STR] = "string",
    [litaC_types__TypeKind_ARRAY] = "array",
    [litaC_types__TypeKind_PTR] = "pointer",
    [litaC_types__TypeKind_FUNC_PTR] = "func_pointer",
    [litaC_types__TypeKind_STRUCT] = "struct",
    [litaC_types__TypeKind_UNION] = "union",
    [litaC_types__TypeKind_TRAIT] = "trait",
    [litaC_types__TypeKind_ENUM] = "enum",
    [litaC_types__TypeKind_FUNC] = "func",
    [litaC_types__TypeKind_CONST] = "const",
    [litaC_types__TypeKind_GENERIC_PARAM] = "generic_param",
    [litaC_types__TypeKind_POISON] = "poison",
    [litaC_types__TypeKind_MAX_TYPE_KINDS] = ""
};
litaC_i64 litaC_types__idGen = (litaC_i64)litaC_types__TypeKind_MAX_TYPE_KINDS;
litaC_types__TypeInfo litaC_types__BOOL_TYPE =  {
    .kind = litaC_types__TypeKind_BOOL,
    .typeid = (litaC_i64)litaC_types__TypeKind_BOOL,
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__CHAR_TYPE =  {
    .kind = litaC_types__TypeKind_CHAR,
    .typeid = (litaC_i64)litaC_types__TypeKind_CHAR,
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__I8_TYPE =  {
    .kind = litaC_types__TypeKind_I8,
    .typeid = (litaC_i64)litaC_types__TypeKind_I8,
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__U8_TYPE =  {
    .kind = litaC_types__TypeKind_U8,
    .typeid = (litaC_i64)litaC_types__TypeKind_U8,
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__I16_TYPE =  {
    .kind = litaC_types__TypeKind_I16,
    .typeid = (litaC_i64)litaC_types__TypeKind_I16,
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__U16_TYPE =  {
    .kind = litaC_types__TypeKind_U16,
    .typeid = (litaC_i64)litaC_types__TypeKind_U16,
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__I32_TYPE =  {
    .kind = litaC_types__TypeKind_I32,
    .typeid = (litaC_i64)litaC_types__TypeKind_I32,
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__U32_TYPE =  {
    .kind = litaC_types__TypeKind_U32,
    .typeid = (litaC_i64)litaC_types__TypeKind_U32,
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__I64_TYPE =  {
    .kind = litaC_types__TypeKind_I64,
    .typeid = (litaC_i64)litaC_types__TypeKind_I64,
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__U64_TYPE =  {
    .kind = litaC_types__TypeKind_U64,
    .typeid = (litaC_i64)litaC_types__TypeKind_U64,
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__F32_TYPE =  {
    .kind = litaC_types__TypeKind_F32,
    .typeid = (litaC_i64)litaC_types__TypeKind_F32,
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__F64_TYPE =  {
    .kind = litaC_types__TypeKind_F64,
    .typeid = (litaC_i64)litaC_types__TypeKind_F64,
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__USIZE_TYPE =  {
    .kind = litaC_types__TypeKind_USIZE,
    .typeid = (litaC_i64)litaC_types__TypeKind_USIZE,
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__NULL_TYPE =  {
    .kind = litaC_types__TypeKind_NULL,
    .typeid = (litaC_i64)litaC_types__TypeKind_NULL,
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__VOID_TYPE =  {
    .kind = litaC_types__TypeKind_VOID,
    .typeid = (litaC_i64)litaC_types__TypeKind_VOID,
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__STR_TYPE =  {
    .kind = litaC_types__TypeKind_STR,
    .typeid = (litaC_i64)litaC_types__TypeKind_STR,
    .sym = NULL
};
litaC_types__TypeInfo litaC_types__POISON_TYPE =  {
    .kind = litaC_types__TypeKind_POISON,
    .typeid = (litaC_i64)litaC_types__TypeKind_POISON,
    .sym = NULL
};
litaC_types__TypeInfo* litaC_types__BUILTIN_TYPES[litaC_types__TypeKind_MAX_TYPE_KINDS] =  {
    [litaC_types__TypeKind_BOOL] = &(litaC_types__BOOL_TYPE),
    [litaC_types__TypeKind_CHAR] = &(litaC_types__CHAR_TYPE),
    [litaC_types__TypeKind_I8] = &(litaC_types__I8_TYPE),
    [litaC_types__TypeKind_U8] = &(litaC_types__U8_TYPE),
    [litaC_types__TypeKind_I16] = &(litaC_types__I16_TYPE),
    [litaC_types__TypeKind_U16] = &(litaC_types__U16_TYPE),
    [litaC_types__TypeKind_I32] = &(litaC_types__I32_TYPE),
    [litaC_types__TypeKind_U32] = &(litaC_types__U32_TYPE),
    [litaC_types__TypeKind_I64] = &(litaC_types__I64_TYPE),
    [litaC_types__TypeKind_U64] = &(litaC_types__U64_TYPE),
    [litaC_types__TypeKind_F32] = &(litaC_types__F32_TYPE),
    [litaC_types__TypeKind_F64] = &(litaC_types__F64_TYPE),
    [litaC_types__TypeKind_USIZE] = &(litaC_types__USIZE_TYPE),
    [litaC_types__TypeKind_NULL] = &(litaC_types__NULL_TYPE),
    [litaC_types__TypeKind_VOID] = &(litaC_types__VOID_TYPE),
    [litaC_types__TypeKind_STR] = &(litaC_types__STR_TYPE),
    [litaC_types__TypeKind_POISON] = &(litaC_types__POISON_TYPE)
};
litaC_ast__Identifier litaC_module__BUILTIN_IMPORT_IDENT =  {
    
};
litaC_lex__Token litaC_module__BUILTIN_IMPORT_TOKEN =  {
    .type = litaC_lex__TokenType_STRING,
    .value =  {
        .str =  {
            .buffer = "builtin",
            .length = 7
        }
    }
};
litaC_module__Module litaC_module__builtins =  {
    
};
FILE* litaC_common__outputFile = NULL;

#define litaC_lita__LITA_VERSION ("0.1.6-alpha")

#define litaC_lita__DEFAULT_BUILD_CMD ("clang -std=c99 %input% -o %output%  -D_CRT_SECURE_NO_WARNINGS")
litaC_intern__InternedString litaC_intern__EMPTY_STR =  {
    .buffer = NULL,
    .length = 0
};
litaC_intern__InternedString litaC_intern__VOID =  {
    
};
litaC_intern__InternedString litaC_intern__NULL =  {
    
};
litaC_intern__InternedString litaC_intern__BOOL =  {
    
};
litaC_intern__InternedString litaC_intern__CHAR =  {
    
};
litaC_intern__InternedString litaC_intern__I8 =  {
    
};
litaC_intern__InternedString litaC_intern__U8 =  {
    
};
litaC_intern__InternedString litaC_intern__I16 =  {
    
};
litaC_intern__InternedString litaC_intern__U16 =  {
    
};
litaC_intern__InternedString litaC_intern__I32 =  {
    
};
litaC_intern__InternedString litaC_intern__U32 =  {
    
};
litaC_intern__InternedString litaC_intern__I64 =  {
    
};
litaC_intern__InternedString litaC_intern__U64 =  {
    
};
litaC_intern__InternedString litaC_intern__F32 =  {
    
};
litaC_intern__InternedString litaC_intern__F64 =  {
    
};
litaC_intern__InternedString litaC_intern__USIZE =  {
    
};
litaC_intern__InternedString litaC_intern__CONST =  {
    
};
litaC_intern__InternedString litaC_intern__STRING =  {
    
};
litaC_intern__InternedString litaC_intern__GENERIC_PARAM =  {
    
};
litaC_intern__InternedString litaC_intern__POISON =  {
    
};
litaC_intern__InternedString litaC_intern__BUILTIN =  {
    
};
litaC_intern__InternedString litaC_intern__MAIN =  {
    
};
litaC_intern__InternedString litaC_intern__NUM_OF_TYPE_INFOS =  {
    
};
litaC_intern__InternedString litaC_intern__TYPE_INFOS =  {
    
};
litaC_intern__InternedString litaC_intern__PROFILE_TAG =  {
    
};
litaC_intern__InternedString litaC_intern__PROFILE_ENTRIES =  {
    
};
litaC_intern__InternedString litaC_intern__IF =  {
    
};
litaC_intern__InternedString litaC_intern__STATIC_IF =  {
    
};
litaC_intern__InternedString litaC_intern__ELSE =  {
    
};
litaC_intern__InternedString litaC_intern__ELSEIF =  {
    
};
litaC_intern__InternedString litaC_intern__PRECHECK =  {
    
};
litaC_intern__InternedString litaC_intern__POSTCHECK =  {
    
};
litaC_intern__InternedString litaC_intern__POSTPARSE =  {
    
};
litaC_intern__InternedString litaC_intern__END =  {
    
};
litaC_intern__InternedString litaC_intern__ELSE_ERROR =  {
    
};
litaC_intern__InternedString litaC_intern__INCLUDE =  {
    
};
litaC_intern__InternedString litaC_intern__RAW =  {
    
};
litaC_intern__InternedString litaC_intern__INLINE =  {
    
};
litaC_intern__InternedString litaC_intern__NOINLINE =  {
    
};
litaC_intern__InternedString litaC_intern__STATIC =  {
    
};
litaC_intern__InternedString litaC_intern__ATOMIC =  {
    
};
litaC_intern__InternedString litaC_intern__REGISTER =  {
    
};
litaC_intern__InternedString litaC_intern__THREADLOCAL =  {
    
};
litaC_intern__InternedString litaC_intern__EXPORT =  {
    
};
litaC_intern__InternedString litaC_intern__PACKED =  {
    
};
litaC_intern__InternedString litaC_intern__CC =  {
    
};
litaC_intern__InternedString litaC_intern__CFILE =  {
    
};
litaC_intern__InternedString litaC_intern__CINCLUDE =  {
    
};
litaC_intern__InternedString litaC_intern__FOREIGN =  {
    
};
litaC_intern__InternedString litaC_intern__ALIAS =  {
    
};
litaC_intern__InternedString litaC_intern__ASSTR =  {
    
};
litaC_intern__InternedString litaC_intern__TOSTR =  {
    
};
litaC_intern__InternedString litaC_intern__COMPILER_OPTION =  {
    
};
const litaC_char* litaC_error_codes__errorCodeText[43] =  {
    [litaC_error_codes__ErrorCode_INVALID_ASSIGNMENT] = "Invalid assignment statement",
    [litaC_error_codes__ErrorCode_INVALID_CONST_EXPR] = "Invalid constant expression",
    [litaC_error_codes__ErrorCode_INVALID_ARRAY_DIMENSION_EXPR] = "Invalid array dimension expression",
    [litaC_error_codes__ErrorCode_INVALID_CHARACTER] = "Invalid character",
    [litaC_error_codes__ErrorCode_INVALID_NUMBER] = "Invalid number",
    [litaC_error_codes__ErrorCode_INVALID_FIELD] = "Invalid field member",
    [litaC_error_codes__ErrorCode_INVALID_IMPORT_ACCESS] = "Invalid import access",
    [litaC_error_codes__ErrorCode_INVALID_CONTINUE] = "Invalid continue statement",
    [litaC_error_codes__ErrorCode_INVALID_BREAK] = "Invalid break statement",
    [litaC_error_codes__ErrorCode_INVALID_OBJECT_INIT] = "Invalid structure initializer",
    [litaC_error_codes__ErrorCode_INVALID_MODULE_ACCESS] = "Invalid module access",
    [litaC_error_codes__ErrorCode_INVALID_VARARG_POSITION] = "Invalid variable argument position",
    [litaC_error_codes__ErrorCode_INVALID_NOTE_DECL] = "Invalid note declaration, must preceed either a 'var' or 'const' declaration",
    [litaC_error_codes__ErrorCode_INVALID_LABEL_STMT] = "Invalid label statement, goto labels are only valid in functions",
    [litaC_error_codes__ErrorCode_INVALID_COMP_STMT] = "Invalid compile time statement",
    [litaC_error_codes__ErrorCode_INVALID_DEFAULT_ASSIGNMENT] = "Invalid default assignment statement, only allowed for 'struct'",
    [litaC_error_codes__ErrorCode_INVALID_TRAIT_MEMBER] = "Invalid trait member, only function pointers are allowed",
    [litaC_error_codes__ErrorCode_INVALID_TYPE_IDENTIFIER] = "Invalid fully qualified type identifier.  Qualified names must follow this format 'std.example::MyType'",
    [litaC_error_codes__ErrorCode_MISSING_COMMA] = "Missing ,",
    [litaC_error_codes__ErrorCode_MISSING_SEMICOLON] = "Missing ;",
    [litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACE] = "Missing }",
    [litaC_error_codes__ErrorCode_MISSING_EQUALS] = "Missing =",
    [litaC_error_codes__ErrorCode_MISSING_IDENTIFIER] = "Missing identifier",
    [litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACKET] = "Missing ]",
    [litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN] = "Missing )",
    [litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN] = "Missing (",
    [litaC_error_codes__ErrorCode_MISSING_LEFT_BRACE] = "Missing {",
    [litaC_error_codes__ErrorCode_MISSING_ARRAY_BRACKETS] = "Missing []",
    [litaC_error_codes__ErrorCode_MISSING_COLON] = "Missing :",
    [litaC_error_codes__ErrorCode_MISSING_WHILE] = "Missing 'while'",
    [litaC_error_codes__ErrorCode_MISSING_AS] = "Missing 'as'",
    [litaC_error_codes__ErrorCode_MISSING_GENERIC_END] = "Missing >",
    [litaC_error_codes__ErrorCode_MISSING_COMP_STMT_END] = "Missing #end",
    [litaC_error_codes__ErrorCode_MISSING_ERROR_MESSAGE] = "Missing error message",
    [litaC_error_codes__ErrorCode_RANGE_INTEGER] = "Integer literal out of range",
    [litaC_error_codes__ErrorCode_RANGE_LONG] = "Long literal out of range",
    [litaC_error_codes__ErrorCode_RANGE_REAL] = "Real literal out of range",
    [litaC_error_codes__ErrorCode_UNEXPECTED_EOF] = "Unexpected end of file",
    [litaC_error_codes__ErrorCode_UNEXPECTED_TOKEN] = "Unexpected token",
    [litaC_error_codes__ErrorCode_UNIMPLEMENTED] = "Unimplemented feature",
    [litaC_error_codes__ErrorCode_UNKNOWN_ERROR] = "An unknown error occured",
    [litaC_error_codes__ErrorCode_TOO_MANY_ERRORS] = "Too many syntax errors",
    [litaC_error_codes__ErrorCode_MAX_NUM_ERROR_CODES] = ""
};
const litaC_char* litaC_std__json__escapeStrings[256] =  {
    ['"'] = "\\\"",
    ['\b'] = "\\b",
    ['\f'] = "\\f",
    ['\n'] = "\\n",
    ['\r'] = "\\r",
    ['\t'] = "\\t",
    ['\\'] = "\\\\",
    ['\0'] = "\\0"
};
const litaC_char* litaC_std__json__escapeChars[256] =  {
    ['b'] = "\\\\b",
    ['f'] = "\\\\f",
    ['n'] = "\\\\n",
    ['r'] = "\\\\r",
    ['t'] = "\\\\t",
    ['\\'] = "\\\\",
    ['\''] = "\\'",
    ['"'] = "\\\\\"",
    ['\0'] = "\\0"
};
litaC_std__json__JsonNode* litaC_std__json__JSON_NULL = &((litaC_std__json__JsonNode) {
    .alloc = NULL,
    .type = litaC_std__json__JsonType_NULL,
    .value =  {
        0
    }
});
litaC_std__json__JsonNode* litaC_std__json__JSON_TRUE = &((litaC_std__json__JsonNode) {
    .alloc = NULL,
    .type = litaC_std__json__JsonType_BOOLEAN,
    .value =  {
        .boolValue = litaC_true
    }
});
litaC_std__json__JsonNode* litaC_std__json__JSON_FALSE = &((litaC_std__json__JsonNode) {
    .alloc = NULL,
    .type = litaC_std__json__JsonType_BOOLEAN,
    .value =  {
        .boolValue = litaC_false
    }
});
const litaC_char* litaC_std__json__tokenKindNames[14] =  {
    [litaC_std__json__TokenKind_EOF] = "EOF",
    [litaC_std__json__TokenKind_ERROR] = "ERROR",
    [litaC_std__json__TokenKind_COMMA] = ",",
    [litaC_std__json__TokenKind_COLON] = ":",
    [litaC_std__json__TokenKind_LEFT_BRACE] = "{",
    [litaC_std__json__TokenKind_RIGHT_BRACE] = "}",
    [litaC_std__json__TokenKind_LEFT_BRACKET] = "[",
    [litaC_std__json__TokenKind_RIGHT_BRACKET] = "]",
    [litaC_std__json__TokenKind_NULL] = "null",
    [litaC_std__json__TokenKind_INT_NUMBER] = "int",
    [litaC_std__json__TokenKind_REAL_NUMBER] = "float",
    [litaC_std__json__TokenKind_TRUE] = "true",
    [litaC_std__json__TokenKind_FALSE] = "false",
    [litaC_std__json__TokenKind_STRING] = "string"
};
litaC_i32 litaC_std__json__charToDigit[256] =  {
    ['0'] = 0,
    ['1'] = 1,
    ['2'] = 2,
    ['3'] = 3,
    ['4'] = 4,
    ['5'] = 5,
    ['6'] = 6,
    ['7'] = 7,
    ['8'] = 8,
    ['9'] = 9,
    ['a'] = 10,
    ['A'] = 10,
    ['b'] = 11,
    ['B'] = 11,
    ['c'] = 12,
    ['C'] = 12,
    ['d'] = 13,
    ['D'] = 13,
    ['e'] = 14,
    ['E'] = 14,
    ['f'] = 15,
    ['F'] = 15
};
litaC_char litaC_std__json__escapeToChar[256] =  {
    ['0'] = '\0',
    ['\''] = '\'',
    ['"'] = '"',
    ['\\'] = '\\',
    ['n'] = '\n',
    ['r'] = '\r',
    ['t'] = '\t',
    ['/'] = '/'
};
litaC_lex__TokenType litaC_parser__DECL_ADJUST_TOKENS[12] =  {
    litaC_lex__TokenType_IMPORT,
    litaC_lex__TokenType_HASH,
    litaC_lex__TokenType_PUBLIC,
    litaC_lex__TokenType_INTERNAL,
    litaC_lex__TokenType_VAR,
    litaC_lex__TokenType_CONST,
    litaC_lex__TokenType_FUNC,
    litaC_lex__TokenType_STRUCT,
    litaC_lex__TokenType_UNION,
    litaC_lex__TokenType_TRAIT,
    litaC_lex__TokenType_ENUM,
    litaC_lex__TokenType_TYPEDEF
};
litaC_lex__TokenType litaC_parser__STMT_ADJUST_TOKENS[12] =  {
    litaC_lex__TokenType_IMPORT,
    litaC_lex__TokenType_HASH,
    litaC_lex__TokenType_PUBLIC,
    litaC_lex__TokenType_INTERNAL,
    litaC_lex__TokenType_VAR,
    litaC_lex__TokenType_CONST,
    litaC_lex__TokenType_FUNC,
    litaC_lex__TokenType_STRUCT,
    litaC_lex__TokenType_UNION,
    litaC_lex__TokenType_TRAIT,
    litaC_lex__TokenType_ENUM,
    litaC_lex__TokenType_TYPEDEF
};

#define litaC_lsp__lsp__VERSION ("0.12")
const litaC_char* litaC_cgen__escapeStrings[256] =  {
    ['\b'] = "\\b",
    ['\f'] = "\\f",
    ['\n'] = "\\n",
    ['\r'] = "\\r",
    ['\t'] = "\\t",
    ['\\'] = "\\\\",
    ['\''] = "\\'",
    ['\0'] = "\\0"
};
const litaC_char* litaC_cgen__escapeChars[256] =  {
    ['b'] = "\\\\b",
    ['f'] = "\\\\f",
    ['n'] = "\\\\n",
    ['r'] = "\\\\r",
    ['t'] = "\\\\t",
    ['\\'] = "\\\\",
    ['\''] = "\\'",
    ['"'] = "\\\\\"",
    ['\0'] = "\\0"
};
litaC_dependency_graph__Dependency litaC_dependency_graph__EmptyDependency =  {
    .state = litaC_dependency_graph__State_EMPTY
};

#define litaC_config__LITAC_HOME_DEFAULT ("")

#define litaC_config__BUILD_CMD_DEFAULT ("clang %input% -std=c99 -o %output% -D_CRT_SECURE_NO_WARNINGS")

#define litaC_config__OUTPUT_DIR_DEFAULT (".")

#define litaC_config__OUTPUT_NAME_DEFAULT ("a")

#define litaC_pkg_mgr__pkg__SEPARATOR ("|")

#define litaC_pkg_mgr__pkg_install__INSTALL_COMPLETED_FILE (".litac_pkg")
litaC_i32 litaC_main__RunLitac(litaC_lita__LitaOptions* litaC_options) {
    litaC_f64 litaC_startTime = litaC_std__system__SystemTimeMSec();
    litaC_lita__Lita litaC_lita =  {
        
    };
    litaC_lita__Lita_init(&((litaC_lita)), litaC_options);
    
    if(litaC_options->languageServer) {
        {
            litaC_lsp__lsp__LspServer litaC_server =  {
                
            };
            litaC_lsp__lsp__LspServer_init(&((litaC_server)), &(litaC_lita));
            
            litaC_lsp__lsp__LspServer_start(&((litaC_server)));
            {
                litaC_i32 ___result = 0;
                litaC_lsp__lsp__LspServer_free(&((litaC_server)));
                litaC_lita__Lita_free(&((litaC_lita)));
                return ___result;
                
            }
            
            litaC_lsp__lsp__LspServer_free(&((litaC_server)));
            
            
        }
        
    } 
    
    litaC_module__Module* litaC_root = litaC_lita__Lita_parse(&((litaC_lita)));
    if(!(litaC_root)) {
        {
            goto report;
            
            
            
        }
        
    } 
    
    if(!(litaC_lita__Lita_typeCheck(&((litaC_lita)), litaC_root, 0))) {
        {
            goto report;
            
            
            
        }
        
    } 
    
    if(litaC_options->checkerOnly) {
        {
            goto report;
            
            
            
        }
        
    } 
    
    if(!(litaC_lita__Lita_transpile(&((litaC_lita)), litaC_root))) {
        {
            goto report;
            
            
            
        }
        
    } 
    
    litaC_bool litaC_runProgram = litaC_options->run;
    report:;
    
    litaC_f64 litaC_totalTime = litaC_std__system__SystemTimeMSec() - litaC_startTime;
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(1024, NULL);
    
    if(!(litaC_std__array__Array_empty_cb_PhaseError_ce_(&((litaC_lita.result.errors))))) {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_PhaseError_ce_(&((litaC_lita.result.errors)));litaC_i += 1) {
                {
                    litaC_error_codes__PrintError(&((litaC_sb)), litaC_std__array__Array_get_cb_PhaseError_ce_(&((litaC_lita.result.errors)), litaC_i));
                    printf("%s\n", litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb))));
                    litaC_std__string_buffer__StringBuffer_clear(&((litaC_sb)));
                    
                    
                }
            }
            printf("Total errors: %d\n", litaC_std__array__Array_size_cb_PhaseError_ce_(&((litaC_lita.result.errors))));
            
            
        }
        
    } 
    
    if(litaC_options->showProfileInfo) {
        {
            litaC_std__mem__linear_allocator__LinearAllocator* litaC_allocator = (litaC_std__mem__linear_allocator__LinearAllocator*)litaC_lita.allocator;
            printf("\n\n");
            printf("%-30s %-17s %-6s %-14s %-5s\n", "Segment", "Time", "%", "Mem", "#");
            printf("====================================================================================\n");
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_lita__MetricType_MAX_METRIC_TYPES;litaC_i += 1) {
                {
                    litaC_lita__Metric* litaC_metric = &(litaC_lita.metrics[litaC_i]);
                    printf("%-30s %-15.6f   %3.0f%% %-14zu %-5u\n", litaC_lita__MetricTypeAsStr(litaC_i), litaC_metric->executionTime, (litaC_metric->executionTime / litaC_totalTime) * 100.f, litaC_metric->bytesAllocated, litaC_metric->allocationCount);
                    
                    
                }
            }
            printf("\n");
            printf("Total time:         %f\n", litaC_totalTime);
            printf("Total memory:       %zu\n", litaC_allocator->totalBytesAllocated);
            printf("Total allocations:  %u\n", litaC_allocator->totalAllocations);
            printf("Total source lines: %u\n", litaC_lita.totalSourceLines);
            printf("\n");
            
            
        }
        
    } 
    
    if(litaC_runProgram) {
        {
            {
                litaC_i32 ___result = litaC_lita__Lita_run(&((litaC_lita)));
                litaC_std__string_buffer__StringBuffer_free(&((litaC_sb)));
                litaC_lita__Lita_free(&((litaC_lita)));
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    {
        litaC_i32 ___result = 0;
        litaC_std__string_buffer__StringBuffer_free(&((litaC_sb)));
        litaC_lita__Lita_free(&((litaC_lita)));
        return ___result;
        
    }
    
    litaC_std__string_buffer__StringBuffer_free(&((litaC_sb)));
    litaC_lita__Lita_free(&((litaC_lita)));
    
}

litaC_main__ParseStatus litaC_main__ParseArgs(litaC_i32 litaC_n,litaC_char** litaC_args,litaC_lita__LitaOptions* litaC_options) {
    litaC_std__cmdline__CmdParser litaC_parser = litaC_std__cmdline__CmdParserInit(litaC_std__mem__defaultAllocator);
    
    litaC_parser.header = "<usage> litac [options] [source file to compile]\nOPTIONS:";
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "languageServer", '\0', "Start the LitaC language server", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "lib", '\0', "The LitaC library path", litaC_std__cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "cPrefx", '\0', "The symbol prefix to use on the generated C code output", litaC_std__cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "cFormat", '\0', "Formats the C output", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "run", '\0', "Runs the program after a successful compile", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "checkerOnly", '\0', "Only runs the type checker, does not compile", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "cOnly", '\0', "Only creates the C output file, does not cimple the generated C code", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "profile", '\0', "Reports profile metrics of the compiler", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "disableLine", '\0', "Disables #line dorective in C output", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "debug", '\0', "Enables debug mode", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "verbose", '\0', "Enables verbose output", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "instrument", '\0', "Enables profile instrumentation of @profile annotated functions", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "srcDir", '\0', "Specifies the source code directory, defaults to the parent folder of the supplied source file", litaC_std__cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "doc", '\0', "Generates document output", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "docDir", '\0', "Directory where the generated documents are written to, defaults to './output'", litaC_std__cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "docAll", '\0', "Includes non-public types in the documentation generation", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "output", 'o', "The name of the compiled binary", litaC_std__cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "outputDir", '\0', "The directory in which the C ouput files are stored", litaC_std__cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "version", 'v', "Displays the LitaC version", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "help", 'h', "Displays this help", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "types", 't', "Includes TypeInfo for reflection\n<arg> can be:\nall       Means all types will have reflection values\ntagged    Means only basic types and types annotated with @typeinfo will have reflection values", litaC_std__cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "test", '\0', "Runs functions annotated with @test\n<arg> is a regex of which tests should be run", litaC_std__cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "testFile", '\0', "Runs functions annotated with @test in the supplied source file only", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "testDir", '\0', "Specifies the source code test directory", litaC_std__cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "pkg-install", '\0', "Scans for a pkg.json file and downloads and installs LitaC packages defined in the `dependencies` section.\nIf successful, creates a build.json which is used for building this LitaC project.", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "force", '\0', "Forces a full clean install of all packages.  Must be ran with `pkg-install` option, otherwise will be ignored.", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "pkg-run", '\0', "Runs a script defined in the `commands` section in this projects `pkg.json`.  The argument passed of this option is used to run the `commands.{option}` command", litaC_std__cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "pkg-init", '\0', "Initializes a new LitaC package project", litaC_std__cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "pkg-build", '\0', "Builds the LitaC package", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "release", '\0', "Marks builds in release mode", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "proxy", '\0', "Defines a proxy server to use when making network calls.  Ex. -proxy https://proxy.com:443", litaC_std__cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "buildCmd", 'b', "The underlying C compiler build and compile command.  Variables will be substituted if found:\n%output%\tThe executable name\n%input%\tThe file(s) generated.\n%options%\tThe generated @compiler_option's if -strict option is enabled. \nOtherwise, the LitaC compiler will append any @compiler_option flags to this command.", litaC_std__cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "strict", '\0', "The LitaC compiler will not modify the `buildCmd` option (for applying @compiler_option), instead it will store the generated @compiler_options in the %options% substitution variable.", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "tcc", '\0', "Use tcc to compile.  This ignores buildCmd/strictBuildCmd", 0, NULL);
    litaC_std__cmdline__CmdParser_addOption(&((litaC_parser)), "maxMemory", '\0', "The max amount of memory allowed for allocation. NOTE: This is a temporary option", litaC_std__cmdline__OptionFlag_HAS_ARGUMENT, NULL);
    if(litaC_std__cmdline__CmdParser_parse(&((litaC_parser)), litaC_n, litaC_args) != litaC_std__cmdline__CmdParserStatus_OK) {
        {
            goto err_print;
            
            
            
        }
        
    } 
    
    if(litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "version")) {
        {
            printf("Version: %s\n", litaC_lita__LITA_VERSION);
            goto terminate;
            
            
            
        }
        
    } 
    
    if(litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "help")) {
        {
            {
                litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(16, NULL);
                
                litaC_std__cmdline__CmdParser_printHelp(&((litaC_parser)), &((litaC_sb)));
                printf("%s\n", litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb))));
                litaC_std__string_buffer__StringBuffer_free(&((litaC_sb)));
                
                
            }
            goto terminate;
            
            
            
        }
        
    } 
    
    litaC_options->pkgOptions.pkgCmd = litaC_lita__PkgCommand_PKG_NONE;
    if(litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "pkg-install")) {
        {
            litaC_options->pkgOptions.pkgCmd = litaC_lita__PkgCommand_PKG_INSTALL;
            litaC_options->pkgOptions.forceClean = litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "force");
            
            
        }
        
    } 
    
    if(litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "pkg-run")) {
        {
            litaC_options->pkgOptions.pkgCmd = litaC_lita__PkgCommand_PKG_RUN;
            litaC_options->pkgOptions.pkgRunCmdArg = litaC_std__cmdline__CmdParser_getOption(&((litaC_parser)), "pkg-run")->value;
            
            
        }
        
    } 
    
    if(litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "pkg-init")) {
        {
            litaC_options->pkgOptions.pkgCmd = litaC_lita__PkgCommand_PKG_INIT;
            litaC_options->pkgOptions.pkgName = litaC_std__cmdline__CmdParser_getOption(&((litaC_parser)), "pkg-init")->value;
            
            
        }
        
    } 
    
    if(litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "pkg-build")) {
        {
            litaC_options->pkgOptions.pkgCmd = litaC_lita__PkgCommand_PKG_BUILD;
            litaC_options->pkgOptions.isRelease = litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "release");
            
            
        }
        
    } 
    
    litaC_options->languageServer = litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "languageServer");
    if(!(litaC_options->languageServer)) {
        {
            if(litaC_options->pkgOptions.pkgCmd == litaC_lita__PkgCommand_PKG_NONE) {
                {
                    if(litaC_std__array__Array_size_cb__ptr_const_char_ce_(&((litaC_parser.args))) < 2) {
                        {
                            printf("Missing input file\n");
                            goto err;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__system__GetAbsolutePath(litaC_std__system__CurrentWorkingPath(), litaC_std__array__Array_get_cb__ptr_const_char_ce_(&((litaC_parser.args)), 1), litaC_options->inputFile);
                    
                    
                }
                
            } else {
                {
                    if(litaC_std__array__Array_size_cb__ptr_const_char_ce_(&((litaC_parser.args))) > 1) {
                        {
                            litaC_std__system__GetAbsolutePath(litaC_std__system__CurrentWorkingPath(), litaC_std__array__Array_get_cb__ptr_const_char_ce_(&((litaC_parser.args)), 1), litaC_options->inputFile);
                            if(!(litaC_std__system__FileExists(litaC_options->inputFile))) {
                                {
                                    printf("Could not find '%s'\n", litaC_options->inputFile);
                                    goto err;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            } 
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_lib = litaC_std__system__GetEnv("LITAC_HOME");
    if(!(litaC_lib)) {
        litaC_lib = litaC_config__LITAC_HOME_DEFAULT;
        
    } 
    
    litaC_std__system__GetAbsolutePath("", litaC_lib, litaC_options->litaPath);
    litaC_options->checkerOnly = litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "checkerOnly");
    litaC_options->cOutputOnly = litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "cOnly");
    litaC_options->showProfileInfo = litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "profile");
    litaC_options->run = litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "run");
    litaC_options->isDebug = litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "debug");
    litaC_options->cFormat = litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "cFormat");
    litaC_options->instrument = litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "instrument");
    litaC_options->disableLineSync = litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "disableLine");
    litaC_options->isVerbose = litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "verbose");
    litaC_options->isTcc = litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "tcc");
    litaC_options->isStrict = litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "strict");
    if(litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "maxMemory")) {
        {
            const litaC_char* litaC_memoryStr = litaC_std__cmdline__CmdParser_getOption(&((litaC_parser)), "maxMemory")->value;
            litaC_std__string_view__StringView litaC_view = litaC_std__string_view__StringViewInit(litaC_memoryStr, -(1));
            litaC_options->maxMemory = strtol(litaC_memoryStr, NULL, 10);
            if(litaC_std__string_view__StringView_indexOf(litaC_view, "GB", -(1)) > -(1) || litaC_std__string_view__StringView_indexOf(litaC_view, "GiB", -(1)) > -(1) || litaC_std__string_view__StringView_indexOf(litaC_view, "gb", -(1)) > -(1) || litaC_std__string_view__StringView_indexOf(litaC_view, "gib", -(1)) > -(1)) {
                {
                    litaC_options->maxMemory *= litaC_std__mem__GiB;
                    
                    
                }
                
            } else {
                if(litaC_std__string_view__StringView_indexOf(litaC_view, "MB", -(1)) > -(1) || litaC_std__string_view__StringView_indexOf(litaC_view, "MiB", -(1)) > -(1) || litaC_std__string_view__StringView_indexOf(litaC_view, "mb", -(1)) > -(1) || litaC_std__string_view__StringView_indexOf(litaC_view, "mib", -(1)) > -(1)) {
                    {
                        litaC_options->maxMemory *= litaC_std__mem__MiB;
                        
                        
                    }
                    
                } else {
                    if(litaC_std__string_view__StringView_indexOf(litaC_view, "KB", -(1)) > -(1) || litaC_std__string_view__StringView_indexOf(litaC_view, "KiB", -(1)) > -(1) || litaC_std__string_view__StringView_indexOf(litaC_view, "kb", -(1)) > -(1) || litaC_std__string_view__StringView_indexOf(litaC_view, "kib", -(1)) > -(1)) {
                        {
                            litaC_options->maxMemory *= litaC_std__mem__KiB;
                            
                            
                        }
                        
                    } 
                    
                } 
                
            } 
            
            
            
        }
        
    } else {
        {
            litaC_options->maxMemory = 300 * litaC_std__mem__MiB;
            
            
        }
    } 
    
    litaC_options->typeOption = litaC_lita__TypeInfoOption_NONE;
    if(litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "types")) {
        {
            const litaC_char* litaC_opt = litaC_std__cmdline__CmdParser_getOption(&((litaC_parser)), "types")->value;
            if(strcmp(litaC_opt, "all") == 0) {
                {
                    litaC_options->typeOption = litaC_lita__TypeInfoOption_ALL;
                    
                    
                }
                
            } else {
                if(strcmp(litaC_opt, "tagged") == 0) {
                    {
                        litaC_options->typeOption = litaC_lita__TypeInfoOption_TAGGED;
                        
                        
                    }
                    
                } 
                
            } 
            
            
            
        }
        
    } 
    
    if(litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "test")) {
        {
            litaC_options->testsRegex = litaC_std__cmdline__CmdParser_getOption(&((litaC_parser)), "test")->value;
            litaC_options->testsOnly = litaC_true;
            
            
        }
        
    } 
    
    if(litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "testFile")) {
        {
            litaC_options->testFileOnly = litaC_true;
            litaC_options->testsOnly = litaC_true;
            
            
        }
        
    } 
    
    if(litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "proxy")) {
        {
            litaC_options->proxy = litaC_std__cmdline__CmdParser_getOption(&((litaC_parser)), "proxy")->value;
            
            
        }
        
    } 
    
    if(litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "buildCmd")) {
        {
            litaC_options->compileCmd = litaC_std__cmdline__CmdParser_getOption(&((litaC_parser)), "buildCmd")->value;
            
            
        }
        
    } else {
        {
            litaC_options->compileCmd = litaC_config__BUILD_CMD_DEFAULT;
            
            
        }
    } 
    
    const litaC_char* litaC_cPrefix = (litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "cPrefix")) ? litaC_std__cmdline__CmdParser_getOption(&((litaC_parser)), "cPrefix")->value : "litaC_";
    litaC_std__string__StringCopy(litaC_cPrefix, litaC_options->cPrefix, litaC_lita__MAX_PREFIX_SIZE);
    const litaC_char* litaC_outputFile = (litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "output")) ? litaC_std__cmdline__CmdParser_getOption(&((litaC_parser)), "output")->value : litaC_config__OUTPUT_NAME_DEFAULT;
    litaC_std__string__StringCopy(litaC_outputFile, litaC_options->outputFile, _MAX_PATH);
    const litaC_char* litaC_outputPath = (litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "outputDir")) ? litaC_std__cmdline__CmdParser_getOption(&((litaC_parser)), "outputDir")->value : litaC_config__OUTPUT_DIR_DEFAULT;
    litaC_std__string__StringCopy(litaC_outputPath, litaC_options->outputPath, _MAX_PATH);
    litaC_i32 litaC_len = strlen(litaC_options->outputPath);
    if(litaC_len > 0) {
        {
            if(litaC_options->outputPath[litaC_len - 1] != '/') {
                {
                    strcat(litaC_options->outputPath, "/");
                    
                    
                }
                
            } 
            
            litaC_char litaC_output[_MAX_PATH] =  {
                0
            };
            litaC_std__system__GetAbsolutePath(litaC_std__system__CurrentWorkingPath(), litaC_options->outputPath, litaC_output);
            litaC_std__string__StringCopy(litaC_output, litaC_options->outputPath, _MAX_PATH);
            
            
        }
        
    } 
    
    if(litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "srcDir")) {
        {
            litaC_std__string__StringCopy(litaC_std__cmdline__CmdParser_getOption(&((litaC_parser)), "srcDir")->value, litaC_options->srcPath, _MAX_PATH);
            
            
        }
        
    } 
    
    if(strnlen(litaC_options->srcPath, _MAX_PATH) == 0) {
        {
            litaC_std__string_view__StringView litaC_path = litaC_std__string_view__StringViewInit(litaC_options->inputFile, _MAX_PATH);
            litaC_i32 litaC_index = litaC_std__string_view__StringView_lastIndexOfAt(litaC_path, "/src/", 5, -(1));
            if(litaC_index > -(1)) {
                {
                    litaC_std__string__StringCopy(litaC_options->inputFile, litaC_options->srcPath, litaC_index + 5);
                    
                    
                }
                
            } else {
                {
                    litaC_std__system__FileParent(litaC_options->inputFile, litaC_options->srcPath, NULL);
                    
                    
                }
            } 
            
            
            
        }
        
    } 
    
    if(litaC_std__cmdline__CmdParser_hasOption(&((litaC_parser)), "testDir")) {
        {
            litaC_std__string__StringCopy(litaC_std__cmdline__CmdParser_getOption(&((litaC_parser)), "testDir")->value, litaC_options->testPath, _MAX_PATH);
            
            
        }
        
    } else {
        {
            litaC_std__string__StringCopy("/test", litaC_options->testPath, _MAX_PATH);
            
            
        }
    } 
    
    if(strnlen(litaC_options->srcPath, _MAX_PATH) > 0) {
        {
            litaC_std__system__FileParent(litaC_options->srcPath, litaC_options->projectPath, NULL);
            
            
        }
        
    } else {
        {
            litaC_std__string__StringCopy(litaC_std__system__CurrentWorkingPath(), litaC_options->projectPath, _MAX_PATH);
            
            
        }
    } 
    
    if(strlen(litaC_options->projectPath) == 0) {
        {
            litaC_std__string__StringCopy(".", litaC_options->projectPath, 2);
            
            
        }
        
    } 
    
    litaC_main__TrimPath(litaC_options->projectPath);
    litaC_main__TrimPath(litaC_options->srcPath);
    litaC_main__TrimPath(litaC_options->libPath);
    litaC_main__TrimPath(litaC_options->litaPath);
    litaC_main__TrimPath(litaC_options->testPath);
    {
        litaC_main__ParseStatus ___result = litaC_main__ParseStatus_OK;
        litaC_std__cmdline__CmdParser_free(&((litaC_parser)));
        return ___result;
        
    }
    
    terminate:;
    
    {
        litaC_main__ParseStatus ___result = litaC_main__ParseStatus_TERMINATE;
        litaC_std__cmdline__CmdParser_free(&((litaC_parser)));
        return ___result;
        
    }
    
    err_print:;
    
    {
        litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(16, NULL);
        
        litaC_std__cmdline__CmdParser_printHelp(&((litaC_parser)), &((litaC_sb)));
        printf("%s", litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb))));
        litaC_std__string_buffer__StringBuffer_free(&((litaC_sb)));
        
        
    }
    err:;
    
    {
        litaC_main__ParseStatus ___result = litaC_main__ParseStatus_ERROR;
        litaC_std__cmdline__CmdParser_free(&((litaC_parser)));
        return ___result;
        
    }
    
    litaC_std__cmdline__CmdParser_free(&((litaC_parser)));
    
}

litaC_void litaC_main__TrimPath(litaC_char* litaC_path) {
    litaC_i32 litaC_len = strlen(litaC_path);
    if(litaC_len < 1) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_path[litaC_len - 1] == '/' || litaC_path[litaC_len - 1] == '\\') {
        {
            litaC_path[litaC_len - 1] = '\0';
            
            
        }
        
    } 
    
    
}

litaC_i32 litaC_main__HandlePkgCommand(litaC_lita__LitaOptions* litaC_options) {
    litaC_usize litaC_size = (litaC_options->maxMemory > 0) ? litaC_options->maxMemory : 1024 * 1024 * 1024;
    litaC_std__mem__linear_allocator__LinearAllocator litaC_linearAllocator =  {
        
    };
    litaC_std__mem__linear_allocator__LinearAllocator_init(&((litaC_linearAllocator)), litaC_std__mem__Allocator_alloc(litaC_std__mem__defaultAllocator, litaC_size), litaC_size, LITAC_DEFAULT_ALIGNMENT, litaC_std__mem__linear_allocator__DEFAULT_EXPAND_INFO);
    
    litaC_pkg_mgr__PackageManager litaC_pm =  {
        
    };
    litaC_pkg_mgr__PackageManager_init(&((litaC_pm)), (litaC_pkg_mgr__PackageOptions) {
        .projectPath = litaC_options->projectPath,
        .litaOptions = litaC_options,
        .pkgDir = ".pkgs"
    }, &((litaC_linearAllocator.allocator)));
    
    switch(litaC_options->pkgOptions.pkgCmd) {
        case litaC_lita__PkgCommand_PKG_INSTALL: {
            {
                {
                    litaC_i32 ___result = litaC_main__RunPkgInstall(litaC_options, &(litaC_pm));
                    litaC_pkg_mgr__PackageManager_free(&((litaC_pm)));
                    litaC_std__mem__Allocator_free(litaC_std__mem__defaultAllocator, litaC_linearAllocator.mem);
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_lita__PkgCommand_PKG_RUN: {
            {
                {
                    litaC_i32 ___result = litaC_main__RunPkgCommand(litaC_options, &(litaC_pm));
                    litaC_pkg_mgr__PackageManager_free(&((litaC_pm)));
                    litaC_std__mem__Allocator_free(litaC_std__mem__defaultAllocator, litaC_linearAllocator.mem);
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_lita__PkgCommand_PKG_INIT: {
            {
                {
                    litaC_i32 ___result = litaC_main__RunPkgInit(litaC_options, &(litaC_pm));
                    litaC_pkg_mgr__PackageManager_free(&((litaC_pm)));
                    litaC_std__mem__Allocator_free(litaC_std__mem__defaultAllocator, litaC_linearAllocator.mem);
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_lita__PkgCommand_PKG_BUILD: {
            {
                {
                    litaC_i32 ___result = litaC_main__RunPkgBuild(litaC_options, &(litaC_pm));
                    litaC_pkg_mgr__PackageManager_free(&((litaC_pm)));
                    litaC_std__mem__Allocator_free(litaC_std__mem__defaultAllocator, litaC_linearAllocator.mem);
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        default: {
            {
                litaC_i32 ___result = 0;
                litaC_pkg_mgr__PackageManager_free(&((litaC_pm)));
                litaC_std__mem__Allocator_free(litaC_std__mem__defaultAllocator, litaC_linearAllocator.mem);
                return ___result;
                
            }
            
            
            
        }
    }
    {
        litaC_i32 ___result = 0;
        litaC_pkg_mgr__PackageManager_free(&((litaC_pm)));
        litaC_std__mem__Allocator_free(litaC_std__mem__defaultAllocator, litaC_linearAllocator.mem);
        return ___result;
        
    }
    
    litaC_pkg_mgr__PackageManager_free(&((litaC_pm)));
    litaC_std__mem__Allocator_free(litaC_std__mem__defaultAllocator, litaC_linearAllocator.mem);
    
}

litaC_i32 litaC_main__RunPkgInstall(litaC_lita__LitaOptions* litaC_options,litaC_pkg_mgr__PackageManager* litaC_pm) {
    litaC_pkg_mgr__PkgStatus litaC_status = litaC_pkg_mgr__PackageManager_installCommand(litaC_pm, (litaC_pkg_mgr__PackageInstallOptions) {
        .fullSync = litaC_options->pkgOptions.forceClean,
        .httpOptions =  {
            .proxy = litaC_options->proxy
        }
    });
    if(litaC_status != litaC_pkg_mgr__PkgStatus_OK) {
        {
            printf("Error installing packages:\nErrorCode: %s - %s\n", litaC_pkg_mgr__PkgStatusAsStr(litaC_status), litaC_std__string_buffer__StringBuffer_cStr(&((litaC_pm->errors))));
            return 1;
            
            
            
        }
        
    } 
    
    litaC_build__BuildFile litaC_buildFile =  {
        
    };
    
    litaC_status = litaC_pkg_mgr__PackageManager_createBuildFile(litaC_pm, &(litaC_buildFile));
    if(litaC_status != litaC_pkg_mgr__PkgStatus_OK) {
        {
            printf("Error creating build.json:\nErrorCode: %s - %s\n", litaC_pkg_mgr__PkgStatusAsStr(litaC_status), litaC_std__string_buffer__StringBuffer_cStr(&((litaC_pm->errors))));
            {
                litaC_i32 ___result = 1;
                litaC_build__BuildFile_free(&((litaC_buildFile)));
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_char litaC_temp[_MAX_PATH] = {0};
    litaC_std__string__String litaC_build = litaC_std__string__StringInit(litaC_temp, _MAX_PATH, 0);
    litaC_std__string__String_format(&((litaC_build)), "%s/.build.json", litaC_options->projectPath);
    litaC_std__io__File litaC_file =  {
        
    };
    litaC_std__io__File_open(&((litaC_file)), litaC_std__string__String_cStr(litaC_build), litaC_std__io__FileOpenOp_WRITE);
    
    printf("Writing '%s'.\n", litaC_std__string__String_cStr(litaC_build));
    if(!(litaC_build__BuildFile_writeTo(&((litaC_buildFile)), &(litaC_file)))) {
        {
            printf("Error writing out build.json\n");
            {
                litaC_i32 ___result = 1;
                litaC_std__io__File_close(&((litaC_file)));
                litaC_build__BuildFile_free(&((litaC_buildFile)));
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    printf("Success.\n");
    {
        litaC_i32 ___result = 0;
        litaC_std__io__File_close(&((litaC_file)));
        litaC_build__BuildFile_free(&((litaC_buildFile)));
        return ___result;
        
    }
    
    litaC_std__io__File_close(&((litaC_file)));
    litaC_build__BuildFile_free(&((litaC_buildFile)));
    
}

litaC_i32 litaC_main__RunPkgCommand(litaC_lita__LitaOptions* litaC_options,litaC_pkg_mgr__PackageManager* litaC_pm) {
    litaC_pkg_mgr__PkgStatus litaC_status = litaC_pkg_mgr__PackageManager_runCommand(litaC_pm, litaC_options->pkgOptions.pkgRunCmdArg);
    if(litaC_status != litaC_pkg_mgr__PkgStatus_OK) {
        {
            printf("Error running pkg command:\nErrorCode: %s - %s\n", litaC_pkg_mgr__PkgStatusAsStr(litaC_status), litaC_std__string_buffer__StringBuffer_cStr(&((litaC_pm->errors))));
            return 1;
            
            
            
        }
        
    } 
    
    return 0;
    
    
}

litaC_i32 litaC_main__RunPkgInit(litaC_lita__LitaOptions* litaC_options,litaC_pkg_mgr__PackageManager* litaC_pm) {
    litaC_pkg_mgr__PkgStatus litaC_status = litaC_pkg_mgr__PackageManager_initCommand(litaC_pm, (litaC_pkg_mgr__PackageInitOptions) {
        .name = litaC_options->pkgOptions.pkgName,
        .version = "0.0.1",
        .type = "executable",
        .repo = ""
    });
    if(litaC_status != litaC_pkg_mgr__PkgStatus_OK) {
        {
            printf("Error running pkg init:\nErrorCode: %s - %s\n", litaC_pkg_mgr__PkgStatusAsStr(litaC_status), litaC_std__string_buffer__StringBuffer_cStr(&((litaC_pm->errors))));
            return 1;
            
            
            
        }
        
    } 
    
    return 0;
    
    
}

litaC_i32 litaC_main__RunPkgBuild(litaC_lita__LitaOptions* litaC_options,litaC_pkg_mgr__PackageManager* litaC_pm) {
    litaC_pkg_mgr__PkgStatus litaC_status = litaC_pkg_mgr__PackageManager_buildCommand(litaC_pm, (litaC_pkg_mgr__PackageBuildOptions) {
        .isRelease = litaC_options->pkgOptions.isRelease
    });
    if(litaC_status != litaC_pkg_mgr__PkgStatus_OK) {
        {
            printf("Error running pkg build:\nErrorCode: %s - %s\n", litaC_pkg_mgr__PkgStatusAsStr(litaC_status), litaC_std__string_buffer__StringBuffer_cStr(&((litaC_pm->errors))));
            return 1;
            
            
            
        }
        
    } 
    
    return 0;
    
    
}

litaC_void* litaC_std__mem__memduplicate(const litaC_void* litaC_p,litaC_usize litaC_len,const litaC_std__mem__Allocator* litaC_a) {
    litaC_void* litaC_copy = litaC_std__mem__Allocator_alloc(litaC_a, litaC_len);
    memcpy(litaC_copy, litaC_p, litaC_len);
    return litaC_copy;
    
    
}

litaC_bool litaC_std__mem__isPowerOfTwo(litaC_usize litaC_x) {
    return (litaC_x & (litaC_x - 1)) == 0;
    
    
}

litaC_usize litaC_std__mem__alignForward(litaC_usize litaC_ptr,litaC_usize litaC_align) {
    assert(litaC_std__mem__isPowerOfTwo(litaC_align));
    litaC_usize litaC_p = litaC_ptr;
    litaC_usize litaC_a = litaC_align;
    litaC_usize litaC_modulo = litaC_p & (litaC_a - 1);
    if(litaC_modulo != 0) {
        {
            litaC_p += (litaC_a - litaC_modulo);
            
            
        }
        
    } 
    
    return litaC_p;
    
    
}

LITAC_INLINE 
litaC_void* litaC_std__mem__Allocator_alloc(const litaC_std__mem__Allocator* litaC_a,litaC_usize litaC_size) {
    return litaC_a->allocFn(litaC_a, litaC_size);
    
    
}

LITAC_INLINE 
litaC_void* litaC_std__mem__Allocator_calloc(const litaC_std__mem__Allocator* litaC_a,litaC_usize litaC_num,litaC_usize litaC_size) {
    return litaC_a->callocFn(litaC_a, litaC_num, litaC_size);
    
    
}

LITAC_INLINE 
litaC_void* litaC_std__mem__Allocator_realloc(const litaC_std__mem__Allocator* litaC_a,litaC_void* litaC_ptr,litaC_usize litaC_oldsize,litaC_usize litaC_newsize) {
    return litaC_a->reallocFn(litaC_a, litaC_ptr, litaC_oldsize, litaC_newsize);
    
    
}

LITAC_INLINE 
litaC_void litaC_std__mem__Allocator_free(const litaC_std__mem__Allocator* litaC_a,litaC_void* litaC_ptr) {
    litaC_a->freeFn(litaC_a, litaC_ptr);
    
}

litaC_void* litaC_std__mem__libc_allocator__cMalloc(const litaC_std__mem__Allocator* litaC_a,litaC_usize litaC_size) {
    return malloc(litaC_size);
    
    
}

litaC_void* litaC_std__mem__libc_allocator__cCalloc(const litaC_std__mem__Allocator* litaC_a,litaC_usize litaC_num,litaC_usize litaC_size) {
    return calloc(litaC_num, litaC_size);
    
    
}

litaC_void* litaC_std__mem__libc_allocator__cRealloc(const litaC_std__mem__Allocator* litaC_a,litaC_void* litaC_ptr,litaC_usize litaC_oldSize,litaC_usize litaC_size) {
    return realloc(litaC_ptr, litaC_size);
    
    
}

litaC_void litaC_std__mem__libc_allocator__cFree(const litaC_std__mem__Allocator* litaC_a,litaC_void* litaC_ptr) {
    return free(litaC_ptr);
    
    
}

litaC_void litaC_std__mem__linear_allocator__LinearAllocator_init(litaC_std__mem__linear_allocator__LinearAllocator* litaC_this,litaC_void* litaC_mem,litaC_usize litaC_size,litaC_usize litaC_align,litaC_std__mem__linear_allocator__ExpandInfo litaC_expandInfo) {
    litaC_this->allocator = (litaC_std__mem__Allocator) {
        .allocFn = &(litaC_std__mem__linear_allocator__LinearMalloc),
        .callocFn = &(litaC_std__mem__linear_allocator__LinearCalloc),
        .reallocFn = &(litaC_std__mem__linear_allocator__LinearRealloc),
        .freeFn = &(litaC_std__mem__linear_allocator__LinearFree)
    };
    litaC_this->mem = litaC_mem;
    litaC_this->size = litaC_size;
    litaC_this->totalBytesAllocated = 0;
    litaC_this->totalAllocations = 0;
    litaC_this->currentOffset = 0;
    litaC_this->alignment = litaC_align;
    litaC_this->expandInfo = litaC_expandInfo;
    
}


litaC_void litaC_std__mem__linear_allocator__LinearAllocator_clear(litaC_std__mem__linear_allocator__LinearAllocator* litaC_this) {
    litaC_this->totalBytesAllocated = 0;
    litaC_this->totalAllocations = 0;
    litaC_this->currentOffset = 0;
    
}

litaC_void* litaC_std__mem__linear_allocator__LinearAllocator_malloc(litaC_std__mem__linear_allocator__LinearAllocator* litaC_this,litaC_usize litaC_size) {
    litaC_usize litaC_currPtr = (litaC_usize)litaC_this->mem + litaC_this->currentOffset;
    litaC_usize litaC_offset = litaC_std__mem__alignForward(litaC_currPtr, litaC_this->alignment);
    litaC_offset -= (litaC_usize)litaC_this->mem;
    litaC_usize litaC_newOffset = litaC_offset + litaC_size;
    if(litaC_newOffset > litaC_this->size) {
        {
            switch(litaC_this->expandInfo.strategy) {
                case litaC_std__mem__linear_allocator__ExpandStrategy_DOUBLE_MEMORY: {
                    {
                        litaC_usize litaC_newSize = litaC_this->size << 1;
                        while(litaC_newOffset > litaC_newSize) {
                            {
                                litaC_newSize = litaC_newSize << 1;
                                
                                
                            }
                        }
                        litaC_void* litaC_newMem = litaC_std__mem__Allocator_realloc(litaC_this->expandInfo.allocator, litaC_this->mem, litaC_this->size, litaC_newSize);
                        if(!(litaC_newMem)) {
                            {
                                fprintf(stderr, "Failed to allocate: %zu, %zu + %zu will exceed limit of %zu, then failed to realloc from expanding strategy\n", litaC_size, litaC_offset, litaC_size, litaC_this->size);
                                return NULL;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_this->mem = litaC_newMem;
                        litaC_this->size = litaC_newSize;
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        fprintf(stderr, "Failed to allocate: %zu, %zu + %zu will exceed limit of %zu\n", litaC_size, litaC_offset, litaC_size, litaC_this->size);
                        return NULL;
                        
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
        
    } 
    
    litaC_this->currentOffset = litaC_newOffset;
    litaC_this->totalBytesAllocated = (litaC_size + litaC_offset);
    litaC_this->totalAllocations += 1;
    litaC_char* litaC_ptr = ((litaC_char*)litaC_this->mem) + litaC_offset;
    return litaC_ptr;
    
    
}

litaC_void* litaC_std__mem__linear_allocator__LinearMalloc(const litaC_std__mem__Allocator* litaC_alloc,litaC_usize litaC_size) {
    litaC_std__mem__linear_allocator__LinearAllocator* litaC_this = (litaC_std__mem__linear_allocator__LinearAllocator*)litaC_alloc;
    return litaC_std__mem__linear_allocator__LinearAllocator_malloc(litaC_this, litaC_size);
    
    
}

litaC_void* litaC_std__mem__linear_allocator__LinearCalloc(const litaC_std__mem__Allocator* litaC_alloc,litaC_usize litaC_num,litaC_usize litaC_size) {
    litaC_std__mem__linear_allocator__LinearAllocator* litaC_this = (litaC_std__mem__linear_allocator__LinearAllocator*)litaC_alloc;
    litaC_void* litaC_result = litaC_std__mem__linear_allocator__LinearAllocator_malloc(litaC_this, litaC_size * litaC_num);
    if(litaC_result) {
        {
            memset(litaC_result, 0, litaC_size * litaC_num);
            
            
        }
        
    } 
    
    return litaC_result;
    
    
}

litaC_void* litaC_std__mem__linear_allocator__LinearRealloc(const litaC_std__mem__Allocator* litaC_alloc,litaC_void* litaC_ptr,litaC_usize litaC_oldSize,litaC_usize litaC_size) {
    if(litaC_ptr == NULL) {
        {
            return litaC_std__mem__linear_allocator__LinearMalloc(litaC_alloc, litaC_size);
            
            
            
        }
        
    } 
    
    litaC_std__mem__linear_allocator__LinearAllocator* litaC_this = (litaC_std__mem__linear_allocator__LinearAllocator*)litaC_alloc;
    litaC_void* litaC_result = litaC_std__mem__linear_allocator__LinearAllocator_malloc(litaC_this, litaC_size);
    if(litaC_result) {
        {
            litaC_usize litaC_len = MIN(litaC_oldSize, litaC_size);
            memcpy(litaC_result, litaC_ptr, litaC_len);
            
            
        }
        
    } 
    
    return litaC_result;
    
    
}

litaC_void litaC_std__mem__linear_allocator__LinearFree(const litaC_std__mem__Allocator* litaC_alloc,litaC_void* litaC_ptr) {
    
}

litaC_std__io__FileStatus litaC_std__io__File_open(litaC_std__io__File* litaC_file,const litaC_char* litaC_filename,litaC_std__io__FileOpenOp litaC_op) {
    {
        const char* litaC_opStr = "rb";
        switch(litaC_op) {
            case litaC_std__io__FileOpenOp_READ_ONLY_BINARY: {
                {
                    litaC_opStr = "rb";
                    break;
                    
                    
                }
                
                
            }
            case litaC_std__io__FileOpenOp_READ_ONLY: {
                litaC_opStr = "r";
                break;
                
                
            }
            case litaC_std__io__FileOpenOp_WRITE_BINARY: {
                {
                    litaC_opStr = "wb";
                    break;
                    
                    
                }
                
                
            }
            case litaC_std__io__FileOpenOp_WRITE: {
                {
                    litaC_opStr = "w";
                    break;
                    
                    
                }
                
                
            }
            case litaC_std__io__FileOpenOp_WRITE_APPEND: {
                {
                    litaC_opStr = "a";
                    break;
                    
                    
                }
                
                
            }
            case litaC_std__io__FileOpenOp_WRITE_APPEND_BINARY: {
                {
                    litaC_opStr = "ab";
                    break;
                    
                    
                }
                
                
            }
        }
        litaC_file->file = fopen(litaC_filename, litaC_opStr);
        if(litaC_file->file == NULL) {
            {
                return litaC_std__io__FileStatus_FileNotFoundError;
                
                
                
            }
            
        } 
        
        return litaC_std__io__FileStatus_Ok;
        
        
        
    }
    
}

litaC_usize litaC_std__io__File_length(litaC_std__io__File* litaC_file) {
    {
        if(!(litaC_file) || !(litaC_file->file)) {
            {
                return 0;
                
                
                
            }
            
        } 
        
        if(fseek(litaC_file->file, 0, SEEK_END)) {
            {
                return 0;
                
                
                
            }
            
        } 
        
        litaC_i64 litaC_len = ftell(litaC_file->file);
        return litaC_len;
        
        
        
    }
    
}

litaC_i32 litaC_std__io__File_handle(litaC_std__io__File* litaC_file) {
    {
        return fileno(litaC_file->file);
        
        
        
    }
    
}

litaC_void litaC_std__io__File_close(litaC_std__io__File* litaC_file) {
    {
        if(litaC_file && litaC_file->file) {
            {
                fclose(litaC_file->file);
                
                
            }
            
        } 
        
        
        
    }
    
}

litaC_i64 litaC_std__io__FileLength(const litaC_char* litaC_fileName) {
    FILE* litaC_fp = fopen(litaC_fileName, "r");
    if(litaC_fp == NULL) {
        {
            return -(1);
            
            
            
        }
        
    } 
    
    
    if(fseek(litaC_fp, 0, SEEK_END)) {
        {
            {
                litaC_i64 ___result = -(1);
                fclose(litaC_fp);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_i64 litaC_len = ftell(litaC_fp);
    {
        litaC_i64 ___result = litaC_len;
        fclose(litaC_fp);
        return ___result;
        
    }
    
    fclose(litaC_fp);
    
}

litaC_std__io__FileStatus litaC_std__io__ReadFile(const litaC_char* litaC_fileName,litaC_char** litaC_data,litaC_usize* litaC_length,const litaC_std__mem__Allocator* litaC_alloc) {
    {
        FILE* litaC_fp = fopen(litaC_fileName, "r");
        if(litaC_fp == NULL) {
            {
                *(litaC_length) = -(1);
                return litaC_std__io__FileStatus_FileNotFoundError;
                
                
                
            }
            
        } 
        
        
        if(fseek(litaC_fp, 0, SEEK_END)) {
            {
                *(litaC_length) = -(1);
                {
                    litaC_std__io__FileStatus ___result = litaC_std__io__FileStatus_IOError;
                    fclose(litaC_fp);
                    return ___result;
                    
                }
                
                
                
            }
            
        } 
        
        litaC_i64 litaC_len = ftell(litaC_fp);
        if(litaC_len < 0L) {
            {
                *(litaC_length) = -(1);
                {
                    litaC_std__io__FileStatus ___result = litaC_std__io__FileStatus_IOError;
                    fclose(litaC_fp);
                    return ___result;
                    
                }
                
                
                
            }
            
        } 
        
        if(fseek(litaC_fp, 0, SEEK_SET)) {
            {
                *(litaC_length) = -(1);
                {
                    litaC_std__io__FileStatus ___result = litaC_std__io__FileStatus_IOError;
                    fclose(litaC_fp);
                    return ___result;
                    
                }
                
                
                
            }
            
        } 
        
        litaC_char* litaC_buf = (litaC_char*)litaC_std__mem__Allocator_alloc(litaC_alloc, sizeof(litaC_char) * ((litaC_u64)litaC_len + 1UL));
        (*(litaC_data)) = litaC_buf;
        litaC_i64 litaC_newLen = fread(litaC_buf, sizeof(litaC_char), litaC_len, litaC_fp);
        if(ferror(litaC_fp)) {
            {
                *(litaC_length) = -(1);
                {
                    litaC_std__io__FileStatus ___result = litaC_std__io__FileStatus_IOError;
                    fclose(litaC_fp);
                    return ___result;
                    
                }
                
                
                
            }
            
        } 
        
        litaC_buf[litaC_newLen] = '\0';
        *(litaC_length) = litaC_newLen;
        {
            litaC_std__io__FileStatus ___result = litaC_std__io__FileStatus_Ok;
            fclose(litaC_fp);
            return ___result;
            
        }
        
        fclose(litaC_fp);
        
        
    }
    
}

litaC_std__io__FileStatus litaC_std__io__WriteFile(const litaC_char* litaC_fileName,const litaC_char* litaC_buffer,litaC_usize litaC_len) {
    {
        FILE* litaC_fp = fopen(litaC_fileName, "w");
        if(litaC_fp == NULL) {
            {
                return litaC_std__io__FileStatus_FileNotFoundError;
                
                
                
            }
            
        } 
        
        
        litaC_std__io__File litaC_file =  {
            .file = litaC_fp
        };
        {
            litaC_std__io__FileStatus ___result = litaC_std__io__File_writeBytes(&((litaC_file)), litaC_buffer, litaC_len);
            fclose(litaC_fp);
            return ___result;
            
        }
        
        fclose(litaC_fp);
        
        
    }
    
}

litaC_std__io__FileStatus litaC_std__io__File_writeBytes(litaC_std__io__File* litaC_file,const litaC_char* litaC_buffer,litaC_usize litaC_len) {
    {
        litaC_u64 litaC_bytesWritten = fwrite((const litaC_void*)litaC_buffer, sizeof(litaC_char), litaC_len, litaC_file->file);
        if(litaC_bytesWritten != litaC_len) {
            {
                return litaC_std__io__FileStatus_IOError;
                
                
                
            }
            
        } 
        
        return litaC_std__io__FileStatus_Ok;
        
        
        
    }
    
}

litaC_std__cmdline__CmdParser litaC_std__cmdline__CmdParserInit(const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_std__cmdline__CmdParser litaC_parser =  {
        
    };
    litaC_std__cmdline__CmdParser_init(&((litaC_parser)), litaC_allocator);
    return litaC_parser;
    
    
}

litaC_void litaC_std__cmdline__CmdParser_init(litaC_std__cmdline__CmdParser* litaC_p,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_p->options = litaC_std__array__ArrayInit_cb_Option_ce_(16, litaC_allocator);
    litaC_p->args = litaC_std__array__ArrayInit_cb__ptr_const_char_ce_(16, litaC_allocator);
    litaC_p->status = litaC_std__cmdline__CmdParserStatus_OK;
    
}

litaC_void litaC_std__cmdline__CmdParser_free(litaC_std__cmdline__CmdParser* litaC_p) {
    litaC_std__array__Array_free_cb_Option_ce_(&((litaC_p->options)));
    litaC_std__array__Array_free_cb__ptr_const_char_ce_(&((litaC_p->args)));
    
}

litaC_void litaC_std__cmdline__CmdParser_addOption(litaC_std__cmdline__CmdParser* litaC_p,const litaC_char* litaC_longName,litaC_char litaC_shortName,const litaC_char* litaC_description,litaC_i32 litaC_flags,const litaC_char* litaC_defaultValue) {
    litaC_std__array__Array_add_cb_Option_ce_(&((litaC_p->options)), (litaC_std__cmdline__Option) {
        .name = litaC_longName,
        .shortName = litaC_shortName,
        .description = litaC_description,
        .value = NULL,
        .flags = litaC_flags,
        .defaultValue = litaC_defaultValue
    });
    
}

litaC_std__cmdline__Option* litaC_std__cmdline__CmdParser_getOption(litaC_std__cmdline__CmdParser* litaC_p,const litaC_char* litaC_longName) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_Option_ce_(&((litaC_p->options)));litaC_i += 1) {
        {
            litaC_std__cmdline__Option* litaC_opt = &(litaC_p->options.elements[litaC_i]);
            if(strcmp(litaC_opt->name, litaC_longName) == 0) {
                {
                    return litaC_opt;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return NULL;
    
    
}

litaC_std__cmdline__Option* litaC_std__cmdline__CmdParser_getOptionShort(litaC_std__cmdline__CmdParser* litaC_p,litaC_char litaC_shortName) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_Option_ce_(&((litaC_p->options)));litaC_i += 1) {
        {
            litaC_std__cmdline__Option* litaC_opt = &(litaC_p->options.elements[litaC_i]);
            if(litaC_opt->shortName == litaC_shortName) {
                {
                    return litaC_opt;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return NULL;
    
    
}

litaC_bool litaC_std__cmdline__CmdParser_hasOption(litaC_std__cmdline__CmdParser* litaC_p,const litaC_char* litaC_longName) {
    litaC_std__cmdline__Option* litaC_opt = litaC_std__cmdline__CmdParser_getOption(litaC_p, litaC_longName);
    if(!(litaC_opt)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_opt->flags & litaC_std__cmdline__OptionFlag_IS_USED;
    
    
}

litaC_bool litaC_std__cmdline__CmdParser_hasOptionShort(litaC_std__cmdline__CmdParser* litaC_p,litaC_char litaC_shortName) {
    litaC_std__cmdline__Option* litaC_opt = litaC_std__cmdline__CmdParser_getOptionShort(litaC_p, litaC_shortName);
    if(!(litaC_opt)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_opt->flags & litaC_std__cmdline__OptionFlag_IS_USED;
    
    
}

litaC_std__cmdline__CmdParserStatus litaC_std__cmdline__CmdParser_parse(litaC_std__cmdline__CmdParser* litaC_p,litaC_i32 litaC_argc,litaC_char** litaC_argv) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_argc;litaC_i += 1) {
        {
            litaC_char* litaC_arg = litaC_argv[litaC_i];
            litaC_i32 litaC_len = strlen(litaC_arg);
            litaC_std__cmdline__Option* litaC_opt = NULL;
            if(litaC_len && litaC_arg[0] == '-') {
                {
                    litaC_char* litaC_normalizedArg = litaC_arg + 1;
                    litaC_opt = (litaC_len < 3) ? litaC_std__cmdline__CmdParser_getOptionShort(litaC_p, litaC_normalizedArg[0]) : litaC_std__cmdline__CmdParser_getOption(litaC_p, litaC_normalizedArg);
                    
                    
                }
                
            } 
            
            if(litaC_opt) {
                {
                    if(litaC_opt->flags & litaC_std__cmdline__OptionFlag_HAS_ARGUMENT) {
                        {
                            if(litaC_i + 1 >= litaC_argc) {
                                {
                                    snprintf(litaC_p->errors, litaC_std__cmdline__MAX_MESSAGE_SIZE, "'%s' is missing argument", litaC_arg);
                                    litaC_p->status = litaC_std__cmdline__CmdParserStatus_MISSING_ARGUMENT;
                                    return litaC_p->status;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_opt->value = litaC_argv[litaC_i + 1];
                            litaC_i += 1;
                            
                            
                        }
                        
                    } 
                    
                    litaC_opt->flags |= litaC_std__cmdline__OptionFlag_IS_USED;
                    
                    
                }
                
            } else {
                {
                    litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_p->args)), litaC_arg);
                    
                    
                }
            } 
            
            
            
        }
    }
    return litaC_std__cmdline__CmdParserStatus_OK;
    
    
}

litaC_void litaC_std__cmdline__CmdParser_printHelp(litaC_std__cmdline__CmdParser* litaC_p,litaC_std__string_buffer__StringBuffer* litaC_sb) {
    if(litaC_p->header) {
        {
            litaC_std__string_buffer__StringBuffer_append(litaC_sb, "%s\n", litaC_p->header);
            
            
        }
        
    } 
    
    litaC_char litaC_name[256] = {0};
    litaC_std__string__String litaC_nameStr = litaC_std__string__StringInit(litaC_name, 256, 0);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_Option_ce_(&((litaC_p->options)));litaC_i += 1) {
        {
            litaC_std__cmdline__Option* litaC_opt = &(litaC_p->options.elements[litaC_i]);
            if(litaC_opt->flags & litaC_std__cmdline__OptionFlag_HAS_ARGUMENT) {
                {
                    litaC_std__string__String_format(&((litaC_nameStr)), "%s <arg>", litaC_opt->name);
                    if(litaC_opt->shortName != '\0') {
                        {
                            litaC_std__string_buffer__StringBuffer_append(litaC_sb, "    -%c, -%-16s", litaC_opt->shortName, litaC_std__string__String_cStr(litaC_nameStr));
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_std__string_buffer__StringBuffer_append(litaC_sb, "    -%-20s", litaC_std__string__String_cStr(litaC_nameStr));
                            
                            
                        }
                    } 
                    
                    
                    
                }
                
            } else {
                {
                    if(litaC_opt->shortName != '\0') {
                        {
                            litaC_std__string_buffer__StringBuffer_append(litaC_sb, "    -%c, -%-16s", litaC_opt->shortName, litaC_opt->name);
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_std__string_buffer__StringBuffer_append(litaC_sb, "    -%-20s", litaC_opt->name);
                            
                            
                        }
                    } 
                    
                    
                    
                }
            } 
            
            const litaC_char* litaC_it = litaC_opt->description;
            while(*(litaC_it)) {
                {
                    litaC_char litaC_c = *(litaC_it);
                    
                    if(litaC_c == '\n') {
                        {
                            litaC_std__string_buffer__StringBuffer_append(litaC_sb, "\n%25s", "");
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_std__string_buffer__StringBuffer_append(litaC_sb, "%c", litaC_c);
                            
                            
                        }
                    } 
                    
                    litaC_it += 1;
                    
                    
                }
            }
            litaC_std__string_buffer__StringBuffer_append(litaC_sb, "\n");
            
            
        }
    }
    
}

litaC_std__string_buffer__StringBuffer litaC_std__string_buffer__StringBufferInit(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__string_buffer__StringBuffer litaC_sb =  {
        
    };
    litaC_std__string_buffer__StringBuffer_init(&((litaC_sb)), litaC_initialSize, litaC_alloc);
    return litaC_sb;
    
    
}

litaC_void litaC_std__string_buffer__StringBuffer_init(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_std__mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_b->alloc = litaC_alloc;
    litaC_b->length = 0;
    litaC_b->capacity = litaC_initialSize;
    litaC_i32 litaC_length = litaC_initialSize;
    litaC_b->buffer = (litaC_char*)litaC_std__mem__Allocator_calloc(litaC_alloc, litaC_length, sizeof(litaC_char));
    
}

litaC_void litaC_std__string_buffer__StringBuffer_free(litaC_std__string_buffer__StringBuffer* litaC_b) {
    if(litaC_b && litaC_b->buffer) {
        {
            litaC_std__mem__Allocator_free(litaC_b->alloc, (litaC_void*)litaC_b->buffer);
            litaC_b->buffer = NULL;
            litaC_b->length = 0;
            litaC_b->capacity = 0;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_std__string_buffer__StringBuffer_appendStr(litaC_std__string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_str) {
    if(litaC_str == NULL) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_len = strlen(litaC_str);
    litaC_std__string_buffer__StringBuffer_appendStrn(litaC_b, litaC_str, litaC_len);
    
}

litaC_void litaC_std__string_buffer__StringBuffer_appendStrn(litaC_std__string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len) {
    if(litaC_str == NULL || litaC_len < 1) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_b->length + litaC_len > litaC_b->capacity) {
        {
            litaC_std__string_buffer__BufferGrow(litaC_b, litaC_len);
            
            
        }
        
    } 
    
    memcpy((litaC_void*)(&(litaC_b->buffer[litaC_b->length])), (const litaC_void*)litaC_str, litaC_len * sizeof(litaC_char));
    litaC_b->length += litaC_len;
    
}

litaC_i32 litaC_std__string_buffer__StringBuffer_appendFloat(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_f64 litaC_f) {
    return litaC_std__string_buffer__StringBuffer_append(litaC_b, "%f", litaC_f);
    
    
}

litaC_i32 litaC_std__string_buffer__StringBuffer_appendI32(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_i) {
    return litaC_std__string_buffer__StringBuffer_append(litaC_b, "%d", litaC_i);
    
    
}

litaC_i32 litaC_std__string_buffer__StringBuffer_appendI64(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_i64 litaC_i) {
    return litaC_std__string_buffer__StringBuffer_append(litaC_b, "%ld", litaC_i);
    
    
}

litaC_i32 litaC_std__string_buffer__StringBuffer_appendU32(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_u32 litaC_i) {
    return litaC_std__string_buffer__StringBuffer_append(litaC_b, "%u", litaC_i);
    
    
}

litaC_i32 litaC_std__string_buffer__StringBuffer_appendU64(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_u64 litaC_i) {
    return litaC_std__string_buffer__StringBuffer_append(litaC_b, "%lu", litaC_i);
    
    
}

litaC_i32 litaC_std__string_buffer__StringBuffer_appendChar(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_char litaC_c) {
    if(litaC_b->length + 1 >= litaC_b->capacity) {
        {
            litaC_std__string_buffer__BufferGrow(litaC_b, 1);
            
            
        }
        
    } 
    
    litaC_b->buffer[litaC_b->length] = litaC_c;
    litaC_b->length += 1;
    return 1;
    
    
}

litaC_i32 litaC_std__string_buffer__StringBuffer_append(litaC_std__string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_format,...) {
    va_list litaC_args1 = {0};
    va_start(litaC_args1, litaC_format);
    litaC_i32 litaC_len = _vscprintf(litaC_format, litaC_args1);
    if(litaC_b->length + litaC_len >= litaC_b->capacity) {
        {
            litaC_i32 litaC_growBy = (litaC_b->length + litaC_len + 1) - litaC_b->capacity;
            litaC_std__string_buffer__BufferGrow(litaC_b, litaC_growBy);
            
            
        }
        
    } 
    
    litaC_len = vsnprintf(&(litaC_b->buffer[litaC_b->length]), litaC_len + 1, litaC_format, litaC_args1);
    va_end(litaC_args1);
    if(litaC_len < 0) {
        {
            return litaC_len;
            
            
            
        }
        
    } 
    
    litaC_b->length += litaC_len;
    return litaC_len;
    
    
}

litaC_i32 litaC_std__string_buffer__StringBuffer_appendArgs(litaC_std__string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_format,va_list litaC_args) {
    va_list litaC_copyArgs = {0};
    va_copy(litaC_copyArgs, litaC_args);
    litaC_i32 litaC_len = _vscprintf(litaC_format, litaC_copyArgs);
    if(litaC_b->length + litaC_len >= litaC_b->capacity) {
        {
            litaC_std__string_buffer__BufferGrow(litaC_b, (litaC_len + 1) - litaC_b->capacity);
            
            
        }
        
    } 
    
    litaC_len = vsnprintf(&(litaC_b->buffer[litaC_b->length]), litaC_len + 1, litaC_format, litaC_copyArgs);
    va_end(litaC_copyArgs);
    if(litaC_len < 0) {
        {
            return litaC_len;
            
            
            
        }
        
    } 
    
    litaC_b->length += litaC_len;
    return litaC_len;
    
    
}

litaC_void litaC_std__string_buffer__StringBuffer_delete(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_start,litaC_i32 litaC_end) {
    if(litaC_b->length == 0) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_start < 0) {
        {
            litaC_start = 0;
            
            
        }
        
    } 
    
    if(litaC_end > litaC_b->length) {
        {
            litaC_end = litaC_b->length;
            
            
        }
        
    } 
    
    if(litaC_start > litaC_end) {
        {
            return;
            
            
            
        }
        
    } 
    
    memmove((litaC_void*)(&(litaC_b->buffer[litaC_start])), (const litaC_void*)(&(litaC_b->buffer[litaC_end])), (litaC_b->length - litaC_end) * sizeof(litaC_char));
    litaC_b->length -= (litaC_end - litaC_start);
    
}

litaC_bool litaC_std__string_buffer__StringBuffer_contains(litaC_std__string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len) {
    return litaC_std__string_buffer__StringBuffer_indexOf(litaC_b, litaC_str, litaC_len) > -(1);
    
    
}

litaC_i32 litaC_std__string_buffer__StringBuffer_indexOf(litaC_std__string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len) {
    return litaC_std__string_buffer__StringBuffer_indexOfAt(litaC_b, litaC_str, litaC_len, 0);
    
    
}

litaC_i32 litaC_std__string_buffer__StringBuffer_indexOfAt(litaC_std__string_buffer__StringBuffer* litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len,litaC_i32 litaC_fromIndex) {
    litaC_std__string_view__StringView litaC_view = litaC_std__string_buffer__StringBuffer_asStringView(litaC_b);
    return litaC_std__string_view__StringView_indexOfAt(litaC_view, litaC_str, litaC_len, litaC_fromIndex);
    
    
}

litaC_i32 litaC_std__string_buffer__StringBuffer_replace(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_start,litaC_i32 litaC_end,const litaC_char* litaC_str) {
    litaC_std__string_buffer__StringBuffer_delete(litaC_b, litaC_start, litaC_end);
    return litaC_std__string_buffer__StringBuffer_insert(litaC_b, litaC_start, "%s", litaC_str);
    
    
}

litaC_i32 litaC_std__string_buffer__StringBuffer_insert(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_index,const litaC_char* litaC_format,...) {
    if(litaC_index < 0) {
        {
            litaC_index = 0;
            
            
        }
        
    } 
    
    if(litaC_index > litaC_b->length) {
        {
            litaC_index = litaC_b->length;
            
            
        }
        
    } 
    
    va_list litaC_args = {0};
    va_start(litaC_args, litaC_format);
    litaC_i32 litaC_len = _vscprintf(litaC_format, litaC_args);
    if(litaC_len < 0) {
        {
            return litaC_len;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_required = litaC_b->length + litaC_len + 1;
    if(litaC_required >= litaC_b->capacity) {
        {
            litaC_std__string_buffer__BufferGrow(litaC_b, litaC_required - litaC_b->capacity);
            
            
        }
        
    } 
    
    litaC_char litaC_startChar = litaC_b->buffer[litaC_index];
    litaC_i32 litaC_moveLength = litaC_b->length - litaC_index;
    memmove((litaC_void*)(&(litaC_b->buffer[litaC_index + litaC_len])), (const litaC_void*)(&(litaC_b->buffer[litaC_index])), litaC_moveLength * sizeof(litaC_char));
    litaC_i32 litaC_n = vsnprintf(&(litaC_b->buffer[litaC_index]), litaC_len + 1, litaC_format, litaC_args);
    va_end(litaC_args);
    if(litaC_n < 0) {
        {
            return litaC_n;
            
            
            
        }
        
    } 
    
    litaC_b->buffer[litaC_index + litaC_len] = litaC_startChar;
    litaC_b->length += litaC_n;
    return litaC_len;
    
    
}

litaC_void litaC_std__string_buffer__StringBuffer_trim(litaC_std__string_buffer__StringBuffer* litaC_b) {
    litaC_i32 litaC_start = 0;
    litaC_i32 litaC_end = 0;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_b->length;litaC_i += 1) {
        {
            litaC_char litaC_c = litaC_b->buffer[litaC_i];
            if(litaC_std__ascii__char_isWhitespace(litaC_c)) {
                {
                    litaC_end += 1;
                    
                    
                }
                
            } else {
                {
                    break;
                    
                    
                }
            } 
            
            
            
        }
    }
    if(litaC_end > litaC_start) {
        {
            litaC_std__string_buffer__StringBuffer_delete(litaC_b, litaC_start, litaC_end);
            
            
        }
        
    } 
    
    litaC_start = litaC_b->length - 1;
    litaC_end = litaC_b->length - 1;
    for(litaC_i32 litaC_i = litaC_b->length - 1;litaC_i >= 0;litaC_i -= 1) {
        {
            litaC_char litaC_c = litaC_b->buffer[litaC_i];
            if(litaC_std__ascii__char_isWhitespace(litaC_c)) {
                {
                    litaC_start -= 1;
                    
                    
                }
                
            } else {
                {
                    break;
                    
                    
                }
            } 
            
            
            
        }
    }
    if(litaC_end > litaC_start) {
        {
            litaC_std__string_buffer__StringBuffer_delete(litaC_b, litaC_start, litaC_end);
            
            
        }
        
    } 
    
    
}

litaC_i32 litaC_std__string_buffer__StringBuffer_copyTo(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_char* litaC_buf,litaC_i32 litaC_len,litaC_bool litaC_addZero) {
    litaC_std__string_view__StringView litaC_view = litaC_std__string_buffer__StringBuffer_asStringView(litaC_b);
    return litaC_std__string_view__StringView_copyTo(litaC_view, litaC_buf, litaC_len, litaC_addZero);
    
    
}

litaC_void litaC_std__string_buffer__StringBuffer_forEach(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_bool (*litaC_fn)(litaC_char)) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_b->length;litaC_i += 1) {
        {
            if(litaC_fn(litaC_b->buffer[litaC_i])) {
                {
                    break;
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

LITAC_INLINE 
litaC_bool litaC_std__string_buffer__StringBuffer_empty(litaC_std__string_buffer__StringBuffer* litaC_b) {
    return litaC_b->length == 0;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__string_buffer__StringBuffer_size(litaC_std__string_buffer__StringBuffer* litaC_b) {
    return litaC_b->length;
    
    
}

LITAC_INLINE 
litaC_std__string_buffer__StringBuffer* litaC_std__string_buffer__StringBuffer_clear(litaC_std__string_buffer__StringBuffer* litaC_b) {
    litaC_b->length = 0;
    return litaC_b;
    
    
}

const litaC_char* litaC_std__string_buffer__StringBuffer_cStrConst(litaC_std__string_buffer__StringBuffer* litaC_b) {
    return (const litaC_char*)litaC_std__string_buffer__StringBuffer_cStr(litaC_b);
    
    
}

litaC_char* litaC_std__string_buffer__StringBuffer_cStr(litaC_std__string_buffer__StringBuffer* litaC_b) {
    if(litaC_b->length + 1 > litaC_b->capacity) {
        {
            litaC_std__string_buffer__BufferGrow(litaC_b, 1);
            
            
        }
        
    } 
    
    litaC_b->buffer[litaC_b->length] = '\0';
    return litaC_b->buffer;
    
    
}

LITAC_INLINE 
litaC_std__string_view__StringView litaC_std__string_buffer__StringBuffer_asStringView(litaC_std__string_buffer__StringBuffer* litaC_b) {
    return (litaC_std__string_view__StringView) {
        .buffer = litaC_b->buffer,
        .length = litaC_b->length
    };
    
    
}

litaC_char litaC_std__string_buffer__StringBuffer_get(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_index) {
    if(litaC_index < 0 || litaC_index >= litaC_b->length) {
        {
            return '\0';
            
            
            
        }
        
    } 
    
    return litaC_b->buffer[litaC_index];
    
    
}

litaC_void litaC_std__string_buffer__StringBuffer_reserve(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_length) {
    litaC_i32 litaC_available = litaC_b->capacity - litaC_b->length;
    if(litaC_available >= litaC_length) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_std__string_buffer__BufferGrow(litaC_b, litaC_length - litaC_available);
    
}

litaC_void litaC_std__string_buffer__BufferGrow(litaC_std__string_buffer__StringBuffer* litaC_b,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_b->capacity * 2;
    litaC_i32 litaC_minReq = litaC_b->capacity + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_char) * (litaC_u64)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_char) * (litaC_u64)litaC_b->capacity);
    litaC_char* litaC_newBuffer = (litaC_char*)litaC_std__mem__Allocator_realloc(litaC_b->alloc, (litaC_void*)litaC_b->buffer, litaC_oldlength, litaC_newlength);
    assert(litaC_newBuffer);
    litaC_b->buffer = litaC_newBuffer;
    litaC_b->capacity = litaC_n;
    
}

litaC_std__string_view__StringView litaC_std__string_view__StringViewInit(const litaC_char* litaC_str,litaC_i32 litaC_len) {
    if(litaC_str == NULL) {
        {
            return (litaC_std__string_view__StringView) {
                .buffer = NULL,
                .length = 0
            };
            
            
            
        }
        
    } 
    
    return (litaC_std__string_view__StringView) {
        .buffer = litaC_str,
        .length = ((litaC_len < 0)) ? strlen(litaC_str) : litaC_len
    };
    
    
}

litaC_u32 litaC_std__string_view__StringView_hash(litaC_std__string_view__StringView litaC_b) {
    litaC_u32 litaC_hash = 5381U;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_b.length;litaC_i += 1) {
        {
            litaC_hash = ((litaC_hash << 5U) + litaC_hash) + ((litaC_u32)(litaC_b.buffer[litaC_i]));
            
            
        }
    }
    return litaC_hash;
    
    
}

litaC_std__string_view__StringView litaC_std__string_view__StringView_substring(litaC_std__string_view__StringView litaC_b,litaC_i32 litaC_start,litaC_i32 litaC_end) {
    litaC_i32 litaC_endIndex = (litaC_end < 0) ? litaC_b.length : litaC_end;
    if(litaC_endIndex <= litaC_start || litaC_start < 0 || litaC_start >= litaC_b.length) {
        {
            return (litaC_std__string_view__StringView) {
                .buffer = NULL,
                .length = 0
            };
            
            
            
        }
        
    } 
    
    return (litaC_std__string_view__StringView) {
        .buffer = &(litaC_b.buffer[litaC_start]),
        .length = litaC_endIndex - litaC_start
    };
    
    
}

litaC_bool litaC_std__string_view__StringView_startsWith(litaC_std__string_view__StringView litaC_b,const litaC_char* litaC_prefix,litaC_i32 litaC_len,litaC_i32 litaC_fromIndex) {
    if(!(litaC_prefix)) {
        return litaC_false;
        
        
    } 
    
    const litaC_char* litaC_ta = litaC_b.buffer;
    litaC_i32 litaC_to = litaC_fromIndex;
    const litaC_char* litaC_pa = litaC_prefix;
    litaC_i32 litaC_po = 0;
    litaC_i32 litaC_pc = ((litaC_len < 0)) ? strlen(litaC_prefix) : litaC_len;
    if((litaC_fromIndex < 0) || (litaC_fromIndex > litaC_b.length - litaC_pc)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    while((litaC_pc -= 1) >= 0) {
        {
            if(litaC_ta[litaC_to] != litaC_pa[litaC_po]) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_to += 1;
            litaC_po += 1;
            
            
        }
    }
    return litaC_true;
    
    
}

litaC_bool litaC_std__string_view__StringView_endsWith(litaC_std__string_view__StringView litaC_b,const litaC_char* litaC_suffix,litaC_i32 litaC_len) {
    if(!(litaC_suffix)) {
        return litaC_false;
        
        
    } 
    
    litaC_len = ((litaC_len < 0)) ? strlen(litaC_suffix) : litaC_len;
    return litaC_std__string_view__StringView_startsWith(litaC_b, litaC_suffix, litaC_len, litaC_b.length - litaC_len);
    
    
}

litaC_bool litaC_std__string_view__StringView_equals(litaC_std__string_view__StringView litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len) {
    if(!(litaC_str)) {
        {
            return litaC_b.buffer == NULL;
            
            
            
        }
        
    } 
    
    litaC_len = ((litaC_len < 0)) ? strlen(litaC_str) : litaC_len;
    if(litaC_b.length != litaC_len) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return strncmp(litaC_b.buffer, litaC_str, litaC_len) == 0;
    
    
}

litaC_bool litaC_std__string_view__StringView_equalsStringView(litaC_std__string_view__StringView litaC_b,litaC_std__string_view__StringView litaC_other) {
    return litaC_std__string_view__StringView_equals(litaC_b, litaC_other.buffer, litaC_other.length);
    
    
}

litaC_bool litaC_std__string_view__StringView_contains(litaC_std__string_view__StringView litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len) {
    return litaC_std__string_view__StringView_indexOf(litaC_b, litaC_str, litaC_len) > -(1);
    
    
}

litaC_i32 litaC_std__string_view__StringView_indexOf(litaC_std__string_view__StringView litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len) {
    return litaC_std__string_view__StringView_indexOfAt(litaC_b, litaC_str, litaC_len, 0);
    
    
}

litaC_i32 litaC_std__string_view__StringView_indexOfAt(litaC_std__string_view__StringView litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len,litaC_i32 litaC_fromIndex) {
    if(!(litaC_str)) {
        return -(1);
        
        
    } 
    
    const litaC_char* litaC_target = litaC_str;
    const litaC_char* litaC_source = litaC_b.buffer;
    litaC_i32 litaC_targetOffset = 0;
    litaC_i32 litaC_sourceOffset = 0;
    litaC_char litaC_first = litaC_target[0];
    litaC_i32 litaC_targetCount = litaC_len;
    if(litaC_len < 0) {
        {
            litaC_targetCount = strlen(litaC_str);
            
            
        }
        
    } 
    
    litaC_i32 litaC_max = litaC_sourceOffset + (litaC_b.length - litaC_targetCount);
    for(litaC_i32 litaC_i = litaC_sourceOffset + litaC_fromIndex;litaC_i <= litaC_max;litaC_i += 1) {
        {
            if(litaC_source[litaC_i] != litaC_first) {
                {
                    while(litaC_i <= litaC_max && litaC_source[litaC_i] != litaC_first) {
                        {
                            litaC_i += 1;
                            
                            
                        }
                    }
                    
                    
                }
                
            } 
            
            if(litaC_i <= litaC_max) {
                {
                    litaC_i32 litaC_j = litaC_i + 1;
                    litaC_i32 litaC_end = litaC_j + litaC_targetCount - 1;
                    for(litaC_i32 litaC_k = litaC_targetOffset + 1;litaC_j < litaC_end && litaC_source[litaC_j] == litaC_target[litaC_k];) {
                        {
                            litaC_j += 1;
                            litaC_k += 1;
                            
                            
                        }
                    }
                    if(litaC_j == litaC_end) {
                        {
                            return litaC_i - litaC_sourceOffset;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return -(1);
    
    
}

litaC_i32 litaC_std__string_view__StringView_lastIndexOfAt(litaC_std__string_view__StringView litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len,litaC_i32 litaC_fromIndex) {
    litaC_i32 litaC_sourceCount = litaC_b.length;
    litaC_i32 litaC_targetCount = (litaC_len < 0) ? strlen(litaC_str) : litaC_len;
    litaC_i32 litaC_targetOffset = 0;
    litaC_i32 litaC_sourceOffset = 0;
    const litaC_char* litaC_source = litaC_b.buffer;
    const litaC_char* litaC_target = litaC_str;
    litaC_i32 litaC_rightIndex = litaC_sourceCount - litaC_targetCount;
    if(litaC_fromIndex < 0) {
        {
            litaC_fromIndex = litaC_sourceCount;
            
            
        }
        
    } 
    
    if(litaC_fromIndex > litaC_rightIndex) {
        {
            litaC_fromIndex = litaC_rightIndex;
            
            
        }
        
    } 
    
    if(litaC_targetCount == 0) {
        {
            return litaC_fromIndex;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_strLastIndex = litaC_targetOffset + litaC_targetCount - 1;
    litaC_char litaC_strLastChar = litaC_target[litaC_strLastIndex];
    litaC_i32 litaC_min = litaC_sourceOffset + litaC_targetCount - 1;
    litaC_i32 litaC_i = litaC_min + litaC_fromIndex;
    startSearchForLastChar:;
    
    while(litaC_true) {
        {
            while(litaC_i >= litaC_min && litaC_source[litaC_i] != litaC_strLastChar) {
                {
                    litaC_i -= 1;
                    
                    
                }
            }
            if(litaC_i < litaC_min) {
                {
                    return -(1);
                    
                    
                    
                }
                
            } 
            
            litaC_i32 litaC_j = litaC_i - 1;
            litaC_i32 litaC_start = litaC_j - (litaC_targetCount - 1);
            litaC_i32 litaC_k = litaC_strLastIndex - 1;
            while(litaC_j > litaC_start) {
                {
                    if(litaC_source[litaC_j] != litaC_target[litaC_k]) {
                        {
                            litaC_i -= 1;
                            goto startSearchForLastChar;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_j -= 1;
                    litaC_k -= 1;
                    
                    
                }
            }
            return litaC_start - litaC_sourceOffset + 1;
            
            
            
        }
    }
    
}

litaC_i32 litaC_std__string_view__StringView_copyTo(litaC_std__string_view__StringView litaC_b,litaC_char* litaC_buf,litaC_i32 litaC_len,litaC_bool litaC_addZero) {
    if(!(litaC_buf) || litaC_len == 0) {
        return 0;
        
        
    } 
    
    litaC_i32 litaC_bytesCopied = litaC_len;
    if(litaC_b.length < litaC_len) {
        {
            litaC_bytesCopied = litaC_b.length;
            
            
        }
        
    } 
    
    memcpy((litaC_void*)litaC_buf, (const litaC_void*)(&(litaC_b.buffer[0])), litaC_bytesCopied * sizeof(litaC_char));
    if(litaC_addZero) {
        litaC_buf[litaC_bytesCopied] = '\0';
        
    } 
    
    return (litaC_bytesCopied);
    
    
}

litaC_std__string_view__StringView litaC_std__string_view__StringView_copy(litaC_std__string_view__StringView litaC_s,const litaC_std__mem__Allocator* litaC_allocator) {
    if(litaC_s.length < 1) {
        {
            return (litaC_std__string_view__StringView) {
                .buffer = NULL,
                .length = 0
            };
            
            
            
        }
        
    } 
    
    litaC_char* litaC_copiedStr = (litaC_char*)litaC_std__mem__Allocator_alloc(litaC_allocator, (litaC_s.length + 1) * sizeof(litaC_char));
    memcpy(litaC_copiedStr, litaC_s.buffer, litaC_s.length);
    litaC_copiedStr[litaC_s.length] = '\0';
    return (litaC_std__string_view__StringView) {
        .buffer = litaC_copiedStr,
        .length = litaC_s.length
    };
    
    
}

litaC_void litaC_std__string_view__StringView_forEach(litaC_std__string_view__StringView litaC_b,litaC_bool (*litaC_fn)(litaC_char)) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_b.length;litaC_i += 1) {
        {
            if(litaC_fn(litaC_b.buffer[litaC_i])) {
                {
                    break;
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

litaC_bool litaC_std__string_view__StringView_empty(litaC_std__string_view__StringView litaC_b) {
    return litaC_b.length == 0;
    
    
}

litaC_i32 litaC_std__string_view__StringView_size(litaC_std__string_view__StringView litaC_b) {
    return litaC_b.length;
    
    
}

litaC_void litaC_std__string_view__StringView_clear(litaC_std__string_view__StringView litaC_b) {
    litaC_b.length = 0;
    
}

litaC_char litaC_std__string_view__StringView_get(litaC_std__string_view__StringView litaC_b,litaC_i32 litaC_index) {
    if(litaC_index < 0 || litaC_index >= litaC_b.length) {
        {
            return '\0';
            
            
            
        }
        
    } 
    
    return litaC_b.buffer[litaC_index];
    
    
}

litaC_bool litaC_std__ascii__char_isWhitespace(litaC_char litaC_this) {
    return litaC_std__ascii__WHITESPACE[litaC_this & 0xFF];
    
    
}

litaC_bool litaC_std__ascii__char_isNumeric(litaC_char litaC_this) {
    return litaC_this > 47 && litaC_this < 58;
    
    
}

litaC_bool litaC_std__ascii__char_isAlphabetic(litaC_char litaC_this) {
    return (litaC_this > 64 && litaC_this < 91) || (litaC_this > 96 && litaC_this < 123);
    
    
}

litaC_bool litaC_std__ascii__char_isAlphanumeric(litaC_char litaC_this) {
    return litaC_std__ascii__char_isNumeric(litaC_this) || litaC_std__ascii__char_isAlphabetic(litaC_this);
    
    
}

litaC_std__string__String litaC_std__string__CString(litaC_char* litaC_str,litaC_i32 litaC_len) {
    if(litaC_str == NULL) {
        {
            return (litaC_std__string__String) {
                .buffer = NULL,
                .length = 0,
                .capacity = 0
            };
            
            
            
        }
        
    } 
    
    if(litaC_len < 0) {
        {
            litaC_len = strlen(litaC_str);
            
            
        }
        
    } 
    
    return (litaC_std__string__String) {
        .buffer = litaC_str,
        .length = litaC_len,
        .capacity = litaC_len
    };
    
    
}

litaC_std__string__String litaC_std__string__StringInit(litaC_char* litaC_str,litaC_i32 litaC_capacity,litaC_i32 litaC_len) {
    if(litaC_str == NULL) {
        {
            return (litaC_std__string__String) {
                .buffer = NULL,
                .length = 0,
                .capacity = 0
            };
            
            
            
        }
        
    } 
    
    if(litaC_len < 0) {
        {
            litaC_len = strlen(litaC_str);
            
            
        }
        
    } 
    
    if(litaC_len > litaC_capacity) {
        {
            litaC_len = litaC_capacity;
            
            
        }
        
    } 
    
    return (litaC_std__string__String) {
        .buffer = litaC_str,
        .length = litaC_len,
        .capacity = litaC_capacity
    };
    
    
}

litaC_i32 litaC_std__string__String_format(litaC_std__string__String* litaC_s,const litaC_char* litaC_format,...) {
    va_list litaC_args = {0};
    va_start(litaC_args, litaC_format);
    litaC_i32 litaC_len = vsnprintf(litaC_s->buffer, litaC_s->capacity, litaC_format, litaC_args);
    va_end(litaC_args);
    if(litaC_len < 0) {
        {
            return litaC_len;
            
            
            
        }
        
    } 
    
    litaC_s->length = litaC_len;
    return litaC_len;
    
    
}

litaC_i32 litaC_std__string__String_append(litaC_std__string__String* litaC_s,const litaC_char* litaC_format,...) {
    va_list litaC_args1 = {0};
    va_start(litaC_args1, litaC_format);
    litaC_i32 litaC_len = vsnprintf(litaC_s->buffer + litaC_s->length, litaC_s->capacity - litaC_s->length, litaC_format, litaC_args1);
    va_end(litaC_args1);
    if(litaC_len < 0) {
        {
            return litaC_len;
            
            
            
        }
        
    } 
    
    litaC_s->length += litaC_len;
    return litaC_len;
    
    
}

litaC_void litaC_std__string__String_appendStr(litaC_std__string__String* litaC_b,const litaC_char* litaC_str) {
    if(litaC_str == NULL) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_len = strlen(litaC_str);
    litaC_std__string__String_appendStrn(litaC_b, litaC_str, litaC_len);
    
}

litaC_void litaC_std__string__String_appendStrn(litaC_std__string__String* litaC_b,const litaC_char* litaC_str,litaC_i32 litaC_len) {
    if(litaC_str == NULL || litaC_len < 1) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_b->length + litaC_len > litaC_b->capacity) {
        {
            litaC_len = litaC_b->capacity - litaC_b->length;
            
            
        }
        
    } 
    
    memcpy((litaC_void*)(&(litaC_b->buffer[litaC_b->length])), (const litaC_void*)litaC_str, litaC_len * sizeof(litaC_char));
    litaC_b->length += litaC_len;
    
}

litaC_void litaC_std__string__String_setStrn(litaC_std__string__String* litaC_s,const litaC_char* litaC_str,litaC_i32 litaC_len) {
    if(litaC_str == NULL || litaC_len < 1) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_len > litaC_s->capacity) {
        {
            litaC_len = litaC_s->capacity;
            
            
        }
        
    } 
    
    memcpy((litaC_void*)(&(litaC_s->buffer[0])), (const litaC_void*)litaC_str, litaC_len * sizeof(litaC_char));
    litaC_s->length = litaC_len;
    
}

litaC_void litaC_std__string__String_appendChar(litaC_std__string__String* litaC_s,litaC_char litaC_c) {
    if(litaC_s->length >= litaC_s->capacity) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_s->buffer[litaC_s->length] = litaC_c;
    litaC_s->length += 1;
    
}

litaC_std__string_view__StringView litaC_std__string__String_substring(litaC_std__string__String litaC_s,litaC_i32 litaC_start,litaC_i32 litaC_end) {
    if(litaC_start < 0 || litaC_end < litaC_start) {
        {
            return (litaC_std__string_view__StringView) {
                .buffer = NULL,
                .length = 0
            };
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_len = litaC_end - litaC_start;
    return (litaC_std__string_view__StringView) {
        .buffer = litaC_s.buffer + litaC_start,
        .length = litaC_len
    };
    
    
}

litaC_std__string_view__StringView litaC_std__string__String_asView(litaC_std__string__String litaC_s) {
    return (litaC_std__string_view__StringView) {
        .buffer = litaC_s.buffer,
        .length = litaC_s.length
    };
    
    
}

litaC_void litaC_std__string__String_memset(litaC_std__string__String litaC_s,litaC_i32 litaC_value) {
    if(litaC_s.capacity < 1) {
        return;
        
        
    } 
    
    memset((litaC_void*)litaC_s.buffer, litaC_value, litaC_s.capacity * sizeof(litaC_char));
    
}

litaC_void litaC_std__string__String_toLower(litaC_std__string__String litaC_s) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_s.length;litaC_i += 1) {
        {
            litaC_s.buffer[litaC_i] = (litaC_char)tolower(litaC_s.buffer[litaC_i]);
            
            
        }
    }
    
}

litaC_void litaC_std__string__String_toUpper(litaC_std__string__String litaC_s) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_s.length;litaC_i += 1) {
        {
            litaC_s.buffer[litaC_i] = (litaC_char)toupper(litaC_s.buffer[litaC_i]);
            
            
        }
    }
    
}

litaC_std__string__String litaC_std__string__String_copy(litaC_std__string__String litaC_s,const litaC_std__mem__Allocator* litaC_allocator) {
    if(litaC_s.length < 1) {
        {
            return (litaC_std__string__String) {
                .buffer = NULL,
                .length = 0,
                .capacity = 0
            };
            
            
            
        }
        
    } 
    
    litaC_char* litaC_copiedStr = (litaC_char*)litaC_std__mem__Allocator_alloc(litaC_allocator, (litaC_s.length + 1) * sizeof(litaC_char));
    memcpy(litaC_copiedStr, litaC_s.buffer, litaC_s.length);
    litaC_copiedStr[litaC_s.length] = '\0';
    return (litaC_std__string__String) {
        .buffer = litaC_copiedStr,
        .length = litaC_s.length,
        .capacity = litaC_s.length
    };
    
    
}

litaC_void litaC_std__string__String_adjust(litaC_std__string__String* litaC_s) {
    litaC_s->length = strnlen(litaC_s->buffer, litaC_s->capacity);
    
}

litaC_void litaC_std__string__String_clear(litaC_std__string__String* litaC_s) {
    litaC_std__string__String_memset(*((litaC_s)), 0);
    litaC_s->length = 0;
    
}

litaC_bool litaC_std__string__String_empty(litaC_std__string__String litaC_s) {
    return litaC_s.length < 1;
    
    
}

litaC_i32 litaC_std__string__String_size(litaC_std__string__String litaC_s) {
    return litaC_s.length;
    
    
}

litaC_i32 litaC_std__string__String_remaining(litaC_std__string__String litaC_s) {
    return litaC_s.capacity - litaC_s.length;
    
    
}

litaC_char* litaC_std__string__String_cStr(litaC_std__string__String litaC_s) {
    if(litaC_s.length < litaC_s.capacity && litaC_s.length > 0) {
        {
            litaC_s.buffer[litaC_s.length] = '\0';
            
            
        }
        
    } 
    
    return litaC_s.buffer;
    
    
}

const litaC_char* litaC_std__string__String_cStrConst(litaC_std__string__String litaC_s) {
    if(litaC_s.length < litaC_s.capacity && litaC_s.length > 0) {
        {
            litaC_s.buffer[litaC_s.length] = '\0';
            
            
        }
        
    } 
    
    return (const litaC_char*)litaC_s.buffer;
    
    
}

litaC_char* litaC_std__string__StringClone(const litaC_char* litaC_original,litaC_i32 litaC_len,const litaC_std__mem__Allocator* litaC_allocator) {
    if(!(litaC_original)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    if(litaC_len < 0) {
        {
            litaC_len = strlen(litaC_original);
            
            
        }
        
    } 
    
    litaC_char* litaC_copiedStr = NULL;
    if(litaC_len > 0) {
        {
            litaC_copiedStr = (litaC_char*)litaC_std__mem__Allocator_alloc(litaC_allocator, (litaC_len + 1) * sizeof(litaC_char));
            memcpy(litaC_copiedStr, litaC_original, litaC_len);
            litaC_copiedStr[litaC_len] = '\0';
            
            
        }
        
    } 
    
    return litaC_copiedStr;
    
    
}

litaC_char* litaC_std__string__StringCopy(const litaC_char* litaC_src,litaC_char* litaC_dest,litaC_usize litaC_size) {
    if(!(litaC_src)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    if(litaC_size > 0) {
        {
            litaC_usize litaC_i = {0};
            for(litaC_i = 0;
            litaC_i < litaC_size - 1 && litaC_src[litaC_i];litaC_i += 1) {
                {
                    litaC_dest[litaC_i] = litaC_src[litaC_i];
                    
                    
                }
            }
            litaC_dest[litaC_i] = '\0';
            
            
        }
        
    } 
    
    return litaC_dest;
    
    
}

const litaC_char* litaC_std__system__ArchAsStr(Lita_ArchType litaC_type) {
    switch(litaC_type) {
        case Lita_ArchType_UNKNOWN: {
            return "UNKNOWN";
            
            
            
        }
        case Lita_ArchType_ARM32: {
            return "ARM32";
            
            
            
        }
        case Lita_ArchType_ARM64: {
            return "ARM64";
            
            
            
        }
        case Lita_ArchType_X86: {
            return "X86";
            
            
            
        }
        case Lita_ArchType_X86_64: {
            return "X86_64";
            
            
            
        }
        case Lita_ArchType_SPARC: {
            return "SPARC";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

Lita_ArchType litaC_std__system__ArchFromStr(const litaC_char* litaC_str,litaC_usize litaC_len) {
    if(!(litaC_str)) {
        {
            return Lita_ArchType_UNKNOWN;
            
            
            
        }
        
    } 
    
    if(litaC_std__system__strcicmp(litaC_str, "ARM32", litaC_len) == 0) {
        {
            return Lita_ArchType_ARM32;
            
            
            
        }
        
    } 
    
    if(litaC_std__system__strcicmp(litaC_str, "ARM64", litaC_len) == 0) {
        {
            return Lita_ArchType_ARM64;
            
            
            
        }
        
    } 
    
    if(litaC_std__system__strcicmp(litaC_str, "X86", litaC_len) == 0) {
        {
            return Lita_ArchType_X86;
            
            
            
        }
        
    } 
    
    if(litaC_std__system__strcicmp(litaC_str, "X86_64", litaC_len) == 0) {
        {
            return Lita_ArchType_X86_64;
            
            
            
        }
        
    } 
    
    if(litaC_std__system__strcicmp(litaC_str, "SPARC", litaC_len) == 0) {
        {
            return Lita_ArchType_SPARC;
            
            
            
        }
        
    } 
    
    return Lita_ArchType_UNKNOWN;
    
    
}

const litaC_char* litaC_std__system__OSAsStr(Lita_OSType litaC_type) {
    switch(litaC_type) {
        case Lita_OSType_WINDOWS: {
            return "WINDOWS";
            
            
            
        }
        case Lita_OSType_ANDROID: {
            return "ANDROID";
            
            
            
        }
        case Lita_OSType_LINUX: {
            return "LINUX";
            
            
            
        }
        case Lita_OSType_BSD: {
            return "BSD";
            
            
            
        }
        case Lita_OSType_IOS: {
            return "IOS";
            
            
            
        }
        case Lita_OSType_MAC: {
            return "MAC";
            
            
            
        }
        case Lita_OSType_OTHER: {
            return "OTHER";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

Lita_OSType litaC_std__system__OSFromStr(const litaC_char* litaC_str,litaC_usize litaC_len) {
    if(!(litaC_str)) {
        {
            return Lita_OSType_OTHER;
            
            
            
        }
        
    } 
    
    if(litaC_std__system__strcicmp(litaC_str, "WINDOWS", litaC_len) == 0) {
        {
            return Lita_OSType_WINDOWS;
            
            
            
        }
        
    } 
    
    if(litaC_std__system__strcicmp(litaC_str, "ANDROID", litaC_len) == 0) {
        {
            return Lita_OSType_ANDROID;
            
            
            
        }
        
    } 
    
    if(litaC_std__system__strcicmp(litaC_str, "LINUX", litaC_len) == 0) {
        {
            return Lita_OSType_LINUX;
            
            
            
        }
        
    } 
    
    if(litaC_std__system__strcicmp(litaC_str, "BSD", litaC_len) == 0) {
        {
            return Lita_OSType_BSD;
            
            
            
        }
        
    } 
    
    if(litaC_std__system__strcicmp(litaC_str, "IOS", litaC_len) == 0) {
        {
            return Lita_OSType_IOS;
            
            
            
        }
        
    } 
    
    if(litaC_std__system__strcicmp(litaC_str, "MAC", litaC_len) == 0) {
        {
            return Lita_OSType_MAC;
            
            
            
        }
        
    } 
    
    if(litaC_std__system__strcicmp(litaC_str, "MACOS", litaC_len) == 0) {
        {
            return Lita_OSType_MAC;
            
            
            
        }
        
    } 
    
    return Lita_OSType_OTHER;
    
    
}



litaC_bool litaC_std__system__SystemInit() {
    return litaC_std__system__system_win___SystemInit();
    
    
}

Lita_OSType litaC_std__system__GetOS() {
    return litaOS;
    
    
}

Lita_ArchType litaC_std__system__GetArch() {
    return litaArch;
    
    
}

litaC_char* litaC_std__system__GetEnv(const litaC_char* litaC_varName) {
    return getenv(litaC_varName);
    
    
}

const litaC_char* litaC_std__system__CurrentWorkingPath() {
    return litaC_std__system__system_win___CurrentWorkingPath();
    
    
}

litaC_bool litaC_std__system__FileTruncate(const litaC_char* litaC_filename,litaC_usize litaC_newLength) {
    return litaC_std__system__system_win___FileTruncate(litaC_filename, litaC_newLength);
    
    
}

litaC_bool litaC_std__system__FileTruncateFile(FILE* litaC_file,litaC_usize litaC_newLength) {
    return litaC_std__system__system_win___FileTruncateFile(litaC_file, litaC_newLength);
    
    
}

litaC_bool litaC_std__system__FileDelete(const litaC_char* litaC_filename) {
    return litaC_std__system__system_win___FileDelete(litaC_filename);
    
    
}

litaC_bool litaC_std__system__FileExists(const litaC_char* litaC_filename) {
    FileStat litaC_s = {0};
    return _stat(litaC_filename, &(litaC_s)) == 0;
    
    
}

litaC_bool litaC_std__system__FileMove(const litaC_char* litaC_srcFilename,const litaC_char* litaC_destFilename) {
    return rename(litaC_srcFilename, litaC_destFilename) == 0;
    
    
}

litaC_bool litaC_std__system__FileIsDir(const litaC_char* litaC_filename) {
    return litaC_std__system__system_win___FileIsDir(litaC_filename);
    
    
}

litaC_bool litaC_std__system__Mkdir(const litaC_char* litaC_dir) {
    return litaC_std__system__system_win___Mkdir(litaC_dir);
    
    
}

litaC_bool litaC_std__system__Mkdirs(const litaC_char* litaC_dir) {
    litaC_char litaC_temp[_MAX_PATH] = {0};
    litaC_std__string__String litaC_path = litaC_std__string__StringInit(litaC_temp, _MAX_PATH, 0);
    litaC_std__string_view__StringView litaC_workingPath = litaC_std__string_view__StringViewInit(litaC_dir, -(1));
    litaC_i32 litaC_index = 0;
    if(litaC_workingPath.length > 2) {
        {
            if(litaC_workingPath.buffer[2] == ':') {
                {
                    litaC_std__string__String_append(&((litaC_path)), "%.*s", 2, litaC_workingPath.buffer);
                    litaC_index = 3;
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    while(litaC_index >= 0) {
        {
            litaC_index = litaC_std__string_view__StringView_indexOfAt(litaC_workingPath, "/", 1, litaC_index);
            if(litaC_index > -(1)) {
                {
                    litaC_std__string__String_format(&((litaC_path)), "%.*s", litaC_index, litaC_workingPath.buffer);
                    litaC_std__system__system_win___Mkdir(litaC_std__string__String_cStr(litaC_path));
                    litaC_index += 1;
                    
                    
                }
                
            } else {
                {
                    break;
                    
                    
                }
            } 
            
            
            
        }
    }
    return litaC_std__system__system_win___Mkdir(litaC_dir);
    
    
}

litaC_char* litaC_std__system__FilePath(const litaC_char* litaC_filename,litaC_char* litaC_out) {
    litaC_i32 litaC_index = 0;
    if(!(litaC_filename)) {
        {
            goto end;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_len = strlen(litaC_filename);
    if(litaC_len > 0) {
        {
            for(litaC_index = litaC_len - 1;
            litaC_index >= 0;litaC_index -= 1) {
                {
                    litaC_char litaC_c = litaC_filename[litaC_index];
                    if(litaC_c == '/' || litaC_c == '\\') {
                        {
                            memcpy(litaC_out, litaC_filename, litaC_index);
                            goto end;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            litaC_index = 0;
            
            
        }
        
    } 
    
    end:;
    
    litaC_out[litaC_index] = '\0';
    return litaC_out;
    
    
}

litaC_char* litaC_std__system__FileParent(const litaC_char* litaC_filename,litaC_char* litaC_out,litaC_i32* litaC_length) {
    litaC_i32 litaC_index = 0;
    if(!(litaC_filename)) {
        {
            goto end;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_len = strlen(litaC_filename);
    if(litaC_len > 0) {
        {
            litaC_index = litaC_len - 1;
            if(litaC_filename[litaC_len - 1] == '/') {
                {
                    litaC_index -= 1;
                    
                    
                }
                
            } 
            
            for(;litaC_index >= 0;litaC_index -= 1) {
                {
                    litaC_char litaC_c = litaC_filename[litaC_index];
                    if(litaC_c == '/' || litaC_c == '\\') {
                        {
                            memcpy(litaC_out, litaC_filename, litaC_index);
                            goto end;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            litaC_index = 0;
            
            
        }
        
    } 
    
    end:;
    
    if(litaC_length) {
        {
            (*(litaC_length)) = litaC_index;
            
            
        }
        
    } 
    
    litaC_out[litaC_index] = '\0';
    return litaC_out;
    
    
}

litaC_char* litaC_std__system__PathNormalize(const litaC_char* litaC_filename,litaC_char* litaC_out) {
    if(!(litaC_filename)) {
        {
            goto end;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_len = strlen(litaC_filename);
    litaC_i32 litaC_i = 0;
    for(;litaC_i < litaC_len;litaC_i += 1) {
        {
            litaC_char litaC_c = litaC_filename[litaC_i];
            if(litaC_c == '\\') {
                {
                    litaC_c = '/';
                    
                    
                }
                
            } 
            
            litaC_out[litaC_i] = litaC_c;
            
            
        }
    }
    end:;
    
    litaC_out[litaC_i] = '\0';
    return litaC_out;
    
    
}

litaC_i32 litaC_std__system__strcicmp(const litaC_char* litaC_a,const litaC_char* litaC_b,litaC_usize litaC_size) {
    if(litaC_a == litaC_b) {
        return 0;
        
        
    } 
    
    if(!(litaC_a) && litaC_b) {
        return -(1);
        
        
    } 
    
    if(litaC_a && !(litaC_b)) {
        return 1;
        
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_size;litaC_i += 1) {
        {
            litaC_char litaC_ac = *(litaC_a);
            litaC_char litaC_bc = *(litaC_b);
            if(!(litaC_ac) && litaC_bc) {
                return -(1);
                
                
            } 
            
            if(litaC_ac && !(litaC_bc)) {
                return 1;
                
                
            } 
            
            if(!(litaC_ac) && !(litaC_bc)) {
                return 0;
                
                
            } 
            
            litaC_i32 litaC_d = tolower(litaC_ac) - tolower(litaC_bc);
            if(litaC_d != 0) {
                {
                    return litaC_d;
                    
                    
                    
                }
                
            } 
            
            litaC_a += 1;
            litaC_b += 1;
            
            
        }
    }
    return 0;
    
    
}

litaC_char* litaC_std__system__GetAbsolutePath(const litaC_char* litaC_pwd,const litaC_char* litaC_path,litaC_char* litaC_output) {
    litaC_std__string__String litaC_absStr = litaC_std__string__StringInit(litaC_output, _MAX_PATH, 0);
    litaC_std__string_view__StringView litaC_pathStr = litaC_std__string_view__StringViewInit(litaC_path, -(1));
    if(litaC_std__string_view__StringView_startsWith(litaC_pathStr, ".", -(1), 0)) {
        {
            litaC_std__string__String_append(&((litaC_absStr)), "%s/", litaC_pwd);
            
            
        }
        
    } 
    
    while(*(litaC_path)) {
        {
            if(litaC_path[0] == '\\') {
                {
                    if(litaC_path[1] == '\\') {
                        {
                            litaC_path += 1;
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__string__String_appendChar(&((litaC_absStr)), '/');
                    
                    
                }
                
            } else {
                if(litaC_path[0] == '.') {
                    {
                        if(litaC_path[1] == '.') {
                            {
                                litaC_i32 litaC_len = litaC_absStr.length;
                                litaC_i32 litaC_index = litaC_len - 1;
                                litaC_i32 litaC_upCount = 0;
                                for(;litaC_index >= 0;litaC_index -= 1) {
                                    {
                                        if(litaC_absStr.buffer[litaC_index] == '/' || litaC_absStr.buffer[litaC_index] == '\\') {
                                            {
                                                litaC_upCount += 1;
                                                if(litaC_upCount > 1) {
                                                    {
                                                        break;
                                                        
                                                        
                                                    }
                                                    
                                                } 
                                                
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        
                                        
                                    }
                                }
                                if(litaC_index < 0) {
                                    {
                                        litaC_index = 0;
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_absStr.length = litaC_index;
                                if(litaC_absStr.buffer[litaC_index] == '/' || litaC_absStr.buffer[litaC_index] == '\\') {
                                    {
                                        litaC_absStr.length = litaC_index + 1;
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } else {
                            if(litaC_path[1] == '/' || litaC_path[1] == '\\') {
                                {
                                    litaC_path += 1;
                                    
                                    
                                }
                                
                            } else {
                                {
                                    litaC_std__string__String_appendChar(&((litaC_absStr)), '.');
                                    
                                    
                                }
                            } 
                            
                        } 
                        
                        
                        
                    }
                    
                } else {
                    {
                        litaC_std__string__String_appendChar(&((litaC_absStr)), *(litaC_path));
                        
                        
                    }
                } 
                
            } 
            
            litaC_path += 1;
            
            
        }
    }
    return litaC_std__string__String_cStr(litaC_absStr);
    
    
}

litaC_bool litaC_std__system__PathEquals(const litaC_char* litaC_a,const litaC_char* litaC_b) {
    return litaC_std__system__strcicmp(litaC_a, litaC_b, _MAX_PATH) == 0;
    
    
}

litaC_char* litaC_std__system__FilePathToUri(const litaC_char* litaC_path,litaC_char* litaC_output) {
    litaC_std__string__String litaC_outputStr = litaC_std__string__StringInit(litaC_output, _MAX_PATH, 0);
    {
        litaC_std__string__String_append(&((litaC_outputStr)), "%s", "file:///");
        
        
    }
    while(*(litaC_path)) {
        {
            const litaC_char* litaC_escaped = litaC_std__system__uriEscapeChars[(litaC_i32)(*(litaC_path))];
            if(litaC_escaped) {
                {
                    litaC_std__string__String_append(&((litaC_outputStr)), "%s", litaC_escaped);
                    
                    
                }
                
            } else {
                {
                    litaC_std__string__String_appendChar(&((litaC_outputStr)), *(litaC_path));
                    
                    
                }
            } 
            
            litaC_path += 1;
            
            
        }
    }
    return litaC_std__string__String_cStr(litaC_outputStr);
    
    
}

litaC_char* litaC_std__system__UriToFilePath(const litaC_char* litaC_uri,litaC_char* litaC_output) {
    if(strncmp(litaC_uri, "file:///", 8) == 0) {
        {
            {
                litaC_uri = &(litaC_uri[8]);
                
                
            }
            
            
        }
        
    } 
    
    litaC_std__string__String litaC_outputStr = litaC_std__string__StringInit(litaC_output, _MAX_PATH, 0);
    while(*(litaC_uri)) {
        {
            if(*(litaC_uri) == '%') {
                {
                    if(litaC_uri[1] == '2') {
                        {
                            if(litaC_uri[2] == '0') {
                                {
                                    litaC_std__string__String_appendChar(&((litaC_outputStr)), ' ');
                                    
                                    
                                }
                                
                            } else {
                                if(litaC_uri[2] == '1') {
                                    {
                                        litaC_std__string__String_appendChar(&((litaC_outputStr)), '!');
                                        
                                        
                                    }
                                    
                                } else {
                                    if(litaC_uri[2] == '3') {
                                        {
                                            litaC_std__string__String_appendChar(&((litaC_outputStr)), '#');
                                            
                                            
                                        }
                                        
                                    } else {
                                        if(litaC_uri[2] == '4') {
                                            {
                                                litaC_std__string__String_appendChar(&((litaC_outputStr)), '$');
                                                
                                                
                                            }
                                            
                                        } else {
                                            if(litaC_uri[2] == '5') {
                                                {
                                                    litaC_std__string__String_appendChar(&((litaC_outputStr)), '%');
                                                    
                                                    
                                                }
                                                
                                            } else {
                                                if(litaC_uri[2] == '6') {
                                                    {
                                                        litaC_std__string__String_appendChar(&((litaC_outputStr)), '&');
                                                        
                                                        
                                                    }
                                                    
                                                } else {
                                                    if(litaC_uri[2] == '7') {
                                                        {
                                                            litaC_std__string__String_appendChar(&((litaC_outputStr)), '\'');
                                                            
                                                            
                                                        }
                                                        
                                                    } else {
                                                        if(litaC_uri[2] == '8') {
                                                            {
                                                                litaC_std__string__String_appendChar(&((litaC_outputStr)), '(');
                                                                
                                                                
                                                            }
                                                            
                                                        } else {
                                                            if(litaC_uri[2] == '9') {
                                                                {
                                                                    litaC_std__string__String_appendChar(&((litaC_outputStr)), ')');
                                                                    
                                                                    
                                                                }
                                                                
                                                            } else {
                                                                if(litaC_uri[2] == 'A') {
                                                                    {
                                                                        litaC_std__string__String_appendChar(&((litaC_outputStr)), '*');
                                                                        
                                                                        
                                                                    }
                                                                    
                                                                } else {
                                                                    if(litaC_uri[2] == 'B') {
                                                                        {
                                                                            litaC_std__string__String_appendChar(&((litaC_outputStr)), '+');
                                                                            
                                                                            
                                                                        }
                                                                        
                                                                    } else {
                                                                        if(litaC_uri[2] == 'C') {
                                                                            {
                                                                                litaC_std__string__String_appendChar(&((litaC_outputStr)), ',');
                                                                                
                                                                                
                                                                            }
                                                                            
                                                                        } else {
                                                                            if(litaC_uri[2] == 'F') {
                                                                                {
                                                                                    litaC_std__string__String_appendChar(&((litaC_outputStr)), '/');
                                                                                    
                                                                                    
                                                                                }
                                                                                
                                                                            } else {
                                                                                {
                                                                                    litaC_std__string__String_append(&((litaC_outputStr)), "%s", "%2");
                                                                                    litaC_uri += 2;
                                                                                    continue;
                                                                                    
                                                                                    
                                                                                }
                                                                            } 
                                                                            
                                                                        } 
                                                                        
                                                                    } 
                                                                    
                                                                } 
                                                                
                                                            } 
                                                            
                                                        } 
                                                        
                                                    } 
                                                    
                                                } 
                                                
                                            } 
                                            
                                        } 
                                        
                                    } 
                                    
                                } 
                                
                            } 
                            
                            
                            
                        }
                        
                    } else {
                        if(litaC_uri[1] == '3') {
                            {
                                if(litaC_uri[2] == 'A') {
                                    {
                                        litaC_std__string__String_appendChar(&((litaC_outputStr)), ':');
                                        
                                        
                                    }
                                    
                                } else {
                                    if(litaC_uri[2] == 'B') {
                                        {
                                            litaC_std__string__String_appendChar(&((litaC_outputStr)), ';');
                                            
                                            
                                        }
                                        
                                    } else {
                                        if(litaC_uri[2] == 'D') {
                                            {
                                                litaC_std__string__String_appendChar(&((litaC_outputStr)), '=');
                                                
                                                
                                            }
                                            
                                        } else {
                                            if(litaC_uri[2] == 'F') {
                                                {
                                                    litaC_std__string__String_appendChar(&((litaC_outputStr)), '?');
                                                    
                                                    
                                                }
                                                
                                            } else {
                                                {
                                                    litaC_std__string__String_append(&((litaC_outputStr)), "%s", "%3");
                                                    litaC_uri += 2;
                                                    continue;
                                                    
                                                    
                                                }
                                            } 
                                            
                                        } 
                                        
                                    } 
                                    
                                } 
                                
                                
                                
                            }
                            
                        } else {
                            if(litaC_uri[1] == '4') {
                                {
                                    if(litaC_uri[2] == '0') {
                                        {
                                            litaC_std__string__String_appendChar(&((litaC_outputStr)), '@');
                                            
                                            
                                        }
                                        
                                    } else {
                                        {
                                            litaC_std__string__String_append(&((litaC_outputStr)), "%s", "%4");
                                            litaC_uri += 2;
                                            continue;
                                            
                                            
                                        }
                                    } 
                                    
                                    
                                    
                                }
                                
                            } else {
                                if(litaC_uri[1] == '5') {
                                    {
                                        if(litaC_uri[2] == 'B') {
                                            {
                                                litaC_std__string__String_appendChar(&((litaC_outputStr)), '[');
                                                
                                                
                                            }
                                            
                                        } else {
                                            if(litaC_uri[2] == 'D') {
                                                {
                                                    litaC_std__string__String_appendChar(&((litaC_outputStr)), ']');
                                                    
                                                    
                                                }
                                                
                                            } else {
                                                {
                                                    litaC_std__string__String_append(&((litaC_outputStr)), "%s", "%5");
                                                    litaC_uri += 2;
                                                    continue;
                                                    
                                                    
                                                }
                                            } 
                                            
                                        } 
                                        
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        litaC_std__string__String_appendChar(&((litaC_outputStr)), *(litaC_uri));
                                        litaC_uri += 1;
                                        continue;
                                        
                                        
                                    }
                                } 
                                
                            } 
                            
                        } 
                        
                    } 
                    
                    litaC_uri += 3;
                    continue;
                    
                    
                }
                
            } 
            
            litaC_std__string__String_appendChar(&((litaC_outputStr)), *(litaC_uri));
            litaC_uri += 1;
            
            
        }
    }
    return litaC_std__string__String_cStr(litaC_outputStr);
    
    
}


litaC_f64 litaC_std__system__SystemTimeMSec() {
    return litaC_std__system__system_win___SystemTimeMSec();
    
    
}

const litaC_char* litaC_std__system__CurrentDateTime() {
    time_t litaC_rawtime = {0};
    tm* litaC_timeinfo = NULL;
    time(&(litaC_rawtime));
    litaC_timeinfo = localtime(&(litaC_rawtime));
    return asctime(litaC_timeinfo);
    
    
}

litaC_std__system__Process litaC_std__system__SystemExec(const litaC_char* litaC_command) {
    FILE* litaC_pipe = _popen(litaC_command, litaC_std__system__OPEN_MODE);
    return (litaC_std__system__Process) {
        .pipe = litaC_pipe
    };
    
    
}

litaC_i64 litaC_std__system__Process_readOutput(litaC_std__system__Process* litaC_this,litaC_char* litaC_buffer,litaC_usize litaC_length) {
    if(!(litaC_this->pipe)) {
        {
            return -(1);
            
            
            
        }
        
    } 
    
    return fread(litaC_buffer, sizeof(litaC_char), litaC_length, litaC_this->pipe);
    
    
}

litaC_u64 litaC_std__system__Process_writeInput(litaC_std__system__Process* litaC_this,litaC_char* litaC_buffer,litaC_usize litaC_length) {
    if(!(litaC_this->pipe)) {
        {
            return -(1);
            
            
            
        }
        
    } 
    
    return fwrite(litaC_buffer, sizeof(litaC_char), litaC_length, litaC_this->pipe);
    
    
}

litaC_void litaC_std__system__Process_close(litaC_std__system__Process* litaC_this) {
    if(litaC_this->pipe) {
        _pclose(litaC_this->pipe);
        
    } 
    
    
}


LITAC_INLINE 
litaC_bool litaC_std__system__system_win___SystemInit() {
    if(litaC_std__system__system_win__systemStart == 0) {
        {
            LARGE_INTEGER litaC_freq = {0};
            if(!(QueryPerformanceFrequency(&(litaC_freq)))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_std__system__system_win__systemFreq = (litaC_f64)litaC_freq.QuadPart / 1000.0;
            LARGE_INTEGER litaC_time = {0};
            QueryPerformanceCounter(&(litaC_time));
            litaC_std__system__system_win__systemStart = litaC_time.QuadPart;
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

LITAC_INLINE 
const litaC_char* litaC_std__system__system_win___CurrentWorkingPath() {
    static 
    litaC_char litaC_path[_MAX_PATH] = {0};
    if(litaC_std__system__system_win__pwd[0] == 0) {
        {
            GetCurrentDirectory(_MAX_PATH, litaC_path);
            litaC_std__system__GetAbsolutePath("", litaC_path, litaC_std__system__system_win__pwd);
            
            
        }
        
    } 
    
    return litaC_std__system__system_win__pwd;
    
    
}

LITAC_INLINE 
litaC_char* litaC_std__system__system_win___GetFullPathName(const litaC_char* litaC_fileName,litaC_char* litaC_output) {
    GetFullPathNameA(litaC_fileName, _MAX_PATH, litaC_output, NULL);
    return litaC_output;
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__system__system_win___Mkdir(const litaC_char* litaC_dir) {
    CreateDirectoryA(litaC_dir, NULL);
    litaC_std__string_view__StringView litaC_view = litaC_std__string_view__StringViewInit(litaC_dir, -(1));
    if(litaC_std__string_view__StringView_endsWith(litaC_view, "/", -(1))) {
        {
            litaC_char litaC_path[_MAX_PATH] =  {
                0
            };
            litaC_std__string__String litaC_normalized = litaC_std__string__StringInit(litaC_path, _MAX_PATH, 0);
            litaC_std__string__String_format(&((litaC_normalized)), "%.*s", litaC_view.length - 1, litaC_view.buffer);
            return litaC_std__system__FileExists(litaC_std__string__String_cStr(litaC_normalized));
            
            
            
        }
        
    } 
    
    return litaC_std__system__FileExists(litaC_dir);
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__system__system_win___FileIsDir(const litaC_char* litaC_filename) {
    litaC_i64 litaC_res = GetFileAttributesA(litaC_filename);
    return (litaC_res != INVALID_FILE_ATTRIBUTES && (litaC_res & FILE_ATTRIBUTE_DIRECTORY));
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__system__system_win___FileTruncate(const litaC_char* litaC_filename,litaC_usize litaC_newLength) {
    FILE* litaC_file = fopen(litaC_filename, "rw");
    return litaC_std__system__system_win___FileTruncateFile(litaC_file, litaC_newLength);
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__system__system_win___FileTruncateFile(FILE* litaC_file,litaC_usize litaC_newLength) {
    if(!(litaC_file)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_fd = fileno(litaC_file);
    return ftruncate(litaC_fd, litaC_newLength);
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__system__system_win___FileDelete(const litaC_char* litaC_filename) {
    if(litaC_std__system__system_win___FileIsDir(litaC_filename)) {
        {
            return RemoveDirectoryA(litaC_filename);
            
            
            
        }
        
    } 
    
    return DeleteFile(litaC_filename);
    
    
}

LITAC_INLINE 

litaC_f64 litaC_std__system__system_win___SystemTimeMSec() {
    LARGE_INTEGER litaC_time = {0};
    QueryPerformanceCounter(&(litaC_time));
    assert(litaC_std__system__system_win__systemFreq != 0);
    return ((litaC_f64)(litaC_time.QuadPart - litaC_std__system__system_win__systemStart) / litaC_std__system__system_win__systemFreq) / 1000.0;
    
    
}

litaC_u32 litaC_std__map__StrHashFn(const litaC_char* litaC_str) {
    litaC_u32 litaC_hash = 5381U;
    while(*(litaC_str)) {
        {
            litaC_hash = ((litaC_hash << 5U) + litaC_hash) ^ ((litaC_u32)(*(litaC_str)));
            litaC_str += 1;
            
            
        }
    }
    return litaC_hash;
    
    
}

litaC_bool litaC_std__map__StrEqualFn(const litaC_char* litaC_a,const litaC_char* litaC_b) {
    if(!(litaC_a) && !(litaC_b)) {
        return litaC_true;
        
        
    } 
    
    if(!(litaC_a) || !(litaC_b)) {
        return litaC_false;
        
        
    } 
    
    return strcmp(litaC_a, litaC_b) == 0;
    
    
}

litaC_u32 litaC_std__map__nextPowerOf2(litaC_u32 litaC_n) {
    litaC_i32 litaC_count = 0;
    if(litaC_n && !((litaC_n & (litaC_n - 1)))) {
        return litaC_n;
        
        
    } 
    
    while(litaC_n != 0) {
        {
            litaC_n >>= 1;
            litaC_count += 1;
            
            
        }
    }
    return 1 << litaC_count;
    
    
}

litaC_u32 litaC_std__map__BlahHash(litaC_i32 litaC_a) {
    return 3;
    
    
}

litaC_bool litaC_std__map__BlahEq(litaC_i32 litaC_a,litaC_i32 litaC_b) {
    return litaC_a == litaC_b;
    
    
}

litaC_void litaC_std__map__Print(litaC_std__map__Map_cb_i32_c_i32_ce_* litaC_m) {
    printf("\n");
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            litaC_std__map__Key_cb_i32_ce_ litaC_key = litaC_m->keys[litaC_i];
            litaC_i32 litaC_value = litaC_m->values[litaC_i];
            printf("Key: %d/%d Value: %d @ %d\n", litaC_key.key, litaC_key.state, litaC_value, litaC_i);
            
            
        }
    }
    
}


litaC_void litaC_std__profile__StartWatch(litaC_std__profile__ProfileTag litaC_tag) {
    litaC_std__profile__ProfileEntry* litaC_entry = &(litaC_std__profile__profileEntries[litaC_tag]);
    litaC_entry->count += 1;
    litaC_entry->startTime = litaC_std__system__SystemTimeMSec();
    
}


litaC_void litaC_std__profile__StopWatch(litaC_std__profile__ProfileTag litaC_tag) {
    litaC_f64 litaC_endTime = litaC_std__system__SystemTimeMSec();
    litaC_std__profile__ProfileEntry* litaC_entry = &(litaC_std__profile__profileEntries[litaC_tag]);
    litaC_entry->totalTime += (litaC_endTime - litaC_entry->startTime);
    
}


litaC_void litaC_std__profile__ExportTimings(const litaC_char* litaC_filename) {
    printf("Exporting '%s' with %d instrumented functions...\n", litaC_filename, litaC_std__profile__ProfileTag_MAX_PROFILE_TAGS);
    
}

litaC_bool litaC_std__http__Http_init(litaC_std__http__Http* litaC_this,litaC_std__http__HttpOptions* litaC_options,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_this->options = *(litaC_options);
    if(curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_void litaC_std__http__Http_free(litaC_std__http__Http* litaC_this) {
    curl_global_cleanup();
    
}

litaC_void litaC_std__http__Http_setProxy(litaC_std__http__Http* litaC_this,const litaC_char* litaC_proxy) {
    litaC_this->options.proxy = litaC_proxy;
    
}

litaC_bool litaC_std__http__Http_get(litaC_std__http__Http* litaC_this,const litaC_char* litaC_url,litaC_std__http__HttpResponse* litaC_resp) {
    litaC_std__http__HttpRequest litaC_req =  {
        .url = litaC_url,
        .type = litaC_std__http__HttpRequestType_GET,
        .body = NULL
    };
    return litaC_std__http__Http_makeRequest(litaC_this, &(litaC_req), litaC_resp);
    
    
}

litaC_bool litaC_std__http__Http_makeRequest(litaC_std__http__Http* litaC_this,litaC_std__http__HttpRequest* litaC_req,litaC_std__http__HttpResponse* litaC_resp) {
    CURL* litaC_curl = curl_easy_init();
    if(!(litaC_curl)) {
        {
            litaC_resp->statusCode = -(1);
            return litaC_false;
            
            
            
        }
        
    } 
    
    
    curl_easy_setopt(litaC_curl, CURLOPT_URL, litaC_req->url);
    curl_easy_setopt(litaC_curl, CURLOPT_NOPROGRESS, 1L);
    curl_easy_setopt(litaC_curl, CURLOPT_FOLLOWLOCATION, 1L);
    curl_easy_setopt(litaC_curl, CURLOPT_MAXREDIRS, 8L);
    curl_easy_setopt(litaC_curl, CURLOPT_SSL_VERIFYPEER, litaC_false);
    if(litaC_this->options.proxy) {
        {
            curl_easy_setopt(litaC_curl, CURLOPT_PROXY, litaC_this->options.proxy);
            
            
        }
        
    } 
    
    curl_easy_setopt(litaC_curl, CURLOPT_WRITEFUNCTION, (litaC_void*)(&(litaC_std__http__HttpWriteCallback)));
    curl_easy_setopt(litaC_curl, CURLOPT_WRITEDATA, litaC_resp);
    if(litaC_req->type == litaC_std__http__HttpRequestType_POST) {
        {
            
            
        }
        
    } 
    
    CURLcode litaC_curlRes = curl_easy_perform(litaC_curl);
    if(litaC_curlRes) {
        {
            const litaC_char* litaC_body = curl_easy_strerror(litaC_curlRes);
            litaC_std__http__HttpWriteCallback((litaC_void*)litaC_body, strlen(litaC_body), 1, litaC_resp);
            litaC_resp->statusCode = -(1);
            {
                litaC_bool ___result = litaC_false;
                curl_easy_cleanup(litaC_curl);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_i64 litaC_code = 0L;
    curl_easy_getinfo(litaC_curl, CURLINFO_RESPONSE_CODE, &(litaC_code));
    litaC_resp->statusCode = (litaC_i32)litaC_code;
    {
        litaC_bool ___result = litaC_true;
        curl_easy_cleanup(litaC_curl);
        return ___result;
        
    }
    
    curl_easy_cleanup(litaC_curl);
    
}

litaC_usize litaC_std__http__HttpWriteCallback(litaC_void* litaC_data,litaC_usize litaC_size,litaC_usize litaC_n,litaC_void* litaC_userdata) {
    litaC_usize litaC_totalSize = litaC_size * litaC_n;
    litaC_std__http__HttpResponse* litaC_resp = (litaC_std__http__HttpResponse*)litaC_userdata;
    if(litaC_resp->bodyFn) {
        {
            return litaC_resp->bodyFn(litaC_data, litaC_size, litaC_n, litaC_resp->userdata);
            
            
            
        }
        
    } 
    
    litaC_std__string_buffer__StringBuffer_append(&((litaC_resp->body)), "%.*s", litaC_totalSize, litaC_data);
    return litaC_totalSize;
    
    
}

litaC_bool litaC_lex__Token_nameEquals(litaC_lex__Token* litaC_token,const litaC_char* litaC_str) {
    if(litaC_token->type != litaC_lex__TokenType_IDENTIFIER) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_std__string_view__StringView_equals(litaC_token->value.str, litaC_str, -(1));
    
    
}

litaC_i32 litaC_lex__SrcPos_getLineLength(litaC_lex__SrcPos* litaC_p) {
    if(!(litaC_p->lineStart)) {
        return -(1);
        
        
    } 
    
    litaC_i32 litaC_len = 0;
    while(litaC_p->lineStart[litaC_len] != '\0') {
        {
            if(litaC_p->lineStart[litaC_len] == '\n') {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_len += 1;
            
            
        }
    }
    return litaC_len;
    
    
}


const litaC_char* litaC_lex__Token_asString(litaC_lex__Token* litaC_t) {
    static 
    litaC_char litaC_buffer[260] = {0};
    if(litaC_t->type == litaC_lex__TokenType_IDENTIFIER || litaC_t->type == litaC_lex__TokenType_STRING) {
        {
            litaC_std__string__String litaC_str = litaC_std__string__StringInit(litaC_buffer, 260, 0);
            litaC_std__string__String_format(&((litaC_str)), "%.*s", litaC_t->value.str.length, litaC_t->value.str.buffer);
            return litaC_std__string__String_cStr(litaC_str);
            
            
            
        }
        
    } 
    
    return litaC_lex__tokenText[litaC_t->type];
    
    
}

litaC_void litaC_lex__Token_print(litaC_lex__Token* litaC_token) {
    printf("%s: '%s' '%.*s' ", litaC_lex__TokenTypeAsStr(litaC_token->type), litaC_lex__Token_asString(litaC_token), (litaC_i32)(litaC_token->pos.end - litaC_token->pos.start), litaC_token->pos.start);
    if(litaC_token->type == litaC_lex__TokenType_INT_NUMBER) {
        {
            printf("value: '%d'", (litaC_i32)litaC_token->value.intValue);
            printf(" typeInfo: %s", litaC_types__TypeKindAsStr(litaC_token->typeInfo->kind));
            
            
        }
        
    } else {
        if(litaC_token->type == litaC_lex__TokenType_FLOAT_NUMBER) {
            {
                printf("value: '%f'", litaC_token->value.floatValue);
                printf(" typeInfo: %s", litaC_types__TypeKindAsStr(litaC_token->typeInfo->kind));
                
                
            }
            
        } else {
            if(litaC_token->type == litaC_lex__TokenType_STRING) {
                {
                    printf("value: '%.*s'", litaC_token->value.str.length, litaC_token->value.str.buffer);
                    
                    
                }
                
            } else {
                if(litaC_token->type == litaC_lex__TokenType_ERROR) {
                    {
                        printf("error: '%s'", "X");
                        
                        
                    }
                    
                } 
                
            } 
            
        } 
        
    } 
    
    printf("\n");
    
}

litaC_lex__Lexer litaC_lex__LexerInit(const litaC_char* litaC_filename,const litaC_char* litaC_text,litaC_i64 litaC_length,const litaC_std__mem__Allocator* litaC_allocator) {
    return (litaC_lex__Lexer) {
        .allocator = litaC_allocator,
        .token =  {
            .type = litaC_lex__TokenType_END_OF_FILE,
            .typeInfo = NULL,
            .pos =  {
                .filename = litaC_filename,
                .start = litaC_text,
                .end = NULL
            }
        },
        .stream = litaC_text,
        .length = litaC_length,
        .lineStart = litaC_text,
        .lineNumber = 1,
        .position = 1,
        .errorMsg = NULL
    };
    
    
}

litaC_bool litaC_lex__Lexer_hasError(litaC_lex__Lexer* litaC_l) {
    return litaC_l->errorMsg != NULL;
    
    
}

litaC_void litaC_lex__Lexer_error(litaC_lex__Lexer* litaC_l,const litaC_char* litaC_format,...) {
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_l->allocator);
    va_list litaC_args = {0};
    va_start(litaC_args, litaC_format);
    litaC_std__string_buffer__StringBuffer_appendArgs(&((litaC_sb)), litaC_format, litaC_args);
    va_end(litaC_args);
    litaC_l->errorMsg = litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb)));
    litaC_lex__Lexer_errorToken(litaC_l);
    
}

litaC_i32 litaC_lex__Lexer_nextChar(litaC_lex__Lexer* litaC_l) {
    litaC_u8 litaC_c = (litaC_u8)(*(litaC_l->stream));
    if(litaC_c >= 0x80) {
        {
            litaC_i32 litaC_result = 0;
            litaC_i32 litaC_len = litaC_std__unicode__utf8__Utf8Decode((const litaC_u8*)litaC_l->stream, -(1), &(litaC_result));
            if(litaC_len < 0) {
                {
                    litaC_lex__Lexer_error(litaC_l, "Invalid codepoint");
                    return litaC_std__unicode__utf8__INVALID_RUNE;
                    
                    
                    
                }
                
            } 
            
            litaC_i32 litaC_width = litaC_std__unicode__utf8__Utf8CharWidth(litaC_result);
            litaC_l->stream += litaC_len;
            litaC_l->position += litaC_width;
            return litaC_result;
            
            
            
        }
        
    } 
    
    if(litaC_c == '\n') {
        {
            litaC_l->lineStart = litaC_l->stream + 1;
            litaC_l->lineNumber += 1;
            litaC_l->position = 0;
            
            
        }
        
    } 
    
    litaC_l->stream += 1;
    litaC_l->position += 1;
    return (litaC_i32)(*(litaC_l->stream));
    
    
}

litaC_lex__Token litaC_lex__Lexer_eofToken(litaC_lex__Lexer* litaC_l) {
    litaC_l->token.type = litaC_lex__TokenType_END_OF_FILE;
    litaC_l->token.pos.lineStart = litaC_l->lineStart;
    litaC_l->token.pos.lineNumber = litaC_l->lineNumber;
    litaC_l->token.pos.position = litaC_l->position;
    return litaC_l->token;
    
    
}

litaC_lex__Token litaC_lex__Lexer_errorToken(litaC_lex__Lexer* litaC_l) {
    litaC_l->token.type = litaC_lex__TokenType_ERROR;
    litaC_l->token.pos.lineStart = litaC_l->lineStart;
    litaC_l->token.pos.lineNumber = litaC_l->lineNumber;
    litaC_l->token.pos.position = litaC_l->position;
    return litaC_l->token;
    
    
}

litaC_void litaC_lex__Lexer_skipWhitespace(litaC_lex__Lexer* litaC_l) {
    while(isspace(*(litaC_l->stream))) {
        {
            litaC_lex__Lexer_nextChar(litaC_l);
            
            
        }
    }
    
}

litaC_void litaC_lex__Lexer_skipComments(litaC_lex__Lexer* litaC_l) {
    if(*(litaC_l->stream) == '/') {
        {
            if(litaC_l->stream[1] == '/') {
                {
                    litaC_lex__Lexer_nextChar(litaC_l);
                    do {
                        {
                            litaC_lex__Lexer_nextChar(litaC_l);
                            if(*(litaC_l->stream) == '\n') {
                                {
                                    break;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                    }
                    while(!(litaC_lex__Lexer_eof(litaC_l)));
                    
                    
                }
                
            } else {
                if(litaC_l->stream[1] == '*') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        do {
                            {
                                litaC_lex__Lexer_nextChar(litaC_l);
                                if((litaC_l->stream[0] == '*' && litaC_l->stream[1] == '/')) {
                                    {
                                        litaC_lex__Lexer_nextChar(litaC_l);
                                        litaC_lex__Lexer_nextChar(litaC_l);
                                        break;
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                        }
                        while(!(litaC_lex__Lexer_eof(litaC_l)));
                        
                        
                    }
                    
                } 
                
            } 
            
            
            
        }
        
    } 
    
    
}

litaC_bool litaC_lex__Lexer_isValidIdentifierStart(litaC_lex__Lexer* litaC_l,litaC_char litaC_c) {
    return ((litaC_c == '_') || (litaC_c >= 'A' && litaC_c <= 'Z') || (litaC_c >= 'a' && litaC_c <= 'z'));
    
    
}

litaC_bool litaC_lex__Lexer_isValidIdentifierChar(litaC_lex__Lexer* litaC_l,litaC_char litaC_c) {
    return ((litaC_c == '_') || (isdigit(litaC_c)) || (isalpha(litaC_c)));
    
    
}

litaC_bool litaC_lex__Lexer_isSymbolStart(litaC_lex__Lexer* litaC_l,litaC_char litaC_c) {
    return ((litaC_c > ' ' && litaC_c < '0') || (litaC_c > '9' && litaC_c < 'A') || (litaC_c > 'Z' && litaC_c < '_') || (litaC_c > 'z' && litaC_c < 127));
    
    
}

litaC_bool litaC_lex__Lexer_checkKeyword(litaC_lex__Lexer* litaC_l) {
    litaC_i32 litaC_len = litaC_l->token.value.str.length;
    if(litaC_len < litaC_lex__MAX_KEYWORD_CACHE) {
        {
            const litaC_char** litaC_keywords = litaC_lex__keywordCache[litaC_len];
            for(litaC_i32 litaC_i = 0;;litaC_i += 1) {
                {
                    const litaC_char* litaC_keyword = litaC_keywords[litaC_i];
                    if(!(litaC_keyword)) {
                        break;
                        
                    } 
                    
                    if(strncmp(litaC_l->token.value.str.buffer, litaC_keyword, litaC_len) == 0) {
                        {
                            litaC_l->token.type = litaC_lex__keywordCacheIndex[litaC_len][litaC_i];
                            return litaC_true;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_lex__Token litaC_lex__Lexer_scanWord(litaC_lex__Lexer* litaC_l) {
    litaC_i32 litaC_length = 0;
    while(litaC_lex__Lexer_isValidIdentifierChar(litaC_l, *(litaC_l->stream))) {
        {
            litaC_l->stream += 1;
            litaC_length += 1;
            
            
        }
    }
    litaC_l->position += litaC_length;
    litaC_l->token.pos.end = litaC_l->stream;
    litaC_l->token.type = litaC_lex__TokenType_IDENTIFIER;
    litaC_l->token.value.str = litaC_std__string_view__StringViewInit(litaC_l->token.pos.start, litaC_length);
    litaC_lex__Lexer_checkKeyword(litaC_l);
    return litaC_l->token;
    
    
}

litaC_void litaC_lex__Lexer_scanInt(litaC_lex__Lexer* litaC_l,litaC_char* litaC_stream) {
    litaC_i32 litaC_base = 10;
    litaC_char* litaC_start_digits = litaC_stream;
    if(*(litaC_stream) == '0') {
        {
            litaC_stream += 1;
            if(tolower(*(litaC_stream)) == 'x') {
                {
                    litaC_stream += 1;
                    litaC_base = 16;
                    litaC_start_digits = litaC_stream;
                    
                    
                }
                
            } else {
                if(tolower(*(litaC_stream)) == 'b') {
                    {
                        litaC_stream += 1;
                        litaC_base = 2;
                        litaC_start_digits = litaC_stream;
                        
                        
                    }
                    
                } else {
                    if(isdigit(*(litaC_stream))) {
                        {
                            litaC_base = 8;
                            litaC_start_digits = litaC_stream;
                            
                            
                        }
                        
                    } 
                    
                } 
                
            } 
            
            
            
        }
        
    } 
    
    litaC_i64 litaC_val = 0;
    for(;;) {
        {
            litaC_i32 litaC_digit = litaC_lex__charToDigit[(litaC_i32)(*(litaC_stream))];
            if(litaC_digit == 0 && *(litaC_stream) != '0') {
                {
                    break;
                    
                    
                }
                
            } 
            
            if(litaC_digit >= litaC_base) {
                {
                    litaC_lex__Lexer_error(litaC_l, "Digit '%c' out of range for base %d", *(litaC_stream), litaC_base);
                    litaC_digit = 0;
                    
                    
                }
                
            } 
            
            if(litaC_val > (ULLONG_MAX - litaC_digit) / litaC_base) {
                {
                    litaC_lex__Lexer_error(litaC_l, "Integer literal overflow");
                    while(isdigit(*(litaC_stream))) {
                        {
                            litaC_stream += 1;
                            
                            
                        }
                    }
                    litaC_val = 0;
                    break;
                    
                    
                }
                
            } 
            
            litaC_val = litaC_val * litaC_base + litaC_digit;
            litaC_stream += 1;
            
            
        }
    }
    if(litaC_stream == litaC_start_digits) {
        {
            litaC_lex__Lexer_error(litaC_l, "Expected base %d digit, got '%c'", litaC_base, *(litaC_stream));
            
            
        }
        
    } 
    
    if(litaC_lex__Lexer_hasError(litaC_l)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_l->token.type = litaC_lex__TokenType_INT_NUMBER;
    litaC_l->token.value.intValue = litaC_val;
    
}

litaC_void litaC_lex__Lexer_scanFloat(litaC_lex__Lexer* litaC_l,litaC_char* litaC_stream) {
    litaC_char* litaC_start = litaC_stream;
    while(isdigit(*(litaC_stream))) {
        {
            litaC_stream += 1;
            
            
        }
    }
    if(*(litaC_stream) == '.') {
        {
            litaC_stream += 1;
            
            
        }
        
    } 
    
    while(isdigit(*(litaC_stream))) {
        {
            litaC_stream += 1;
            
            
        }
    }
    if(tolower(*(litaC_stream)) == 'e') {
        {
            litaC_stream += 1;
            if(*(litaC_stream) == '+' || *(litaC_stream) == '-') {
                {
                    litaC_stream += 1;
                    
                    
                }
                
            } 
            
            if(!(isdigit(*(litaC_stream)))) {
                {
                    litaC_lex__Lexer_error(litaC_l, "Expected digit after float literal exponent, found '%c'.", *(litaC_stream));
                    
                    
                }
                
            } 
            
            while(isdigit(*(litaC_stream))) {
                {
                    litaC_stream += 1;
                    
                    
                }
            }
            
            
        }
        
    } 
    
    litaC_f64 litaC_val = strtod(litaC_start, NULL);
    if(litaC_val == HUGE_VAL) {
        {
            litaC_lex__Lexer_error(litaC_l, "Float literal overflow");
            
            
        }
        
    } 
    
    if(litaC_lex__Lexer_hasError(litaC_l)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_l->token.type = litaC_lex__TokenType_FLOAT_NUMBER;
    litaC_l->token.value.floatValue = litaC_val;
    
}

litaC_void litaC_lex__Lexer_scanTypeInfo(litaC_lex__Lexer* litaC_l) {
    litaC_char litaC_c = *(litaC_l->stream);
    if(litaC_c == 'u' || litaC_c == 'i') {
        {
            if(litaC_l->token.typeInfo == &(litaC_types__F32_TYPE) || litaC_l->token.typeInfo == &(litaC_types__F64_TYPE)) {
                {
                    litaC_lex__Lexer_error(litaC_l, "Integer type designation on floating point number not allowed");
                    return;
                    
                    
                    
                }
                
            } 
            
            const litaC_char* litaC_start = litaC_l->stream;
            litaC_i32 litaC_len = 0;
            do {
                {
                    litaC_len += 1;
                    litaC_lex__Lexer_nextChar(litaC_l);
                    if(!(litaC_lex__VALID_TYPE_INFO_CHAR[*(litaC_l->stream)])) {
                        {
                            break;
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            while(!(litaC_lex__Lexer_eof(litaC_l)));
            litaC_types__TypeKind litaC_kind = litaC_types__TypeKindFromString(litaC_start, litaC_len);
            switch(litaC_kind) {
                case litaC_types__TypeKind_I8: {
                    {
                        litaC_l->token.typeInfo = &(litaC_types__I8_TYPE);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_types__TypeKind_U8: {
                    {
                        litaC_l->token.typeInfo = &(litaC_types__U8_TYPE);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_types__TypeKind_I16: {
                    {
                        litaC_l->token.typeInfo = &(litaC_types__I16_TYPE);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_types__TypeKind_U16: {
                    {
                        litaC_l->token.typeInfo = &(litaC_types__U16_TYPE);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_types__TypeKind_I32: {
                    {
                        litaC_l->token.typeInfo = &(litaC_types__I32_TYPE);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_types__TypeKind_U32: {
                    {
                        litaC_l->token.typeInfo = &(litaC_types__U32_TYPE);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_types__TypeKind_I64: {
                    {
                        litaC_l->token.typeInfo = &(litaC_types__I64_TYPE);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_types__TypeKind_U64: {
                    {
                        litaC_l->token.typeInfo = &(litaC_types__U64_TYPE);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_types__TypeKind_USIZE: {
                    {
                        litaC_l->token.typeInfo = &(litaC_types__USIZE_TYPE);
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        litaC_lex__Lexer_error(litaC_l, "Invalid number type designator");
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
        
    } else {
        if(tolower(litaC_c) == 'f' || tolower(litaC_c) == 'd') {
            {
                const litaC_char* litaC_start = litaC_l->stream;
                litaC_i32 litaC_len = 0;
                do {
                    {
                        litaC_len += 1;
                        litaC_lex__Lexer_nextChar(litaC_l);
                        if(!(isdigit(*(litaC_l->stream)))) {
                            {
                                break;
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                while(!(litaC_lex__Lexer_eof(litaC_l)));
                if(litaC_len == 1) {
                    {
                        if(tolower(litaC_c) == 'f') {
                            {
                                litaC_l->token.typeInfo = &(litaC_types__F32_TYPE);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_l->token.typeInfo = &(litaC_types__F64_TYPE);
                                
                                
                            }
                        } 
                        
                        
                        
                    }
                    
                } else {
                    {
                        litaC_types__TypeKind litaC_kind = litaC_types__TypeKindFromString(litaC_start, litaC_len);
                        switch(litaC_kind) {
                            case litaC_types__TypeKind_F32: {
                                {
                                    litaC_l->token.typeInfo = &(litaC_types__F32_TYPE);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_types__TypeKind_F64: {
                                {
                                    litaC_l->token.typeInfo = &(litaC_types__F64_TYPE);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            default: {
                                {
                                    litaC_lex__Lexer_error(litaC_l, "Invalid number type designator");
                                    
                                    
                                }
                                
                                
                            }
                        }
                        
                        
                    }
                } 
                
                
                
            }
            
        } 
        
    } 
    
    
}

litaC_bool litaC_lex__IsHex(litaC_i32 litaC_c) {
    return isdigit(litaC_c) || litaC_lex__IsHexChar(litaC_c);
    
    
}

litaC_bool litaC_lex__IsHexChar(litaC_char litaC_c) {
    litaC_c = tolower(litaC_c);
    return litaC_c == 'a' || litaC_c == 'b' || litaC_c == 'c' || litaC_c == 'd' || litaC_c == 'e' || litaC_c == 'f';
    
    
}

litaC_lex__Token litaC_lex__Lexer_scanNumber(litaC_lex__Lexer* litaC_l) {
    litaC_char litaC_numBuf[256] = {0};
    litaC_i32 litaC_numIndex = 0;
    litaC_bool litaC_hasDecimal = litaC_false;
    litaC_bool litaC_hasExpo = litaC_false;
    litaC_bool litaC_isHex = litaC_false;
    while(!(litaC_lex__Lexer_eof(litaC_l))) {
        {
            litaC_char litaC_c = *(litaC_l->stream);
            if(litaC_c == '.') {
                {
                    if(litaC_hasDecimal) {
                        {
                            break;
                            
                            
                        }
                        
                    } 
                    
                    litaC_hasDecimal = litaC_true;
                    
                    
                }
                
            } else {
                if(tolower(litaC_c) == 'e' && !(litaC_isHex)) {
                    {
                        if(litaC_hasExpo) {
                            {
                                break;
                                
                                
                            }
                            
                        } 
                        
                        litaC_hasExpo = litaC_true;
                        
                        
                    }
                    
                } else {
                    if(!(isdigit(litaC_c)) && litaC_c != '_') {
                        {
                            if(litaC_c == 'x' || litaC_c == 'X') {
                                {
                                    litaC_isHex = litaC_true;
                                    
                                    
                                }
                                
                            } else {
                                if(litaC_isHex) {
                                    {
                                        if(!(litaC_lex__IsHexChar(litaC_c))) {
                                            {
                                                break;
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        break;
                                        
                                        
                                    }
                                } 
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                } 
                
            } 
            
            if(litaC_c != '_') {
                {
                    litaC_numBuf[litaC_numIndex] = litaC_c;
                    litaC_numIndex += 1;
                    
                    
                }
                
            } 
            
            litaC_l->stream += 1;
            
            
        }
    }
    litaC_numBuf[litaC_numIndex] = '\0';
    if(litaC_hasDecimal || litaC_hasExpo) {
        {
            litaC_lex__Lexer_scanFloat(litaC_l, litaC_numBuf);
            litaC_l->token.typeInfo = &(litaC_types__F64_TYPE);
            
            
        }
        
    } else {
        {
            litaC_lex__Lexer_scanInt(litaC_l, litaC_numBuf);
            litaC_l->token.typeInfo = &(litaC_types__I32_TYPE);
            if(litaC_l->token.value.intValue > INT_MAX) {
                {
                    if(litaC_l->token.value.intValue > UINT_MAX) {
                        {
                            litaC_l->token.typeInfo = &(litaC_types__I64_TYPE);
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_l->token.typeInfo = &(litaC_types__U32_TYPE);
                            
                            
                        }
                    } 
                    
                    
                    
                }
                
            } 
            
            
            
        }
    } 
    
    if(litaC_lex__Lexer_hasError(litaC_l)) {
        {
            return litaC_lex__Lexer_errorToken(litaC_l);
            
            
            
        }
        
    } 
    
    litaC_lex__Lexer_scanTypeInfo(litaC_l);
    litaC_l->token.pos.end = litaC_l->stream;
    return litaC_l->token;
    
    
}

litaC_lex__Token litaC_lex__Lexer_scanChar(litaC_lex__Lexer* litaC_l) {
    litaC_i32 litaC_c = litaC_lex__Lexer_nextChar(litaC_l);
    litaC_i32 litaC_value = '\0';
    litaC_bool litaC_isValid = litaC_true;
    if(litaC_c == '\\') {
        {
            litaC_c = litaC_lex__Lexer_nextChar(litaC_l);
            if(litaC_c == 'u' || litaC_c == 'U') {
                {
                    litaC_i32 litaC_count = 0;
                    litaC_i32 litaC_reqCount = (litaC_c == 'u') ? 4 : 8;
                    const litaC_char* litaC_pos = litaC_l->stream;
                    for(;;) {
                        {
                            litaC_c = litaC_lex__Lexer_nextChar(litaC_l);
                            if(litaC_c == '\n' || litaC_c < 0) {
                                {
                                    litaC_lex__Lexer_error(litaC_l, "char literal not terminated");
                                    return litaC_lex__Lexer_errorToken(litaC_l);
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            if(litaC_c == '\'') {
                                {
                                    break;
                                    
                                    
                                }
                                
                            } 
                            
                            if(!(litaC_lex__IsHex(litaC_c))) {
                                {
                                    litaC_lex__Lexer_error(litaC_l, "invalid unicode codepoint hex component: '%c'", litaC_c);
                                    litaC_isValid = litaC_false;
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_count += 1;
                            
                            
                        }
                    }
                    if(litaC_count != litaC_reqCount) {
                        {
                            litaC_lex__Lexer_error(litaC_l, "invalid unicode codepoint literal: '%.*s', must be %d hex digits in length", litaC_count + 1, litaC_pos, litaC_reqCount);
                            litaC_isValid = litaC_false;
                            
                            
                        }
                        
                    } 
                    
                    if(litaC_isValid) {
                        {
                            litaC_value = (litaC_i32)strtol(litaC_pos + 1, NULL, 16);
                            
                            
                        }
                        
                    } 
                    
                    if(litaC_isValid && !(litaC_lex__Lexer_validateCodepoint(litaC_l, litaC_pos, litaC_count))) {
                        {
                            litaC_isValid = litaC_false;
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } else {
                if(litaC_c == 'x') {
                    {
                        assert(litaC_false);
                        
                        
                    }
                    
                } else {
                    {
                        if(litaC_c >= 256) {
                            {
                                litaC_lex__Lexer_error(litaC_l, "Illegal escaped character, character out of byte range (hex value): '%x'", litaC_c);
                                return litaC_lex__Lexer_errorToken(litaC_l);
                                
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_lex__escapeToChar[litaC_c] == 0 && litaC_c != '0') {
                            {
                                litaC_isValid = litaC_false;
                                
                                
                            }
                            
                        } 
                        
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_value = litaC_lex__escapeToChar[litaC_c];
                        
                        
                    }
                } 
                
            } 
            
            
            
        }
        
    } else {
        {
            litaC_value = litaC_c;
            litaC_lex__Lexer_nextChar(litaC_l);
            
            
        }
    } 
    
    if(litaC_value >= 256) {
        {
            litaC_lex__Lexer_error(litaC_l, "Illegal character literal, character out of byte range (hex value): '%x'", litaC_value);
            return litaC_lex__Lexer_errorToken(litaC_l);
            
            
            
        }
        
    } 
    
    if(*(litaC_l->stream) != '\'') {
        {
            return litaC_lex__Lexer_errorToken(litaC_l);
            
            
            
        }
        
    } 
    
    litaC_lex__Lexer_nextChar(litaC_l);
    if(!(litaC_isValid)) {
        {
            return litaC_lex__Lexer_errorToken(litaC_l);
            
            
            
        }
        
    } 
    
    litaC_l->token.type = litaC_lex__TokenType_CHAR;
    litaC_l->token.pos.end = litaC_l->stream;
    litaC_l->token.value.intValue = litaC_value;
    return litaC_l->token;
    
    
}

litaC_bool litaC_lex__Lexer_validateCodepoint(litaC_lex__Lexer* litaC_l,const litaC_char* litaC_str,litaC_i32 litaC_len) {
    if(litaC_len != 4 && litaC_len != 8) {
        {
            litaC_lex__Lexer_error(litaC_l, "invalid unicode codepoint literal: '%.*s'", litaC_len + 1, litaC_str);
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_codepoint = litaC_std__unicode__utf8__Utf8HexDecode(litaC_str + 1, litaC_len);
    if(!(litaC_std__unicode__utf8__Utf8CodepointValid(litaC_codepoint))) {
        {
            litaC_lex__Lexer_error(litaC_l, "invalid unicode codepoint literal: '%.*s'", litaC_len + 1, litaC_str);
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_codepoint >= 0 && litaC_codepoint <= 159) {
        {
            if(litaC_codepoint == 36 || litaC_codepoint == 64 || litaC_codepoint == 96) {
                {
                    
                    
                }
                
            } else {
                {
                    litaC_lex__Lexer_error(litaC_l, "universal character name: '%.*s' refers to a control character.  A universal character name may not represent a character in the range 0000-009F, inclusive, with the exceptions of 0024 ('$'), 0040 ('@') and 0060 ('`')", litaC_len + 1, litaC_str);
                    return litaC_false;
                    
                    
                    
                }
            } 
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_lex__Token litaC_lex__Lexer_scanString(litaC_lex__Lexer* litaC_l) {
    litaC_bool litaC_isVerbatim = litaC_false;
    litaC_bool litaC_isValid = litaC_true;
    const litaC_char* litaC_startPos = NULL;
    assert(litaC_l->stream[0] == '"');
    if(litaC_l->stream[1] == '"' && litaC_l->stream[2] == '"') {
        {
            litaC_isVerbatim = litaC_true;
            litaC_lex__Lexer_nextChar(litaC_l);
            litaC_lex__Lexer_nextChar(litaC_l);
            
            
        }
        
    } 
    
    litaC_lex__Lexer_nextChar(litaC_l);
    litaC_l->token.value.str.buffer = litaC_l->stream;
    litaC_startPos = litaC_l->stream;
    for(;;) {
        {
            if(litaC_l->stream[0] == '\0') {
                {
                    litaC_lex__Lexer_error(litaC_l, "string literal not terminated");
                    litaC_isValid = litaC_false;
                    break;
                    
                    
                }
                
            } 
            
            if(litaC_l->stream[0] == '\\') {
                {
                    litaC_i32 litaC_c = litaC_lex__Lexer_nextChar(litaC_l);
                    if(litaC_c == 'u' || litaC_c == 'U') {
                        {
                            litaC_i32 litaC_count = 0;
                            litaC_i32 litaC_reqCount = (litaC_c == 'u') ? 4 : 8;
                            const litaC_char* litaC_pos = litaC_l->stream;
                            for(;;) {
                                {
                                    litaC_c = litaC_lex__Lexer_nextChar(litaC_l);
                                    if(litaC_c < 0) {
                                        {
                                            litaC_lex__Lexer_error(litaC_l, "string literal not terminated");
                                            litaC_isValid = litaC_false;
                                            break;
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    if(litaC_count >= litaC_reqCount || litaC_c == ' ' || litaC_c == '\n' || litaC_c == '"') {
                                        {
                                            break;
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    if(!(litaC_lex__IsHex(litaC_c))) {
                                        {
                                            litaC_lex__Lexer_error(litaC_l, "invalid unicode codepoint hex component: '%c'", litaC_c);
                                            litaC_isValid = litaC_false;
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    litaC_count += 1;
                                    
                                    
                                }
                            }
                            if(litaC_count != litaC_reqCount && litaC_isValid) {
                                {
                                    litaC_lex__Lexer_error(litaC_l, "invalid unicode codepoint literal: '%.*s', must be %d hex digits in length", litaC_count + 1, litaC_pos, litaC_reqCount);
                                    litaC_isValid = litaC_false;
                                    
                                    
                                }
                                
                            } 
                            
                            if(litaC_isValid && !(litaC_lex__Lexer_validateCodepoint(litaC_l, litaC_pos, litaC_count))) {
                                {
                                    litaC_isValid = litaC_false;
                                    
                                    
                                }
                                
                            } 
                            
                            continue;
                            
                            
                        }
                        
                    } else {
                        if(litaC_c == 'x') {
                            {
                                assert(litaC_false);
                                
                                
                            }
                            
                        } else {
                            {
                                if(litaC_c >= 256) {
                                    {
                                        litaC_lex__Lexer_error(litaC_l, "Illegal escaped character, character out of byte range (hex value): '%x'", litaC_c);
                                        litaC_isValid = litaC_false;
                                        continue;
                                        
                                        
                                    }
                                    
                                } 
                                
                                if(litaC_lex__escapeToChar[litaC_c] == 0 && litaC_c != '0') {
                                    {
                                        litaC_lex__Lexer_error(litaC_l, "Illegal escaped character: '%c'", litaC_c);
                                        litaC_isValid = litaC_false;
                                        continue;
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                        } 
                        
                    } 
                    
                    
                    
                }
                
            } else {
                if(litaC_l->stream[0] == '"') {
                    {
                        if(!(litaC_isVerbatim)) {
                            {
                                litaC_lex__Lexer_nextChar(litaC_l);
                                break;
                                
                                
                            }
                            
                        } else {
                            if(litaC_l->stream[1] == '"' && litaC_l->stream[2] == '"') {
                                {
                                    litaC_lex__Lexer_nextChar(litaC_l);
                                    litaC_lex__Lexer_nextChar(litaC_l);
                                    litaC_lex__Lexer_nextChar(litaC_l);
                                    break;
                                    
                                    
                                }
                                
                            } 
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_lex__Lexer_nextChar(litaC_l);
            
            
        }
    }
    litaC_isValid = litaC_isValid && !(litaC_lex__Lexer_hasError(litaC_l));
    litaC_l->token.type = litaC_lex__TokenType_STRING;
    litaC_l->token.pos.end = litaC_l->stream;
    if(litaC_isVerbatim) {
        {
            litaC_l->token.value.str.length = (litaC_i32)((litaC_l->stream - litaC_startPos) - 3);
            litaC_l->token.mod = litaC_lex__Mod_MULTISTR;
            
            
        }
        
    } else {
        {
            litaC_l->token.value.str.length = (litaC_i32)((litaC_l->stream - litaC_startPos) - 1);
            litaC_l->token.mod = litaC_lex__Mod_NONE;
            
            
        }
    } 
    
    return (litaC_isValid) ? litaC_l->token : litaC_lex__Lexer_errorToken(litaC_l);
    
    
}

litaC_lex__Token litaC_lex__Lexer_scanSymbol(litaC_lex__Lexer* litaC_l) {
    litaC_char litaC_c = *(litaC_l->stream);
    litaC_lex__Lexer_nextChar(litaC_l);
    switch(litaC_c) {
        case '+': {
            {
                litaC_l->token.type = litaC_lex__TokenType_PLUS;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_PLUS_EQ;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '-': {
            {
                litaC_l->token.type = litaC_lex__TokenType_MINUS;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_MINUS_EQ;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '*': {
            {
                litaC_l->token.type = litaC_lex__TokenType_STAR;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_MUL_EQ;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '%': {
            {
                litaC_l->token.type = litaC_lex__TokenType_MOD;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_MOD_EQ;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '/': {
            {
                litaC_l->token.type = litaC_lex__TokenType_SLASH;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_DIV_EQ;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '$': {
            {
                litaC_l->token.type = litaC_lex__TokenType_DOLLAR;
                break;
                
                
            }
            
            
        }
        case '#': {
            {
                litaC_l->token.type = litaC_lex__TokenType_HASH;
                break;
                
                
            }
            
            
        }
        case '.': {
            {
                litaC_l->token.type = litaC_lex__TokenType_DOT;
                if(litaC_l->stream[0] == '.') {
                    {
                        if(litaC_l->stream[1] == '.') {
                            {
                                litaC_lex__Lexer_nextChar(litaC_l);
                                litaC_lex__Lexer_nextChar(litaC_l);
                                litaC_l->token.type = litaC_lex__TokenType_VAR_ARGS;
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '@': {
            {
                litaC_l->token.type = litaC_lex__TokenType_AT;
                if(strncmp(litaC_l->stream, "note", 4) == 0) {
                    {
                        litaC_l->token.type = litaC_lex__TokenType_NOTE;
                        litaC_l->stream += 4;
                        litaC_l->position += 4;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '?': {
            {
                litaC_l->token.type = litaC_lex__TokenType_QUESTION_MARK;
                break;
                
                
            }
            
            
        }
        case ',': {
            {
                litaC_l->token.type = litaC_lex__TokenType_COMMA;
                break;
                
                
            }
            
            
        }
        case ';': {
            {
                litaC_l->token.type = litaC_lex__TokenType_SEMICOLON;
                break;
                
                
            }
            
            
        }
        case ':': {
            {
                litaC_l->token.type = litaC_lex__TokenType_COLON;
                if(litaC_l->stream[0] == ':') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_COLON_COLON;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '"': {
            {
                litaC_l->token.type = litaC_lex__TokenType_DOUBLE_QUOTE;
                break;
                
                
            }
            
            
        }
        case '<': {
            {
                litaC_l->token.type = litaC_lex__TokenType_LESS_THAN;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_LESS_EQUALS;
                        
                        
                    }
                    
                } else {
                    if(litaC_l->stream[0] == '<') {
                        {
                            litaC_lex__Lexer_nextChar(litaC_l);
                            litaC_l->token.type = litaC_lex__TokenType_LSHIFT;
                            if(litaC_l->stream[0] == '=') {
                                {
                                    litaC_lex__Lexer_nextChar(litaC_l);
                                    litaC_l->token.type = litaC_lex__TokenType_LSHIFT_EQ;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '>': {
            {
                litaC_l->token.type = litaC_lex__TokenType_GREATER_THAN;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_GREATER_EQUALS;
                        
                        
                    }
                    
                } else {
                    if(litaC_l->stream[0] == '>' && litaC_l->stream[1] == '=') {
                        {
                            litaC_lex__Lexer_nextChar(litaC_l);
                            litaC_lex__Lexer_nextChar(litaC_l);
                            litaC_l->token.type = litaC_lex__TokenType_RSHIFT_EQ;
                            
                            
                        }
                        
                    } 
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '=': {
            {
                litaC_l->token.type = litaC_lex__TokenType_EQUALS;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_EQUALS_EQUALS;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '!': {
            {
                litaC_l->token.type = litaC_lex__TokenType_NOT;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_NOT_EQUALS;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '~': {
            {
                litaC_l->token.type = litaC_lex__TokenType_BNOT;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_BNOT_EQ;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '^': {
            {
                litaC_l->token.type = litaC_lex__TokenType_XOR;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_XOR_EQ;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '&': {
            {
                litaC_l->token.type = litaC_lex__TokenType_BAND;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_BAND_EQ;
                        
                        
                    }
                    
                } else {
                    if(litaC_l->stream[0] == '&') {
                        {
                            litaC_lex__Lexer_nextChar(litaC_l);
                            litaC_l->token.type = litaC_lex__TokenType_AND;
                            
                            
                        }
                        
                    } 
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '|': {
            {
                litaC_l->token.type = litaC_lex__TokenType_BOR;
                if(litaC_l->stream[0] == '=') {
                    {
                        litaC_lex__Lexer_nextChar(litaC_l);
                        litaC_l->token.type = litaC_lex__TokenType_BOR_EQ;
                        
                        
                    }
                    
                } else {
                    if(litaC_l->stream[0] == '|') {
                        {
                            litaC_lex__Lexer_nextChar(litaC_l);
                            litaC_l->token.type = litaC_lex__TokenType_OR;
                            
                            
                        }
                        
                    } 
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case '(': {
            {
                litaC_l->token.type = litaC_lex__TokenType_LEFT_PAREN;
                break;
                
                
            }
            
            
        }
        case ')': {
            {
                litaC_l->token.type = litaC_lex__TokenType_RIGHT_PAREN;
                break;
                
                
            }
            
            
        }
        case '[': {
            {
                litaC_l->token.type = litaC_lex__TokenType_LEFT_BRACKET;
                break;
                
                
            }
            
            
        }
        case ']': {
            {
                litaC_l->token.type = litaC_lex__TokenType_RIGHT_BRACKET;
                break;
                
                
            }
            
            
        }
        case '{': {
            {
                litaC_l->token.type = litaC_lex__TokenType_LEFT_BRACE;
                break;
                
                
            }
            
            
        }
        case '}': {
            {
                litaC_l->token.type = litaC_lex__TokenType_RIGHT_BRACE;
                break;
                
                
            }
            
            
        }
        case '\\': {
            {
                litaC_l->token.type = litaC_lex__TokenType_BACK_SLASH;
                break;
                
                
            }
            
            
        }
        default: {
            {
                return litaC_lex__Lexer_errorToken(litaC_l);
                
                
                
            }
            
            
        }
    }
    litaC_l->token.pos.end = litaC_l->stream;
    return litaC_l->token;
    
    
}

litaC_bool litaC_lex__Lexer_eof(litaC_lex__Lexer* litaC_l) {
    return *(litaC_l->stream) == '\0';
    
    
}

litaC_lex__Token litaC_lex__Lexer_nextToken(litaC_lex__Lexer* litaC_l) {
    repeat:;
    
    if(litaC_lex__Lexer_eof(litaC_l)) {
        {
            return litaC_lex__Lexer_eofToken(litaC_l);
            
            
            
        }
        
    } 
    
    litaC_lex__Lexer_skipComments(litaC_l);
    litaC_l->errorMsg = NULL;
    litaC_l->token.pos.lineNumber = litaC_l->lineNumber;
    litaC_l->token.pos.lineStart = litaC_l->lineStart;
    litaC_l->token.pos.start = litaC_l->stream;
    litaC_l->token.pos.position = litaC_l->position;
    litaC_l->token.typeInfo = NULL;
    litaC_char litaC_c = *(litaC_l->stream);
    switch(litaC_c) {
        case '\0': {
            {
                return litaC_lex__Lexer_eofToken(litaC_l);
                
                
                
            }
            
            
        }
        case ' ': 
        case '\n': 
        case '\r': 
        case '\t': {
            {
                litaC_lex__Lexer_skipWhitespace(litaC_l);
                goto repeat;
                
                
                
            }
            
            
        }
        case '"': {
            {
                return litaC_lex__Lexer_scanString(litaC_l);
                
                
                
            }
            
            
        }
        case '\'': {
            {
                return litaC_lex__Lexer_scanChar(litaC_l);
                
                
                
            }
            
            
        }
        default: {
            {
                if(litaC_lex__Lexer_isValidIdentifierStart(litaC_l, litaC_c)) {
                    {
                        return litaC_lex__Lexer_scanWord(litaC_l);
                        
                        
                        
                    }
                    
                } 
                
                if(isdigit(litaC_c)) {
                    {
                        return litaC_lex__Lexer_scanNumber(litaC_l);
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lex__Lexer_isSymbolStart(litaC_l, litaC_c)) {
                    {
                        return litaC_lex__Lexer_scanSymbol(litaC_l);
                        
                        
                        
                    }
                    
                } 
                
                litaC_i32 litaC_n = litaC_lex__Lexer_nextChar(litaC_l);
                litaC_u8 litaC_invalidChar[4] = {0};
                litaC_i32 litaC_len = litaC_std__unicode__utf8__Utf8Encode(litaC_n, litaC_invalidChar);
                litaC_lex__Lexer_error(litaC_l, "unexpected character: '%.*s'", litaC_len, litaC_invalidChar);
                return litaC_lex__Lexer_errorToken(litaC_l);
                
                
                
            }
            
            
        }
    }
    return litaC_lex__Lexer_eofToken(litaC_l);
    
    
}


litaC_i32 litaC_std__unicode__utf8__Utf8Decode(const litaC_u8* litaC_str,litaC_i32 litaC_len,litaC_i32* litaC_codepoint) {
    const litaC_u8* litaC_dest = (const litaC_u8*)utf8codepoint((const litaC_void*)litaC_str, litaC_codepoint);
    return (litaC_i32)(litaC_dest - litaC_str);
    
    
}

litaC_i32 litaC_std__unicode__utf8__Utf8HexDecode(const litaC_char* litaC_str,litaC_i32 litaC_len) {
    litaC_char litaC_buffer[9] =  {
        
    };
    litaC_len = (litaC_len == 4) ? 4 : 8;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_len;litaC_i += 1) {
        {
            litaC_buffer[litaC_i] = litaC_str[litaC_i];
            
            
        }
    }
    litaC_buffer[litaC_len] = '\0';
    return (litaC_i32)strtol(litaC_buffer, NULL, 16);
    
    
}


litaC_i32 litaC_std__unicode__utf8__Utf8Encode(litaC_i32 litaC_codepoint,litaC_u8* litaC_dst) {
    if(litaC_codepoint < 0x00) {
        {
            return 0;
            
            
            
        }
        
    } else {
        if(litaC_codepoint < 0x80) {
            {
                litaC_dst[0] = (litaC_u8)litaC_codepoint;
                return 1;
                
                
                
            }
            
        } else {
            if(litaC_codepoint < 0x800) {
                {
                    litaC_dst[0] = (litaC_u8)(0xC0 + (litaC_codepoint >> 6));
                    litaC_dst[1] = (litaC_u8)(0x80 + (litaC_codepoint & 0x3F));
                    return 2;
                    
                    
                    
                }
                
            } else {
                if(litaC_codepoint < 0x10000) {
                    {
                        litaC_dst[0] = (litaC_u8)(0xE0 + (litaC_codepoint >> 12));
                        litaC_dst[1] = (litaC_u8)(0x80 + ((litaC_codepoint >> 6) & 0x3F));
                        litaC_dst[2] = (litaC_u8)(0x80 + (litaC_codepoint & 0x3F));
                        return 3;
                        
                        
                        
                    }
                    
                } else {
                    if(litaC_codepoint < 0x110000) {
                        {
                            litaC_dst[0] = (litaC_u8)(0xF0 + (litaC_codepoint >> 18));
                            litaC_dst[1] = (litaC_u8)(0x80 + ((litaC_codepoint >> 12) & 0x3F));
                            litaC_dst[2] = (litaC_u8)(0x80 + ((litaC_codepoint >> 6) & 0x3F));
                            litaC_dst[3] = (litaC_u8)(0x80 + (litaC_codepoint & 0x3F));
                            return 4;
                            
                            
                            
                        }
                        
                    } 
                    
                } 
                
            } 
            
        } 
        
    } 
    
    return 0;
    
    
}


litaC_i32 litaC_std__unicode__utf8__Utf8CharWidth(litaC_i32 litaC_codepoint) {
    if(litaC_codepoint >= 32 && litaC_codepoint < 127) {
        return 1;
        
        
    } 
    
    if(litaC_codepoint == 0) {
        return 0;
        
        
    } 
    
    if(litaC_codepoint > 0 && litaC_codepoint < 32) {
        return -(1);
        
        
    } 
    
    if(litaC_codepoint > 159 && litaC_codepoint < 256) {
        return -(1);
        
        
    } 
    
    if(litaC_codepoint == 127) {
        return -(1);
        
        
    } 
    
    if(litaC_codepoint == 0xD288 || litaC_codepoint == 0xD289 || litaC_codepoint == 0xE1AABE || (litaC_codepoint >= 0xE2839D && litaC_codepoint <= 0xE283A4) || (litaC_codepoint >= 0xEA99B0 && litaC_codepoint <= 0xEA99B2)) {
        {
            return 0;
            
            
            
        }
        
    } 
    
    if((litaC_codepoint >= 0xCC80 && litaC_codepoint <= 0xCDAF) || (litaC_codepoint >= 0xD283 && litaC_codepoint <= 0xD287) || (litaC_codepoint >= 0xD691 && litaC_codepoint <= 0xD787) || (litaC_codepoint >= 0xD890 && litaC_codepoint <= 0xDBAD) || (litaC_codepoint >= 0xDC91) || (litaC_codepoint >= 0xDCB0 && litaC_codepoint <= 0xDFBD)) {
        {
            return 0;
            
            
            
        }
        
    } 
    
    if(litaC_codepoint == 0xC2AD) {
        return 1;
        
        
    } 
    
    if(litaC_codepoint == 0xE2808B) {
        {
            return 0;
            
            
            
        }
        
    } 
    
    if(litaC_codepoint >= 0xE185A0 && litaC_codepoint <= 0xE187BF) {
        {
            return 0;
            
            
            
        }
        
    } 
    
    return 1;
    
    
}

litaC_bool litaC_std__unicode__utf8__Utf8CodepointValid(litaC_i32 litaC_codepoint) {
    return (((litaC_u32)litaC_codepoint) - 0xd800 > 0x07ff) && (((litaC_u32)litaC_codepoint < 0x110000));
    
    
}

litaC_types__TypeKind litaC_types__TypeKindFromString(const litaC_char* litaC_str,litaC_i32 litaC_len) {
    litaC_std__string_view__StringView litaC_view = litaC_std__string_view__StringViewInit(litaC_str, litaC_len);
    for(litaC_i32 litaC_i = litaC_types__TypeKind_BOOL;litaC_i < litaC_types__TypeKind_MAX_TYPE_KINDS;litaC_i += 1) {
        {
            if(litaC_std__string_view__StringView_equals(litaC_view, litaC_types__typeKindText[litaC_i], -(1))) {
                {
                    return litaC_i;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_types__TypeKind_MAX_TYPE_KINDS;
    
    
}

litaC_bool litaC_types__IsPtr(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_type->kind == litaC_types__TypeKind_CONST) {
        {
            litaC_types__TypeInfo* litaC_constInfo = litaC_type;
            return litaC_types__IsPtr(litaC_constInfo->constOf);
            
            
            
        }
        
    } 
    
    return litaC_type->kind == litaC_types__TypeKind_PTR;
    
    
}

litaC_bool litaC_types__IsPtrLike(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_PTR: 
        case litaC_types__TypeKind_STR: 
        case litaC_types__TypeKind_ARRAY: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__TypeInfo* litaC_constInfo = litaC_type;
                return litaC_types__IsPtrLike(litaC_constInfo->constOf);
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    
}

litaC_bool litaC_types__IsPtrOf(litaC_types__TypeInfo* litaC_type,litaC_types__TypeKind litaC_kind) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__TypeInfo* litaC_ptrInfo = litaC_type;
                return litaC_ptrInfo->ptrOf->kind == litaC_kind;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STR: {
            {
                return litaC_kind == litaC_types__TypeKind_CHAR;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__TypeInfo* litaC_arrayInfo = litaC_type;
                return litaC_arrayInfo->arrayOf->kind == litaC_kind;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__TypeInfo* litaC_constInfo = litaC_type;
                return litaC_constInfo->constOf->kind == litaC_kind;
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    
}

litaC_bool litaC_types__IsFuncLike(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_FUNC: 
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    
}

litaC_bool litaC_types__IsPrimitive(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_type->kind < litaC_types__TypeKind_STR;
    
    
}

litaC_bool litaC_types__IsNumberLike(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_BOOL: 
        case litaC_types__TypeKind_CHAR: 
        case litaC_types__TypeKind_I8: 
        case litaC_types__TypeKind_U8: 
        case litaC_types__TypeKind_I16: 
        case litaC_types__TypeKind_U16: 
        case litaC_types__TypeKind_I32: 
        case litaC_types__TypeKind_U32: 
        case litaC_types__TypeKind_I64: 
        case litaC_types__TypeKind_U64: 
        case litaC_types__TypeKind_F32: 
        case litaC_types__TypeKind_F64: 
        case litaC_types__TypeKind_USIZE: 
        case litaC_types__TypeKind_PTR: 
        case litaC_types__TypeKind_STR: 
        case litaC_types__TypeKind_ARRAY: 
        case litaC_types__TypeKind_NULL: 
        case litaC_types__TypeKind_ENUM: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__TypeInfo* litaC_constInfo = litaC_type;
                return litaC_types__IsNumberLike(litaC_constInfo->constOf);
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    
}

litaC_bool litaC_types__IsInteger(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_BOOL: 
        case litaC_types__TypeKind_CHAR: 
        case litaC_types__TypeKind_I8: 
        case litaC_types__TypeKind_U8: 
        case litaC_types__TypeKind_I16: 
        case litaC_types__TypeKind_U16: 
        case litaC_types__TypeKind_I32: 
        case litaC_types__TypeKind_U32: 
        case litaC_types__TypeKind_I64: 
        case litaC_types__TypeKind_U64: 
        case litaC_types__TypeKind_USIZE: 
        case litaC_types__TypeKind_ENUM: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__TypeInfo* litaC_constInfo = litaC_type;
                return litaC_types__IsInteger(litaC_constInfo->constOf);
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    
}

litaC_bool litaC_types__IsBooleanable(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_BOOL: 
        case litaC_types__TypeKind_CHAR: 
        case litaC_types__TypeKind_I8: 
        case litaC_types__TypeKind_U8: 
        case litaC_types__TypeKind_I16: 
        case litaC_types__TypeKind_U16: 
        case litaC_types__TypeKind_I32: 
        case litaC_types__TypeKind_U32: 
        case litaC_types__TypeKind_I64: 
        case litaC_types__TypeKind_U64: 
        case litaC_types__TypeKind_F32: 
        case litaC_types__TypeKind_F64: 
        case litaC_types__TypeKind_USIZE: 
        case litaC_types__TypeKind_PTR: 
        case litaC_types__TypeKind_STR: 
        case litaC_types__TypeKind_ARRAY: 
        case litaC_types__TypeKind_NULL: 
        case litaC_types__TypeKind_FUNC_PTR: 
        case litaC_types__TypeKind_ENUM: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__TypeInfo* litaC_constInfo = litaC_type;
                return litaC_types__IsBooleanable(litaC_constInfo->constOf);
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    
}

litaC_bool litaC_types__IsStringLike(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_type->kind == litaC_types__TypeKind_STR) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    if(litaC_type->kind == litaC_types__TypeKind_ARRAY) {
        {
            return litaC_types__IsCharLike(litaC_type->arrayOf);
            
            
            
        }
        
    } 
    
    if(!(litaC_types__IsPtr(litaC_type))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_ptrOf = litaC_type->ptrOf;
    return litaC_types__IsCharLike(litaC_ptrOf);
    
    
}

litaC_bool litaC_types__IsCharLike(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_CHAR: 
        case litaC_types__TypeKind_I8: 
        case litaC_types__TypeKind_U8: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__TypeInfo* litaC_constInfo = litaC_type;
                return litaC_types__IsCharLike(litaC_constInfo->constOf);
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    
}

litaC_types__TypeInfo* litaC_types__AsTraitFuncPtr(litaC_types__TypeInfo* litaC_type,litaC_intern__InternedString litaC_name,litaC_types_new__TypeCache* litaC_typeCache) {
    if(!(litaC_type)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    assert(litaC_type->kind == litaC_types__TypeKind_FUNC_PTR);
    litaC_types__TypeInfo* litaC_funcPtr = litaC_type;
    assert(litaC_funcPtr->isTrait);
    litaC_std__array__Array_cb__ptr_TypeInfo_ce_ litaC_params = litaC_std__array__ArrayInit_cb__ptr_TypeInfo_ce_(litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcPtr->paramDecls))) + 1, litaC_typeCache->allocator);
    litaC_std__array__Array_add_cb__ptr_TypeInfo_ce_(&((litaC_params)), (litaC_types__TypeInfo*)litaC_types_new__TypeCache_newPtrTypeInfo(litaC_typeCache, &(litaC_types__VOID_TYPE)));
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcPtr->paramDecls)));litaC_i += 1) {
        {
            litaC_std__array__Array_add_cb__ptr_TypeInfo_ce_(&((litaC_params)), litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_funcPtr->paramDecls)), litaC_i));
            
            
        }
    }
    litaC_types__TypeInfo* litaC_result = litaC_types_new__TypeCache_newFuncPtrTypeInfo(litaC_typeCache, litaC_funcPtr->genericParams, litaC_funcPtr->returnType, litaC_params, litaC_funcPtr->hasVarargs);
    litaC_result->name = litaC_name;
    return litaC_result;
    
    
}

litaC_types__TypeInfo* litaC_types__AsAggregate(litaC_types__TypeInfo* litaC_type) {
    assert(litaC_types__IsAggregateLike(litaC_type));
    if(litaC_types__IsAggregate(litaC_type)) {
        {
            if(litaC_type->kind == litaC_types__TypeKind_CONST) {
                {
                    litaC_types__TypeInfo* litaC_constInfo = litaC_type;
                    return litaC_types__AsAggregate(litaC_constInfo->constOf);
                    
                    
                    
                }
                
            } 
            
            return litaC_type;
            
            
            
        }
        
    } 
    
    if(litaC_types__IsPtrAggregate(litaC_type)) {
        {
            litaC_types__TypeInfo* litaC_ptrInfo = NULL;
            if(litaC_type->kind == litaC_types__TypeKind_CONST) {
                {
                    litaC_types__TypeInfo* litaC_constInfo = litaC_type;
                    litaC_ptrInfo = litaC_constInfo->constOf;
                    
                    
                }
                
            } else {
                {
                    litaC_ptrInfo = litaC_type->ptrOf;
                    
                    
                }
            } 
            
            return litaC_types__AsAggregate(litaC_ptrInfo);
            
            
            
        }
        
    } 
    
    assert(litaC_false);
    return NULL;
    
    
}

litaC_bool litaC_types__IsAggregateLike(litaC_types__TypeInfo* litaC_type) {
    return litaC_types__IsAggregate(litaC_type) || litaC_types__IsPtrAggregate(litaC_type);
    
    
}

litaC_bool litaC_types__IsAggregate(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_type->kind == litaC_types__TypeKind_CONST) {
        {
            litaC_types__TypeInfo* litaC_constInfo = litaC_type;
            return litaC_types__IsAggregate(litaC_constInfo->constOf);
            
            
            
        }
        
    } 
    
    return litaC_type->kind == litaC_types__TypeKind_STRUCT || litaC_type->kind == litaC_types__TypeKind_UNION || litaC_type->kind == litaC_types__TypeKind_TRAIT;
    
    
}

litaC_bool litaC_types__IsPtrAggregate(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_types__IsPtr(litaC_type))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_ptrInfo = NULL;
    if(litaC_type->kind == litaC_types__TypeKind_CONST) {
        {
            litaC_types__TypeInfo* litaC_constInfo = litaC_type;
            litaC_ptrInfo = litaC_constInfo->constOf;
            
            
        }
        
    } else {
        {
            litaC_ptrInfo = litaC_type->ptrOf;
            
            
        }
    } 
    
    return litaC_types__IsAggregate(litaC_ptrInfo);
    
    
}

litaC_bool litaC_types__IsTrait(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_type->kind == litaC_types__TypeKind_CONST) {
        {
            litaC_types__TypeInfo* litaC_constInfo = litaC_type;
            return litaC_types__IsTrait(litaC_constInfo->constOf);
            
            
            
        }
        
    } 
    
    return litaC_type->kind == litaC_types__TypeKind_TRAIT;
    
    
}

litaC_bool litaC_types__IsPtrTrait(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_types__IsPtr(litaC_type))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_ptrInfo = NULL;
    if(litaC_type->kind == litaC_types__TypeKind_CONST) {
        {
            litaC_types__TypeInfo* litaC_constInfo = litaC_type;
            litaC_ptrInfo = litaC_constInfo->constOf;
            
            
        }
        
    } else {
        {
            litaC_ptrInfo = litaC_type->ptrOf;
            
            
        }
    } 
    
    return litaC_types__IsTrait(litaC_ptrInfo);
    
    
}

litaC_bool litaC_types__IsTraitLike(litaC_types__TypeInfo* litaC_type) {
    return litaC_types__IsTrait(litaC_type) || litaC_types__IsPtrTrait(litaC_type);
    
    
}

litaC_bool litaC_types__IsFieldAccessible(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_types__IsAggregate(litaC_type) || litaC_types__IsPtrAggregate(litaC_type) || litaC_type->kind == litaC_types__TypeKind_ENUM) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_bool litaC_types__IsGenericCapable(litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_FUNC: 
        case litaC_types__TypeKind_FUNC_PTR: 
        case litaC_types__TypeKind_STRUCT: 
        case litaC_types__TypeKind_TRAIT: 
        case litaC_types__TypeKind_UNION: {
            return litaC_true;
            
            
            
        }
        default: {
            return litaC_false;
            
            
            
        }
    }
    
}

litaC_types__TypeInfo* litaC_types__TypeInfo_getBaseType(litaC_types__TypeInfo* litaC_this) {
    if(!(litaC_this)) {
        return NULL;
        
        
    } 
    
    switch(litaC_this->kind) {
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__TypeInfo* litaC_info = litaC_this;
                return litaC_types__TypeInfo_getBaseType(litaC_info->ptrOf);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__TypeInfo* litaC_info = litaC_this;
                return litaC_types__TypeInfo_getBaseType(litaC_info->constOf);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__TypeInfo* litaC_info = litaC_this;
                if(litaC_info->arrayOf->kind == litaC_types__TypeKind_ARRAY) {
                    {
                        return litaC_types__TypeInfo_getBaseType(litaC_info->arrayOf);
                        
                        
                        
                    }
                    
                } 
                
                return litaC_info->arrayOf;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STR: {
            {
                return &(litaC_types__CHAR_TYPE);
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_this;
                
                
                
            }
            
            
        }
    }
    
}

litaC_types__TypeInfo* litaC_types__TypeInfo_getTypeOf(litaC_types__TypeInfo* litaC_this) {
    if(!(litaC_this)) {
        return NULL;
        
        
    } 
    
    switch(litaC_this->kind) {
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__TypeInfo* litaC_info = litaC_this;
                return litaC_info->ptrOf;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__TypeInfo* litaC_info = litaC_this;
                return litaC_info->constOf;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__TypeInfo* litaC_info = litaC_this;
                return litaC_info->arrayOf;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STR: {
            {
                return &(litaC_types__CHAR_TYPE);
                
                
                
            }
            
            
        }
        default: {
            {
                return NULL;
                
                
                
            }
            
            
        }
    }
    
}

const litaC_char* litaC_types__TypeInfo_toStringDebug(litaC_types__TypeInfo* litaC_this) {
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, NULL);
    litaC_types__TypeInfo_toString(litaC_this, &((litaC_sb)), litaC_false);
    return litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb)));
    
    
}

litaC_void litaC_types__TypeInfo_toString(litaC_types__TypeInfo* litaC_this,litaC_std__string_buffer__StringBuffer* litaC_sb,litaC_bool litaC_fullyQualify) {
    if(!(litaC_this)) {
        return;
        
        
    } 
    
    switch(litaC_this->kind) {
        case litaC_types__TypeKind_BOOL: 
        case litaC_types__TypeKind_CHAR: 
        case litaC_types__TypeKind_I8: 
        case litaC_types__TypeKind_U8: 
        case litaC_types__TypeKind_I16: 
        case litaC_types__TypeKind_U16: 
        case litaC_types__TypeKind_I32: 
        case litaC_types__TypeKind_U32: 
        case litaC_types__TypeKind_I64: 
        case litaC_types__TypeKind_U64: 
        case litaC_types__TypeKind_F32: 
        case litaC_types__TypeKind_F64: 
        case litaC_types__TypeKind_USIZE: 
        case litaC_types__TypeKind_NULL: 
        case litaC_types__TypeKind_VOID: 
        case litaC_types__TypeKind_GENERIC_PARAM: {
            {
                litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, litaC_this->name.buffer, litaC_this->name.length);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STRUCT: 
        case litaC_types__TypeKind_UNION: 
        case litaC_types__TypeKind_TRAIT: 
        case litaC_types__TypeKind_ENUM: {
            {
                if(litaC_fullyQualify && litaC_this->sym) {
                    {
                        litaC_intern__InternedString litaC_name = litaC_this->sym->declared->id.packageName;
                        litaC_std__string_buffer__StringBuffer_append(litaC_sb, "%.*s::", litaC_name.length, litaC_name.buffer);
                        
                        
                    }
                    
                } 
                
                litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, litaC_this->name.buffer, litaC_this->name.length);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STR: {
            {
                litaC_std__string_buffer__StringBuffer_appendStr(litaC_sb, "*const char");
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__TypeInfo* litaC_arrayInfo = litaC_this;
                if(litaC_arrayInfo->length) {
                    {
                        litaC_std__string_buffer__StringBuffer_append(litaC_sb, "[%llu]", litaC_arrayInfo->length);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, "[]", 2);
                        
                        
                    }
                } 
                
                litaC_types__TypeInfo_toString(litaC_arrayInfo->arrayOf, litaC_sb, litaC_fullyQualify);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__TypeInfo* litaC_ptrInfo = litaC_this;
                litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, "*", 1);
                litaC_types__TypeInfo_toString(litaC_ptrInfo->ptrOf, litaC_sb, litaC_fullyQualify);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__TypeInfo* litaC_constInfo = litaC_this;
                litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, "const ", 6);
                litaC_types__TypeInfo_toString(litaC_constInfo->constOf, litaC_sb, litaC_fullyQualify);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                litaC_types__TypeInfo* litaC_funcPtrInfo = litaC_this;
                litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, "func", 4);
                if(!(litaC_std__array__Array_empty_cb_GenericParam_ce_(&((litaC_funcPtrInfo->genericParams))))) {
                    {
                        litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, "<", 1);
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_funcPtrInfo->genericParams)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, ",", 1);
                                    
                                } 
                                
                                litaC_ast__Identifier litaC_t = litaC_std__array__Array_get_cb_GenericParam_ce_(&((litaC_funcPtrInfo->genericParams)), litaC_i).name;
                                litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, litaC_t.str.buffer, litaC_t.str.length);
                                
                                
                            }
                        }
                        litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, ">", 1);
                        
                        
                    }
                    
                } 
                
                litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, "(", 1);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcPtrInfo->paramDecls)));litaC_i += 1) {
                    {
                        if(litaC_i > 0) {
                            litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, ",", 1);
                            
                        } 
                        
                        litaC_types__TypeInfo* litaC_paramType = litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_funcPtrInfo->paramDecls)), litaC_i);
                        litaC_types__TypeInfo_toString(litaC_paramType, litaC_sb, litaC_fullyQualify);
                        
                        
                    }
                }
                litaC_std__string_buffer__StringBuffer_appendStr(litaC_sb, ") : ");
                litaC_types__TypeInfo_toString(litaC_funcPtrInfo->returnType, litaC_sb, litaC_fullyQualify);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC: {
            {
                litaC_types__TypeInfo* litaC_funcInfo = litaC_this;
                litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, "func", 4);
                if(!(litaC_std__array__Array_empty_cb_GenericParam_ce_(&((litaC_funcInfo->funcDecl->decl.genericParams))))) {
                    {
                        litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, "<", 1);
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_funcInfo->funcDecl->decl.genericParams)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, ",", 1);
                                    
                                } 
                                
                                litaC_ast__Identifier litaC_t = litaC_std__array__Array_get_cb_GenericParam_ce_(&((litaC_funcInfo->funcDecl->decl.genericParams)), litaC_i).name;
                                litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, litaC_t.str.buffer, litaC_t.str.length);
                                
                                
                            }
                        }
                        litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, ">", 1);
                        
                        
                    }
                    
                } 
                
                litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, "(", 1);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)));litaC_i += 1) {
                    {
                        if(litaC_i > 0) {
                            litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, ",", 1);
                            
                        } 
                        
                        litaC_ast__ParameterDecl* litaC_paramType = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)), litaC_i);
                        litaC_types__TypeInfo_toString(litaC_paramType->typeInfo, litaC_sb, litaC_fullyQualify);
                        
                        
                    }
                }
                litaC_std__string_buffer__StringBuffer_appendStr(litaC_sb, ") : ");
                litaC_types__TypeInfo_toString(litaC_funcInfo->returnType, litaC_sb, litaC_fullyQualify);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_POISON: {
            {
                litaC_std__string_buffer__StringBuffer_appendStr(litaC_sb, "<poison>");
                break;
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    
}

litaC_bool litaC_types__TypeInfo_strictEquals(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_other) {
    if(litaC_this == litaC_other) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    if(litaC_this && !(litaC_other)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_this) && litaC_other) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_this->kind != litaC_types__TypeKind_GENERIC_PARAM && litaC_other->kind != litaC_types__TypeKind_GENERIC_PARAM) {
        {
            if(litaC_other->kind != litaC_this->kind) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    switch(litaC_this->kind) {
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__TypeInfo* litaC_thisInfo = litaC_this;
                litaC_types__TypeInfo* litaC_otherInfo = litaC_other;
                return litaC_types__TypeInfo_strictEquals(litaC_thisInfo->ptrOf, litaC_otherInfo->ptrOf);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__TypeInfo* litaC_thisInfo = litaC_this;
                litaC_types__TypeInfo* litaC_otherInfo = litaC_other;
                return litaC_types__TypeInfo_strictEquals(litaC_thisInfo->constOf, litaC_otherInfo->constOf);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__TypeInfo* litaC_thisInfo = litaC_this;
                litaC_types__TypeInfo* litaC_otherInfo = litaC_other;
                if(litaC_thisInfo->length != litaC_otherInfo->length) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_types__TypeInfo_strictEquals(litaC_thisInfo->arrayOf, litaC_otherInfo->arrayOf);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                litaC_types__TypeInfo* litaC_thisInfo = litaC_this;
                litaC_types__TypeInfo* litaC_otherInfo = litaC_other;
                if(litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_thisInfo->paramDecls))) != litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_otherInfo->paramDecls)))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_types__TypeInfo_strictEquals(litaC_thisInfo->returnType, litaC_otherInfo->returnType))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_thisInfo->paramDecls)));litaC_i += 1) {
                    {
                        litaC_types__TypeInfo* litaC_a = litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_thisInfo->paramDecls)), litaC_i);
                        litaC_types__TypeInfo* litaC_b = litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_otherInfo->paramDecls)), litaC_i);
                        if(litaC_types__TypeInfo_strictEquals(litaC_a, litaC_b)) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_GENERIC_PARAM: {
            {
                if(litaC_other->kind == litaC_types__TypeKind_GENERIC_PARAM) {
                    {
                        return litaC_this->name.addr == litaC_other->name.addr;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_true;
                
                
                
            }
            
            
        }
        default: {
            {
                if(litaC_other->kind == litaC_types__TypeKind_GENERIC_PARAM) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_this->typeid == litaC_other->typeid;
                
                
                
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_bool litaC_types__TypeInfo_isAssignable(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_other,litaC_checker__TypeChecker* litaC_checker,litaC_bool litaC_allowDecay,litaC_bool litaC_allowPtrArithmetic) {
    assert(litaC_this != NULL);
    assert(litaC_other != NULL);
    if(litaC_other->typeid == litaC_this->typeid) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    switch(litaC_this->kind) {
        case litaC_types__TypeKind_BOOL: {
            {
                if(litaC_other->kind == litaC_types__TypeKind_VOID) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CHAR: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_U32;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I8: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_I8;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U8: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_U8;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I16: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_I16;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U16: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_U16;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I32: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_I32 || litaC_other->kind == litaC_types__TypeKind_ENUM;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U32: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_U32 || litaC_other->kind == litaC_types__TypeKind_ENUM;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I64: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_I64 || litaC_other->kind == litaC_types__TypeKind_ENUM;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U64: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_U64 || litaC_other->kind == litaC_types__TypeKind_ENUM;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_F32: {
            {
                return litaC_other->kind == litaC_types__TypeKind_F32 || litaC_other->kind <= litaC_types__TypeKind_U32;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_F64: {
            {
                return litaC_other->kind == litaC_types__TypeKind_F32 || litaC_other->kind == litaC_types__TypeKind_F64;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_USIZE: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_USIZE || litaC_other->kind == litaC_types__TypeKind_NULL || litaC_types__IsPtrLike(litaC_other);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_NULL: {
            {
                return litaC_other->kind == litaC_types__TypeKind_NULL;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_VOID: {
            {
                return litaC_other->kind == litaC_types__TypeKind_VOID;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STR: {
            {
                if(litaC_allowPtrArithmetic && litaC_types__IsInteger(litaC_other)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_other, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                if(litaC_allowPtrArithmetic && litaC_types__IsInteger(litaC_other)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_allowDecay) {
                    {
                        return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_other, litaC_checker);
                        
                        
                        
                    }
                    
                } 
                
                return litaC_false;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_PTR: {
            {
                if(litaC_allowPtrArithmetic && litaC_types__IsInteger(litaC_other)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_other, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__TypeInfo* litaC_thisInfo = litaC_this;
                if(litaC_other->kind != litaC_types__TypeKind_CONST) {
                    {
                        return litaC_types__TypeInfo_isAssignable(litaC_thisInfo->constOf, litaC_other, litaC_checker, litaC_true, litaC_true);
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__TypeInfo* litaC_otherInfo = litaC_other;
                return litaC_types__TypeInfo_isAssignable(litaC_thisInfo->constOf, litaC_otherInfo->constOf, litaC_checker, litaC_true, litaC_true);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STRUCT: {
            {
                if(litaC_other->kind != litaC_types__TypeKind_STRUCT) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_this->typeid == litaC_other->typeid;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_UNION: {
            {
                if(litaC_other->kind != litaC_types__TypeKind_UNION) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_this->typeid == litaC_other->typeid;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_TRAIT: {
            {
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_other, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ENUM: {
            {
                if(litaC_types__IsInteger(litaC_other)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_other->kind != litaC_types__TypeKind_ENUM) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_this->typeid == litaC_other->typeid;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                if(litaC_other->kind == litaC_types__TypeKind_NULL) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_types__IsPtrOf(litaC_other, litaC_types__TypeKind_VOID)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_types__IsFuncLike(litaC_other))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__TypeInfo* litaC_thisInfo = litaC_this;
                if(litaC_other->kind != litaC_types__TypeKind_FUNC) {
                    {
                        return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_other, litaC_checker);
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__TypeInfo* litaC_funcInfo = litaC_other;
                if(litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params))) != litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_thisInfo->paramDecls)))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_funcInfo->funcDecl->params->isVararg != litaC_thisInfo->hasVarargs) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_types__TypeInfo_strictEquals(litaC_funcInfo->returnType, litaC_thisInfo->returnType))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_thisInfo->paramDecls)));litaC_i += 1) {
                    {
                        litaC_types__TypeInfo* litaC_a = litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_thisInfo->paramDecls)), litaC_i);
                        litaC_ast__ParameterDecl* litaC_b = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)), litaC_i);
                        if(!(litaC_b->typeInfo)) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        if(!(litaC_types__TypeInfo_strictEquals(litaC_a, litaC_b->typeInfo))) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_POISON: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_GENERIC_PARAM: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        default: {
            {
                printf("Type: %s\n", litaC_types__typeKindText[litaC_this->kind]);
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_bool litaC_types__TypeInfo_isDeclarable(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_other,litaC_checker__TypeChecker* litaC_checker) {
    switch(litaC_this->kind) {
        case litaC_types__TypeKind_BOOL: {
            {
                return litaC_other->kind == litaC_types__TypeKind_BOOL;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CHAR: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_U32;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I8: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_I8;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U8: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_U8;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I16: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_I16;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U16: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_U16;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I32: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_I32 || litaC_other->kind == litaC_types__TypeKind_ENUM;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U32: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_U32 || litaC_other->kind == litaC_types__TypeKind_ENUM;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I64: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_I64 || litaC_other->kind == litaC_types__TypeKind_ENUM;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U64: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_U64 || litaC_other->kind == litaC_types__TypeKind_ENUM;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_F32: {
            {
                return litaC_other->kind == litaC_types__TypeKind_F32 || litaC_other->kind <= litaC_types__TypeKind_U32;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_F64: {
            {
                return litaC_other->kind == litaC_types__TypeKind_F32 || litaC_other->kind == litaC_types__TypeKind_F64;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_USIZE: {
            {
                return litaC_other->kind <= litaC_types__TypeKind_USIZE || litaC_other->kind == litaC_types__TypeKind_NULL || litaC_types__IsPtrLike(litaC_other);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_NULL: {
            {
                return litaC_other->kind == litaC_types__TypeKind_NULL;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_VOID: {
            {
                return litaC_other->kind == litaC_types__TypeKind_VOID;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STR: {
            {
                if(litaC_types__IsPtr(litaC_other)) {
                    {
                        litaC_types__TypeInfo* litaC_otherPtr = litaC_other;
                        if(litaC_otherPtr->ptrOf->kind == litaC_types__TypeKind_CONST) {
                            {
                                litaC_types__TypeInfo* litaC_constOf = litaC_otherPtr->ptrOf;
                                return litaC_constOf->constOf->kind == litaC_types__TypeKind_CHAR;
                                
                                
                                
                            }
                            
                        } 
                        
                        return litaC_otherPtr->ptrOf->kind == litaC_types__TypeKind_CHAR;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_other->kind == litaC_types__TypeKind_STR;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__TypeInfo* litaC_thisArray = litaC_this;
                if(litaC_other->kind == litaC_types__TypeKind_STR) {
                    {
                        if(litaC_thisArray->arrayOf->kind == litaC_types__TypeKind_CONST) {
                            {
                                return litaC_types__IsPtrOf(litaC_thisArray->arrayOf, litaC_types__TypeKind_CHAR);
                                
                                
                                
                            }
                            
                        } 
                        
                        if(!(litaC_types__IsPtrOf(litaC_thisArray, litaC_types__TypeKind_CHAR))) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_other->kind == litaC_types__TypeKind_PTR) {
                    {
                        litaC_types__TypeInfo* litaC_otherPtr = litaC_other;
                        return litaC_types__TypeInfo_isDeclarable(litaC_thisArray->arrayOf, litaC_otherPtr->ptrOf, litaC_checker);
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_other->kind != litaC_types__TypeKind_ARRAY) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__TypeInfo* litaC_otherArray = litaC_other;
                if(!(litaC_types__TypeInfo_isDeclarable(litaC_thisArray->arrayOf, litaC_otherArray->arrayOf, litaC_checker))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_thisArray->length)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_thisArray->length == litaC_otherArray->length;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_PTR: {
            {
                if(litaC_other->kind == litaC_types__TypeKind_NULL) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_other->kind == litaC_types__TypeKind_FUNC_PTR) {
                    {
                        if(litaC_types__IsPtrOf(litaC_this, litaC_types__TypeKind_VOID)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_types__IsPtrLike(litaC_other))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__TypeInfo* litaC_thisPtr = litaC_this;
                litaC_bool litaC_isVoidPtr = litaC_false;
                litaC_bool litaC_isConst = litaC_false;
                litaC_types__TypeInfo* litaC_ptrOf = litaC_thisPtr->ptrOf;
                if(litaC_thisPtr->ptrOf->kind == litaC_types__TypeKind_CONST) {
                    {
                        litaC_types__TypeInfo* litaC_thisConst = litaC_thisPtr->ptrOf;
                        litaC_ptrOf = litaC_thisConst->constOf;
                        litaC_isConst = litaC_true;
                        
                        
                    }
                    
                } 
                
                if(litaC_ptrOf->kind == litaC_types__TypeKind_VOID) {
                    {
                        litaC_isVoidPtr = litaC_true;
                        
                        
                    }
                    
                } 
                
                switch(litaC_other->kind) {
                    case litaC_types__TypeKind_PTR: {
                        {
                            litaC_types__TypeInfo* litaC_otherPtr = litaC_other;
                            if(litaC_otherPtr->ptrOf->kind == litaC_types__TypeKind_CONST) {
                                {
                                    if(!(litaC_isConst)) {
                                        {
                                            return litaC_false;
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            if(litaC_isVoidPtr) {
                                {
                                    return litaC_true;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            if(litaC_types__IsTrait(litaC_ptrOf)) {
                                {
                                    litaC_types__TypeInfo* litaC_otherPtrOf = litaC_types__TypeInfo_getBaseType(litaC_otherPtr);
                                    if(litaC_types__IsTrait(litaC_otherPtrOf)) {
                                        {
                                            return litaC_ptrOf->typeid == litaC_otherPtrOf->typeid;
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    return litaC_false;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            if(litaC_types__IsPtrAggregate(litaC_this) && litaC_types__IsPtrAggregate(litaC_other)) {
                                {
                                    litaC_types__TypeInfo* litaC_otherAgg = litaC_types__TypeInfo_getBaseType(litaC_other);
                                    litaC_types__TypeInfo* litaC_thisAgg = litaC_types__TypeInfo_getBaseType(litaC_this);
                                    if(litaC_otherAgg->typeid == litaC_thisAgg->typeid) {
                                        {
                                            return litaC_true;
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    litaC_ast__FieldStmt litaC_field = litaC_types__TypeInfo_getFieldByType(litaC_otherAgg, litaC_thisAgg, litaC_true);
                                    return (litaC_field.kind == litaC_ast__StmtKind_VAR_FIELD_DECL) || (litaC_field.kind == litaC_ast__StmtKind_TRAIT_FIELD_DECL);
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            return litaC_types__TypeInfo_isDeclarable(litaC_thisPtr->ptrOf, litaC_otherPtr->ptrOf, litaC_checker);
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_ARRAY: {
                        {
                            if(litaC_isVoidPtr) {
                                {
                                    return litaC_true;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_types__TypeInfo* litaC_otherArray = litaC_other;
                            return litaC_types__TypeInfo_isDeclarable(litaC_thisPtr->ptrOf, litaC_otherArray->arrayOf, litaC_checker);
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_STR: {
                        {
                            if(!(litaC_isConst)) {
                                {
                                    return litaC_false;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            if(litaC_isVoidPtr) {
                                {
                                    return litaC_true;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            return litaC_types__TypeInfo_isDeclarable(litaC_thisPtr->ptrOf, &(litaC_types__CHAR_TYPE), litaC_checker);
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_CONST: {
                        {
                            return litaC_false;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_FUNC_PTR: {
                        {
                            return litaC_true;
                            
                            
                            
                        }
                        
                        
                    }
                    default: {
                        {
                            return litaC_false;
                            
                            
                            
                        }
                        
                        
                    }
                }
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__TypeInfo* litaC_constInfo = litaC_this;
                if(litaC_other->kind == litaC_types__TypeKind_CONST) {
                    {
                        litaC_types__TypeInfo* litaC_otherConst = litaC_other;
                        litaC_other = litaC_otherConst->constOf;
                        
                        
                    }
                    
                } 
                
                return litaC_types__TypeInfo_isDeclarable(litaC_constInfo->constOf, litaC_other, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                if(litaC_other->kind == litaC_types__TypeKind_NULL) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_types__IsPtrOf(litaC_other, litaC_types__TypeKind_VOID)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_other->kind != litaC_types__TypeKind_FUNC_PTR) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__TypeInfo* litaC_fnPtrInfo = litaC_this;
                litaC_types__TypeInfo* litaC_otherFnPtrInfo = litaC_other;
                if(litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_fnPtrInfo->paramDecls))) != litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_otherFnPtrInfo->paramDecls)))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_fnPtrInfo->hasVarargs != litaC_otherFnPtrInfo->hasVarargs) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_types__TypeInfo_strictEquals(litaC_fnPtrInfo->returnType, litaC_otherFnPtrInfo->returnType))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_fnPtrInfo->paramDecls)));litaC_i += 1) {
                    {
                        litaC_types__TypeInfo* litaC_a = litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_fnPtrInfo->paramDecls)), litaC_i);
                        litaC_types__TypeInfo* litaC_b = litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_otherFnPtrInfo->paramDecls)), litaC_i);
                        if(!(litaC_types__TypeInfo_strictEquals(litaC_a, litaC_b))) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STRUCT: {
            {
                if(litaC_other->kind != litaC_types__TypeKind_STRUCT) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_this->typeid == litaC_other->typeid) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__TypeInfo* litaC_aggInfo = litaC_other;
                if(litaC_std__array__Array_empty_cb_FieldStmt_ce_(&((litaC_aggInfo->aggDecl->fields)))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                litaC_ast__FieldStmt litaC_field = litaC_types__TypeInfo_getFieldByPosition(litaC_aggInfo, 0);
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_field.typeInfo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_UNION: {
            {
                if(litaC_other->kind != litaC_types__TypeKind_UNION) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_this->typeid == litaC_other->typeid) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__TypeInfo* litaC_aggInfo = litaC_other;
                if(litaC_std__array__Array_empty_cb_FieldStmt_ce_(&((litaC_aggInfo->aggDecl->fields)))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                litaC_ast__FieldStmt litaC_field = litaC_types__TypeInfo_getFieldByPosition(litaC_aggInfo, 0);
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_field.typeInfo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_TRAIT: {
            {
                if(litaC_this->typeid == litaC_other->typeid) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_types__IsPtr(litaC_other))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__TypeInfo* litaC_aggInfo = litaC_types__TypeInfo_getBaseType(litaC_other);
                return litaC_types__TypeInfo_implementsTrait(litaC_aggInfo, litaC_this, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ENUM: {
            {
                if(litaC_other->kind != litaC_types__TypeKind_ENUM) {
                    {
                        return litaC_types__IsInteger(litaC_other);
                        
                        
                        
                    }
                    
                } 
                
                return litaC_this->typeid == litaC_other->typeid;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC: {
            {
                assert(litaC_false);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_POISON: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_bool litaC_types__TypeInfo_canCastTo(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_castTo,litaC_checker__TypeChecker* litaC_checker) {
    if(litaC_types__IsPtrOf(litaC_castTo, litaC_types__TypeKind_VOID)) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    if(litaC_castTo->kind == litaC_types__TypeKind_NULL) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_this->kind) {
        case litaC_types__TypeKind_BOOL: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CHAR: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I8: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U8: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I16: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U16: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I32: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U32: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I64: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U64: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_F32: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_F64: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_USIZE: {
            {
                return litaC_types__IsNumberLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_NULL: {
            {
                return litaC_types__IsPtrLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_VOID: {
            {
                return litaC_castTo->kind == litaC_types__TypeKind_VOID;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STR: {
            {
                if(litaC_types__IsPtrLike(litaC_castTo)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_castTo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                return litaC_types__IsPtrLike(litaC_castTo);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_PTR: {
            {
                if(litaC_castTo->kind == litaC_types__TypeKind_PTR) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_types__IsInteger(litaC_castTo)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_castTo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_castTo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STRUCT: {
            {
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_castTo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_UNION: {
            {
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_castTo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_TRAIT: {
            {
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_castTo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ENUM: {
            {
                if(litaC_types__IsInteger(litaC_castTo)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_castTo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC: {
            {
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_castTo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                if(litaC_castTo->kind != litaC_types__TypeKind_CONST) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_types__TypeInfo_isDeclarable(litaC_this, litaC_castTo, litaC_checker);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_POISON: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_bool litaC_types__IsFuncImpl(litaC_types__TypeInfo* litaC_traitFn,litaC_types__TypeInfo* litaC_fn,litaC_checker__TypeChecker* litaC_checker) {
    assert(litaC_traitFn);
    assert(litaC_fn);
    if(litaC_fn->kind != litaC_types__TypeKind_FUNC) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_funcInfo = litaC_fn;
    if(litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params))) != litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_traitFn->paramDecls))) + 1) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_funcInfo->funcDecl->params->isVararg != litaC_traitFn->hasVarargs) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_types__TypeInfo_strictEquals(litaC_funcInfo->returnType, litaC_traitFn->returnType))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_firstArg = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)), 0)->typeInfo;
    if(!(litaC_types__IsPtr(litaC_firstArg))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_traitFn->paramDecls)));litaC_i += 1) {
        {
            litaC_types__TypeInfo* litaC_a = litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_traitFn->paramDecls)), litaC_i);
            litaC_ast__ParameterDecl* litaC_b = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)), litaC_i + 1);
            if(!(litaC_b->typeInfo)) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            if(!(litaC_types__TypeInfo_strictEquals(litaC_a, litaC_b->typeInfo))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_true;
    
    
}

litaC_ast__TypeSpec* litaC_types__TypeInfo_asTypeSpec(litaC_types__TypeInfo* litaC_this,litaC_module__Module* litaC_module) {
    litaC_lex__SrcPos litaC_pos = ((litaC_this->sym)) ? litaC_this->sym->decl->stmt.node.startPos : (litaC_lex__SrcPos) {
        
    };
    litaC_ast_new__TypeSpecAllocator* litaC_allocator = &(litaC_module->typeSpecAllocator);
    switch(litaC_this->kind) {
        case litaC_types__TypeKind_BOOL: {
            {
                return litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_intern__BOOL, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CHAR: {
            {
                return litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_intern__CHAR, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I8: {
            {
                return litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_intern__I8, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U8: {
            {
                return litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_intern__U8, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I16: {
            {
                return litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_intern__I16, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U16: {
            {
                return litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_intern__U16, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I32: {
            {
                return litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_intern__I32, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U32: {
            {
                return litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_intern__U32, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_I64: {
            {
                return litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_intern__I64, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_U64: {
            {
                return litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_intern__U64, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_F32: {
            {
                return litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_intern__F32, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_F64: {
            {
                return litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_intern__F64, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_USIZE: {
            {
                return litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_intern__USIZE, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_NULL: {
            {
                return litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_intern__NULL, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_VOID: {
            {
                return litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_intern__VOID, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STR: {
            {
                return litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_intern__STRING, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_GENERIC_PARAM: {
            {
                litaC_types__TypeInfo* litaC_genericParamInfo = litaC_this;
                return litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_genericParamInfo->name, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__TypeInfo* litaC_arrayInfo = litaC_this;
                litaC_ast__TypeSpec* litaC_arrayTypeSpec = litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_ARRAY, litaC_pos, litaC_allocator);
                litaC_arrayTypeSpec->base = litaC_types__TypeInfo_asTypeSpec(litaC_arrayInfo->arrayOf, litaC_module);
                litaC_arrayTypeSpec->numElements = litaC_arrayInfo->numOfElements;
                return litaC_arrayTypeSpec;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__TypeInfo* litaC_ptrInfo = litaC_this;
                litaC_ast__TypeSpec* litaC_ptrTypeSpec = litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_PTR, litaC_pos, litaC_allocator);
                litaC_ptrTypeSpec->base = litaC_types__TypeInfo_asTypeSpec(litaC_ptrInfo->ptrOf, litaC_module);
                return litaC_ptrTypeSpec;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__TypeInfo* litaC_constInfo = litaC_this;
                litaC_ast__TypeSpec* litaC_constTypeSpec = litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_CONST, litaC_pos, litaC_allocator);
                litaC_constTypeSpec->base = litaC_types__TypeInfo_asTypeSpec(litaC_constInfo->constOf, litaC_module);
                return litaC_constTypeSpec;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                litaC_types__TypeInfo* litaC_funcInfo = litaC_this;
                litaC_std__array__Array_cb__ptr_TypeSpec_ce_ litaC_args =  {
                    
                };
                litaC_std__array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_args)), litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcInfo->paramDecls))), litaC_module->allocator);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcInfo->paramDecls)));litaC_i += 1) {
                    {
                        litaC_types__TypeInfo* litaC_param = litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_funcInfo->paramDecls)), litaC_i);
                        litaC_std__array__Array_add_cb__ptr_TypeSpec_ce_(&((litaC_args)), litaC_types__TypeInfo_asTypeSpec(litaC_param, litaC_module));
                        
                        
                    }
                }
                litaC_ast__TypeSpec* litaC_result = litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_FUNC_PTR, litaC_pos, litaC_allocator);
                litaC_result->ret = litaC_types__TypeInfo_asTypeSpec(litaC_funcInfo->returnType, litaC_module);
                litaC_result->args = litaC_args;
                litaC_result->hasVarargs = litaC_funcInfo->hasVarargs;
                litaC_result->genericParams = litaC_funcInfo->genericParams;
                return litaC_result;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_TRAIT: 
        case litaC_types__TypeKind_UNION: 
        case litaC_types__TypeKind_STRUCT: {
            {
                litaC_types__TypeInfo* litaC_aggInfo = litaC_this;
                litaC_ast__TypeSpec* litaC_result = litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_aggInfo->name, litaC_allocator);
                litaC_std__array__Array_cb__ptr_TypeSpec_ce_ litaC_args =  {
                    
                };
                litaC_std__array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_args)), litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_aggInfo->aggDecl->decl.genericParams))), litaC_module->allocator);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_aggInfo->aggDecl->decl.genericParams)));litaC_i += 1) {
                    {
                        litaC_ast__GenericParam litaC_param = litaC_std__array__Array_get_cb_GenericParam_ce_(&((litaC_aggInfo->aggDecl->decl.genericParams)), litaC_i);
                        litaC_intern__InternedString litaC_name = litaC_param.name.str;
                        litaC_std__array__Array_add_cb__ptr_TypeSpec_ce_(&((litaC_args)), litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_name, litaC_allocator));
                        
                        
                    }
                }
                litaC_result->genericArgs = litaC_args;
                return litaC_result;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ENUM: {
            {
                litaC_types__TypeInfo* litaC_info = litaC_this;
                return litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_info->name, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC: {
            {
                litaC_types__TypeInfo* litaC_info = litaC_this;
                return litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_info->name, litaC_allocator);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_POISON: {
            {
                return litaC_ast_new__NewNameTypeSpecIntern(litaC_pos, litaC_intern__POISON, litaC_allocator);
                
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return NULL;
    
    
}

litaC_types__TypeInfo* litaC_types__TypeInfo_asPtr(litaC_types__TypeInfo* litaC_this,litaC_types_new__TypeCache* litaC_typeCache) {
    litaC_std__array__Array_cb_GenericParam_ce_ litaC_genericParams = litaC_std__array__ArrayInit_cb_GenericParam_ce_(litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_this->funcDecl->decl.genericParams))), litaC_typeCache->allocator);
    litaC_std__array__Array_addAll_cb_GenericParam_ce_(&((litaC_genericParams)), &((litaC_this->funcDecl->decl.genericParams)));
    litaC_std__array__Array_cb__ptr_TypeInfo_ce_ litaC_paramDecls = litaC_std__array__ArrayInit_cb__ptr_TypeInfo_ce_(litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_this->funcDecl->params->params))), litaC_typeCache->allocator);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_this->funcDecl->params->params)));litaC_i += 1) {
        {
            litaC_ast__ParameterDecl* litaC_p = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_this->funcDecl->params->params)), litaC_i);
            litaC_std__array__Array_add_cb__ptr_TypeInfo_ce_(&((litaC_paramDecls)), litaC_p->typeInfo);
            
            
        }
    }
    litaC_types__TypeInfo* litaC_funcPtr = litaC_types_new__TypeCache_newFuncPtrTypeInfo(litaC_typeCache, litaC_genericParams, litaC_this->returnType, litaC_paramDecls, litaC_this->funcDecl->flags & litaC_ast__FuncFlags_HAS_VARARGS);
    litaC_funcPtr->name = litaC_this->name;
    return litaC_funcPtr;
    
    
}

litaC_ast__EnumFieldEntryDecl* litaC_types__TypeInfo_getEnumField(litaC_types__TypeInfo* litaC_this,litaC_intern__InternedString litaC_name) {
    assert(litaC_this != NULL);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_this->enumDecl->fields)));litaC_i += 1) {
        {
            litaC_ast__EnumFieldEntryDecl* litaC_field = litaC_std__array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_this->enumDecl->fields)), litaC_i);
            if(litaC_intern__InternedString_equals(&((litaC_field->decl.name.str)), &((litaC_name)))) {
                {
                    return litaC_field;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return NULL;
    
    
}

litaC_i32 litaC_types__TypeInfo_getEnumFieldIndex(litaC_types__TypeInfo* litaC_this,litaC_intern__InternedString litaC_name) {
    assert(litaC_this != NULL);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_this->enumDecl->fields)));litaC_i += 1) {
        {
            litaC_ast__EnumFieldEntryDecl* litaC_field = litaC_std__array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_this->enumDecl->fields)), litaC_i);
            if(litaC_intern__InternedString_equals(&((litaC_field->decl.name.str)), &((litaC_name)))) {
                {
                    return litaC_i;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return -(1);
    
    
}

const litaC_char* litaC_types__TypeInfo_getBaseName(litaC_types__TypeInfo* litaC_this,litaC_char* litaC_name,litaC_intern__InternedString* litaC_alias) {
    assert(litaC_this != NULL);
    litaC_i32 litaC_index = 0;
    const litaC_char* litaC_n = litaC_this->name.buffer;
    litaC_i32 litaC_len = litaC_this->name.length;
    if(litaC_alias) {
        {
            for(;litaC_index < litaC_alias->length && litaC_index < litaC_symbols__MAX_SYMBOL_NAME;litaC_index += 1) {
                {
                    litaC_name[litaC_index] = litaC_alias->buffer[litaC_index];
                    
                    
                }
            }
            litaC_name[litaC_index + 0] = ':';
            litaC_name[litaC_index + 1] = ':';
            litaC_index += 2;
            litaC_len += litaC_index;
            
            
        }
        
    } 
    
    while(litaC_index < litaC_len && litaC_index < litaC_symbols__MAX_SYMBOL_NAME && *(litaC_n)) {
        {
            litaC_char litaC_c = *(litaC_n);
            if(litaC_c == '<') {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_name[litaC_index] = litaC_c;
            litaC_n += 1;
            litaC_index += 1;
            
            
        }
    }
    litaC_name[litaC_index] = '\0';
    return litaC_name;
    
    
}

litaC_ast__FieldStmt litaC_types__TypeInfo_getFieldByPosition(litaC_types__TypeInfo* litaC_this,litaC_i32 litaC_position) {
    assert(litaC_this != NULL);
    if(litaC_position < 0 || litaC_position >= litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_this->aggDecl->fields)))) {
        {
            return (litaC_ast__FieldStmt) {
                .kind = litaC_ast__StmtKind_POISON_EXPR
            };
            
            
            
        }
        
    } 
    
    return litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_this->aggDecl->fields)), litaC_position);
    
    
}

litaC_ast__FieldStmt litaC_types__TypeInfo_getField(litaC_types__TypeInfo* litaC_this,litaC_intern__InternedString litaC_name) {
    assert(litaC_this != NULL);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_this->aggDecl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_this->aggDecl->fields)), litaC_i);
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        litaC_ast__TraitFieldDecl* litaC_varField = litaC_field.traitField;
                        if(litaC_intern__InternedString_equals(&((litaC_varField->decl.name.str)), &((litaC_name)))) {
                            {
                                if(!(litaC_field.typeInfo)) {
                                    {
                                        goto err;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                return litaC_field;
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                        if(litaC_intern__InternedString_equals(&((litaC_varField->decl.name.str)), &((litaC_name)))) {
                            {
                                if(!(litaC_field.typeInfo)) {
                                    {
                                        goto err;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                return litaC_field;
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                    {
                        litaC_ast__EnumDecl* litaC_enumField = litaC_field.enumField;
                        if(litaC_intern__InternedString_equals(&((litaC_enumField->decl.name.str)), &((litaC_name)))) {
                            {
                                return litaC_field;
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                        if(litaC_aggField->decl.declaration.name.token.type == litaC_lex__TokenType_VOID) {
                            {
                                litaC_types__TypeInfo* litaC_aggType = litaC_aggField->decl.declaration.sym->type;
                                litaC_ast__FieldStmt litaC_result = litaC_types__TypeInfo_getField(litaC_aggType, litaC_name);
                                if(litaC_result.kind != litaC_ast__StmtKind_POISON_EXPR) {
                                    {
                                        return litaC_result;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_intern__InternedString_equals(&((litaC_aggField->decl.declaration.name.str)), &((litaC_name)))) {
                            {
                                return litaC_field;
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        goto err;
                        
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    err:;
    
    return (litaC_ast__FieldStmt) {
        .kind = litaC_ast__StmtKind_POISON_EXPR
    };
    
    
}


litaC_i32 litaC_types__TypeInfo_getFieldIndex(litaC_types__TypeInfo* litaC_this,litaC_intern__InternedString litaC_name) {
    assert(litaC_this != NULL);
    litaC_i32 litaC_index = 0;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_this->aggDecl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_this->aggDecl->fields)), litaC_i);
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        litaC_ast__TraitFieldDecl* litaC_varField = litaC_field.traitField;
                        if(litaC_intern__InternedString_equals(&((litaC_varField->decl.name.str)), &((litaC_name)))) {
                            {
                                if(!(litaC_field.typeInfo)) {
                                    {
                                        goto err;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                return litaC_index;
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                        if(litaC_intern__InternedString_equals(&((litaC_varField->decl.name.str)), &((litaC_name)))) {
                            {
                                if(!(litaC_field.typeInfo)) {
                                    {
                                        goto err;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                return litaC_index;
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                    {
                        litaC_ast__EnumDecl* litaC_enumField = litaC_field.enumField;
                        if(litaC_intern__InternedString_equals(&((litaC_enumField->decl.name.str)), &((litaC_name)))) {
                            {
                                return litaC_index;
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                        if(litaC_aggField->decl.declaration.name.token.type == litaC_lex__TokenType_VOID) {
                            {
                                litaC_types__TypeInfo* litaC_aggType = litaC_aggField->decl.declaration.sym->type;
                                litaC_i32 litaC_result = litaC_types__TypeInfo_getFieldIndex(litaC_aggType, litaC_name);
                                if(litaC_result < 0) {
                                    {
                                        litaC_index += litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_aggType->aggDecl->fields)));
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        return litaC_index + litaC_result;
                                        
                                        
                                        
                                    }
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_intern__InternedString_equals(&((litaC_aggField->decl.declaration.name.str)), &((litaC_name)))) {
                            {
                                return litaC_index;
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        goto err;
                        
                        
                        
                    }
                    
                    
                }
            }
            litaC_index += 1;
            
            
        }
    }
    err:;
    
    return -(1);
    
    
}


litaC_types__FieldPositionResult litaC_types__TypeInfo_getFieldPosition(litaC_types__TypeInfo* litaC_this,litaC_intern__InternedString litaC_name) {
    litaC_types__FieldPath litaC_path =  {
        
    };
    if(litaC_types__TypeInfo_getFieldPath(litaC_this, litaC_name, &(litaC_path))) {
        {
            litaC_types__TypeInfo* litaC_aggInfo = litaC_this;
            litaC_i32 litaC_index = litaC_path.numOfFields - 1;
            while(litaC_index > 0) {
                {
                    litaC_types__TypeInfo* litaC_fieldInfo = litaC_path.fields[litaC_index].typeInfo;
                    if(litaC_types__IsAggregate(litaC_fieldInfo)) {
                        {
                            litaC_aggInfo = litaC_fieldInfo;
                            break;
                            
                            
                        }
                        
                    } 
                    
                    litaC_index -= 1;
                    
                    
                }
            }
            return (litaC_types__FieldPositionResult) {
                .aggInfo = litaC_aggInfo,
                .position = litaC_types__TypeInfo_getFieldIndex(litaC_aggInfo, litaC_name)
            };
            
            
            
        }
        
    } 
    
    return (litaC_types__FieldPositionResult) {
        .aggInfo = NULL,
        .position = -(1)
    };
    
    
}


litaC_ast__FieldStmt litaC_types__TypeInfo_getFieldByType(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_bool litaC_isParent) {
    assert(litaC_this != NULL);
    litaC_bool litaC_isGenericCapable = litaC_symbols__Symbol_isGenericCapable(litaC_type->sym);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_this->aggDecl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_this->aggDecl->fields)), litaC_i);
            if(!(litaC_types__IsAggregateLike(litaC_field.typeInfo))) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_isParent && litaC_field.kind == litaC_ast__StmtKind_VAR_FIELD_DECL) {
                {
                    if(!(litaC_field.varField->decl.attributes.isUsing)) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            litaC_types__TypeInfo* litaC_fieldBaseType = litaC_types__TypeInfo_getBaseType(litaC_field.typeInfo);
            if(litaC_symbols__Symbol_isGenericCapable(litaC_fieldBaseType->sym) && litaC_isGenericCapable) {
                {
                    if(litaC_fieldBaseType->genericTypeid == litaC_type->genericTypeid) {
                        {
                            return litaC_field;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            if(litaC_fieldBaseType->typeid == litaC_type->typeid) {
                {
                    return litaC_field;
                    
                    
                    
                }
                
            } 
            
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                        if(litaC_aggField->decl.declaration.name.token.type == litaC_lex__TokenType_VOID) {
                            {
                                litaC_types__TypeInfo* litaC_aggType = litaC_aggField->decl.declaration.sym->type;
                                litaC_ast__FieldStmt litaC_result = litaC_types__TypeInfo_getFieldByType(litaC_aggType, litaC_type, litaC_false);
                                if(litaC_result.kind != litaC_ast__StmtKind_POISON_EXPR) {
                                    {
                                        return litaC_result;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    return (litaC_ast__FieldStmt) {
        .kind = litaC_ast__StmtKind_POISON_EXPR
    };
    
    
}

litaC_ast__FieldStmt litaC_types__TypeInfo_getFieldWithUsing(litaC_types__TypeInfo* litaC_this,litaC_intern__InternedString litaC_name) {
    assert(litaC_this != NULL);
    litaC_ast__FieldStmt litaC_fieldStmt = litaC_types__TypeInfo_getField(litaC_this, litaC_name);
    if(litaC_fieldStmt.kind != litaC_ast__StmtKind_POISON_EXPR) {
        {
            return litaC_fieldStmt;
            
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_this->aggDecl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_this->aggDecl->fields)), litaC_i);
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        continue;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                        if(!(litaC_varField->decl.attributes.isUsing)) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        if(!(litaC_types__IsAggregate(litaC_field.typeInfo)) && !(litaC_types__IsPtrAggregate(litaC_field.typeInfo))) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        litaC_types__TypeInfo* litaC_baseType = litaC_types__TypeInfo_getBaseType(litaC_field.typeInfo);
                        assert(litaC_baseType->kind == litaC_types__TypeKind_STRUCT || litaC_baseType->kind == litaC_types__TypeKind_UNION);
                        litaC_fieldStmt = litaC_types__TypeInfo_getFieldWithUsing(litaC_baseType, litaC_name);
                        if(litaC_fieldStmt.kind != litaC_ast__StmtKind_POISON_EXPR) {
                            {
                                return litaC_fieldStmt;
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        continue;
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    return (litaC_ast__FieldStmt) {
        .kind = litaC_ast__StmtKind_POISON_EXPR
    };
    
    
}

litaC_void litaC_types__FieldPath_add(litaC_types__FieldPath* litaC_this,litaC_ast__FieldStmt litaC_field) {
    litaC_this->fields[litaC_this->numOfFields] = litaC_field;
    litaC_this->numOfFields += 1;
    assert(litaC_this->numOfFields < litaC_types__MAX_FIELD_PATH);
    
}

litaC_void litaC_types__FieldPath_pop(litaC_types__FieldPath* litaC_this) {
    litaC_this->numOfFields -= 1;
    if(litaC_this->numOfFields < 0) {
        {
            litaC_this->numOfFields = 0;
            
            
        }
        
    } 
    
    
}

litaC_bool litaC_types__TypeInfo_getFieldPath(litaC_types__TypeInfo* litaC_this,litaC_intern__InternedString litaC_name,litaC_types__FieldPath* litaC_path) {
    assert(litaC_this != NULL);
    litaC_ast__FieldStmt litaC_fieldStmt = litaC_types__TypeInfo_getField(litaC_this, litaC_name);
    if(litaC_fieldStmt.kind != litaC_ast__StmtKind_POISON_EXPR) {
        {
            litaC_types__FieldPath_add(litaC_path, litaC_fieldStmt);
            return litaC_true;
            
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_this->aggDecl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_this->aggDecl->fields)), litaC_i);
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        continue;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                        if(!(litaC_varField->decl.attributes.isUsing)) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        if(!(litaC_types__IsAggregate(litaC_field.typeInfo)) && !(litaC_types__IsPtrAggregate(litaC_field.typeInfo))) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        litaC_types__TypeInfo* litaC_baseType = litaC_types__TypeInfo_getBaseType(litaC_field.typeInfo);
                        assert(litaC_types__IsAggregate(litaC_baseType));
                        litaC_types__FieldPath_add(litaC_path, litaC_field);
                        if(litaC_types__TypeInfo_getFieldPath(litaC_baseType, litaC_name, litaC_path)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_types__FieldPath_pop(litaC_path);
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        continue;
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_bool litaC_types__TypeInfo_getFieldPathByType(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_types__FieldPath* litaC_path) {
    assert(litaC_this != NULL);
    litaC_ast__FieldStmt litaC_fieldStmt = litaC_types__TypeInfo_getFieldByType(litaC_this, litaC_type, litaC_true);
    if(litaC_fieldStmt.kind != litaC_ast__StmtKind_POISON_EXPR) {
        {
            litaC_types__FieldPath_add(litaC_path, litaC_fieldStmt);
            return litaC_true;
            
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_this->aggDecl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_this->aggDecl->fields)), litaC_i);
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        continue;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                        if(!(litaC_varField->decl.attributes.isUsing)) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        if(!(litaC_types__IsAggregateLike(litaC_field.typeInfo))) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        litaC_types__TypeInfo* litaC_baseType = litaC_types__TypeInfo_getBaseType(litaC_field.typeInfo);
                        assert(litaC_baseType->kind == litaC_types__TypeKind_STRUCT || litaC_baseType->kind == litaC_types__TypeKind_UNION);
                        litaC_types__FieldPath_add(litaC_path, litaC_field);
                        if(litaC_types__TypeInfo_getFieldPathByType(litaC_baseType, litaC_type, litaC_path)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_types__FieldPath_pop(litaC_path);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        litaC_types__TypeInfo* litaC_baseType = litaC_types__TypeInfo_getBaseType(litaC_field.typeInfo);
                        litaC_types__FieldPath_add(litaC_path, litaC_field);
                        if(litaC_types__TypeInfo_getFieldPathByType(litaC_baseType, litaC_type, litaC_path)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_types__FieldPath_pop(litaC_path);
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        continue;
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    return litaC_false;
    
    
}


const litaC_char* litaC_types__TypeInfo_getFunctionName(litaC_types__TypeInfo* litaC_this,litaC_char* litaC_result,litaC_intern__InternedString litaC_methodName,litaC_intern__InternedString* litaC_alias) {
    memset(litaC_result, 0, litaC_symbols__MAX_SYMBOL_NAME);
    litaC_types__TypeInfo_getBaseName(litaC_this, litaC_result, litaC_alias);
    litaC_std__string__String litaC_buffer = litaC_std__string__StringInit(litaC_result, litaC_symbols__MAX_SYMBOL_NAME, -(1));
    litaC_std__string__String_appendStrn(&((litaC_buffer)), "_", 1);
    litaC_std__string__String_appendStrn(&((litaC_buffer)), litaC_methodName.buffer, litaC_methodName.length);
    return litaC_std__string__String_cStrConst(litaC_buffer);
    
    
}

litaC_types__MethodResult litaC_types__TypeInfo_getMethod(litaC_types__TypeInfo* litaC_this,litaC_intern__Strings* litaC_strings,litaC_module__Module* litaC_module,litaC_intern__InternedString litaC_methodName) {
    if(!(litaC_this->sym)) {
        {
            goto not_found;
            
            
            
        }
        
    } 
    
    litaC_char litaC_funcName[256] =  {
        0
    };
    litaC_types__TypeInfo_getFunctionName(litaC_this, litaC_funcName, litaC_methodName, NULL);
    litaC_intern__InternedString litaC_funcNameInterned = litaC_intern__Strings_internCopy(litaC_strings, litaC_funcName, -(1));
    litaC_symbols__Symbol* litaC_methodSym = litaC_module__Module_getFuncType(litaC_module, litaC_funcNameInterned);
    if(litaC_methodSym == NULL || litaC_methodSym->kind != litaC_symbols__SymbolKind_FUNC) {
        {
            litaC_intern__InternedString* litaC_alias = litaC_module__Module_getImportAlias(litaC_module, litaC_this->sym->declared);
            if(!(litaC_alias)) {
                {
                    goto not_found;
                    
                    
                    
                }
                
            } 
            
            litaC_types__TypeInfo_getFunctionName(litaC_this, litaC_funcName, litaC_methodName, litaC_alias);
            litaC_funcNameInterned = litaC_intern__Strings_internCopy(litaC_strings, litaC_funcName, -(1));
            litaC_methodSym = litaC_module__Module_getFuncType(litaC_module, litaC_funcNameInterned);
            if(litaC_methodSym == NULL || litaC_methodSym->kind != litaC_symbols__SymbolKind_FUNC) {
                {
                    goto not_found;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_ast__FuncDecl* litaC_decl = (litaC_ast__FuncDecl*)litaC_methodSym->decl;
    if(!((litaC_decl->flags & litaC_ast__FuncFlags_IS_METHOD))) {
        {
            goto not_found;
            
            
            
        }
        
    } 
    
    if(litaC_std__array__Array_empty_cb__ptr_ParameterDecl_ce_(&((litaC_decl->params->params)))) {
        {
            goto not_found;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_base = litaC_types__TypeInfo_getBaseType(litaC_std__array__Array_first_cb__ptr_ParameterDecl_ce_(&((litaC_decl->params->params)))->typeInfo);
    if(litaC_this == NULL || litaC_base == NULL) {
        {
            goto not_found;
            
            
            
        }
        
    } 
    
    if(litaC_methodSym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
        {
            litaC_types__TypeInfo* litaC_thisGenericType = litaC_this;
            litaC_types__TypeInfo* litaC_baseGenericType = litaC_base;
            if(litaC_thisGenericType->genericTypeid == litaC_baseGenericType->genericTypeid) {
                {
                    return (litaC_types__MethodResult) {
                        .symbol = litaC_methodSym,
                        .name = litaC_funcNameInterned
                    };
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(litaC_types__TypeInfo_strictEquals(litaC_this, litaC_base)) {
        {
            return (litaC_types__MethodResult) {
                .symbol = litaC_methodSym,
                .name = litaC_funcNameInterned
            };
            
            
            
        }
        
    } 
    
    not_found:;
    
    return (litaC_types__MethodResult) {
        .symbol = NULL,
        .name = litaC_intern__EMPTY_STR
    };
    
    
}

litaC_bool litaC_types__TypeInfo_implementsTrait(litaC_types__TypeInfo* litaC_this,litaC_types__TypeInfo* litaC_iface,litaC_checker__TypeChecker* litaC_checker) {
    if(!(litaC_types__IsAggregateLike(litaC_iface))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_aggIface = litaC_types__AsAggregate(litaC_iface);
    if(!(litaC_aggIface->sym) || !((litaC_aggIface->sym->flags & litaC_symbols__SymbolFlags_IS_TRAIT))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_checker__TypeChecker_implementsTrait(litaC_checker, litaC_this, litaC_aggIface);
    
    
}

litaC_i64 litaC_types__NextTypeId() {
    litaC_types__idGen += 1;
    return litaC_types__idGen;
    
    
}


litaC_void litaC_types__TypesInit(litaC_intern__Strings* litaC_strings) {
    litaC_types__idGen = (litaC_i64)litaC_types__TypeKind_MAX_TYPE_KINDS;
    litaC_types__BOOL_TYPE.name = litaC_intern__BOOL;
    litaC_types__CHAR_TYPE.name = litaC_intern__CHAR;
    litaC_types__I8_TYPE.name = litaC_intern__I8;
    litaC_types__U8_TYPE.name = litaC_intern__U8;
    litaC_types__I16_TYPE.name = litaC_intern__I16;
    litaC_types__U16_TYPE.name = litaC_intern__U16;
    litaC_types__I32_TYPE.name = litaC_intern__I32;
    litaC_types__U32_TYPE.name = litaC_intern__U32;
    litaC_types__I64_TYPE.name = litaC_intern__I64;
    litaC_types__U64_TYPE.name = litaC_intern__U64;
    litaC_types__F32_TYPE.name = litaC_intern__F32;
    litaC_types__F64_TYPE.name = litaC_intern__F64;
    litaC_types__USIZE_TYPE.name = litaC_intern__USIZE;
    litaC_types__NULL_TYPE.name = litaC_intern__NULL;
    litaC_types__VOID_TYPE.name = litaC_intern__VOID;
    litaC_types__STR_TYPE.name = litaC_intern__STRING;
    litaC_types__POISON_TYPE.name = litaC_intern__POISON;
    
}

litaC_void litaC_ast_new__TypeSpecAllocator_init(litaC_ast_new__TypeSpecAllocator* litaC_this,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_this->allocator = litaC_allocator;
    litaC_std__bucket_list__BucketList_init_cb_TypeSpec_ce_(&((litaC_this->typeSpecs)), 1024, litaC_allocator);
    
}

litaC_void litaC_ast_new__TypeSpecAllocator_free(litaC_ast_new__TypeSpecAllocator* litaC_this) {
    litaC_std__bucket_list__BucketList_free_cb_TypeSpec_ce_(&((litaC_this->typeSpecs)));
    
}

litaC_void litaC_ast_new__TypeSpecAllocator_clear(litaC_ast_new__TypeSpecAllocator* litaC_this) {
    litaC_std__bucket_list__BucketList_clear_cb_TypeSpec_ce_(&((litaC_this->typeSpecs)));
    
}

litaC_ast__TypeSpec* litaC_ast_new__TypeSpecAllocator_alloc(litaC_ast_new__TypeSpecAllocator* litaC_this) {
    litaC_std__bucket_list__BucketList_add_cb_TypeSpec_ce_(&((litaC_this->typeSpecs)), (litaC_ast__TypeSpec) {
        
    });
    return litaC_std__bucket_list__BucketList_lastPtr_cb_TypeSpec_ce_(&((litaC_this->typeSpecs)));
    
    
}

litaC_ast__TypeSpec* litaC_ast_new__NewVoidTypeSpec(litaC_lex__SrcPos litaC_pos,litaC_ast_new__TypeSpecAllocator* litaC_typeAllocator) {
    litaC_ast__TypeSpec* litaC_voidSpec = litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_NAME, litaC_pos, litaC_typeAllocator);
    litaC_voidSpec->name = litaC_intern__VOID;
    return (litaC_ast__TypeSpec*)litaC_voidSpec;
    
    
}

litaC_ast__TypeSpec* litaC_ast_new__NewNameTypeSpecIntern(litaC_lex__SrcPos litaC_pos,litaC_intern__InternedString litaC_name,litaC_ast_new__TypeSpecAllocator* litaC_typeAllocator) {
    litaC_ast__TypeSpec* litaC_result = litaC_ast_new__TypeSpecAllocator_alloc(litaC_typeAllocator);
    litaC_result->kind = litaC_ast__TypeSpecKind_NAME;
    litaC_result->pos = litaC_pos;
    litaC_result->base = NULL;
    litaC_result->name = litaC_name;
    litaC_std__array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_result->genericArgs)), 0, litaC_typeAllocator->allocator);
    return litaC_result;
    
    
}

litaC_ast__TypeSpec* litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind litaC_kind,litaC_lex__SrcPos litaC_pos,litaC_ast_new__TypeSpecAllocator* litaC_typeAllocator) {
    switch(litaC_kind) {
        case litaC_ast__TypeSpecKind_NONE: {
            {
                litaC_ast__TypeSpec* litaC_result = litaC_ast_new__TypeSpecAllocator_alloc(litaC_typeAllocator);
                litaC_result->kind = litaC_ast__TypeSpecKind_NONE;
                litaC_result->pos = litaC_pos;
                litaC_result->base = NULL;
                return litaC_result;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_ARRAY: {
            {
                litaC_ast__TypeSpec* litaC_result = litaC_ast_new__TypeSpecAllocator_alloc(litaC_typeAllocator);
                litaC_result->kind = litaC_ast__TypeSpecKind_ARRAY;
                litaC_result->pos = litaC_pos;
                litaC_result->base = NULL;
                litaC_result->numElements = NULL;
                return (litaC_ast__TypeSpec*)litaC_result;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_PTR: {
            {
                litaC_ast__TypeSpec* litaC_result = litaC_ast_new__TypeSpecAllocator_alloc(litaC_typeAllocator);
                litaC_result->kind = litaC_ast__TypeSpecKind_PTR;
                litaC_result->pos = litaC_pos;
                litaC_result->base = NULL;
                return (litaC_ast__TypeSpec*)litaC_result;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_CONST: {
            {
                litaC_ast__TypeSpec* litaC_result = litaC_ast_new__TypeSpecAllocator_alloc(litaC_typeAllocator);
                litaC_result->kind = litaC_ast__TypeSpecKind_CONST;
                litaC_result->pos = litaC_pos;
                litaC_result->base = NULL;
                return (litaC_ast__TypeSpec*)litaC_result;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_NAME: {
            {
                litaC_ast__TypeSpec* litaC_result = litaC_ast_new__TypeSpecAllocator_alloc(litaC_typeAllocator);
                litaC_result->kind = litaC_ast__TypeSpecKind_NAME;
                litaC_result->pos = litaC_pos;
                litaC_result->base = NULL;
                litaC_result->name = litaC_intern__EMPTY_STR;
                litaC_std__array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_result->genericArgs)), 0, litaC_typeAllocator->allocator);
                return (litaC_ast__TypeSpec*)litaC_result;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_FUNC_PTR: {
            {
                litaC_ast__TypeSpec* litaC_result = litaC_ast_new__TypeSpecAllocator_alloc(litaC_typeAllocator);
                litaC_result->kind = litaC_ast__TypeSpecKind_FUNC_PTR;
                litaC_result->pos = litaC_pos;
                litaC_result->base = NULL;
                litaC_std__array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_result->args)), 0, litaC_typeAllocator->allocator);
                litaC_result->ret = NULL;
                litaC_result->hasVarargs = litaC_false;
                litaC_std__array__Array_init_cb_GenericParam_ce_(&((litaC_result->genericParams)), 0, litaC_typeAllocator->allocator);
                return (litaC_ast__TypeSpec*)litaC_result;
                
                
                
            }
            
            
        }
        default: {
            {
                litaC_common__Panic("Invalid TypeSpecKind: '%d'\n", litaC_kind);
                
                
            }
            
            
        }
    }
    return NULL;
    
    
}

litaC_ast__Decl* litaC_ast_new__NewImportDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_name,litaC_ast__Identifier litaC_alias,litaC_bool litaC_isUsing,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__ImportDecl* litaC_decl = litaC_std__mem__new_cb_ImportDecl_ce_(litaC_allocator);
    litaC_decl->decl.stmt.node.kind = litaC_ast__StmtKind_IMPORT_DECL;
    litaC_decl->decl.stmt.node.startPos = litaC_startPos;
    litaC_decl->decl.stmt.node.endPos = litaC_endPos;
    litaC_decl->decl.name = litaC_name;
    litaC_decl->alias = litaC_alias;
    litaC_decl->isUsing = litaC_isUsing;
    return (litaC_ast__Decl*)litaC_decl;
    
    
}

litaC_ast__Decl* litaC_ast_new__NewVarDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_name,litaC_ast__TypeSpec* litaC_type,litaC_ast__Expr* litaC_expr,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__VarDecl* litaC_decl = litaC_std__mem__new_cb_VarDecl_ce_(litaC_allocator);
    litaC_decl->decl.stmt.node.kind = litaC_ast__StmtKind_VAR_DECL;
    litaC_decl->decl.stmt.node.startPos = litaC_startPos;
    litaC_decl->decl.stmt.node.endPos = litaC_endPos;
    litaC_decl->decl.name = litaC_name;
    litaC_decl->typeSpec = litaC_type;
    litaC_decl->expr = litaC_expr;
    return (litaC_ast__Decl*)litaC_decl;
    
    
}

litaC_ast__Decl* litaC_ast_new__NewFuncDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_name,litaC_std__array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_ast__ParametersStmt* litaC_params,litaC_ast__Stmt* litaC_body,litaC_ast__TypeSpec* litaC_returnType,litaC_i32 litaC_flags,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__FuncDecl* litaC_decl = litaC_std__mem__new_cb_FuncDecl_ce_(litaC_allocator);
    litaC_decl->decl.declaration.stmt.node.kind = litaC_ast__StmtKind_FUNC_DECL;
    litaC_decl->decl.declaration.stmt.node.startPos = litaC_startPos;
    litaC_decl->decl.declaration.stmt.node.endPos = litaC_endPos;
    litaC_decl->decl.declaration.name = litaC_name;
    litaC_decl->decl.genericParams = litaC_genericParams;
    litaC_decl->params = litaC_ast__Node_becomeParentOf_cb_ParametersStmt_ce_(&((litaC_decl->decl.declaration.stmt.node)), litaC_params);
    litaC_decl->body = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_decl->decl.declaration.stmt.node)), litaC_body);
    litaC_decl->returnType = litaC_returnType;
    litaC_decl->flags = litaC_flags;
    return (litaC_ast__Decl*)litaC_decl;
    
    
}

litaC_ast__Decl* litaC_ast_new__NewAggregateDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__StmtKind litaC_kind,litaC_ast__Identifier litaC_name,litaC_std__array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_std__array__Array_cb_FieldStmt_ce_ litaC_fields,litaC_i32 litaC_flags,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__AggregateDecl* litaC_decl = litaC_std__mem__new_cb_AggregateDecl_ce_(litaC_allocator);
    litaC_decl->decl.declaration.stmt.node.kind = litaC_kind;
    litaC_decl->decl.declaration.stmt.node.startPos = litaC_startPos;
    litaC_decl->decl.declaration.stmt.node.endPos = litaC_endPos;
    litaC_decl->decl.declaration.name = litaC_name;
    litaC_decl->decl.genericParams = litaC_genericParams;
    litaC_decl->fields = litaC_fields;
    litaC_decl->flags = litaC_flags;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_fields)), litaC_i);
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                    {
                        litaC_ast__Node_becomeParentOf_cb_EnumDecl_ce_(&((litaC_decl->decl.declaration.stmt.node)), litaC_field.enumField);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        litaC_ast__Node_becomeParentOf_cb_AggregateDecl_ce_(&((litaC_decl->decl.declaration.stmt.node)), litaC_field.aggregateField);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        litaC_ast__Node_becomeParentOf_cb_TraitFieldDecl_ce_(&((litaC_decl->decl.declaration.stmt.node)), litaC_field.traitField);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__Node_becomeParentOf_cb_VarFieldDecl_ce_(&((litaC_decl->decl.declaration.stmt.node)), litaC_field.varField);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_POISON_EXPR: {
                    {
                        litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_decl->decl.declaration.stmt.node)), litaC_field.poisonField);
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        assert(litaC_false);
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    return (litaC_ast__Decl*)litaC_decl;
    
    
}

litaC_ast__Decl* litaC_ast_new__NewStructDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_name,litaC_std__array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_std__array__Array_cb_FieldStmt_ce_ litaC_fields,litaC_i32 litaC_flags,const litaC_std__mem__Allocator* litaC_allocator) {
    return litaC_ast_new__NewAggregateDecl(litaC_startPos, litaC_endPos, litaC_ast__StmtKind_STRUCT_DECL, litaC_name, litaC_genericParams, litaC_fields, litaC_flags, litaC_allocator);
    
    
}

litaC_ast__Decl* litaC_ast_new__NewUnionDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_name,litaC_std__array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_std__array__Array_cb_FieldStmt_ce_ litaC_fields,litaC_i32 litaC_flags,const litaC_std__mem__Allocator* litaC_allocator) {
    return litaC_ast_new__NewAggregateDecl(litaC_startPos, litaC_endPos, litaC_ast__StmtKind_UNION_DECL, litaC_name, litaC_genericParams, litaC_fields, litaC_flags, litaC_allocator);
    
    
}

litaC_ast__Decl* litaC_ast_new__NewTraitDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_name,litaC_std__array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_std__array__Array_cb_FieldStmt_ce_ litaC_fields,litaC_i32 litaC_flags,const litaC_std__mem__Allocator* litaC_allocator) {
    return litaC_ast_new__NewAggregateDecl(litaC_startPos, litaC_endPos, litaC_ast__StmtKind_TRAIT_DECL, litaC_name, litaC_genericParams, litaC_fields, litaC_flags, litaC_allocator);
    
    
}

litaC_ast__Decl* litaC_ast_new__NewEnumDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_name,litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_ litaC_fields,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__EnumDecl* litaC_decl = litaC_std__mem__new_cb_EnumDecl_ce_(litaC_allocator);
    litaC_decl->decl.stmt.node.kind = litaC_ast__StmtKind_ENUM_DECL;
    litaC_decl->decl.stmt.node.startPos = litaC_startPos;
    litaC_decl->decl.stmt.node.endPos = litaC_endPos;
    litaC_decl->decl.name = litaC_name;
    litaC_decl->fields = *(litaC_ast__Node_becomeParentOfChildren_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_decl->decl.stmt.node)), &((litaC_fields))));
    return (litaC_ast__Decl*)litaC_decl;
    
    
}

litaC_ast__Decl* litaC_ast_new__NewTypedefDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_name,litaC_std__array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_ast__TypeSpec* litaC_type,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__TypedefDecl* litaC_decl = litaC_std__mem__new_cb_TypedefDecl_ce_(litaC_allocator);
    litaC_decl->decl.declaration.stmt.node.kind = litaC_ast__StmtKind_TYPEDEF_DECL;
    litaC_decl->decl.declaration.stmt.node.startPos = litaC_startPos;
    litaC_decl->decl.declaration.stmt.node.endPos = litaC_endPos;
    litaC_decl->decl.declaration.name = litaC_name;
    litaC_decl->decl.genericParams = litaC_genericParams;
    litaC_decl->type = litaC_type;
    return (litaC_ast__Decl*)litaC_decl;
    
    
}

litaC_ast__Decl* litaC_ast_new__NewNoteDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_name,litaC_std__array__Array_cb_FieldStmt_ce_ litaC_fields,const litaC_std__mem__Allocator* litaC_allocator) {
    return litaC_ast_new__NewAggregateDecl(litaC_startPos, litaC_endPos, litaC_ast__StmtKind_NOTE_DECL, litaC_name, (litaC_std__array__Array_cb_GenericParam_ce_) {
        
    }, litaC_fields, 0, litaC_allocator);
    
    
}

litaC_ast__Decl* litaC_ast_new__NewParameterDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_name,litaC_ast__TypeSpec* litaC_type,litaC_ast__Expr* litaC_defaultExpr,litaC_bool litaC_isUsing,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__ParameterDecl* litaC_decl = litaC_std__mem__new_cb_ParameterDecl_ce_(litaC_allocator);
    litaC_decl->decl.stmt.node.kind = litaC_ast__StmtKind_PARAM_DECL;
    litaC_decl->decl.stmt.node.startPos = litaC_startPos;
    litaC_decl->decl.stmt.node.endPos = litaC_endPos;
    litaC_decl->decl.name = litaC_name;
    litaC_decl->type = litaC_type;
    litaC_decl->defaultExpr = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_decl->decl.stmt.node)), litaC_defaultExpr);
    litaC_decl->decl.attributes.isUsing = litaC_isUsing;
    return (litaC_ast__Decl*)litaC_decl;
    
    
}

litaC_ast__Decl* litaC_ast_new__NewNotesDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_std__array__Array_cb__ptr_NoteStmt_ce_ litaC_notes,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__NotesDecl* litaC_decl = litaC_std__mem__new_cb_NotesDecl_ce_(litaC_allocator);
    litaC_decl->decl.stmt.node.kind = litaC_ast__StmtKind_NOTES_DECL;
    litaC_decl->decl.stmt.node.startPos = litaC_startPos;
    litaC_decl->decl.stmt.node.endPos = litaC_endPos;
    litaC_decl->notes = litaC_notes;
    return (litaC_ast__Decl*)litaC_decl;
    
    
}

litaC_ast__Decl* litaC_ast_new__NewBuiltinDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_types__TypeInfo* litaC_type,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__NativeDecl* litaC_decl = litaC_std__mem__new_cb_NativeDecl_ce_(litaC_allocator);
    litaC_decl->decl.stmt.node.kind = litaC_ast__StmtKind_NATIVE_DECL;
    litaC_decl->decl.stmt.node.startPos = litaC_startPos;
    litaC_decl->decl.stmt.node.endPos = litaC_endPos;
    litaC_decl->typeInfo = litaC_type;
    return (litaC_ast__Decl*)litaC_decl;
    
    
}

litaC_ast__Decl* litaC_ast_new__NewPoisonDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__PoisonDecl* litaC_decl = litaC_std__mem__new_cb_PoisonDecl_ce_(litaC_allocator);
    litaC_decl->decl.stmt.node.kind = litaC_ast__StmtKind_POISON_DECL;
    litaC_decl->decl.stmt.node.startPos = litaC_startPos;
    litaC_decl->decl.stmt.node.endPos = litaC_endPos;
    return (litaC_ast__Decl*)litaC_decl;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewTernaryExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_ast__Expr* litaC_then,litaC_ast__Expr* litaC_other,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__TernaryExpr* litaC_expr = litaC_std__mem__new_cb_TernaryExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_TERNARY_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->cond = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_cond);
    litaC_expr->then = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_then);
    litaC_expr->other = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_other);
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewBinaryExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_left,litaC_lex__TokenType litaC_operator,litaC_ast__Expr* litaC_right,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__BinaryExpr* litaC_binExpr = litaC_std__mem__new_cb_BinaryExpr_ce_(litaC_allocator);
    litaC_binExpr->expr.stmt.node.kind = litaC_ast__StmtKind_BINARY_EXPR;
    litaC_binExpr->expr.stmt.node.startPos = litaC_startPos;
    litaC_binExpr->left = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_binExpr->expr.stmt.node)), litaC_left);
    litaC_binExpr->operator = litaC_operator;
    litaC_binExpr->right = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_binExpr->expr.stmt.node)), litaC_right);
    litaC_binExpr->expr.stmt.node.endPos = litaC_endPos;
    return (litaC_ast__Expr*)litaC_binExpr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewUnaryExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__TokenType litaC_operator,litaC_ast__Expr* litaC_expr,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__UnaryExpr* litaC_unaryExpr = litaC_std__mem__new_cb_UnaryExpr_ce_(litaC_allocator);
    litaC_unaryExpr->expr.stmt.node.kind = litaC_ast__StmtKind_UNARY_EXPR;
    litaC_unaryExpr->expr.stmt.node.startPos = litaC_startPos;
    litaC_unaryExpr->unaryExpr = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_unaryExpr->expr.stmt.node)), litaC_expr);
    litaC_unaryExpr->operator = litaC_operator;
    litaC_unaryExpr->expr.stmt.node.endPos = litaC_endPos;
    return (litaC_ast__Expr*)litaC_unaryExpr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewInitExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__TypeSpec* litaC_type,litaC_std__array__Array_cb__ptr_InitArgExpr_ce_ litaC_arguments,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__InitExpr* litaC_initExpr = litaC_std__mem__new_cb_InitExpr_ce_(litaC_allocator);
    litaC_initExpr->expr.stmt.node.kind = litaC_ast__StmtKind_INIT_EXPR;
    litaC_initExpr->expr.stmt.node.startPos = litaC_startPos;
    litaC_initExpr->expr.stmt.node.endPos = litaC_endPos;
    litaC_initExpr->type = litaC_type;
    litaC_initExpr->arguments = litaC_arguments;
    litaC_ast__Node_becomeParentOfChildren_cb__ptr_InitArgExpr_ce_(&((litaC_initExpr->expr.stmt.node)), &((litaC_initExpr->arguments)));
    return (litaC_ast__Expr*)litaC_initExpr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewFuncCallExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_object,litaC_std__array__Array_cb_CallArg_ce_ litaC_arguments,litaC_std__array__Array_cb__ptr_TypeSpec_ce_ litaC_genericArgs,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__FuncCallExpr* litaC_expr = litaC_std__mem__new_cb_FuncCallExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_FUNC_CALL_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->object = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_object);
    litaC_expr->genericArgs = litaC_genericArgs;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_CallArg_ce_(&((litaC_arguments)));litaC_i += 1) {
        {
            litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_std__array__Array_get_cb_CallArg_ce_(&((litaC_arguments)), litaC_i).argExpr);
            
            
        }
    }
    litaC_expr->arguments = litaC_arguments;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewSubscriptGetExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_object,litaC_ast__Expr* litaC_index,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__SubscriptGetExpr* litaC_expr = litaC_std__mem__new_cb_SubscriptGetExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->object = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_object);
    litaC_expr->index = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_index);
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewSubscriptSetExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_object,litaC_ast__Expr* litaC_index,litaC_lex__TokenType litaC_operator,litaC_ast__Expr* litaC_value,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__SubscriptSetExpr* litaC_expr = litaC_std__mem__new_cb_SubscriptSetExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_SUBSCRIPT_SET_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->object = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_object);
    litaC_expr->index = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_index);
    litaC_expr->operator = litaC_operator;
    litaC_expr->value = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_value);
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewGetExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_object,litaC_ast__IdentifierExpr* litaC_field,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__GetExpr* litaC_expr = litaC_std__mem__new_cb_GetExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_GET_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->object = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_object);
    litaC_expr->field = (litaC_ast__IdentifierExpr*)litaC_ast__Node_becomeParentOf_cb_IdentifierExpr_ce_(&((litaC_expr->expr.stmt.node)), litaC_field);
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewSetExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_object,litaC_ast__IdentifierExpr* litaC_field,litaC_lex__TokenType litaC_operator,litaC_ast__Expr* litaC_value,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__SetExpr* litaC_expr = litaC_std__mem__new_cb_SetExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_SET_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->object = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_object);
    litaC_expr->field = (litaC_ast__IdentifierExpr*)litaC_ast__Node_becomeParentOf_cb_IdentifierExpr_ce_(&((litaC_expr->expr.stmt.node)), litaC_field);
    litaC_expr->operator = litaC_operator;
    litaC_expr->value = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_value);
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewIdentifierExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__TypeSpec* litaC_type,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__IdentifierExpr* litaC_expr = litaC_std__mem__new_cb_IdentifierExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_IDENTIFIER_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->type = litaC_type;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewTypeIdentifierExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__TypeSpec* litaC_type,litaC_bool litaC_isBased,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__TypeIdentifierExpr* litaC_expr = litaC_std__mem__new_cb_TypeIdentifierExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->type = litaC_type;
    litaC_expr->isBased = litaC_isBased;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewCastExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_castExpr,litaC_ast__TypeSpec* litaC_castTo,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__CastExpr* litaC_expr = litaC_std__mem__new_cb_CastExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_CAST_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->exprToCast = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_castExpr);
    litaC_expr->castTo = litaC_castTo;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewArrayDesignationExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_index,litaC_ast__Expr* litaC_value,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__ArrayDesignationExpr* litaC_expr = litaC_std__mem__new_cb_ArrayDesignationExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->index = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_index);
    litaC_expr->value = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_value);
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewInitArgExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_fieldName,litaC_i32 litaC_position,litaC_ast__Expr* litaC_value,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__InitArgExpr* litaC_expr = litaC_std__mem__new_cb_InitArgExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_INIT_ARG_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->fieldName = litaC_fieldName;
    litaC_expr->argPosition = litaC_position;
    litaC_expr->value = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_value);
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewBooleanExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_bool litaC_boolean,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__BooleanExpr* litaC_expr = litaC_std__mem__new_cb_BooleanExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_BOOLEAN_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->boolean = litaC_boolean;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewNullExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__NullExpr* litaC_expr = litaC_std__mem__new_cb_NullExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_NULL_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewNumberExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_number,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__NumberExpr* litaC_expr = litaC_std__mem__new_cb_NumberExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_NUMBER_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->number = litaC_number;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewStringExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_string,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__StringExpr* litaC_expr = litaC_std__mem__new_cb_StringExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_STRING_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->string = litaC_string;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewCharExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_lex__Token litaC_character,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__CharExpr* litaC_expr = litaC_std__mem__new_cb_CharExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_CHAR_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->character = litaC_character;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewGroupExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_groupedExpr,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__GroupExpr* litaC_expr = litaC_std__mem__new_cb_GroupExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_GROUP_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->groupedExpr = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_groupedExpr);
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewArrayInitExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__TypeSpec* litaC_type,litaC_std__array__Array_cb__ptr_Expr_ce_ litaC_values,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__ArrayInitExpr* litaC_expr = litaC_std__mem__new_cb_ArrayInitExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_ARRAY_INIT_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->type = litaC_type;
    litaC_expr->values = *(litaC_ast__Node_becomeParentOfChildren_cb__ptr_Expr_ce_(&((litaC_expr->expr.stmt.node)), &((litaC_values))));
    assert(litaC_expr->type->kind == litaC_ast__TypeSpecKind_ARRAY);
    litaC_ast__TypeSpec* litaC_arrayType = litaC_expr->type;
    if(!(litaC_arrayType->numElements) && !(litaC_std__array__Array_empty_cb__ptr_Expr_ce_(&((litaC_expr->values))))) {
        {
            litaC_lex__Token litaC_token =  {
                .type = litaC_lex__TokenType_USIZE,
                .typeInfo = &(litaC_types__USIZE_TYPE),
                .pos = litaC_startPos,
                .value =  {
                    .intValue = litaC_std__array__Array_size_cb__ptr_Expr_ce_(&((litaC_expr->values)))
                }
            };
            litaC_arrayType->numElements = litaC_ast_new__NewNumberExpr(litaC_startPos, litaC_startPos, litaC_token, litaC_allocator);
            
            
        }
        
    } 
    
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewSizeOfExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_sizeOfExpr,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__SizeOfExpr* litaC_expr = litaC_std__mem__new_cb_SizeOfExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_SIZE_OF_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->sizeOfExpr = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_sizeOfExpr);
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewTypeOfExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_typeOfExpr,litaC_ast__TypeSpec* litaC_type,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__TypeOfExpr* litaC_expr = litaC_std__mem__new_cb_TypeOfExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_TYPE_OF_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->typeOfExpr = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_typeOfExpr);
    litaC_expr->type = litaC_type;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewOffsetOfExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__TypeSpec* litaC_type,litaC_ast__Identifier litaC_field,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__OffsetOfExpr* litaC_expr = litaC_std__mem__new_cb_OffsetOfExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_OFFSET_OF_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    litaC_expr->type = litaC_type;
    litaC_expr->field = litaC_field;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Expr* litaC_ast_new__NewPoisonExpr(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__PoisonExpr* litaC_expr = litaC_std__mem__new_cb_PoisonExpr_ce_(litaC_allocator);
    litaC_expr->expr.stmt.node.kind = litaC_ast__StmtKind_POISON_EXPR;
    litaC_expr->expr.stmt.node.startPos = litaC_startPos;
    litaC_expr->expr.stmt.node.endPos = litaC_endPos;
    return (litaC_ast__Expr*)litaC_expr;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewModuleStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_std__array__Array_cb__ptr_ImportDecl_ce_ litaC_imports,litaC_std__array__Array_cb__ptr_NoteStmt_ce_ litaC_notes,litaC_std__array__Array_cb__ptr_Decl_ce_ litaC_declarations,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__ModuleStmt* litaC_stmt = litaC_std__mem__new_cb_ModuleStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_MODULE_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->imports = litaC_imports;
    litaC_stmt->notes = litaC_notes;
    litaC_stmt->declarations = litaC_declarations;
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewCompStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_intern__InternedString litaC_type,litaC_std__string_view__StringView litaC_expr,litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_body,litaC_ast__CompStmt* litaC_end,litaC_bool litaC_isScriptLoad,litaC_bool litaC_isStatic,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__CompStmt* litaC_stmt = litaC_std__mem__new_cb_CompStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_COMP_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->type = litaC_type;
    litaC_stmt->expr = litaC_expr;
    litaC_stmt->end = litaC_end;
    litaC_stmt->body = litaC_body;
    litaC_stmt->evaluatedStmt = NULL;
    litaC_stmt->isScriptLoad = litaC_isScriptLoad;
    litaC_stmt->isStatic = litaC_isStatic;
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewFuncBodyStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_stmts,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__BlockStmt* litaC_stmt = litaC_std__mem__new_cb_BlockStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_FUNC_BODY_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->stmts = *(litaC_ast__Node_becomeParentOfChildren_cb__ptr_Stmt_ce_(&((litaC_stmt->stmt.node)), &((litaC_stmts))));
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewBlockStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_stmts,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__BlockStmt* litaC_stmt = litaC_std__mem__new_cb_BlockStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_BLOCK_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->stmts = *(litaC_ast__Node_becomeParentOfChildren_cb__ptr_Stmt_ce_(&((litaC_stmt->stmt.node)), &((litaC_stmts))));
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewIfStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_ast__Stmt* litaC_then,litaC_ast__Stmt* litaC_other,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__IfStmt* litaC_stmt = litaC_std__mem__new_cb_IfStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_IF_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->cond = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_stmt->stmt.node)), litaC_cond);
    litaC_stmt->then = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_stmt->stmt.node)), litaC_then);
    litaC_stmt->elseStmt = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_stmt->stmt.node)), litaC_other);
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewWhileStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_ast__Stmt* litaC_body,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__WhileStmt* litaC_stmt = litaC_std__mem__new_cb_WhileStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_WHILE_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->cond = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_stmt->stmt.node)), litaC_cond);
    litaC_stmt->body = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_stmt->stmt.node)), litaC_body);
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewDoWhileStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_ast__Stmt* litaC_body,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__DoWhileStmt* litaC_stmt = litaC_std__mem__new_cb_DoWhileStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_DO_WHILE_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->cond = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_stmt->stmt.node)), litaC_cond);
    litaC_stmt->body = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_stmt->stmt.node)), litaC_body);
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewForStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Stmt* litaC_init,litaC_ast__Expr* litaC_cond,litaC_ast__Stmt* litaC_post,litaC_ast__Stmt* litaC_body,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__ForStmt* litaC_stmt = litaC_std__mem__new_cb_ForStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_FOR_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->init = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_stmt->stmt.node)), litaC_init);
    litaC_stmt->cond = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_stmt->stmt.node)), litaC_cond);
    litaC_stmt->post = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_stmt->stmt.node)), litaC_post);
    litaC_stmt->body = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_stmt->stmt.node)), litaC_body);
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewSwitchCaseStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_ast__Stmt* litaC_body,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__SwitchCaseStmt* litaC_stmt = litaC_std__mem__new_cb_SwitchCaseStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_SWITCH_CASE_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->cond = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_stmt->stmt.node)), litaC_cond);
    litaC_stmt->body = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_stmt->stmt.node)), litaC_body);
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewSwitchStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_cond,litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_ litaC_cases,litaC_ast__Stmt* litaC_defaultStmt,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__SwitchStmt* litaC_stmt = litaC_std__mem__new_cb_SwitchStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_SWITCH_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->cond = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_stmt->stmt.node)), litaC_cond);
    litaC_stmt->cases = *(litaC_ast__Node_becomeParentOfChildren_cb__ptr_SwitchCaseStmt_ce_(&((litaC_stmt->stmt.node)), &((litaC_cases))));
    litaC_stmt->defaultStmt = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_stmt->stmt.node)), litaC_defaultStmt);
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewBreakStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__BreakStmt* litaC_stmt = litaC_std__mem__new_cb_BreakStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_BREAK_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewContinueStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__ContinueStmt* litaC_stmt = litaC_std__mem__new_cb_ContinueStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_CONTINUE_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewReturnStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Expr* litaC_expr,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__ReturnStmt* litaC_stmt = litaC_std__mem__new_cb_ReturnStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_RETURN_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->expr = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_stmt->stmt.node)), litaC_expr);
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewDeferStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Stmt* litaC_defered,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__DeferStmt* litaC_stmt = litaC_std__mem__new_cb_DeferStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_DEFER_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->deferedStmt = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_stmt->stmt.node)), litaC_defered);
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewGotoStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_label,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__GotoStmt* litaC_stmt = litaC_std__mem__new_cb_GotoStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_GOTO_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->label = litaC_label;
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewLabelStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_label,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__LabelStmt* litaC_stmt = litaC_std__mem__new_cb_LabelStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_LABEL_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->label = litaC_label;
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewNoteStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__TypeSpec* litaC_type,litaC_std__array__Array_cb_CallArg_ce_ litaC_arguments,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__NoteStmt* litaC_stmt = litaC_std__mem__new_cb_NoteStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_NOTE_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->type = litaC_type;
    litaC_stmt->arguments = litaC_arguments;
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewEmptyStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__EmptyStmt* litaC_stmt = litaC_std__mem__new_cb_EmptyStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_EMPTY_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewParametersStmt(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_std__array__Array_cb__ptr_ParameterDecl_ce_ litaC_params,litaC_bool litaC_isVararg,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__ParametersStmt* litaC_stmt = litaC_std__mem__new_cb_ParametersStmt_ce_(litaC_allocator);
    litaC_stmt->stmt.node.kind = litaC_ast__StmtKind_PARAMETERS_STMT;
    litaC_stmt->stmt.node.startPos = litaC_startPos;
    litaC_stmt->stmt.node.endPos = litaC_endPos;
    litaC_stmt->params = *(litaC_ast__Node_becomeParentOfChildren_cb__ptr_ParameterDecl_ce_(&((litaC_stmt->stmt.node)), &((litaC_params))));
    litaC_stmt->isVararg = litaC_isVararg;
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewVarFieldDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_fieldName,litaC_ast__TypeSpec* litaC_type,litaC_ast__Attributes litaC_attributes,litaC_ast__Expr* litaC_defaultExpr,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__VarFieldDecl* litaC_stmt = litaC_std__mem__new_cb_VarFieldDecl_ce_(litaC_allocator);
    litaC_stmt->decl.stmt.node.kind = litaC_ast__StmtKind_VAR_FIELD_DECL;
    litaC_stmt->decl.stmt.node.startPos = litaC_startPos;
    litaC_stmt->decl.stmt.node.endPos = litaC_endPos;
    litaC_stmt->decl.name = litaC_fieldName;
    litaC_stmt->type = litaC_type;
    litaC_stmt->decl.attributes = litaC_attributes;
    litaC_stmt->defaultExpr = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_stmt->decl.stmt.node)), litaC_defaultExpr);
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewTraitFieldDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_fieldName,litaC_ast__TypeSpec* litaC_type,litaC_ast__Attributes litaC_attributes,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__TraitFieldDecl* litaC_stmt = litaC_std__mem__new_cb_TraitFieldDecl_ce_(litaC_allocator);
    litaC_stmt->decl.stmt.node.kind = litaC_ast__StmtKind_TRAIT_FIELD_DECL;
    litaC_stmt->decl.stmt.node.startPos = litaC_startPos;
    litaC_stmt->decl.stmt.node.endPos = litaC_endPos;
    litaC_stmt->decl.name = litaC_fieldName;
    litaC_stmt->type = litaC_type;
    litaC_stmt->decl.attributes = litaC_attributes;
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_ast_new__NewEnumFieldEntryDecl(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,litaC_ast__Identifier litaC_fieldName,litaC_ast__Expr* litaC_value,litaC_ast__Attributes litaC_attributes,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_ast__EnumFieldEntryDecl* litaC_stmt = litaC_std__mem__new_cb_EnumFieldEntryDecl_ce_(litaC_allocator);
    litaC_stmt->decl.stmt.node.kind = litaC_ast__StmtKind_ENUM_FIELD_ENTRY_DECL;
    litaC_stmt->decl.stmt.node.startPos = litaC_startPos;
    litaC_stmt->decl.stmt.node.endPos = litaC_endPos;
    litaC_stmt->decl.name = litaC_fieldName;
    litaC_stmt->decl.attributes = litaC_attributes;
    litaC_stmt->value = litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_stmt->decl.stmt.node)), litaC_value);
    return (litaC_ast__Stmt*)litaC_stmt;
    
    
}

litaC_void litaC_ast__Node_setSrcPos(litaC_ast__Node* litaC_n,litaC_lex__SrcPos litaC_start,litaC_lex__SrcPos litaC_end) {
    litaC_n->startPos = litaC_start;
    litaC_n->endPos = litaC_end;
    
}

litaC_std__array__Array_cb_CallArg_ce_* litaC_ast__Node_becomeParentOfChildrenCallArgs(litaC_ast__Node* litaC_n,litaC_std__array__Array_cb_CallArg_ce_* litaC_children) {
    litaC_i32 litaC_size = litaC_std__array__Array_size_cb_CallArg_ce_(litaC_children);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_size;litaC_i += 1) {
        {
            litaC_ast__Expr* litaC_child = litaC_std__array__Array_get_cb_CallArg_ce_(litaC_children, litaC_i).argExpr;
            if(litaC_child) {
                {
                    litaC_ast__Node_becomeParentOf_cb_Expr_ce_(litaC_n, litaC_child);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_children;
    
    
}

litaC_bool litaC_ast__IsExpr(litaC_ast__Node* litaC_node) {
    if(!(litaC_node)) {
        return litaC_false;
        
        
    } 
    
    switch(litaC_node->kind) {
        case litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR: 
        case litaC_ast__StmtKind_ARRAY_INIT_EXPR: 
        case litaC_ast__StmtKind_BINARY_EXPR: 
        case litaC_ast__StmtKind_BOOLEAN_EXPR: 
        case litaC_ast__StmtKind_CAST_EXPR: 
        case litaC_ast__StmtKind_CHAR_EXPR: 
        case litaC_ast__StmtKind_FUNC_CALL_EXPR: 
        case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_GET_EXPR: 
        case litaC_ast__StmtKind_GROUP_EXPR: 
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_INIT_EXPR: 
        case litaC_ast__StmtKind_INIT_ARG_EXPR: 
        case litaC_ast__StmtKind_NULL_EXPR: 
        case litaC_ast__StmtKind_NUMBER_EXPR: 
        case litaC_ast__StmtKind_OFFSET_OF_EXPR: 
        case litaC_ast__StmtKind_SET_EXPR: 
        case litaC_ast__StmtKind_SIZE_OF_EXPR: 
        case litaC_ast__StmtKind_STRING_EXPR: 
        case litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR: 
        case litaC_ast__StmtKind_SUBSCRIPT_SET_EXPR: 
        case litaC_ast__StmtKind_TERNARY_EXPR: 
        case litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_TYPE_OF_EXPR: 
        case litaC_ast__StmtKind_UNARY_EXPR: 
        case litaC_ast__StmtKind_POISON_EXPR: {
            return litaC_true;
            
            
            
        }
        default: {
            return litaC_false;
            
            
            
        }
    }
    
}

litaC_bool litaC_ast__IsDecl(litaC_ast__Node* litaC_node) {
    if(!(litaC_node)) {
        return litaC_false;
        
        
    } 
    
    switch(litaC_node->kind) {
        case litaC_ast__StmtKind_IMPORT_DECL: 
        case litaC_ast__StmtKind_CONST_DECL: 
        case litaC_ast__StmtKind_VAR_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: 
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_ENUM_DECL: 
        case litaC_ast__StmtKind_FUNC_DECL: 
        case litaC_ast__StmtKind_TYPEDEF_DECL: 
        case litaC_ast__StmtKind_PARAM_DECL: 
        case litaC_ast__StmtKind_NATIVE_DECL: 
        case litaC_ast__StmtKind_POISON_DECL: {
            return litaC_true;
            
            
            
        }
        default: {
            return litaC_false;
            
            
            
        }
    }
    
}

litaC_bool litaC_ast__Decl_hasNotes(litaC_ast__Decl* litaC_d) {
    if(!(litaC_d)) {
        return litaC_false;
        
        
    } 
    
    return !(litaC_std__array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_d->attributes.notes))));
    
    
}

litaC_bool litaC_ast__Decl_hasNote(litaC_ast__Decl* litaC_d,const litaC_char* litaC_name) {
    return litaC_ast__Decl_getNote(litaC_d, litaC_name) != NULL;
    
    
}

litaC_ast__NoteStmt* litaC_ast__Decl_getNote(litaC_ast__Decl* litaC_d,const litaC_char* litaC_name) {
    if(!(litaC_d)) {
        return NULL;
        
        
    } 
    
    if(litaC_std__array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_d->attributes.notes)))) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_d->attributes.notes)));litaC_i += 1) {
        {
            litaC_ast__NoteStmt* litaC_note = litaC_std__array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_d->attributes.notes)), litaC_i);
            if(strncmp(litaC_note->type->name.buffer, litaC_name, litaC_note->type->name.length) == 0) {
                {
                    return litaC_note;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return NULL;
    
    
}

litaC_ast__CallArg* litaC_ast__Decl_getNoteArgument(litaC_ast__Decl* litaC_d,const litaC_char* litaC_name,const litaC_char* litaC_arg) {
    litaC_ast__NoteStmt* litaC_note = litaC_ast__Decl_getNote(litaC_d, litaC_name);
    if(!(litaC_note)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    if(litaC_std__array__Array_empty_cb_CallArg_ce_(&((litaC_note->arguments)))) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_CallArg_ce_(&((litaC_note->arguments)));litaC_i += 1) {
        {
            litaC_ast__CallArg* litaC_a = litaC_std__array__Array_getPtr_cb_CallArg_ce_(&((litaC_note->arguments)), litaC_i);
            if(litaC_intern__InternedString_equalsStr(&((litaC_a->argName.str)), litaC_arg)) {
                {
                    return litaC_a;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return NULL;
    
    
}

litaC_ast__TypeSpec* litaC_ast__TypeSpec_getBaseType(litaC_ast__TypeSpec* litaC_this) {
    if(!(litaC_this)) {
        return NULL;
        
        
    } 
    
    switch(litaC_this->kind) {
        case litaC_ast__TypeSpecKind_NONE: {
            {
                return NULL;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_NAME: {
            {
                return litaC_this;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_ARRAY: 
        case litaC_ast__TypeSpecKind_PTR: 
        case litaC_ast__TypeSpecKind_CONST: {
            {
                return litaC_ast__TypeSpec_getBaseType(litaC_this->base);
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_FUNC_PTR: {
            {
                return litaC_this;
                
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return NULL;
    
    
}

litaC_bool litaC_ast__FuncDecl_getName(litaC_ast__FuncDecl* litaC_f,litaC_char* litaC_name) {
    if(litaC_f->decl.declaration.name.token.type != litaC_lex__TokenType_IDENTIFIER) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_f->flags & litaC_ast__FuncFlags_IS_METHOD) {
        {
            if(litaC_std__array__Array_empty_cb__ptr_ParameterDecl_ce_(&((litaC_f->params->params)))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_ast__ParameterDecl* litaC_first = litaC_std__array__Array_first_cb__ptr_ParameterDecl_ce_(&((litaC_f->params->params)));
            if(!(litaC_first->type)) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_ast__TypeSpec* litaC_typeSpec = litaC_first->type;
            const char* litaC_prefix = "";
            retry:;
            
            if(litaC_typeSpec->kind != litaC_ast__TypeSpecKind_NAME) {
                {
                    if(litaC_typeSpec->kind == litaC_ast__TypeSpecKind_PTR || litaC_typeSpec->kind == litaC_ast__TypeSpecKind_CONST || litaC_typeSpec->kind == litaC_ast__TypeSpecKind_ARRAY) {
                        {
                            litaC_typeSpec = litaC_typeSpec->base;
                            if(litaC_typeSpec->kind == litaC_ast__TypeSpecKind_ARRAY) {
                                {
                                    litaC_prefix = "array_";
                                    
                                    
                                }
                                
                            } 
                            
                            goto retry;
                            
                            
                            
                        }
                        
                    } 
                    
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_i32 litaC_totalLen = litaC_f->decl.declaration.name.str.length + litaC_typeSpec->name.length + 2;
            if(litaC_totalLen > litaC_symbols__MAX_SYMBOL_NAME) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_std__string__String litaC_nameStr = litaC_std__string__StringInit(litaC_name, litaC_symbols__MAX_SYMBOL_NAME, 0);
            litaC_std__string__String_format(&((litaC_nameStr)), "%s%.*s_%.*s", litaC_prefix, litaC_typeSpec->name.length, litaC_typeSpec->name.buffer, litaC_f->decl.declaration.name.str.length, litaC_f->decl.declaration.name.str.buffer);
            return litaC_true;
            
            
            
        }
        
    } 
    
    litaC_std__string__String litaC_nameStr = litaC_std__string__StringInit(litaC_name, litaC_symbols__MAX_SYMBOL_NAME, 0);
    litaC_std__string__String_format(&((litaC_nameStr)), "%.*s", litaC_f->decl.declaration.name.str.length, litaC_f->decl.declaration.name.str.buffer);
    return litaC_true;
    
    
}

litaC_bool litaC_ast__Expr_isIdentifier(litaC_ast__Expr* litaC_expr) {
    if(!(litaC_expr)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_expr->stmt.node.kind == litaC_ast__StmtKind_IDENTIFIER_EXPR || litaC_expr->stmt.node.kind == litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR || litaC_expr->stmt.node.kind == litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR;
    
    
}

litaC_bool litaC_ast__Expr_isConstNumberExpr(litaC_ast__Expr* litaC_expr) {
    if(!(litaC_expr)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_expr->stmt.node.kind) {
        case litaC_ast__StmtKind_NUMBER_EXPR: 
        case litaC_ast__StmtKind_BOOLEAN_EXPR: 
        case litaC_ast__StmtKind_CHAR_EXPR: 
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_GET_EXPR: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SIZE_OF_EXPR: {
            {
                litaC_ast__SizeOfExpr* litaC_sizeofExpr = (litaC_ast__SizeOfExpr*)litaC_expr;
                return litaC_ast__Expr_isConstNumberExpr(litaC_sizeofExpr->sizeOfExpr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GROUP_EXPR: {
            {
                litaC_ast__GroupExpr* litaC_groupExpr = (litaC_ast__GroupExpr*)litaC_expr;
                return litaC_ast__Expr_isConstNumberExpr(litaC_groupExpr->groupedExpr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BINARY_EXPR: {
            {
                litaC_ast__BinaryExpr* litaC_binExpr = (litaC_ast__BinaryExpr*)litaC_expr;
                return litaC_ast__Expr_isConstNumberExpr(litaC_binExpr->left) && litaC_ast__Expr_isConstNumberExpr(litaC_binExpr->right);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNARY_EXPR: {
            {
                litaC_ast__UnaryExpr* litaC_unaryExpr = (litaC_ast__UnaryExpr*)litaC_expr;
                return litaC_ast__Expr_isConstNumberExpr(litaC_unaryExpr->unaryExpr);
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_bool litaC_ast__Expr_isConstExpr(litaC_ast__Expr* litaC_expr) {
    if(!(litaC_expr)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_expr->stmt.node.kind) {
        case litaC_ast__StmtKind_NUMBER_EXPR: 
        case litaC_ast__StmtKind_BOOLEAN_EXPR: 
        case litaC_ast__StmtKind_CHAR_EXPR: 
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_STRING_EXPR: 
        case litaC_ast__StmtKind_GET_EXPR: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SIZE_OF_EXPR: {
            {
                litaC_ast__SizeOfExpr* litaC_sizeofExpr = (litaC_ast__SizeOfExpr*)litaC_expr;
                return litaC_ast__Expr_isConstExpr(litaC_sizeofExpr->sizeOfExpr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GROUP_EXPR: {
            {
                litaC_ast__GroupExpr* litaC_groupExpr = (litaC_ast__GroupExpr*)litaC_expr;
                return litaC_ast__Expr_isConstExpr(litaC_groupExpr->groupedExpr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BINARY_EXPR: {
            {
                litaC_ast__BinaryExpr* litaC_binExpr = (litaC_ast__BinaryExpr*)litaC_expr;
                return litaC_ast__Expr_isConstExpr(litaC_binExpr->left) && litaC_ast__Expr_isConstExpr(litaC_binExpr->right);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNARY_EXPR: {
            {
                litaC_ast__UnaryExpr* litaC_unaryExpr = (litaC_ast__UnaryExpr*)litaC_expr;
                return litaC_ast__Expr_isConstExpr(litaC_unaryExpr->unaryExpr);
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_i32 litaC_ast__CallArgSort(litaC_ast__CallArg litaC_a,litaC_ast__CallArg litaC_b) {
    return litaC_a.index - litaC_b.index;
    
    
}

litaC_bool litaC_symbols__Symbol_isGenericCapable(litaC_symbols__Symbol* litaC_this) {
    return litaC_this->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE || litaC_this->flags & litaC_symbols__SymbolFlags_IS_FROM_GENERIC_TEMPLATE;
    
    
}

litaC_bool litaC_symbols__Symbol_isVisibleTo(litaC_symbols__Symbol* litaC_this,litaC_module__Module* litaC_module) {
    if(litaC_this->declared == litaC_module) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    if(litaC_this->flags & litaC_symbols__SymbolFlags_IS_PRIVATE) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_this->flags & litaC_symbols__SymbolFlags_IS_PUBLIC) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    return litaC_module__Module_isInPackage(litaC_this->declared, litaC_module);
    
    
}

litaC_symbols__Scope* litaC_symbols__NewScope(litaC_symbols__ScopeKind litaC_kind,litaC_symbols__Scope* litaC_parent,litaC_phase_result__PhaseResult* litaC_result,litaC_module__Module* litaC_module,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_symbols__Scope* litaC_scope = litaC_std__mem__new_cb_Scope_ce_(litaC_allocator);
    litaC_symbols__Scope_init(litaC_scope, litaC_kind, litaC_parent, litaC_result, litaC_module, litaC_allocator);
    return litaC_scope;
    
    
}

litaC_void litaC_symbols__Scope_init(litaC_symbols__Scope* litaC_scope,litaC_symbols__ScopeKind litaC_kind,litaC_symbols__Scope* litaC_parent,litaC_phase_result__PhaseResult* litaC_result,litaC_module__Module* litaC_module,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_scope->kind = litaC_kind;
    litaC_scope->allocator = litaC_allocator;
    litaC_scope->parent = litaC_parent;
    litaC_scope->result = litaC_result;
    litaC_scope->module = litaC_module;
    litaC_scope->symbolTypes = litaC_intern__InternMap_cb__ptr_Symbol_ce_(NULL, 16, litaC_allocator);
    if(litaC_kind == litaC_symbols__ScopeKind_MODULE) {
        {
            litaC_scope->symbolFuncs = litaC_intern__InternMap_cb__ptr_Symbol_ce_(NULL, 16, litaC_allocator);
            litaC_scope->symbolNotes = litaC_intern__InternMap_cb__ptr_Symbol_ce_(NULL, 16, litaC_allocator);
            
            
        }
        
    } else {
        {
            litaC_scope->symbolFuncs = (litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_) {
                
            };
            litaC_scope->symbolNotes = (litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_) {
                
            };
            
            
        }
    } 
    
    
}

litaC_void litaC_symbols__Scope_initIncrementalBuild(litaC_symbols__Scope* litaC_scope) {
    litaC_symbols__Scope_markReset(litaC_scope, &(litaC_scope->symbolTypes));
    litaC_symbols__Scope_markReset(litaC_scope, &(litaC_scope->symbolFuncs));
    litaC_symbols__Scope_markReset(litaC_scope, &(litaC_scope->symbolNotes));
    
}

litaC_void litaC_symbols__Scope_postIncrementalBuild(litaC_symbols__Scope* litaC_scope) {
    
}

litaC_symbols__Symbol* litaC_symbols__Scope_lookupFunc(litaC_symbols__Scope* litaC_s,litaC_intern__InternedString litaC_name) {
    litaC_symbols__Symbol* litaC_sym = litaC_std__map__Map_get_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_s->symbolFuncs)), litaC_name);
    if(litaC_sym && !((litaC_sym->flags & litaC_symbols__SymbolFlags_IS_MARKED_RESET))) {
        {
            return litaC_sym;
            
            
            
        }
        
    } 
    
    if(!(litaC_s->parent)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    return litaC_symbols__Scope_lookupFunc(litaC_s->parent, litaC_name);
    
    
}

litaC_symbols__Symbol* litaC_symbols__Scope_lookupNote(litaC_symbols__Scope* litaC_s,litaC_intern__InternedString litaC_name) {
    litaC_symbols__Symbol* litaC_sym = litaC_std__map__Map_get_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_s->symbolNotes)), litaC_name);
    if(litaC_sym && !((litaC_sym->flags & litaC_symbols__SymbolFlags_IS_MARKED_RESET))) {
        {
            return litaC_sym;
            
            
            
        }
        
    } 
    
    if(!(litaC_s->parent)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    return litaC_symbols__Scope_lookupNote(litaC_s->parent, litaC_name);
    
    
}

litaC_symbols__Symbol* litaC_symbols__Scope_lookup(litaC_symbols__Scope* litaC_s,litaC_intern__InternedString litaC_name,litaC_bool litaC_includeFuncs) {
    litaC_symbols__Symbol* litaC_sym = NULL;
    if(litaC_includeFuncs) {
        {
            litaC_sym = litaC_std__map__Map_get_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_s->symbolFuncs)), litaC_name);
            if(litaC_sym && !((litaC_sym->flags & litaC_symbols__SymbolFlags_IS_MARKED_RESET))) {
                {
                    return litaC_sym;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_sym = litaC_std__map__Map_get_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_s->symbolTypes)), litaC_name);
    if(litaC_sym && !((litaC_sym->flags & litaC_symbols__SymbolFlags_IS_MARKED_RESET))) {
        {
            return litaC_sym;
            
            
            
        }
        
    } 
    
    if(!(litaC_s->parent)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    return litaC_symbols__Scope_lookup(litaC_s->parent, litaC_name, litaC_includeFuncs);
    
    
}

litaC_void litaC_symbols__Scope_importSymbolWithAlias(litaC_symbols__Scope* litaC_this,litaC_lex__SrcPos litaC_importSrcPos,litaC_intern__InternedString litaC_name,litaC_intern__InternedString litaC_alias,litaC_symbols__Symbol* litaC_symbol) {
    litaC_char litaC_buffer[256] =  {
        
    };
    litaC_std__string__String litaC_fullName = litaC_std__string__StringInit(litaC_buffer, litaC_symbols__MAX_SYMBOL_NAME, 0);
    litaC_std__string__String_appendStrn(&((litaC_fullName)), litaC_alias.buffer, litaC_alias.length);
    litaC_std__string__String_appendStrn(&((litaC_fullName)), "::", 2);
    litaC_std__string__String_appendStrn(&((litaC_fullName)), litaC_name.buffer, litaC_name.length);
    litaC_intern__InternedString litaC_nameIntern = litaC_intern__Strings_internCopy(&((litaC_this->module->lita->strings)), litaC_std__string__String_cStrConst(litaC_fullName), litaC_fullName.length);
    litaC_symbols__Scope_importSymbol(litaC_this, litaC_importSrcPos, litaC_nameIntern, litaC_symbol);
    
}

litaC_void litaC_symbols__Scope_importSymbol(litaC_symbols__Scope* litaC_this,litaC_lex__SrcPos litaC_importSrcPos,litaC_intern__InternedString litaC_name,litaC_symbols__Symbol* litaC_symbol) {
    litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_symbolStorage = &(litaC_this->symbolTypes);
    if(litaC_symbol->kind == litaC_symbols__SymbolKind_FUNC) {
        {
            litaC_symbolStorage = &(litaC_this->symbolFuncs);
            
            
        }
        
    } else {
        if(litaC_symbol->flags & litaC_symbols__SymbolFlags_IS_NOTE) {
            {
                litaC_symbolStorage = &(litaC_this->symbolNotes);
                
                
            }
            
        } 
        
    } 
    
    if(litaC_std__map__Map_contains_cb_InternedString_c__ptr_Symbol_ce_(litaC_symbolStorage, litaC_name)) {
        {
            if(litaC_symbol->flags & litaC_symbols__SymbolFlags_IS_GENERATED) {
                {
                    litaC_ast__CallArg* litaC_isStub = litaC_ast__Decl_getNoteArgument(litaC_symbol->decl, "generated", "stub");
                    if(litaC_isStub && litaC_isStub->argExpr && litaC_isStub->argExpr->stmt.node.kind == litaC_ast__StmtKind_BOOLEAN_EXPR) {
                        {
                            litaC_ast__BooleanExpr* litaC_boolExpr = (litaC_ast__BooleanExpr*)litaC_isStub->argExpr;
                            if(litaC_boolExpr->boolean) {
                                {
                                    return;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } else {
                {
                    litaC_symbols__Symbol* litaC_existingSym = litaC_std__map__Map_get_cb_InternedString_c__ptr_Symbol_ce_(litaC_symbolStorage, litaC_name);
                    if(!((litaC_existingSym->flags & litaC_symbols__SymbolFlags_IS_MARKED_RESET))) {
                        {
                            litaC_ast__Decl* litaC_decl = litaC_existingSym->decl;
                            litaC_phase_result__PhaseResult_addError(litaC_this->result, litaC_importSrcPos, "can't import symbol '%.*s' defined in '%s:%d' because it is already defined in '%s:%d'", litaC_name.length, litaC_name.buffer, litaC_symbol->decl->stmt.node.startPos.filename, litaC_symbol->decl->stmt.node.startPos.lineNumber, litaC_decl->stmt.node.startPos.filename, litaC_decl->stmt.node.startPos.lineNumber);
                            return;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            } 
            
            
            
        }
        
    } 
    
    litaC_std__map__Map_put_cb_InternedString_c__ptr_Symbol_ce_(litaC_symbolStorage, litaC_name, litaC_symbol);
    
}

litaC_void litaC_symbols__Scope_removeSymbol(litaC_symbols__Scope* litaC_this,litaC_symbols__Symbol* litaC_symbol) {
    litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_symbolStorage = &(litaC_this->symbolTypes);
    if(litaC_symbol->kind == litaC_symbols__SymbolKind_FUNC) {
        {
            litaC_symbolStorage = &(litaC_this->symbolFuncs);
            
            
        }
        
    } else {
        if(litaC_symbol->flags & litaC_symbols__SymbolFlags_IS_NOTE) {
            {
                litaC_symbolStorage = &(litaC_this->symbolNotes);
                
                
            }
            
        } 
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_symbolStorage->capacity;litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_value = litaC_symbolStorage->values[litaC_i];
            if(!(litaC_value)) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_value == litaC_symbol) {
                {
                    litaC_intern__InternedString litaC_key = litaC_symbolStorage->keys[litaC_i].key;
                    litaC_std__map__Map_remove_cb_InternedString_c__ptr_Symbol_ce_(litaC_symbolStorage, litaC_key);
                    return;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

litaC_symbols__Symbol* litaC_symbols__Scope_addSymbol(litaC_symbols__Scope* litaC_this,litaC_intern__InternedString litaC_name,litaC_module__Module* litaC_module,litaC_ast__Decl* litaC_decl,litaC_i32 litaC_flags) {
    litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_symbolStorage = &(litaC_this->symbolTypes);
    switch(litaC_decl->stmt.node.kind) {
        case litaC_ast__StmtKind_FUNC_DECL: {
            litaC_symbolStorage = &(litaC_this->symbolFuncs);
            break;
            
            
        }
        case litaC_ast__StmtKind_NOTE_DECL: {
            litaC_symbolStorage = &(litaC_this->symbolNotes);
            break;
            
            
        }
        default: {
            
            
        }
    }
    litaC_symbols__Symbol* litaC_sym = NULL;
    litaC_i32 litaC_isRebuild = litaC_this->module->flags & litaC_module__ModuleFlags_INCREMENTAL_COMPILATION;
    if(litaC_std__map__Map_contains_cb_InternedString_c__ptr_Symbol_ce_(litaC_symbolStorage, litaC_name)) {
        {
            litaC_bool litaC_isError = litaC_true;
            if(litaC_isRebuild) {
                {
                    litaC_sym = litaC_std__map__Map_get_cb_InternedString_c__ptr_Symbol_ce_(litaC_symbolStorage, litaC_name);
                    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_MARKED_RESET) {
                        {
                            litaC_sym->flags &= ~(litaC_symbols__SymbolFlags_IS_MARKED_RESET);
                            litaC_isError = litaC_false;
                            
                            
                        }
                        
                    } else {
                        if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_FROM_GENERIC_TEMPLATE) {
                            {
                                litaC_symbols__Symbol* litaC_existingSym = litaC_std__map__Map_get_cb_InternedString_c__ptr_Symbol_ce_(litaC_symbolStorage, litaC_name);
                                litaC_ast__Decl* litaC_decl = litaC_existingSym->decl;
                                if(litaC_decl == NULL) {
                                    {
                                        litaC_isError = litaC_false;
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            if(litaC_ast__Decl_hasNote(litaC_decl, "generated")) {
                {
                    litaC_isError = litaC_false;
                    
                    
                }
                
            } 
            
            if(litaC_isError) {
                {
                    litaC_symbols__Symbol* litaC_existingSym = litaC_std__map__Map_get_cb_InternedString_c__ptr_Symbol_ce_(litaC_symbolStorage, litaC_name);
                    litaC_ast__Decl* litaC_decl = litaC_existingSym->decl;
                    litaC_phase_result__PhaseResult_addError(litaC_this->result, litaC_decl->stmt.node.startPos, "symbol '%.*s' already defined in %s:%d", litaC_name.length, litaC_name.buffer, litaC_decl->stmt.node.startPos.filename, litaC_decl->stmt.node.startPos.lineNumber);
                    return NULL;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_bool litaC_isNewType = (litaC_decl->stmt.node.kind == litaC_ast__StmtKind_FUNC_DECL || litaC_decl->stmt.node.kind == litaC_ast__StmtKind_STRUCT_DECL || litaC_decl->stmt.node.kind == litaC_ast__StmtKind_UNION_DECL || litaC_decl->stmt.node.kind == litaC_ast__StmtKind_TRAIT_DECL || litaC_decl->stmt.node.kind == litaC_ast__StmtKind_TYPEDEF_DECL || litaC_decl->stmt.node.kind == litaC_ast__StmtKind_NOTE_DECL || litaC_decl->stmt.node.kind == litaC_ast__StmtKind_ENUM_DECL);
    if(litaC_this->kind == litaC_symbols__ScopeKind_FUNC) {
        {
            if(!(litaC_isNewType)) {
                {
                    litaC_flags |= litaC_symbols__SymbolFlags_IS_LOCAL;
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(litaC_ast__Decl_hasNote(litaC_decl, "foreign")) {
        {
            litaC_flags |= litaC_symbols__SymbolFlags_IS_FOREIGN;
            
            
        }
        
    } 
    
    if(litaC_ast__Decl_hasNote(litaC_decl, "generated")) {
        {
            litaC_flags |= litaC_symbols__SymbolFlags_IS_GENERATED;
            
            
        }
        
    } 
    
    if(litaC_ast__Decl_hasNote(litaC_decl, "hidden")) {
        {
            litaC_flags |= litaC_symbols__SymbolFlags_IS_HIDDEN;
            
            
        }
        
    } 
    
    switch(litaC_decl->attributes.visibility) {
        case litaC_ast__Visibility_PUBLIC: {
            litaC_flags |= litaC_symbols__SymbolFlags_IS_PUBLIC;
            break;
            
            
        }
        case litaC_ast__Visibility_INTERNAL: {
            litaC_flags |= litaC_symbols__SymbolFlags_IS_INTERNAL;
            break;
            
            
        }
        default: {
            litaC_flags |= litaC_symbols__SymbolFlags_IS_PRIVATE;
            
            
        }
    }
    if(litaC_isNewType) {
        {
            litaC_flags |= litaC_symbols__SymbolFlags_IS_TYPE;
            
            
        }
        
    } 
    
    litaC_i32 litaC_kind = litaC_symbols__SymbolKind_VAR;
    switch(litaC_decl->stmt.node.kind) {
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                litaC_flags |= litaC_symbols__SymbolFlags_IS_ALIAS;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NOTE_DECL: 
        case litaC_ast__StmtKind_ENUM_DECL: 
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: {
            {
                litaC_kind = litaC_symbols__SymbolKind_TYPE;
                if(litaC_decl->stmt.node.kind == litaC_ast__StmtKind_TRAIT_DECL) {
                    {
                        litaC_flags |= litaC_symbols__SymbolFlags_IS_TRAIT;
                        
                        
                    }
                    
                } 
                
                if(litaC_decl->stmt.node.kind == litaC_ast__StmtKind_NOTE_DECL) {
                    {
                        litaC_flags |= litaC_symbols__SymbolFlags_IS_NOTE;
                        litaC_flags &= ~(litaC_symbols__SymbolFlags_IS_TYPE);
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                litaC_kind = litaC_symbols__SymbolKind_FUNC;
                if(litaC_ast__Decl_hasNote(litaC_decl, "test")) {
                    {
                        litaC_flags |= litaC_symbols__SymbolFlags_IS_TEST;
                        
                        
                    }
                    
                } 
                
                litaC_ast__FuncDecl* litaC_funcDecl = (litaC_ast__FuncDecl*)litaC_decl;
                if(litaC_funcDecl->flags & litaC_ast__FuncFlags_IS_METHOD) {
                    {
                        litaC_flags |= litaC_symbols__SymbolFlags_IS_METHOD;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONST_DECL: {
            {
                litaC_flags |= litaC_symbols__SymbolFlags_IS_CONSTANT;
                
                
            }
            
            
        }
        default: {
            {
                litaC_kind = litaC_symbols__SymbolKind_VAR;
                break;
                
                
            }
            
            
        }
    }
    litaC_bool litaC_isNewSym = litaC_sym == NULL;
    if(litaC_isNewSym) {
        {
            litaC_sym = litaC_std__mem__new_cb_Symbol_ce_(litaC_this->allocator);
            litaC_sym->type = NULL;
            
            
        }
        
    } 
    
    litaC_sym->kind = litaC_kind;
    litaC_sym->name = litaC_name;
    litaC_sym->state = litaC_symbols__SymbolState_UNRESOLVED;
    litaC_sym->decl = litaC_decl;
    litaC_sym->declared = litaC_module;
    litaC_sym->flags = litaC_flags;
    litaC_decl->sym = litaC_sym;
    if(litaC_isNewSym) {
        {
            litaC_std__map__Map_put_cb_InternedString_c__ptr_Symbol_ce_(litaC_symbolStorage, litaC_sym->name, litaC_sym);
            
            
        }
        
    } 
    
    return litaC_sym;
    
    
}

litaC_void litaC_symbols__Scope_print(litaC_symbols__Scope* litaC_this,const litaC_char* litaC_header) {
    printf("Scope %s {\n", litaC_header);
    for(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_ litaC_it = litaC_std__map__Map_iter_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_this->symbolTypes)));litaC_std__map__MapIterator_hasNext_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));) {
        {
            litaC_symbols__Symbol* litaC_symbol = litaC_std__map__MapIterator_next_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it))).value;
            printf("   '%.*s'\n", litaC_symbol->name.length, litaC_symbol->name.buffer);
            
            
        }
    }
    for(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_ litaC_it = litaC_std__map__Map_iter_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_this->symbolFuncs)));litaC_std__map__MapIterator_hasNext_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));) {
        {
            litaC_symbols__Symbol* litaC_symbol = litaC_std__map__MapIterator_next_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it))).value;
            printf("   '%.*s'\n", litaC_symbol->name.length, litaC_symbol->name.buffer);
            
            
        }
    }
    printf("}\n");
    
}

litaC_void litaC_symbols__Scope_markReset(litaC_symbols__Scope* litaC_this,litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_symbols) {
    for(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_ litaC_it = litaC_std__map__Map_iter_cb_InternedString_c__ptr_Symbol_ce_(litaC_symbols);litaC_std__map__MapIterator_hasNext_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));) {
        {
            litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_ litaC_entry = litaC_std__map__MapIterator_next_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));
            litaC_symbols__Symbol* litaC_symbol = litaC_entry.value;
            litaC_bool litaC_isGenericFromThisModule = litaC_symbol->genericCallsiteModule != NULL && litaC_module__Module_equals(litaC_symbol->genericCallsiteModule, litaC_this->module);
            if(!(litaC_isGenericFromThisModule) && !(litaC_module__Module_equals(litaC_symbol->declared, litaC_this->module))) {
                {
                    litaC_std__map__MapIterator_remove_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_symbol->flags & litaC_symbols__SymbolFlags_IS_FROM_PREPROCESSOR) {
                {
                    litaC_symbols__Scope_removeSymbolFromModules(litaC_this, litaC_symbol);
                    litaC_std__map__MapIterator_remove_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));
                    continue;
                    
                    
                }
                
            } 
            
            litaC_symbol->flags |= litaC_symbols__SymbolFlags_IS_MARKED_RESET;
            litaC_symbol->state = litaC_symbols__SymbolState_UNRESOLVED;
            litaC_symbol->decl = NULL;
            
            
        }
    }
    
}

litaC_void litaC_symbols__Scope_cleanMarked(litaC_symbols__Scope* litaC_this,litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_symbols,litaC_bool litaC_remove) {
    for(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_ litaC_it = litaC_std__map__Map_iter_cb_InternedString_c__ptr_Symbol_ce_(litaC_symbols);litaC_std__map__MapIterator_hasNext_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));) {
        {
            litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_ litaC_entry = litaC_std__map__MapIterator_next_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));
            litaC_symbols__Symbol* litaC_symbol = litaC_entry.value;
            litaC_bool litaC_isGenericFromThisModule = litaC_symbol->genericCallsiteModule != NULL && litaC_module__Module_equals(litaC_symbol->genericCallsiteModule, litaC_this->module);
            if(!(litaC_isGenericFromThisModule) && !(litaC_module__Module_equals(litaC_symbol->declared, litaC_this->module))) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_symbol->flags & litaC_symbols__SymbolFlags_IS_MARKED_RESET) {
                {
                    litaC_symbols__Scope_removeSymbolFromModules(litaC_this, litaC_symbol);
                    if(litaC_remove) {
                        {
                            litaC_std__map__MapIterator_remove_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

litaC_void litaC_symbols__Scope_removeSymbolFromModules(litaC_symbols__Scope* litaC_this,litaC_symbols__Symbol* litaC_symbol) {
    for(litaC_std__map__MapIterator_cb__ptr_const_char_c_ModuleImport_ce_ litaC_it = litaC_std__map__Map_iter_cb__ptr_const_char_c_ModuleImport_ce_(&((litaC_this->module->importedBy)));litaC_std__map__MapIterator_hasNext_cb__ptr_const_char_c_ModuleImport_ce_(&((litaC_it)));) {
        {
            litaC_std__map__MapEntry_cb__ptr_const_char_c_ModuleImport_ce_ litaC_entry = litaC_std__map__MapIterator_next_cb__ptr_const_char_c_ModuleImport_ce_(&((litaC_it)));
            litaC_module__Module* litaC_m = litaC_entry.value.module;
            litaC_symbols__Scope_removeSymbol(&((litaC_m->symbols)), litaC_symbol);
            
            
        }
    }
    
}

litaC_module__Module* litaC_module__BuiltinsInit(litaC_lita__Lita* litaC_lita) {
    litaC_module__BUILTIN_IMPORT_IDENT.str = litaC_intern__BUILTIN;
    litaC_module__BUILTIN_IMPORT_IDENT.token = litaC_module__BUILTIN_IMPORT_TOKEN;
    litaC_module__builtins.text = (litaC_std__string__String) {
        
    };
    litaC_module__builtins.ast = NULL;
    litaC_module__builtins.flags = 0;
    litaC_module__builtins.allocator = litaC_lita->allocator;
    litaC_module__builtins.importedBy = litaC_std__map__StrMap_cb_ModuleImport_ce_((litaC_module__ModuleImport) {
        
    }, 512, litaC_lita->allocator);
    litaC_symbols__Scope_init(&((litaC_module__builtins.symbols)), litaC_symbols__ScopeKind_MODULE, NULL, &((litaC_lita->result)), &(litaC_module__builtins), litaC_lita->allocator);
    litaC_module__builtins.genericSymbols = &(litaC_lita->genericSymbols);
    litaC_module__builtins.lita = litaC_lita;
    litaC_ast_new__TypeSpecAllocator_init(&((litaC_module__builtins.typeSpecAllocator)), litaC_lita->allocator);
    litaC_char litaC_filename[_MAX_PATH] = {0};
    litaC_std__string__String litaC_pathStr = litaC_std__string__StringInit(litaC_filename, _MAX_PATH, 0);
    litaC_std__string__String_format(&((litaC_pathStr)), "%s/stdlib/std/builtins.lita", litaC_lita->options->litaPath);
    litaC_module__ModuleId_fromFile(&((litaC_module__builtins.id)), litaC_lita, litaC_std__string_view__StringViewInit("std/builtins", -(1)), litaC_std__string__String_cStr(litaC_pathStr));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__BOOL_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__CHAR_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__I8_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__U8_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__I16_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__U16_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__I32_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__U32_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__I64_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__U64_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__F32_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__F64_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__USIZE_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__NULL_TYPE));
    litaC_module__AddBuiltin(litaC_lita, &(litaC_types__VOID_TYPE));
    return &(litaC_module__builtins);
    
    
}

litaC_void litaC_module__AddBuiltin(litaC_lita__Lita* litaC_lita,litaC_types__TypeInfo* litaC_type) {
    litaC_symbols__Symbol* litaC_sym = litaC_symbols__Scope_addSymbol(&((litaC_module__builtins.symbols)), litaC_type->name, &(litaC_module__builtins), litaC_ast_new__NewBuiltinDecl((litaC_lex__SrcPos) {
        
    }, (litaC_lex__SrcPos) {
        
    }, litaC_type, litaC_lita->allocator), litaC_symbols__SymbolFlags_IS_BUILTIN | litaC_symbols__SymbolFlags_IS_TYPE | litaC_symbols__SymbolFlags_IS_FOREIGN);
    litaC_sym->state = litaC_symbols__SymbolState_RESOLVED;
    litaC_sym->type = litaC_type;
    litaC_type->sym = litaC_sym;
    
}

litaC_symbols__Symbol* litaC_module__GetBuiltinSymbol(litaC_i64 litaC_typeid) {
    if(litaC_typeid >= litaC_types__TypeKind_MAX_TYPE_KINDS) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_typeInfo = litaC_types__BUILTIN_TYPES[litaC_typeid];
    if(!(litaC_typeInfo)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    return litaC_typeInfo->sym;
    
    
}

litaC_module__Module* litaC_module__NewModule(litaC_lita__Lita* litaC_lita,litaC_std__string_view__StringView litaC_packageName,const litaC_char* litaC_filename) {
    litaC_module__Module* litaC_mod = litaC_std__mem__new_cb_Module_ce_(litaC_lita->allocator);
    litaC_module__Module_init(litaC_mod, litaC_lita);
    litaC_module__ModuleId_fromFile(&((litaC_mod->id)), litaC_lita, litaC_packageName, litaC_filename);
    return litaC_mod;
    
    
}

litaC_void litaC_module__Module_init(litaC_module__Module* litaC_this,litaC_lita__Lita* litaC_lita) {
    litaC_this->text = (litaC_std__string__String) {
        
    };
    litaC_this->ast = NULL;
    litaC_std__mem__arena_allocator__ArenaAllocator_init(&((litaC_this->arena)), 1024 * litaC_std__mem__KiB, litaC_lita->allocator);
    litaC_this->allocator = &(litaC_this->arena.allocator);
    litaC_ast_new__TypeSpecAllocator_init(&((litaC_this->typeSpecAllocator)), litaC_this->allocator);
    litaC_this->importedBy = litaC_std__map__StrMap_cb_ModuleImport_ce_((litaC_module__ModuleImport) {
        
    }, 64, litaC_lita->allocator);
    litaC_symbols__Scope_init(&((litaC_this->symbols)), litaC_symbols__ScopeKind_MODULE, &(litaC_module__builtins.symbols), &(litaC_lita->result), litaC_this, litaC_lita->allocator);
    litaC_this->flags = 0;
    litaC_this->currentScope = &(litaC_this->symbols);
    litaC_this->genericSymbols = &(litaC_lita->genericSymbols);
    litaC_this->lita = litaC_lita;
    
}

litaC_void litaC_module__Module_initIncrementalBuild(litaC_module__Module* litaC_this) {
    litaC_this->text = (litaC_std__string__String) {
        
    };
    litaC_this->ast = NULL;
    litaC_this->flags = 0;
    litaC_this->flags |= litaC_module__ModuleFlags_INCREMENTAL_COMPILATION;
    litaC_std__mem__arena_allocator__ArenaAllocator_clear(&((litaC_this->arena)));
    litaC_ast_new__TypeSpecAllocator_init(&((litaC_this->typeSpecAllocator)), litaC_this->allocator);
    litaC_symbols__Scope_initIncrementalBuild(&((litaC_this->symbols)));
    
}

litaC_bool litaC_module__Module_isBuiltin(litaC_module__Module* litaC_this) {
    return litaC_this == &(litaC_module__builtins);
    
    
}

litaC_void litaC_module__Module_postIncrementalBuild(litaC_module__Module* litaC_this) {
    litaC_this->flags &= ~(litaC_module__ModuleFlags_INCREMENTAL_COMPILATION);
    litaC_symbols__Scope_postIncrementalBuild(&((litaC_this->symbols)));
    
}

litaC_symbols__Symbol* litaC_module__Module_getType(litaC_module__Module* litaC_this,litaC_intern__InternedString litaC_type) {
    litaC_symbols__Symbol* litaC_sym = litaC_symbols__Scope_lookup(&((litaC_this->symbols)), litaC_type, litaC_true);
    if(litaC_sym) {
        {
            return litaC_sym;
            
            
            
        }
        
    } 
    
    return litaC_std__map__Map_get_cb_InternedString_c__ptr_Symbol_ce_(litaC_this->genericSymbols, litaC_type);
    
    
}

litaC_symbols__Symbol* litaC_module__Module_getFuncType(litaC_module__Module* litaC_this,litaC_intern__InternedString litaC_type) {
    litaC_symbols__Symbol* litaC_sym = litaC_symbols__Scope_lookupFunc(&((litaC_this->symbols)), litaC_type);
    if(litaC_sym) {
        {
            return litaC_sym;
            
            
            
        }
        
    } 
    
    return litaC_std__map__Map_get_cb_InternedString_c__ptr_Symbol_ce_(litaC_this->genericSymbols, litaC_type);
    
    
}

litaC_symbols__Symbol* litaC_module__Module_getNoteType(litaC_module__Module* litaC_this,litaC_intern__InternedString litaC_type) {
    litaC_symbols__Symbol* litaC_sym = litaC_symbols__Scope_lookupNote(&((litaC_this->symbols)), litaC_type);
    if(litaC_sym) {
        {
            return litaC_sym;
            
            
            
        }
        
    } 
    
    return litaC_std__map__Map_get_cb_InternedString_c__ptr_Symbol_ce_(litaC_this->genericSymbols, litaC_type);
    
    
}

litaC_bool litaC_module__Module_isMethodForType(litaC_module__Module* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_symbols__Symbol* litaC_sym) {
    if(!((litaC_sym->flags & litaC_symbols__SymbolFlags_IS_METHOD))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_fn = litaC_sym->type;
    if(litaC_fn == NULL || litaC_fn->kind != litaC_types__TypeKind_FUNC || litaC_fn->funcDecl == NULL || litaC_fn->funcDecl->params == NULL) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_fn->funcDecl->params->params))) == 0) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_ast__ParameterDecl* litaC_firstArg = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_fn->funcDecl->params->params)), 0);
    if(!(litaC_firstArg->typeInfo)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_base = litaC_types__TypeInfo_getBaseType(litaC_firstArg->typeInfo);
    if(litaC_types__IsGenericCapable(litaC_type)) {
        {
            litaC_types__TypeInfo* litaC_gen = litaC_type;
            if(litaC_types__IsGenericCapable(litaC_base)) {
                {
                    litaC_types__TypeInfo* litaC_param = litaC_base;
                    if(litaC_gen->genericTypeid == litaC_param->genericTypeid) {
                        {
                            return litaC_true;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            if(litaC_gen->genericTypeid == litaC_base->typeid) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(litaC_base->typeid != litaC_type->typeid) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_i32 litaC_module__Module_getMethodsForType(litaC_module__Module* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_symbols__Symbol** litaC_result) {
    litaC_i32 litaC_numOfSymbols = 0;
    litaC_symbols__Scope* litaC_currentSyms = &(litaC_this->symbols);
    while(litaC_currentSyms) {
        {
            for(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_ litaC_it = litaC_std__map__Map_iter_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_currentSyms->symbolFuncs)));litaC_std__map__MapIterator_hasNext_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));) {
                {
                    litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_ litaC_n = litaC_std__map__MapIterator_next_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));
                    litaC_symbols__Symbol* litaC_sym = litaC_n.value;
                    if(!(litaC_module__Module_isMethodForType(litaC_this, litaC_type, litaC_sym))) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    litaC_result[litaC_numOfSymbols] = litaC_sym;
                    litaC_numOfSymbols += 1;
                    
                    
                }
            }
            litaC_currentSyms = (litaC_currentSyms->parent) ? litaC_currentSyms->parent : NULL;
            
            
        }
    }
    return litaC_numOfSymbols;
    
    
}


litaC_intern__InternedString* litaC_module__Module_getImportAlias(litaC_module__Module* litaC_this,litaC_module__Module* litaC_module) {
    if(!(litaC_module)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_module__ModuleImport litaC_importInfo = litaC_std__map__Map_get_cb__ptr_const_char_c_ModuleImport_ce_(&((litaC_module->importedBy)), litaC_this->id.filename);
    return litaC_importInfo.alias;
    
    
}

litaC_void litaC_module__Module_importModule(litaC_module__Module* litaC_this,litaC_ast__ImportDecl* litaC_importDecl,litaC_module__Module* litaC_moduleToImport) {
    litaC_intern__InternedString* litaC_moduleName = NULL;
    if(litaC_importDecl->alias.token.type == litaC_lex__TokenType_IDENTIFIER) {
        {
            litaC_moduleName = &(litaC_importDecl->alias.str);
            
            
        }
        
    } 
    
    litaC_module__Module_importModuleSymbols(litaC_this, litaC_importDecl->decl.stmt.node.startPos, litaC_moduleToImport, litaC_moduleName, litaC_importDecl->isUsing);
    
}

litaC_void litaC_module__Module_importModuleSymbols(litaC_module__Module* litaC_this,litaC_lex__SrcPos litaC_importSrcPos,litaC_module__Module* litaC_moduleToImport,litaC_intern__InternedString* litaC_moduleName,litaC_bool litaC_isUsing) {
    litaC_std__map__Map_put_cb__ptr_const_char_c_ModuleImport_ce_(&((litaC_moduleToImport->importedBy)), litaC_this->id.filename, (litaC_module__ModuleImport) {
        litaC_this,
        litaC_moduleName,
        litaC_isUsing
    });
    litaC_symbols__Scope litaC_symbols = litaC_moduleToImport->symbols;
    for(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_ litaC_it = litaC_std__map__Map_iter_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_symbols.symbolTypes)));litaC_std__map__MapIterator_hasNext_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));) {
        {
            litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_ litaC_entry = litaC_std__map__MapIterator_next_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));
            litaC_intern__InternedString litaC_symName = litaC_entry.key;
            litaC_symbols__Symbol* litaC_symbol = litaC_entry.value;
            litaC_module__Module_importModuleSymbol(litaC_this, litaC_importSrcPos, litaC_moduleToImport, litaC_moduleName, litaC_symbol, litaC_symName, litaC_isUsing);
            
            
        }
    }
    for(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_ litaC_it = litaC_std__map__Map_iter_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_symbols.symbolFuncs)));litaC_std__map__MapIterator_hasNext_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));) {
        {
            litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_ litaC_entry = litaC_std__map__MapIterator_next_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));
            litaC_intern__InternedString litaC_symName = litaC_entry.key;
            litaC_symbols__Symbol* litaC_symbol = litaC_entry.value;
            litaC_module__Module_importModuleSymbol(litaC_this, litaC_importSrcPos, litaC_moduleToImport, litaC_moduleName, litaC_symbol, litaC_symName, litaC_isUsing);
            
            
        }
    }
    for(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_ litaC_it = litaC_std__map__Map_iter_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_symbols.symbolNotes)));litaC_std__map__MapIterator_hasNext_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));) {
        {
            litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_ litaC_entry = litaC_std__map__MapIterator_next_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));
            litaC_intern__InternedString litaC_symName = litaC_entry.key;
            litaC_symbols__Symbol* litaC_symbol = litaC_entry.value;
            litaC_module__Module_importModuleSymbol(litaC_this, litaC_importSrcPos, litaC_moduleToImport, litaC_moduleName, litaC_symbol, litaC_symName, litaC_isUsing);
            
            
        }
    }
    
}

litaC_void litaC_module__Module_importModuleSymbol(litaC_module__Module* litaC_this,litaC_lex__SrcPos litaC_importSrcPos,litaC_module__Module* litaC_moduleToImport,litaC_intern__InternedString* litaC_moduleName,litaC_symbols__Symbol* litaC_symbol,litaC_intern__InternedString litaC_symName,litaC_bool litaC_isUsing) {
    if(litaC_symbol->flags & litaC_symbols__SymbolFlags_IS_PRIVATE) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_symbol->flags & litaC_symbols__SymbolFlags_IS_INTERNAL) {
        {
            if(!(litaC_module__Module_isInPackage(litaC_this, litaC_moduleToImport))) {
                {
                    return;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(!(litaC_module__Module_equals(litaC_symbol->declared, litaC_moduleToImport))) {
        {
            if(!(litaC_symbol->usingModule) || !(litaC_module__Module_equals(litaC_symbol->usingModule, litaC_moduleToImport))) {
                {
                    return;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(litaC_module__Module_equals(litaC_symbol->declared, litaC_this)) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_isUsing && !(litaC_symbol->usingModule)) {
        {
            litaC_symbol->usingModule = litaC_this;
            
            
        }
        
    } 
    
    if(litaC_symbol->flags & litaC_symbols__SymbolFlags_IS_MARKED_RESET) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_moduleName) {
        {
            litaC_symbols__Scope_importSymbolWithAlias(&((litaC_this->symbols)), litaC_importSrcPos, litaC_symName, *(litaC_moduleName), litaC_symbol);
            
            
        }
        
    } else {
        {
            litaC_symbols__Scope_importSymbol(&((litaC_this->symbols)), litaC_importSrcPos, litaC_symName, litaC_symbol);
            
            
        }
    } 
    
    
}

litaC_char* litaC_module__GetFilenameKey(const litaC_char* litaC_filename,litaC_char* litaC_output) {
    litaC_std__system__GetAbsolutePath(litaC_std__system__CurrentWorkingPath(), litaC_filename, litaC_output);
    litaC_char* litaC_c = litaC_output;
    while(*(litaC_c)) {
        {
            *(litaC_c) = toupper(*(litaC_c));
            litaC_c += 1;
            
            
        }
    }
    return litaC_output;
    
    
}

LITAC_INLINE 
litaC_bool litaC_module__Module_equals(litaC_module__Module* litaC_this,litaC_module__Module* litaC_other) {
    return litaC_this == litaC_other;
    
    
}


litaC_bool litaC_module__Module_isInPackage(litaC_module__Module* litaC_this,litaC_module__Module* litaC_other) {
    if(litaC_this == litaC_other) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    {
        litaC_i32 litaC_rootIndex = litaC_std__string_view__StringView_lastIndexOfAt(litaC_this->id.packageName.view, "::", 2, -(1));
        if(litaC_rootIndex < 0) {
            {
                return litaC_true;
                
                
                
            }
            
        } 
        
        litaC_std__string_view__StringView litaC_root = litaC_std__string_view__StringView_substring(litaC_this->id.packageName.view, 0, litaC_rootIndex);
        litaC_bool litaC_result = litaC_std__string_view__StringView_startsWith(litaC_other->id.packageName.view, litaC_root.buffer, litaC_root.length, 0);
        if(litaC_result) {
            {
                return litaC_true;
                
                
                
            }
            
        } 
        
        
        
    }
    {
        litaC_i32 litaC_rootIndex = litaC_std__string_view__StringView_lastIndexOfAt(litaC_other->id.packageName.view, "::", 2, -(1));
        if(litaC_rootIndex < 0) {
            {
                return litaC_true;
                
                
                
            }
            
        } 
        
        litaC_std__string_view__StringView litaC_root = litaC_std__string_view__StringView_substring(litaC_other->id.packageName.view, 0, litaC_rootIndex);
        litaC_bool litaC_result = litaC_std__string_view__StringView_startsWith(litaC_this->id.packageName.view, litaC_root.buffer, litaC_root.length, 0);
        if(litaC_result) {
            {
                return litaC_true;
                
                
                
            }
            
        } 
        
        
        
    }
    return litaC_false;
    
    
}

litaC_void litaC_module__Module_print(litaC_module__Module* litaC_this,const litaC_char* litaC_header) {
    printf("Module %s %.*s {\n", litaC_header, litaC_this->id.name.length, litaC_this->id.name.buffer);
    litaC_symbols__Scope litaC_symbols = litaC_this->symbols;
    litaC_i32 litaC_i = 0;
    for(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_ litaC_it = litaC_std__map__Map_iter_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_symbols.symbolTypes)));litaC_std__map__MapIterator_hasNext_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));) {
        {
            litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_ litaC_entry = litaC_std__map__MapIterator_next_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));
            litaC_intern__InternedString litaC_symName = litaC_entry.key;
            litaC_symbols__Symbol* litaC_symbol = litaC_entry.value;
            printf("   %d '%.*s' %s\n", litaC_i, litaC_symName.length, litaC_symName.buffer, litaC_symbols__SymbolKindAsStr(litaC_symbol->kind));
            litaC_i += 1;
            
            
        }
    }
    litaC_i = 0;
    for(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_ litaC_it = litaC_std__map__Map_iter_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_symbols.symbolFuncs)));litaC_std__map__MapIterator_hasNext_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));) {
        {
            litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_ litaC_entry = litaC_std__map__MapIterator_next_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));
            litaC_intern__InternedString litaC_symName = litaC_entry.key;
            litaC_symbols__Symbol* litaC_symbol = litaC_entry.value;
            printf("   %d '%.*s' %s\n", litaC_i, litaC_symName.length, litaC_symName.buffer, litaC_symbols__SymbolKindAsStr(litaC_symbol->kind));
            litaC_i += 1;
            
            
        }
    }
    litaC_i = 0;
    for(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_ litaC_it = litaC_std__map__Map_iter_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_symbols.symbolNotes)));litaC_std__map__MapIterator_hasNext_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));) {
        {
            litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_ litaC_entry = litaC_std__map__MapIterator_next_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));
            litaC_intern__InternedString litaC_symName = litaC_entry.key;
            litaC_symbols__Symbol* litaC_symbol = litaC_entry.value;
            printf("   %d '%.*s' %s\n", litaC_i, litaC_symName.length, litaC_symName.buffer, litaC_symbols__SymbolKindAsStr(litaC_symbol->kind));
            litaC_i += 1;
            
            
        }
    }
    printf("}\n");
    
}

litaC_void litaC_module__ModuleId_fromFile(litaC_module__ModuleId* litaC_moduleId,litaC_lita__Lita* litaC_lita,litaC_std__string_view__StringView litaC_packageName,const litaC_char* litaC_filename) {
    litaC_std__system__GetAbsolutePath(litaC_std__system__CurrentWorkingPath(), litaC_filename, litaC_moduleId->filename);
    litaC_module__GetFilenameKey(litaC_filename, litaC_moduleId->filenameKey);
    litaC_std__string_view__StringView litaC_pkg = litaC_module__ToModuleName(litaC_packageName);
    litaC_moduleId->packageName = litaC_intern__Strings_internCopy(&((litaC_lita->strings)), litaC_pkg.buffer, litaC_pkg.length);
    litaC_std__string_view__StringView litaC_pathStr = litaC_std__string_view__StringViewInit(litaC_moduleId->filename, -(1));
    litaC_std__string_view__StringView litaC_name = litaC_module__GetModuleName(litaC_pathStr);
    litaC_moduleId->name = litaC_intern__Strings_internCopy(&((litaC_lita->strings)), litaC_name.buffer, litaC_name.length);
    
}

litaC_std__string_view__StringView litaC_module__ToModulePath(litaC_std__string_view__StringView litaC_moduleName) {
    static 
    litaC_char litaC_modulePath[256] =  {
        0
    };
    litaC_i32 litaC_len = 0;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_moduleName.length;litaC_i += 1) {
        {
            litaC_char litaC_c = litaC_moduleName.buffer[litaC_i];
            if(litaC_c == ':') {
                {
                    litaC_c = '/';
                    litaC_i += 1;
                    
                    
                }
                
            } 
            
            litaC_modulePath[litaC_len] = litaC_c;
            litaC_len += 1;
            
            
        }
    }
    return (litaC_std__string_view__StringView) {
        .length = litaC_len,
        .buffer = litaC_modulePath
    };
    
    
}

litaC_std__string_view__StringView litaC_module__ToModuleName(litaC_std__string_view__StringView litaC_modulePath) {
    static 
    litaC_char litaC_moduleName[256] =  {
        0
    };
    litaC_i32 litaC_len = 0;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_modulePath.length;litaC_i += 1) {
        {
            litaC_char litaC_c = litaC_modulePath.buffer[litaC_i];
            if(litaC_c == '/' || litaC_c == '\\') {
                {
                    litaC_moduleName[litaC_len + 0] = ':';
                    litaC_moduleName[litaC_len + 1] = ':';
                    litaC_len += 2;
                    
                    
                }
                
            } else {
                if(litaC_c == '.') {
                    {
                        continue;
                        
                        
                    }
                    
                } else {
                    {
                        litaC_moduleName[litaC_len] = litaC_c;
                        litaC_len += 1;
                        
                        
                    }
                } 
                
            } 
            
            
            
        }
    }
    return (litaC_std__string_view__StringView) {
        .length = litaC_len,
        .buffer = litaC_moduleName
    };
    
    
}

litaC_std__string_view__StringView litaC_module__GetModuleName(litaC_std__string_view__StringView litaC_pathStr) {
    litaC_i32 litaC_endIndex = -(1);
    litaC_i32 litaC_startIndex = -(1);
    for(litaC_i32 litaC_i = litaC_pathStr.length - 1;litaC_i >= 0;litaC_i -= 1) {
        {
            litaC_char litaC_c = litaC_pathStr.buffer[litaC_i];
            if(litaC_c == '.' && litaC_endIndex < 0) {
                {
                    litaC_endIndex = litaC_i;
                    
                    
                }
                
            } else {
                if(litaC_c == '/') {
                    {
                        litaC_startIndex = litaC_i + 1;
                        break;
                        
                        
                    }
                    
                } 
                
            } 
            
            
            
        }
    }
    if(litaC_endIndex < 0 || litaC_startIndex < 0 || litaC_startIndex > litaC_endIndex) {
        {
            return (litaC_std__string_view__StringView) {
                .buffer = 0,
                .length = 0
            };
            
            
            
        }
        
    } 
    
    return (litaC_std__string_view__StringView) {
        .buffer = litaC_pathStr.buffer + litaC_startIndex,
        .length = litaC_endIndex - litaC_startIndex
    };
    
    
}

litaC_void litaC_std__mem__arena_allocator__ArenaAllocator_init(litaC_std__mem__arena_allocator__ArenaAllocator* litaC_this,litaC_usize litaC_size,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_this->decorated = litaC_alloc;
    litaC_this->allocator = (litaC_std__mem__Allocator) {
        .allocFn = &(litaC_std__mem__arena_allocator__ArenaMalloc),
        .callocFn = &(litaC_std__mem__arena_allocator__ArenaCalloc),
        .reallocFn = &(litaC_std__mem__arena_allocator__ArenaRealloc),
        .freeFn = &(litaC_std__mem__arena_allocator__ArenaFree)
    };
    litaC_void* litaC_mem = (litaC_void*)litaC_std__mem__Allocator_alloc(litaC_this->decorated, sizeof(litaC_std__mem__arena_allocator__Arena) + sizeof(litaC_u8) * litaC_size);
    litaC_this->arena = (litaC_std__mem__arena_allocator__Arena*)litaC_mem;
    litaC_this->arena->size = litaC_size;
    litaC_this->arena->current = 0;
    litaC_this->arena->next = NULL;
    litaC_this->arena->region = (litaC_u8*)(litaC_mem + sizeof(litaC_std__mem__arena_allocator__Arena));
    litaC_this->numberOfArenas = 1;
    litaC_this->numberOfBytesAllocated = litaC_size;
    litaC_this->pageSize = litaC_size;
    
}

litaC_void litaC_std__mem__arena_allocator__ArenaAllocator_free(litaC_std__mem__arena_allocator__ArenaAllocator* litaC_this) {
    litaC_this->numberOfArenas = 0;
    litaC_this->numberOfBytesAllocated = 0;
    const litaC_std__mem__Allocator* litaC_alloc = litaC_this->decorated;
    litaC_std__mem__arena_allocator__Arena* litaC_last = litaC_this->arena;
    if(!(litaC_last)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_std__mem__arena_allocator__Arena* litaC_next = NULL;
    do {
        {
            litaC_next = litaC_last->next;
            litaC_last->next = NULL;
            litaC_std__mem__Allocator_free(litaC_alloc, (litaC_void*)litaC_last);
            litaC_last = litaC_next;
            
            
        }
    }
    while(litaC_next != NULL);
    
}

litaC_void litaC_std__mem__arena_allocator__ArenaAllocator_clear(litaC_std__mem__arena_allocator__ArenaAllocator* litaC_this) {
    litaC_std__mem__arena_allocator__Arena* litaC_a = litaC_this->arena;
    while(litaC_a != NULL) {
        {
            litaC_a->current = 0;
            memset(litaC_a->region, 0, litaC_a->size);
            litaC_a = litaC_a->next;
            
            
        }
    }
    
}

litaC_usize litaC_std__mem__arena_allocator__ArenaAllocator_unusedBytes(litaC_std__mem__arena_allocator__ArenaAllocator* litaC_this) {
    litaC_usize litaC_numberOfUnusedBytes = 0;
    litaC_std__mem__arena_allocator__Arena* litaC_a = litaC_this->arena;
    while(litaC_a != NULL) {
        {
            litaC_usize litaC_delta = litaC_a->size - litaC_a->current;
            litaC_numberOfUnusedBytes += litaC_delta;
            litaC_a = litaC_a->next;
            
            
        }
    }
    return litaC_numberOfUnusedBytes;
    
    
}

litaC_void* litaC_std__mem__arena_allocator__ArenaAllocator_malloc(litaC_std__mem__arena_allocator__ArenaAllocator* litaC_this,litaC_usize litaC_size) {
    litaC_std__mem__arena_allocator__Arena* litaC_a = litaC_this->arena;
    litaC_std__mem__arena_allocator__Arena* litaC_last = litaC_a;
    while(litaC_a != NULL) {
        {
            if((litaC_a->size - litaC_a->current) > litaC_size) {
                {
                    litaC_a->current += litaC_size;
                    return (litaC_void*)(litaC_a->region + (litaC_a->current - litaC_size));
                    
                    
                    
                }
                
            } 
            
            litaC_last = litaC_a;
            litaC_a = litaC_a->next;
            
            
        }
    }
    litaC_usize litaC_asize = (litaC_size > litaC_this->pageSize) ? litaC_size : litaC_this->pageSize;
    litaC_void* litaC_mem = (litaC_void*)litaC_std__mem__Allocator_alloc(litaC_this->decorated, sizeof(litaC_std__mem__arena_allocator__Arena) + sizeof(litaC_char) * litaC_asize);
    litaC_std__mem__arena_allocator__Arena* litaC_next = (litaC_std__mem__arena_allocator__Arena*)litaC_mem;
    litaC_next->size = litaC_asize;
    litaC_next->current = 0;
    litaC_next->next = NULL;
    litaC_next->region = (litaC_u8*)(litaC_mem + sizeof(litaC_std__mem__arena_allocator__Arena));
    litaC_last->next = litaC_next;
    litaC_next->current += litaC_size;
    litaC_this->numberOfArenas += 1;
    litaC_this->numberOfBytesAllocated += litaC_asize;
    return (litaC_void*)litaC_next->region;
    
    
}

litaC_void* litaC_std__mem__arena_allocator__ArenaMalloc(const litaC_std__mem__Allocator* litaC_alloc,litaC_usize litaC_size) {
    litaC_std__mem__arena_allocator__ArenaAllocator* litaC_arena = (litaC_std__mem__arena_allocator__ArenaAllocator*)litaC_alloc;
    return litaC_std__mem__arena_allocator__ArenaAllocator_malloc(litaC_arena, litaC_size);
    
    
}

litaC_void* litaC_std__mem__arena_allocator__ArenaCalloc(const litaC_std__mem__Allocator* litaC_alloc,litaC_usize litaC_num,litaC_usize litaC_size) {
    litaC_std__mem__arena_allocator__ArenaAllocator* litaC_arena = (litaC_std__mem__arena_allocator__ArenaAllocator*)litaC_alloc;
    litaC_void* litaC_result = litaC_std__mem__arena_allocator__ArenaAllocator_malloc(litaC_arena, litaC_size * litaC_num);
    if(litaC_result) {
        {
            memset(litaC_result, 0, litaC_size * litaC_num);
            
            
        }
        
    } 
    
    return litaC_result;
    
    
}

litaC_void* litaC_std__mem__arena_allocator__ArenaRealloc(const litaC_std__mem__Allocator* litaC_alloc,litaC_void* litaC_ptr,litaC_usize litaC_oldSize,litaC_usize litaC_size) {
    if(litaC_ptr == NULL) {
        {
            return litaC_std__mem__arena_allocator__ArenaMalloc(litaC_alloc, litaC_size);
            
            
            
        }
        
    } 
    
    litaC_std__mem__arena_allocator__ArenaAllocator* litaC_arena = (litaC_std__mem__arena_allocator__ArenaAllocator*)litaC_alloc;
    litaC_void* litaC_result = litaC_std__mem__arena_allocator__ArenaAllocator_malloc(litaC_arena, litaC_size);
    if(litaC_result) {
        {
            litaC_usize litaC_len = MIN(litaC_oldSize, litaC_size);
            memcpy(litaC_result, litaC_ptr, litaC_len);
            litaC_std__mem__arena_allocator__ArenaFree(litaC_alloc, litaC_ptr);
            
            
        }
        
    } 
    
    return litaC_result;
    
    
}

litaC_void litaC_std__mem__arena_allocator__ArenaFree(const litaC_std__mem__Allocator* litaC_alloc,litaC_void* litaC_ptr) {
    
}

litaC_phase_result__PhaseResult litaC_phase_result__PhaseResultInit(const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_phase_result__PhaseResult litaC_result =  {
        .allocator = litaC_allocator,
        .enabled = litaC_true,
        .isReadable = litaC_true
    };
    litaC_std__array__Array_init_cb_PhaseError_ce_(&((litaC_result.errors)), 16, litaC_allocator);
    return litaC_result;
    
    
}

litaC_void litaC_phase_result__PhaseResult_addError(litaC_phase_result__PhaseResult* litaC_r,litaC_lex__SrcPos litaC_pos,const litaC_char* litaC_format,...) {
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_r->allocator);
    va_list litaC_args = {0};
    va_start(litaC_args, litaC_format);
    litaC_std__string_buffer__StringBuffer_appendArgs(&((litaC_sb)), litaC_format, litaC_args);
    va_end(litaC_args);
    litaC_phase_result__PhaseResult_addErrorStr(litaC_r, litaC_pos, &((litaC_sb)));
    
}

litaC_void litaC_phase_result__PhaseResult_addErrorStr(litaC_phase_result__PhaseResult* litaC_r,litaC_lex__SrcPos litaC_pos,litaC_std__string_buffer__StringBuffer* litaC_sb) {
    if(!(litaC_r->enabled)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_std__array__Array_add_cb_PhaseError_ce_(&((litaC_r->errors)), (litaC_phase_result__PhaseError) {
        .type = litaC_phase_result__ErrorType_ERROR,
        .message = litaC_std__string_buffer__StringBuffer_cStr(litaC_sb),
        .pos = litaC_pos
    });
    
}

litaC_bool litaC_phase_result__PhaseResult_hasErrors(litaC_phase_result__PhaseResult* litaC_r) {
    return !(litaC_std__array__Array_empty_cb_PhaseError_ce_(&((litaC_r->errors))));
    
    
}

litaC_void litaC_phase_result__PhaseResult_clear(litaC_phase_result__PhaseResult* litaC_r) {
    litaC_std__array__Array_clear_cb_PhaseError_ce_(&((litaC_r->errors)));
    
}

litaC_void litaC_common__Log(litaC_common__LogLevel litaC_level,const litaC_char* litaC_format,...) {
    va_list litaC_args = {0};
    va_start(litaC_args, litaC_format);
    litaC_common__Logv(litaC_level, litaC_format, litaC_args);
    va_end(litaC_args);
    
}

litaC_void litaC_common__Logv(litaC_common__LogLevel litaC_level,const litaC_char* litaC_format,va_list litaC_args) {
    if(!(litaC_common__outputFile)) {
        {
            litaC_common__outputFile = fopen("./litac.log", "w");
            if(!(litaC_common__outputFile)) {
                {
                    litaC_common__outputFile = stdout;
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(litaC_level > litaC_common__LogLevel_DEBUG) {
        {
            vfprintf(stderr, litaC_format, litaC_args);
            fflush(stderr);
            
            
        }
        
    } else {
        {
            vfprintf(litaC_common__outputFile, litaC_format, litaC_args);
            fflush(litaC_common__outputFile);
            
            
        }
    } 
    
    if(litaC_level == litaC_common__LogLevel_FATAL) {
        {
            exit(2);
            
            
        }
        
    } 
    
    
}

litaC_void litaC_common__Info(const litaC_char* litaC_format,...) {
    va_list litaC_args = {0};
    va_start(litaC_args, litaC_format);
    litaC_common__Logv(litaC_common__LogLevel_INFO, litaC_format, litaC_args);
    va_end(litaC_args);
    
}

litaC_void litaC_common__Debug(const litaC_char* litaC_format,...) {
    va_list litaC_args = {0};
    va_start(litaC_args, litaC_format);
    litaC_common__Logv(litaC_common__LogLevel_DEBUG, litaC_format, litaC_args);
    va_end(litaC_args);
    
}

litaC_void litaC_common__Error(const litaC_char* litaC_format,...) {
    va_list litaC_args = {0};
    va_start(litaC_args, litaC_format);
    litaC_common__Logv(litaC_common__LogLevel_ERROR, litaC_format, litaC_args);
    va_end(litaC_args);
    
}

litaC_void litaC_common__Panic(const litaC_char* litaC_format,...) {
    va_list litaC_args = {0};
    va_start(litaC_args, litaC_format);
    litaC_common__Logv(litaC_common__LogLevel_FATAL, litaC_format, litaC_args);
    va_end(litaC_args);
    
}

litaC_char* litaC_common__EscapeName(const litaC_char* litaC_name,litaC_i32 litaC_len,litaC_std__string_buffer__StringBuffer* litaC_sb) {
    litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, litaC_name, litaC_len);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_sb->length;) {
        {
            litaC_char litaC_c = litaC_sb->buffer[litaC_i];
            switch(litaC_c) {
                case '*': {
                    litaC_std__string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_ptr_");
                    litaC_i += 5;
                    break;
                    
                    
                }
                case '<': {
                    litaC_std__string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_cb_");
                    litaC_i += 4;
                    break;
                    
                    
                }
                case '>': {
                    litaC_std__string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_ce_");
                    litaC_i += 4;
                    break;
                    
                    
                }
                case '[': {
                    litaC_std__string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_bb_");
                    litaC_i += 4;
                    break;
                    
                    
                }
                case ']': {
                    litaC_std__string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_be_");
                    litaC_i += 4;
                    break;
                    
                    
                }
                case '(': {
                    litaC_std__string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_pb_");
                    litaC_i += 4;
                    break;
                    
                    
                }
                case ')': {
                    litaC_std__string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_pe_");
                    litaC_i += 4;
                    break;
                    
                    
                }
                case ',': {
                    litaC_std__string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_c_");
                    litaC_i += 3;
                    break;
                    
                    
                }
                case ' ': {
                    litaC_std__string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_");
                    litaC_i += 1;
                    break;
                    
                    
                }
                case '-': {
                    litaC_std__string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_m_");
                    litaC_i += 3;
                    break;
                    
                    
                }
                case ':': {
                    {
                        litaC_i32 litaC_n = litaC_i + 1;
                        if(litaC_n < litaC_sb->length) {
                            {
                                litaC_char litaC_nc = litaC_sb->buffer[litaC_n];
                                if(litaC_nc == ':') {
                                    {
                                        litaC_std__string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 2, "__");
                                        litaC_i += 2;
                                        break;
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_std__string_buffer__StringBuffer_replace(litaC_sb, litaC_i, litaC_i + 1, "_r_");
                        litaC_i += 3;
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        litaC_i += 1;
                        break;
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    return litaC_std__string_buffer__StringBuffer_cStr(litaC_sb);
    
    
}

litaC_void litaC_lita__Lita_init(litaC_lita__Lita* litaC_this,litaC_lita__LitaOptions* litaC_options) {
    litaC_usize litaC_size = (litaC_options->maxMemory > 0) ? litaC_options->maxMemory : 1024 * 1024 * 1024;
    litaC_std__mem__bucket_allocator__BucketAllocator_init(&((litaC_this->globalAllocator)), litaC_std__mem__defaultAllocator, 100 * litaC_std__mem__MiB);
    litaC_this->allocator = &(litaC_this->globalAllocator.allocator);
    litaC_this->options = litaC_options;
    memset(litaC_this->binaryFilename, 0, _MAX_PATH);
    memset(litaC_this->sourceFilename, 0, _MAX_PATH);
    litaC_lita__Lita_reset(litaC_this);
    
}


litaC_void litaC_lita__Lita_reset(litaC_lita__Lita* litaC_this) {
    litaC_std__mem__bucket_allocator__BucketAllocator_clear(&((litaC_this->globalAllocator)));
    litaC_this->totalSourceLines = 0;
    litaC_this->totalAllocations = 0;
    litaC_preprocessor__Preprocessor_init(&((litaC_this->preprocessor)), litaC_this);
    litaC_this->result = litaC_phase_result__PhaseResultInit(litaC_this->allocator);
    litaC_this->modules = litaC_std__map__StrMap_cb__ptr_Module_ce_(NULL, 32, litaC_this->allocator);
    litaC_this->genericSymbols = litaC_intern__InternMap_cb__ptr_Symbol_ce_(NULL, 128, litaC_this->allocator);
    litaC_std__mem__bucket_allocator__BucketAllocator_init(&((litaC_this->stringsAllocator)), litaC_this->allocator, 1 * litaC_std__mem__MiB);
    litaC_intern__Strings_init(&((litaC_this->strings)), &((litaC_this->stringsAllocator.allocator)));
    litaC_types_new__TypeCache_init(&((litaC_this->typeCache)), litaC_this->allocator);
    litaC_types__TypesInit(&((litaC_this->strings)));
    litaC_lsp__references__ReferenceDatabase_init(&((litaC_this->references)), litaC_this->allocator);
    litaC_std__array__Array_init_cb_CCompilerOption_ce_(&((litaC_this->compilerOptions)), 16, litaC_this->allocator);
    {
        litaC_char litaC_temp[_MAX_PATH] = {0};
        litaC_std__string__String litaC_build = litaC_std__string__StringInit(litaC_temp, _MAX_PATH, 0);
        litaC_std__string__String_format(&((litaC_build)), "%s/.build.json", litaC_this->options->projectPath);
        memset((litaC_void*)(&(litaC_this->buildFile)), 0, sizeof(litaC_build__BuildFile));
        if(litaC_std__system__FileExists(litaC_std__string__String_cStr(litaC_build))) {
            {
                litaC_build__BuildFileFromFile(litaC_std__string__String_cStr(litaC_build), &(litaC_this->buildFile), litaC_this->allocator);
                
                
            }
            
        } 
        
        
        
    }
    
}

litaC_void litaC_lita__Lita_free(litaC_lita__Lita* litaC_lita) {
    litaC_std__mem__bucket_allocator__BucketAllocator_free(&((litaC_lita->globalAllocator)));
    
}

litaC_void litaC_lita__Lita_addModule(litaC_lita__Lita* litaC_lita,litaC_module__Module* litaC_module) {
    litaC_std__map__Map_put_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_lita->modules)), litaC_module->id.filenameKey, litaC_module);
    
}

litaC_module__Module* litaC_lita__Lita_getModule(litaC_lita__Lita* litaC_lita,const litaC_char* litaC_filename) {
    static 
    litaC_char litaC_filenameKey[_MAX_PATH] =  {
        0
    };
    litaC_module__GetFilenameKey(litaC_filename, litaC_filenameKey);
    return litaC_std__map__Map_get_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_lita->modules)), litaC_filenameKey);
    
    
}

litaC_void litaC_lita__Lita_startCapture(litaC_lita__Lita* litaC_lita,litaC_lita__MetricType litaC_type) {
    litaC_lita__Metric* litaC_metric = &(litaC_lita->metrics[litaC_type]);
    litaC_std__mem__bucket_allocator__BucketAllocator litaC_allocator = litaC_lita->globalAllocator;
    litaC_metric->bytesAllocated = litaC_allocator.totalBytesAllocated;
    litaC_metric->allocationCount = litaC_allocator.totalAllocations;
    litaC_metric->startTime = litaC_std__system__SystemTimeMSec();
    
}

litaC_void litaC_lita__Lita_endCapture(litaC_lita__Lita* litaC_lita,litaC_lita__MetricType litaC_type) {
    litaC_lita__Metric* litaC_metric = &(litaC_lita->metrics[litaC_type]);
    litaC_std__mem__bucket_allocator__BucketAllocator litaC_allocator = litaC_lita->globalAllocator;
    litaC_metric->bytesAllocated = litaC_allocator.totalBytesAllocated - litaC_metric->bytesAllocated;
    litaC_metric->allocationCount = litaC_allocator.totalAllocations - litaC_metric->allocationCount;
    litaC_metric->executionTime = litaC_std__system__SystemTimeMSec() - litaC_metric->startTime;
    
}

litaC_void litaC_lita__Lita_incrementalBuild(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module) {
    if(!(litaC_module)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_phase_result__PhaseResult_clear(&((litaC_this->result)));
    litaC_lsp__references__ReferenceDatabase_removeLocalSymbolReferences(&((litaC_this->references)), litaC_module);
    litaC_module__Module_initIncrementalBuild(litaC_module);
    
    {
        if(!(litaC_lita__ParseModule(litaC_this, litaC_module, (litaC_lex__SrcPos) {
            
        }))) {
            {
                litaC_module__Module_postIncrementalBuild(litaC_module);
                return;
                
                
                
            }
            
        } 
        
        litaC_ast__ImportDecl* litaC_builtinImport = (litaC_ast__ImportDecl*)litaC_ast_new__NewImportDecl((litaC_lex__SrcPos) {
            
        }, (litaC_lex__SrcPos) {
            
        }, litaC_module__BUILTIN_IMPORT_IDENT, (litaC_ast__Identifier) {
            .str = litaC_intern__EMPTY_STR,
            .token =  {
                .type = litaC_lex__TokenType_VOID
            }
        }, litaC_false, litaC_this->allocator);
        litaC_builtinImport->moduleId = &(litaC_module__builtins.id);
        litaC_std__array__Array_insertAt_cb__ptr_ImportDecl_ce_(&((litaC_module->ast->imports)), 0, litaC_builtinImport);
        
        
    }
    {
        litaC_checker__TypeChecker litaC_checker =  {
            
        };
        litaC_checker__TypeChecker_init(&((litaC_checker)), litaC_this);
        litaC_checker__TypeChecker_typeCheck(&((litaC_checker)), litaC_module, litaC_checker__TypeCheckerFlags_DISABLE_TRAIT_WRAPPERS);
        litaC_lita__Lita_syncSymbols(litaC_this, litaC_module, &(litaC_module->symbols.symbolFuncs), &(litaC_this->programSymbols.symbolFuncs), litaC_symbols__SymbolKind_FUNC);
        litaC_lita__Lita_syncSymbols(litaC_this, litaC_module, &(litaC_module->symbols.symbolTypes), &(litaC_this->programSymbols.symbolTypes), litaC_symbols__SymbolKind_TYPE);
        litaC_lita__Lita_syncSymbols(litaC_this, litaC_module, &(litaC_module->symbols.symbolNotes), &(litaC_this->programSymbols.symbolTypes), litaC_symbols__SymbolKind_TYPE);
        litaC_lita__Lita_syncSymbols(litaC_this, litaC_module, &(litaC_module->symbols.symbolTypes), &(litaC_this->programSymbols.values), litaC_symbols__SymbolKind_VAR);
        
        
    }
    litaC_module__Module_postIncrementalBuild(litaC_module);
    
}

litaC_void litaC_lita__Lita_syncSymbols(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module,litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_moduleSymbols,litaC_std__array__Array_cb__ptr_Symbol_ce_* litaC_symbols,litaC_symbols__SymbolKind litaC_kind) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(litaC_symbols);) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(litaC_symbols, litaC_i);
            if(!(litaC_sym->decl) || !(litaC_module__Module_equals(litaC_sym->declared, litaC_module))) {
                {
                    litaC_i += 1;
                    continue;
                    
                    
                }
                
            } 
            
            litaC_std__array__Array_removeAt_cb__ptr_Symbol_ce_(litaC_symbols, litaC_i);
            
            
        }
    }
    for(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_ litaC_it = litaC_std__map__Map_iter_cb_InternedString_c__ptr_Symbol_ce_(litaC_moduleSymbols);litaC_std__map__MapIterator_hasNext_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));) {
        {
            litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_ litaC_entry = litaC_std__map__MapIterator_next_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));
            litaC_symbols__Symbol* litaC_sym = litaC_entry.value;
            if(!(litaC_module__Module_equals(litaC_sym->declared, litaC_module)) || litaC_sym->kind != litaC_kind) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_std__array__Array_add_cb__ptr_Symbol_ce_(litaC_symbols, litaC_sym);
            
            
        }
    }
    
}

litaC_module__Module* litaC_lita__Lita_parse(litaC_lita__Lita* litaC_this) {
    litaC_lita__Lita_startCapture(litaC_this, litaC_lita__MetricType_PARSING);
    
    litaC_module__Module* litaC_builtin = litaC_module__BuiltinsInit(litaC_this);
    litaC_lita__Lita_addModule(litaC_this, litaC_builtin);
    if(!(litaC_lita__ParseModule(litaC_this, litaC_builtin, (litaC_lex__SrcPos) {
        
    }))) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->result)), (litaC_lex__SrcPos) {
                
            }, "unable to parse builtins.lita");
            {
                litaC_module__Module* ___result = NULL;
                litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_PARSING);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_char* litaC_srcPath = (litaC_this->options->testsOnly) ? litaC_this->options->testPath : litaC_this->options->srcPath;
    litaC_char litaC_absolutePath[_MAX_PATH] =  {
        0
    };
    litaC_std__system__GetAbsolutePath(litaC_std__system__CurrentWorkingPath(), litaC_srcPath, litaC_absolutePath);
    if(!(litaC_std__system__FileExists(litaC_absolutePath))) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->result)), (litaC_lex__SrcPos) {
                
            }, "unable to parse '%s' because it was not found", litaC_absolutePath);
            {
                litaC_module__Module* ___result = NULL;
                litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_PARSING);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_std__string_view__StringView litaC_packageName = litaC_lita__GetPackageName(litaC_absolutePath, litaC_this->options->inputFile);
    litaC_module__Module* litaC_root = litaC_module__NewModule(litaC_this, litaC_packageName, litaC_this->options->inputFile);
    litaC_lita__Lita_addModule(litaC_this, litaC_root);
    if(!(litaC_lita__ParseModule(litaC_this, litaC_root, (litaC_lex__SrcPos) {
        
    }))) {
        {
            {
                litaC_module__Module* ___result = NULL;
                litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_PARSING);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_ast__ImportDecl* litaC_builtinImport = (litaC_ast__ImportDecl*)litaC_ast_new__NewImportDecl((litaC_lex__SrcPos) {
        
    }, (litaC_lex__SrcPos) {
        
    }, litaC_module__BUILTIN_IMPORT_IDENT, (litaC_ast__Identifier) {
        .str = litaC_intern__EMPTY_STR,
        .token =  {
            .type = litaC_lex__TokenType_VOID
        }
    }, litaC_false, litaC_this->allocator);
    litaC_builtinImport->moduleId = &(litaC_builtin->id);
    litaC_std__array__Array_insertAt_cb__ptr_ImportDecl_ce_(&((litaC_root->ast->imports)), 0, litaC_builtinImport);
    {
        litaC_module__Module* ___result = litaC_root;
        litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_PARSING);
        return ___result;
        
    }
    
    litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_PARSING);
    
}

litaC_bool litaC_lita__Lita_typeCheck(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module,litaC_i32 litaC_flags) {
    litaC_lita__Lita_startCapture(litaC_this, litaC_lita__MetricType_TYPE_CHECKING);
    
    litaC_checker__TypeChecker litaC_checker =  {
        
    };
    litaC_checker__TypeChecker_init(&((litaC_checker)), litaC_this);
    litaC_this->programSymbols = litaC_checker__TypeChecker_typeCheck(&((litaC_checker)), litaC_module, litaC_flags);
    {
        litaC_bool ___result = litaC_std__array__Array_empty_cb_PhaseError_ce_(&((litaC_this->result.errors)));
        litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_TYPE_CHECKING);
        return ___result;
        
    }
    
    litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_TYPE_CHECKING);
    
}

litaC_bool litaC_lita__Lita_transpile(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module) {
    if(!(litaC_std__system__Mkdir(litaC_this->options->outputPath))) {
        {
            printf("Unable to create directory: '%s'", litaC_this->options->outputPath);
            return litaC_false;
            
            
            
        }
        
    } 
    
    memset(litaC_this->binaryFilename, 0, _MAX_PATH);
    memset(litaC_this->sourceFilename, 0, _MAX_PATH);
    strcat(litaC_this->sourceFilename, litaC_this->options->outputPath);
    strcat(litaC_this->sourceFilename, litaC_this->options->outputFile);
    strcpy(litaC_this->binaryFilename, litaC_this->sourceFilename);
    {
        strcat(litaC_this->binaryFilename, ".exe");
        
        
    }
    strcat(litaC_this->sourceFilename, ".c");
    if(litaC_this->options->cOutputOnly) {
        {
            if(!(litaC_lita__Lita_emitC(litaC_this, litaC_module, litaC_this->sourceFilename))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_tcc__libtcc__IsLibtccAvailable())) {
        {
            litaC_this->options->isTcc = litaC_false;
            if(!(litaC_this->options->compileCmd)) {
                {
                    litaC_this->options->compileCmd = litaC_lita__DEFAULT_BUILD_CMD;
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(!(litaC_this->options->compileCmd) || litaC_this->options->isTcc) {
        {
            if(!(litaC_lita__Lita_compileWithLibtcc(litaC_this, litaC_module, litaC_this->binaryFilename))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } else {
        {
            if(!(litaC_lita__Lita_emitC(litaC_this, litaC_module, litaC_this->sourceFilename))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            if(!(litaC_lita__Lita_compileC(litaC_this, litaC_module, litaC_this->sourceFilename, litaC_this->binaryFilename))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    } 
    
    return litaC_true;
    
    
}

litaC_void litaC_lita__LibtccErrorFunc(litaC_void* litaC_data,const litaC_char* litaC_msg) {
    litaC_common__Error("%s\n", litaC_msg);
    
}

litaC_bool litaC_lita__Lita_compileWithLibtcc(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module,const litaC_char* litaC_binaryFilename) {
    
    #if LIBTCC_AVAILABLE
    litaC_lita__Lita_startCapture(litaC_this, litaC_lita__MetricType_CGEN);
    litaC_cgen__CGen litaC_cgen =  {
        
    };
    litaC_cgen__CGen_init(&((litaC_cgen)), litaC_this, NULL);
    litaC_cgen__CGen_emitProgram(&((litaC_cgen)), litaC_module);
    litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_CGEN);
    litaC_char* litaC_sourceCode = litaC_std__string_buffer__StringBuffer_cStr(&((litaC_cgen.buf)));
    litaC_lita__Lita_startCapture(litaC_this, litaC_lita__MetricType_CCOMPILE);
    
    TCCState* litaC_state = tcc_new();
    
    tcc_set_error_func(litaC_state, litaC_this, litaC_lita__LibtccErrorFunc);
    tcc_set_output_type(litaC_state, TCC_OUTPUT_EXE);
    tcc_output_file(litaC_state, litaC_binaryFilename);
    litaC_char litaC_temp[256] = {0};
    litaC_std__string__String litaC_buf = litaC_std__string__StringInit(litaC_temp, 256, 0);
    litaC_std__string__String_format(&((litaC_buf)), "%s/lib", litaC_this->options->projectPath);
    if(litaC_std__system__FileExists(litaC_std__string__String_cStr(litaC_buf))) {
        {
            tcc_add_library_path(litaC_state, litaC_std__string__String_cStr(litaC_buf));
            
            
        }
        
    } 
    
    litaC_std__string__String_format(&((litaC_buf)), "%s/include", litaC_this->options->projectPath);
    if(litaC_std__system__FileExists(litaC_std__string__String_cStr(litaC_buf))) {
        {
            tcc_add_include_path(litaC_state, litaC_std__string__String_cStr(litaC_buf));
            
            
        }
        
    } 
    
    if(!(litaC_std__array__Array_empty_cb_CCompilerOption_ce_(&((litaC_this->compilerOptions))))) {
        {
            Lita_OSType litaC_os = litaC_std__system__GetOS();
            litaC_std__string_buffer__StringBuffer litaC_ccOptions = litaC_std__string_buffer__StringBufferInit(256, NULL);
            
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_CCompilerOption_ce_(&((litaC_this->compilerOptions)));litaC_i += 1) {
                {
                    litaC_lita__CCompilerOption* litaC_option = litaC_std__array__Array_getPtr_cb_CCompilerOption_ce_(&((litaC_this->compilerOptions)), litaC_i);
                    if(litaC_option->os != Lita_OSType_OTHER && litaC_option->os != litaC_os) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_ccOptions)), " ", 1);
                    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_ccOptions)), litaC_option->options.buffer, litaC_option->options.length);
                    
                    
                }
            }
            if(!(litaC_std__string_buffer__StringBuffer_empty(&((litaC_ccOptions))))) {
                {
                    tcc_set_options(litaC_state, litaC_std__string_buffer__StringBuffer_cStr(&((litaC_ccOptions))));
                    if(litaC_this->options->isVerbose) {
                        {
                            printf("Options: '%s'\n", litaC_std__string_buffer__StringBuffer_cStr(&((litaC_ccOptions))));
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            litaC_std__string_buffer__StringBuffer_free(&((litaC_ccOptions)));
            
            
        }
        
    } 
    
    if(tcc_compile_string(litaC_state, litaC_sourceCode) < 0) {
        {
            {
                litaC_bool ___result = litaC_false;
                if(litaC_state) {
                    tcc_delete(litaC_state);
                    
                } 
                ;
                litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_CCOMPILE);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    {
        litaC_bool ___result = litaC_true;
        if(litaC_state) {
            tcc_delete(litaC_state);
            
        } 
        ;
        litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_CCOMPILE);
        return ___result;
        
    }
    
    if(litaC_state) {
        tcc_delete(litaC_state);
        
    } 
    ;
    litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_CCOMPILE);
    
    #else
    litaC_common__Panic("tcc is not supported on non x86/64 CPU architectures");
    return litaC_true;
    
    
    #endif
    
    
}

litaC_bool litaC_lita__Lita_emitC(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module,const litaC_char* litaC_cFilename) {
    litaC_lita__Lita_startCapture(litaC_this, litaC_lita__MetricType_CGEN);
    litaC_std__io__File litaC_file = {0};
    {
        
        
    }
    if(litaC_std__io__File_open(&((litaC_file)), litaC_cFilename, litaC_std__io__FileOpenOp_WRITE_BINARY) != litaC_std__io__FileStatus_Ok) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    
    litaC_cgen__CGen litaC_cgen =  {
        
    };
    litaC_cgen__CGen_init(&((litaC_cgen)), litaC_this, &((litaC_file)));
    litaC_cgen__CGen_emitProgram(&((litaC_cgen)), litaC_module);
    litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_CGEN);
    {
        litaC_bool ___result = litaC_std__array__Array_empty_cb_PhaseError_ce_(&((litaC_this->result.errors)));
        litaC_std__io__File_close(&((litaC_file)));
        return ___result;
        
    }
    
    litaC_std__io__File_close(&((litaC_file)));
    
}

litaC_bool litaC_lita__Lita_compileC(litaC_lita__Lita* litaC_this,litaC_module__Module* litaC_module,const litaC_char* litaC_sourceFilename,const litaC_char* litaC_binaryFilename) {
    litaC_lita__Lita_startCapture(litaC_this, litaC_lita__MetricType_CCOMPILE);
    
    litaC_std__string_buffer__StringBuffer litaC_commandStr = litaC_std__string_buffer__StringBufferInit(1024, NULL);
    
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_commandStr)), litaC_this->options->compileCmd);
    litaC_i32 litaC_index = litaC_std__string_buffer__StringBuffer_indexOf(&((litaC_commandStr)), "%output%", -(1));
    if(litaC_index > -(1)) {
        {
            litaC_std__string_buffer__StringBuffer_replace(&((litaC_commandStr)), litaC_index, litaC_index + strlen("%output%"), litaC_binaryFilename);
            
            
        }
        
    } 
    
    litaC_index = litaC_std__string_buffer__StringBuffer_indexOf(&((litaC_commandStr)), "%input%", -(1));
    if(litaC_index > -(1)) {
        {
            litaC_std__string_buffer__StringBuffer_replace(&((litaC_commandStr)), litaC_index, litaC_index + strlen("%input%"), litaC_sourceFilename);
            
            
        }
        
    } 
    
    litaC_lita__Lita_applyCompilerOptions(litaC_this, &((litaC_commandStr)));
    if(litaC_this->options->isVerbose) {
        {
            printf("Running command: '%s'\n", litaC_std__string_buffer__StringBuffer_cStr(&((litaC_commandStr))));
            
            
        }
        
    } 
    
    if(system(litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_commandStr)))) == 0) {
        {
            {
                litaC_bool ___result = litaC_true;
                litaC_std__string_buffer__StringBuffer_free(&((litaC_commandStr)));
                litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_CCOMPILE);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    {
        litaC_bool ___result = litaC_false;
        litaC_std__string_buffer__StringBuffer_free(&((litaC_commandStr)));
        litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_CCOMPILE);
        return ___result;
        
    }
    
    litaC_std__string_buffer__StringBuffer_free(&((litaC_commandStr)));
    litaC_lita__Lita_endCapture(litaC_this, litaC_lita__MetricType_CCOMPILE);
    
}

litaC_void litaC_lita__Lita_applyCompilerOptions(litaC_lita__Lita* litaC_this,litaC_std__string_buffer__StringBuffer* litaC_commandStr) {
    litaC_std__string_buffer__StringBuffer* litaC_buffer = litaC_commandStr;
    litaC_std__string_buffer__StringBuffer litaC_replaceBuffer = {0};
    if(litaC_this->options->isStrict) {
        {
            litaC_std__string_buffer__StringBuffer_init(&((litaC_replaceBuffer)), 256, NULL);
            litaC_buffer = &(litaC_replaceBuffer);
            
            
        }
        
    } 
    
    {
        litaC_char litaC_temp[256] = {0};
        litaC_std__string__String litaC_path = litaC_std__string__StringInit(litaC_temp, 256, 0);
        litaC_std__string__String_format(&((litaC_path)), "%s/lib", litaC_this->options->projectPath);
        if(litaC_std__system__FileExists(litaC_std__string__String_cStr(litaC_path))) {
            {
                litaC_std__string_buffer__StringBuffer_append(litaC_buffer, " -L%s", litaC_std__string__String_cStr(litaC_path));
                
                
            }
            
        } 
        
        litaC_std__string__String_format(&((litaC_path)), "%s/include", litaC_this->options->projectPath);
        if(litaC_std__system__FileExists(litaC_std__string__String_cStr(litaC_path))) {
            {
                litaC_std__string_buffer__StringBuffer_append(litaC_buffer, " -I%s", litaC_std__string__String_cStr(litaC_path));
                
                
            }
            
        } 
        
        
        
    }
    Lita_OSType litaC_os = litaC_std__system__GetOS();
    Lita_ArchType litaC_arch = litaC_std__system__GetArch();
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_CCompilerOption_ce_(&((litaC_this->compilerOptions)));litaC_i += 1) {
        {
            litaC_lita__CCompilerOption* litaC_option = litaC_std__array__Array_getPtr_cb_CCompilerOption_ce_(&((litaC_this->compilerOptions)), litaC_i);
            if(litaC_option->os != Lita_OSType_OTHER && litaC_option->os != litaC_os) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_option->arch != Lita_ArchType_UNKNOWN && litaC_option->arch != litaC_arch) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_std__string_buffer__StringBuffer_appendStrn(litaC_buffer, " ", 1);
            litaC_std__string_buffer__StringBuffer_appendStrn(litaC_buffer, litaC_option->options.buffer, litaC_option->options.length);
            
            
        }
    }
    if(litaC_this->options->isStrict) {
        {
            litaC_i32 litaC_index = litaC_std__string_buffer__StringBuffer_indexOf(litaC_commandStr, "%options%", -(1));
            if(litaC_index >= 0) {
                {
                    litaC_std__string_buffer__StringBuffer_replace(litaC_commandStr, litaC_index, litaC_index + strlen("%options%"), litaC_std__string_buffer__StringBuffer_cStr(litaC_buffer));
                    
                    
                }
                
            } 
            
            litaC_std__string_buffer__StringBuffer_free(litaC_buffer);
            
            
        }
        
    } 
    
    
}

litaC_i32 litaC_lita__Lita_run(litaC_lita__Lita* litaC_this) {
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->allocator);
    
    litaC_char litaC_path[_MAX_PATH] = {0};
    litaC_std__system__FilePath(litaC_this->binaryFilename, litaC_path);
    litaC_i32 litaC_len = strlen(litaC_path);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "cd ", 3);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), litaC_path, litaC_len);
    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), " && .%s", litaC_std__system__PATH_SEPARATOR);
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), &(litaC_this->binaryFilename[litaC_len + 1]));
    {
        litaC_i32 ___result = system(litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb))));
        litaC_std__string_buffer__StringBuffer_free(&((litaC_sb)));
        return ___result;
        
    }
    
    litaC_std__string_buffer__StringBuffer_free(&((litaC_sb)));
    
}

litaC_bool litaC_lita__FindModulePath(litaC_lita__Lita* litaC_lita,litaC_std__string_view__StringView litaC_moduleName,litaC_char* litaC_filename) {
    litaC_char litaC_path[_MAX_PATH] =  {
        0
    };
    litaC_std__string__String litaC_pathStr = litaC_std__string__StringInit(litaC_path, _MAX_PATH, 0);
    
    {
        litaC_std__string__String_format(&((litaC_pathStr)), "%s/%.*s.lita", litaC_lita->options->srcPath, litaC_moduleName.length, litaC_moduleName.buffer);
        if(litaC_std__system__FileExists(litaC_std__string__String_cStrConst(litaC_pathStr))) {
            {
                {
                    litaC_bool ___result = litaC_true;
                    {
                        litaC_std__system__GetAbsolutePath(litaC_std__system__CurrentWorkingPath(), litaC_std__string__String_cStr(litaC_pathStr), litaC_filename);
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
        } 
        
        litaC_std__string__String_format(&((litaC_pathStr)), "%s/%.*s.lita", litaC_lita->options->libPath, litaC_moduleName.length, litaC_moduleName.buffer);
        if(litaC_std__system__FileExists(litaC_std__string__String_cStrConst(litaC_pathStr))) {
            {
                {
                    litaC_bool ___result = litaC_true;
                    {
                        litaC_std__system__GetAbsolutePath(litaC_std__system__CurrentWorkingPath(), litaC_std__string__String_cStr(litaC_pathStr), litaC_filename);
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
        } 
        
        litaC_std__string__String_format(&((litaC_pathStr)), "%s/stdlib/%.*s.lita", litaC_lita->options->litaPath, litaC_moduleName.length, litaC_moduleName.buffer);
        if(litaC_std__system__FileExists(litaC_std__string__String_cStrConst(litaC_pathStr))) {
            {
                {
                    litaC_bool ___result = litaC_true;
                    {
                        litaC_std__system__GetAbsolutePath(litaC_std__system__CurrentWorkingPath(), litaC_std__string__String_cStr(litaC_pathStr), litaC_filename);
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
        } 
        
        
        
    }
    {
        litaC_i32 litaC_index = litaC_std__string_view__StringView_lastIndexOfAt(litaC_moduleName, "/", 1, -(1));
        litaC_std__string_view__StringView litaC_name = (litaC_index < 0) ? litaC_moduleName : litaC_std__string_view__StringView_substring(litaC_moduleName, litaC_index + 1, -(1));
        litaC_std__string__String_format(&((litaC_pathStr)), "%s/%.*s/%.*s.lita", litaC_lita->options->srcPath, litaC_moduleName.length, litaC_moduleName.buffer, litaC_name.length, litaC_name.buffer);
        if(litaC_std__system__FileExists(litaC_std__string__String_cStrConst(litaC_pathStr))) {
            {
                {
                    litaC_bool ___result = litaC_true;
                    {
                        litaC_std__system__GetAbsolutePath(litaC_std__system__CurrentWorkingPath(), litaC_std__string__String_cStr(litaC_pathStr), litaC_filename);
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
        } 
        
        litaC_std__string__String_format(&((litaC_pathStr)), "%s/%.*s/%.*s.lita", litaC_lita->options->libPath, litaC_moduleName.length, litaC_moduleName.buffer, litaC_name.length, litaC_name.buffer);
        if(litaC_std__system__FileExists(litaC_std__string__String_cStrConst(litaC_pathStr))) {
            {
                {
                    litaC_bool ___result = litaC_true;
                    {
                        litaC_std__system__GetAbsolutePath(litaC_std__system__CurrentWorkingPath(), litaC_std__string__String_cStr(litaC_pathStr), litaC_filename);
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
        } 
        
        litaC_std__string__String_format(&((litaC_pathStr)), "%s/stdlib/%.*s/%.*s.lita", litaC_lita->options->litaPath, litaC_moduleName.length, litaC_moduleName.buffer, litaC_name.length, litaC_name.buffer);
        if(litaC_std__system__FileExists(litaC_std__string__String_cStrConst(litaC_pathStr))) {
            {
                {
                    litaC_bool ___result = litaC_true;
                    {
                        litaC_std__system__GetAbsolutePath(litaC_std__system__CurrentWorkingPath(), litaC_std__string__String_cStr(litaC_pathStr), litaC_filename);
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
        } 
        
        
        
    }
    {
        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_const_char_ce_(&((litaC_lita->buildFile.pkgPaths)));litaC_i += 1) {
            {
                const litaC_char* litaC_pkgPath = litaC_std__array__Array_get_cb__ptr_const_char_ce_(&((litaC_lita->buildFile.pkgPaths)), litaC_i);
                litaC_std__string__String_format(&((litaC_pathStr)), "%s/%s/%.*s.lita", litaC_lita->options->projectPath, litaC_pkgPath, litaC_moduleName.length, litaC_moduleName.buffer);
                if(litaC_std__system__FileExists(litaC_std__string__String_cStrConst(litaC_pathStr))) {
                    {
                        {
                            litaC_bool ___result = litaC_true;
                            {
                                litaC_std__system__GetAbsolutePath(litaC_std__system__CurrentWorkingPath(), litaC_std__string__String_cStr(litaC_pathStr), litaC_filename);
                                
                                
                            };
                            return ___result;
                            
                        }
                        
                        
                        
                    }
                    
                } 
                
                litaC_i32 litaC_index = litaC_std__string_view__StringView_lastIndexOfAt(litaC_moduleName, "/", 1, -(1));
                litaC_std__string_view__StringView litaC_name = (litaC_index < 0) ? litaC_moduleName : litaC_std__string_view__StringView_substring(litaC_moduleName, litaC_index + 1, -(1));
                litaC_std__string__String_format(&((litaC_pathStr)), "%s/%s/%.*s/%.*s.lita", litaC_lita->options->projectPath, litaC_pkgPath, litaC_moduleName.length, litaC_moduleName.buffer, litaC_name.length, litaC_name.buffer);
                if(litaC_std__system__FileExists(litaC_std__string__String_cStrConst(litaC_pathStr))) {
                    {
                        {
                            litaC_bool ___result = litaC_true;
                            {
                                litaC_std__system__GetAbsolutePath(litaC_std__system__CurrentWorkingPath(), litaC_std__string__String_cStr(litaC_pathStr), litaC_filename);
                                
                                
                            };
                            return ___result;
                            
                        }
                        
                        
                        
                    }
                    
                } 
                
                
                
            }
        }
        
        
    }
    {
        if(litaC_lita->options->testsOnly) {
            {
                litaC_std__string__String_format(&((litaC_pathStr)), "%s/%.*s.lita", litaC_lita->options->testPath, litaC_moduleName.length, litaC_moduleName.buffer);
                if(litaC_std__system__FileExists(litaC_std__string__String_cStrConst(litaC_pathStr))) {
                    {
                        {
                            litaC_bool ___result = litaC_true;
                            {
                                litaC_std__system__GetAbsolutePath(litaC_std__system__CurrentWorkingPath(), litaC_std__string__String_cStr(litaC_pathStr), litaC_filename);
                                
                                
                            };
                            return ___result;
                            
                        }
                        
                        
                        
                    }
                    
                } 
                
                
                
            }
            
        } 
        
        
        
    }
    litaC_std__string__String_clear(&((litaC_pathStr)));
    {
        litaC_bool ___result = litaC_false;
        {
            litaC_std__system__GetAbsolutePath(litaC_std__system__CurrentWorkingPath(), litaC_std__string__String_cStr(litaC_pathStr), litaC_filename);
            
            
        };
        return ___result;
        
    }
    
    {
        litaC_std__system__GetAbsolutePath(litaC_std__system__CurrentWorkingPath(), litaC_std__string__String_cStr(litaC_pathStr), litaC_filename);
        
        
    };
    
}

litaC_bool litaC_lita__ParseModule(litaC_lita__Lita* litaC_lita,litaC_module__Module* litaC_module,litaC_lex__SrcPos litaC_pos) {
    if(!(litaC_module)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_lita->workspace) {
        {
            litaC_char litaC_output[_MAX_PATH] = {0};
            litaC_char* litaC_uri = litaC_std__system__FilePathToUri(litaC_module->id.filename, litaC_output);
            litaC_uri = litaC_std__system__PathNormalize(litaC_uri, litaC_uri);
            litaC_lsp__document__Document* litaC_doc = litaC_std__map__Map_get_cb__ptr_const_char_c__ptr_Document_ce_(&((litaC_lita->workspace->openedDocuments)), litaC_uri);
            if(litaC_doc) {
                {
                    litaC_module->text.buffer = litaC_std__string_buffer__StringBuffer_cStr(&((litaC_doc->text)));
                    litaC_module->text.length = litaC_doc->text.length;
                    litaC_module->text.capacity = litaC_doc->text.length;
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(!(litaC_module->text.length)) {
        {
            litaC_usize litaC_length = {0};
            litaC_std__io__FileStatus litaC_status = litaC_std__io__ReadFile(litaC_module->id.filename, &(litaC_module->text.buffer), &(litaC_length), litaC_lita->allocator);
            if(litaC_status == litaC_std__io__FileStatus_FileNotFoundError) {
                {
                    const char* litaC_additionalMsg = "";
                    if(strcmp(litaC_module->id.filename, "/stdlib/std/builtins.lita") == 0) {
                        {
                            litaC_additionalMsg = "\nNOTE: Make sure the LITAC_HOME environment variable is set to the litac home directory";
                            
                            
                        }
                        
                    } 
                    
                    litaC_phase_result__PhaseResult_addError(&((litaC_lita->result)), litaC_pos, "Could not open file '%s'%s\n", litaC_module->id.filename, litaC_additionalMsg);
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            if(litaC_status == litaC_std__io__FileStatus_IOError) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_lita->result)), litaC_pos, "Could not read file '%s'\n", litaC_module->id.filename);
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_module->text.length = (litaC_i32)litaC_length;
            litaC_module->text.capacity = (litaC_i32)litaC_length;
            
            
        }
        
    } 
    
    litaC_parser__Parser litaC_parser = litaC_parser__ParserInit(litaC_module->id.filename, litaC_module->text.buffer, litaC_module->text.length, litaC_module, litaC_lita);
    litaC_ast__ModuleStmt* litaC_moduleStmt = litaC_parser__Parser_parseModule(&((litaC_parser)));
    litaC_module->ast = litaC_moduleStmt;
    litaC_lita->totalSourceLines += litaC_parser.totalLines;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_ImportDecl_ce_(&((litaC_module->ast->imports)));litaC_i += 1) {
        {
            litaC_ast__ImportDecl* litaC_importStmt = litaC_std__array__Array_get_cb__ptr_ImportDecl_ce_(&((litaC_module->ast->imports)), litaC_i);
            if(litaC_importStmt->decl.name.token.type == litaC_lex__TokenType_ERROR) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_lita->result)), litaC_importStmt->decl.stmt.node.startPos, "Could not parse import statement");
                    continue;
                    
                    
                }
                
            } 
            
            litaC_char litaC_filename[_MAX_PATH] = {0};
            if(!(litaC_lita__FindModulePath(litaC_lita, litaC_importStmt->decl.name.str.view, litaC_filename))) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_lita->result)), litaC_importStmt->decl.stmt.node.startPos, "Could not find module '%.*s'", litaC_importStmt->decl.name.str.length, litaC_importStmt->decl.name.str.buffer);
                    continue;
                    
                    
                }
                
            } 
            
            litaC_module__Module* litaC_importModule = litaC_lita__Lita_getModule(litaC_lita, litaC_filename);
            if(litaC_importModule) {
                {
                    litaC_importStmt->moduleId = &(litaC_importModule->id);
                    continue;
                    
                    
                }
                
            } 
            
            litaC_importModule = litaC_module__NewModule(litaC_lita, litaC_importStmt->decl.name.str.view, litaC_filename);
            litaC_importStmt->moduleId = &(litaC_importModule->id);
            litaC_lita__Lita_addModule(litaC_lita, litaC_importModule);
            litaC_lita__ParseModule(litaC_lita, litaC_importModule, litaC_importStmt->decl.stmt.node.startPos);
            
            
        }
    }
    return litaC_true;
    
    
}

litaC_std__string_view__StringView litaC_lita__GetPackageName(const litaC_char* litaC_srcPath,const litaC_char* litaC_inputFile) {
    if(!(litaC_inputFile)) {
        {
            return (litaC_std__string_view__StringView) {
                
            };
            
            
            
        }
        
    } 
    
    if(litaC_srcPath) {
        {
            litaC_std__string_view__StringView litaC_inputFileView = litaC_std__string_view__StringViewInit(litaC_inputFile, -(1));
            litaC_i32 litaC_index = litaC_std__string_view__StringView_indexOf(litaC_inputFileView, litaC_srcPath, -(1));
            if(litaC_index > -(1)) {
                {
                    litaC_inputFile = &(litaC_inputFile[litaC_index + strlen(litaC_srcPath)]);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    while(*(litaC_inputFile)) {
        {
            litaC_char litaC_c = *(litaC_inputFile);
            if(litaC_c != '.' && litaC_c != '/' && litaC_c != '\\') {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_inputFile += 1;
            
            
        }
    }
    litaC_i32 litaC_inputLen = strlen(litaC_inputFile);
    litaC_i32 litaC_endCount = 0;
    for(litaC_i32 litaC_i = litaC_inputLen;litaC_i >= 0;litaC_i -= 1) {
        {
            litaC_char litaC_c = litaC_inputFile[litaC_i];
            if(litaC_c == '.') {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_endCount += 1;
            
            
        }
    }
    return (litaC_std__string_view__StringView) {
        .length = litaC_inputLen - litaC_endCount,
        .buffer = litaC_inputFile
    };
    
    
}

litaC_void litaC_std__mem__bucket_allocator__BucketAllocator_init(litaC_std__mem__bucket_allocator__BucketAllocator* litaC_this,const litaC_std__mem__Allocator* litaC_decorated,litaC_usize litaC_bucketSize) {
    litaC_this->allocator = (litaC_std__mem__Allocator) {
        .allocFn = &(litaC_std__mem__GenericMalloc_cb_BucketAllocator_ce_),
        .callocFn = &(litaC_std__mem__GenericCalloc_cb_BucketAllocator_ce_),
        .reallocFn = &(litaC_std__mem__GenericRealloc_cb_BucketAllocator_ce_),
        .freeFn = &(litaC_std__mem__bucket_allocator__BucketFree)
    };
    litaC_this->decorated = litaC_decorated;
    litaC_bucketSize = MAX(litaC_bucketSize, LITAC_DEFAULT_ALIGNMENT);
    litaC_usize litaC_requestSize = sizeof(litaC_std__mem__bucket_allocator__Bucket) + litaC_bucketSize;
    litaC_u8* litaC_memory = (litaC_u8*)litaC_std__mem__Allocator_alloc(litaC_decorated, litaC_requestSize);
    assert(litaC_memory);
    litaC_this->buckets = (litaC_std__mem__bucket_allocator__Bucket*)litaC_memory;
    litaC_this->buckets->mem = litaC_memory + sizeof(litaC_std__mem__bucket_allocator__Bucket);
    litaC_this->buckets->size = litaC_bucketSize;
    litaC_this->buckets->prev = NULL;
    litaC_this->head = litaC_this->buckets;
    litaC_this->bucketSize = litaC_bucketSize;
    litaC_this->totalGrossBytesAllocated = 0;
    litaC_this->totalBytesAllocated = 0;
    litaC_this->totalAllocations = 0;
    litaC_this->currentOffset = 0;
    litaC_this->totalBuckets = 1;
    litaC_this->totalGrossBytesAllocated += litaC_requestSize;
    
}

litaC_void litaC_std__mem__bucket_allocator__BucketAllocator_clear(litaC_std__mem__bucket_allocator__BucketAllocator* litaC_this) {
    assert(litaC_this->buckets != NULL);
    litaC_std__mem__bucket_allocator__Bucket* litaC_n = litaC_this->head;
    while(litaC_n && litaC_n != litaC_this->buckets) {
        {
            litaC_std__mem__bucket_allocator__Bucket* litaC_prev = litaC_n->prev;
            litaC_std__mem__Allocator_free(litaC_this->decorated, (litaC_void*)litaC_n);
            litaC_n = litaC_prev;
            
            
        }
    }
    litaC_this->head = litaC_this->buckets;
    litaC_this->totalBytesAllocated = 0;
    litaC_this->totalAllocations = 0;
    litaC_this->currentOffset = 0;
    litaC_this->totalBuckets = 1;
    
}


litaC_void litaC_std__mem__bucket_allocator__BucketAllocator_free(litaC_std__mem__bucket_allocator__BucketAllocator* litaC_this) {
    litaC_std__mem__bucket_allocator__Bucket* litaC_n = litaC_this->head;
    while(litaC_n) {
        {
            litaC_std__mem__bucket_allocator__Bucket* litaC_prev = litaC_n->prev;
            litaC_std__mem__Allocator_free(litaC_this->decorated, (litaC_void*)litaC_n);
            litaC_n = litaC_prev;
            
            
        }
    }
    litaC_this->head = NULL;
    litaC_this->buckets = NULL;
    litaC_this->totalBytesAllocated = 0;
    litaC_this->totalAllocations = 0;
    litaC_this->currentOffset = 0;
    litaC_this->totalBuckets = 0;
    litaC_this->totalGrossBytesAllocated = 0;
    
}

litaC_void* litaC_std__mem__bucket_allocator__BucketAllocator_malloc(litaC_std__mem__bucket_allocator__BucketAllocator* litaC_this,litaC_usize litaC_size) {
    litaC_usize litaC_currPtr = (litaC_usize)litaC_this->head->mem + litaC_this->currentOffset;
    litaC_usize litaC_offset = litaC_std__mem__alignForward(litaC_currPtr, LITAC_DEFAULT_ALIGNMENT);
    litaC_offset -= (litaC_usize)litaC_this->head->mem;
    litaC_usize litaC_newOffset = litaC_offset + litaC_size;
    litaC_usize litaC_allocationSize = litaC_newOffset - litaC_this->currentOffset;
    if(litaC_newOffset > litaC_this->head->size) {
        {
            litaC_usize litaC_bucketSize = MAX(litaC_size, litaC_this->bucketSize);
            litaC_usize litaC_requestSize = sizeof(litaC_std__mem__bucket_allocator__Bucket) + litaC_bucketSize;
            litaC_u8* litaC_memory = (litaC_u8*)litaC_std__mem__Allocator_alloc(litaC_this->decorated, litaC_requestSize);
            assert(litaC_memory);
            if(!(litaC_memory)) {
                {
                    return NULL;
                    
                    
                    
                }
                
            } 
            
            litaC_std__mem__bucket_allocator__Bucket* litaC_bucket = (litaC_std__mem__bucket_allocator__Bucket*)litaC_memory;
            litaC_bucket->prev = litaC_this->head;
            litaC_bucket->mem = litaC_memory + sizeof(litaC_std__mem__bucket_allocator__Bucket);
            litaC_bucket->size = litaC_bucketSize;
            litaC_this->head = litaC_bucket;
            litaC_this->currentOffset = 0;
            litaC_this->totalBuckets += 1;
            litaC_currPtr = (litaC_usize)litaC_this->head->mem;
            litaC_offset = litaC_std__mem__alignForward(litaC_currPtr, LITAC_DEFAULT_ALIGNMENT);
            litaC_allocationSize = litaC_size + (litaC_offset - litaC_currPtr);
            litaC_offset -= (litaC_usize)litaC_this->head->mem;
            litaC_newOffset = litaC_offset + litaC_size;
            litaC_this->totalGrossBytesAllocated += litaC_requestSize;
            
            
        }
        
    } 
    
    litaC_this->currentOffset = litaC_newOffset;
    litaC_this->totalBytesAllocated += litaC_allocationSize;
    litaC_this->totalAllocations += 1;
    litaC_u8* litaC_ptr = litaC_this->head->mem + litaC_offset;
    return litaC_ptr;
    
    
}

litaC_void litaC_std__mem__bucket_allocator__BucketFree(const litaC_std__mem__Allocator* litaC_alloc,litaC_void* litaC_ptr) {
    
}

litaC_preprocessor__Preprocessor litaC_preprocessor__PreprocessorInit(litaC_lita__Lita* litaC_lita) {
    litaC_preprocessor__Preprocessor litaC_pp =  {
        
    };
    litaC_preprocessor__Preprocessor_init(&((litaC_pp)), litaC_lita);
    return litaC_pp;
    
    
}

litaC_void litaC_preprocessor__Preprocessor_init(litaC_preprocessor__Preprocessor* litaC_this,litaC_lita__Lita* litaC_lita) {
    litaC_this->lita = litaC_lita;
    litaC_std__array__Array_init_cb_CheckerContext_ce_(&((litaC_this->preCheckers)), 8, litaC_lita->allocator);
    litaC_std__array__Array_init_cb_CheckerContext_ce_(&((litaC_this->postCheckers)), 8, litaC_lita->allocator);
    litaC_this->callContext.pp = litaC_this;
    litaC_this->callContext.checker = NULL;
    litaC_this->callContext.comp = NULL;
    litaC_this->callContext.resolveSymbols = litaC_false;
    litaC_std__string_buffer__StringBuffer_init(&((litaC_this->callContext.buffer)), 1024, litaC_lita->allocator);
    litaC_std__array__Array_init_cb_ScriptDecl_ce_(&((litaC_this->declQueue)), 256, litaC_lita->allocator);
    litaC_preprocessor__api__Preprocessor_registerApi(litaC_this);
    
}

litaC_void litaC_preprocessor__Preprocessor_free(litaC_preprocessor__Preprocessor* litaC_this) {
    litaC_preprocessor__api__Preprocessor_deregisterApi(litaC_this);
    
}


litaC_bool litaC_preprocessor__Preprocessor_eval(litaC_preprocessor__Preprocessor* litaC_this,litaC_ast__CompStmt* litaC_comp) {
    litaC_std__string_view__StringView litaC_code = litaC_std__string_view__StringViewInit(litaC_comp->expr.buffer, litaC_comp->expr.length);
    if(litaC_comp->isScriptLoad && litaC_comp->expr.length > 2) {
        {
            litaC_std__string_view__StringView litaC_filename =  {
                litaC_comp->expr.buffer,
                litaC_comp->expr.length
            };
            if(!(litaC_preprocessor__api__Preprocessor_loadScript(litaC_this, litaC_comp, &((litaC_filename)), &(litaC_code)))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(!(litaC_preprocessor__api__Preprocessor_execute(litaC_this, litaC_comp, litaC_code))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_preprocessor__Preprocessor_drainQueue(litaC_this);
    return litaC_true;
    
    
}


litaC_void litaC_preprocessor__Preprocessor_evaluateForModule(litaC_preprocessor__Preprocessor* litaC_this,litaC_module__Module* litaC_module,litaC_ast__ModuleStmt* litaC_moduleStmt,litaC_ast__CompStmt* litaC_comp) {
    assert(litaC_comp != NULL);
    litaC_this->callContext.comp = litaC_comp;
    if(litaC_intern__InternedString_equals(&((litaC_comp->type)), &((litaC_intern__PRECHECK)))) {
        {
            litaC_std__array__Array_add_cb_CheckerContext_ce_(&((litaC_this->preCheckers)), (litaC_preprocessor__CheckerContext) {
                litaC_module,
                litaC_comp
            });
            
            
        }
        
    } else {
        if(litaC_intern__InternedString_equals(&((litaC_comp->type)), &((litaC_intern__POSTCHECK)))) {
            {
                litaC_std__array__Array_add_cb_CheckerContext_ce_(&((litaC_this->postCheckers)), (litaC_preprocessor__CheckerContext) {
                    litaC_module,
                    litaC_comp
                });
                
                
            }
            
        } else {
            if(litaC_intern__InternedString_equals(&((litaC_comp->type)), &((litaC_intern__POSTPARSE)))) {
                {
                    litaC_preprocessor__api__CallContext_postParse(&((litaC_this->callContext)), litaC_module, litaC_moduleStmt, litaC_comp);
                    
                    
                }
                
            } else {
                if(litaC_intern__InternedString_equals(&((litaC_comp->type)), &((litaC_intern__ELSE_ERROR)))) {
                    {
                        litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_comp->stmt.node.startPos, "%.*s", litaC_comp->expr.length, litaC_comp->expr.buffer);
                        
                        
                    }
                    
                } else {
                    if(litaC_intern__InternedString_equals(&((litaC_comp->type)), &((litaC_intern__IF))) || litaC_intern__InternedString_equals(&((litaC_comp->type)), &((litaC_intern__ELSEIF))) || litaC_intern__InternedString_equals(&((litaC_comp->type)), &((litaC_intern__ELSE)))) {
                        {
                            if(litaC_intern__InternedString_equals(&((litaC_comp->type)), &((litaC_intern__ELSE))) || litaC_preprocessor__Preprocessor_eval(litaC_this, litaC_comp)) {
                                {
                                    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Stmt_ce_(&((litaC_comp->body)));litaC_i += 1) {
                                        {
                                            litaC_ast__Stmt* litaC_stmt = litaC_std__array__Array_get_cb__ptr_Stmt_ce_(&((litaC_comp->body)), litaC_i);
                                            switch(litaC_stmt->node.kind) {
                                                case litaC_ast__StmtKind_IMPORT_DECL: {
                                                    {
                                                        litaC_std__array__Array_add_cb__ptr_ImportDecl_ce_(&((litaC_moduleStmt->imports)), (litaC_ast__ImportDecl*)litaC_stmt);
                                                        break;
                                                        
                                                        
                                                    }
                                                    
                                                    
                                                }
                                                case litaC_ast__StmtKind_NOTE_STMT: {
                                                    {
                                                        litaC_std__array__Array_add_cb__ptr_NoteStmt_ce_(&((litaC_moduleStmt->notes)), (litaC_ast__NoteStmt*)litaC_stmt);
                                                        break;
                                                        
                                                        
                                                    }
                                                    
                                                    
                                                }
                                                case litaC_ast__StmtKind_NOTES_DECL: {
                                                    {
                                                        litaC_ast__NotesDecl* litaC_notes = (litaC_ast__NotesDecl*)litaC_stmt;
                                                        litaC_std__array__Array_addAll_cb__ptr_NoteStmt_ce_(&((litaC_moduleStmt->notes)), &((litaC_notes->notes)));
                                                        break;
                                                        
                                                        
                                                    }
                                                    
                                                    
                                                }
                                                case litaC_ast__StmtKind_BLOCK_STMT: {
                                                    {
                                                        litaC_ast__BlockStmt* litaC_block = (litaC_ast__BlockStmt*)litaC_stmt;
                                                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Stmt_ce_(&((litaC_block->stmts)));litaC_i += 1) {
                                                            {
                                                                litaC_ast__Stmt* litaC_s = litaC_std__array__Array_get_cb__ptr_Stmt_ce_(&((litaC_block->stmts)), litaC_i);
                                                                if(litaC_s->node.kind == litaC_ast__StmtKind_NOTE_STMT) {
                                                                    {
                                                                        litaC_std__array__Array_add_cb__ptr_NoteStmt_ce_(&((litaC_moduleStmt->notes)), (litaC_ast__NoteStmt*)litaC_s);
                                                                        
                                                                        
                                                                    }
                                                                    
                                                                } 
                                                                
                                                                
                                                                
                                                            }
                                                        }
                                                        
                                                        
                                                    }
                                                    
                                                    
                                                }
                                                default: {
                                                    {
                                                        if(litaC_ast__IsDecl(&((litaC_stmt->node)))) {
                                                            {
                                                                litaC_std__array__Array_add_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), (litaC_ast__Decl*)litaC_stmt);
                                                                
                                                                
                                                            }
                                                            
                                                        } 
                                                        
                                                        
                                                        
                                                    }
                                                    
                                                    
                                                }
                                            }
                                            
                                            
                                        }
                                    }
                                    
                                    
                                }
                                
                            } else {
                                if(litaC_comp->end) {
                                    {
                                        litaC_preprocessor__Preprocessor_evaluateForModule(litaC_this, litaC_module, litaC_moduleStmt, litaC_comp->end);
                                        
                                        
                                    }
                                    
                                } 
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                } 
                
            } 
            
        } 
        
    } 
    
    
}


litaC_ast__Stmt* litaC_preprocessor__Preprocessor_evaluateForFunction(litaC_preprocessor__Preprocessor* litaC_this,litaC_checker__TypeChecker* litaC_checker,litaC_ast__CompStmt* litaC_comp,litaC_bool litaC_isFirst) {
    assert(litaC_comp != NULL);
    if(litaC_comp->evaluatedStmt) {
        {
            return litaC_comp->evaluatedStmt;
            
            
            
        }
        
    } 
    
    if(!(litaC_isFirst)) {
        {
            if(litaC_intern__InternedString_equals(&((litaC_comp->type)), &((litaC_intern__IF))) || litaC_intern__InternedString_equals(&((litaC_comp->type)), &((litaC_intern__STATIC_IF)))) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_comp->stmt.node.startPos, "'#static_if' and '#if' are only allowed as the first statement in the preprocessor chain.");
                    return NULL;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_this->callContext.checker = litaC_checker;
    litaC_this->callContext.comp = litaC_comp;
    if(litaC_intern__InternedString_equals(&((litaC_comp->type)), &((litaC_intern__IF))) || litaC_intern__InternedString_equals(&((litaC_comp->type)), &((litaC_intern__ELSEIF))) || litaC_intern__InternedString_equals(&((litaC_comp->type)), &((litaC_intern__ELSE)))) {
        {
            if(litaC_intern__InternedString_equals(&((litaC_comp->type)), &((litaC_intern__ELSE))) || litaC_preprocessor__Preprocessor_eval(litaC_this, litaC_comp)) {
                {
                    litaC_comp->evaluatedStmt = litaC_ast_new__NewBlockStmt(litaC_comp->stmt.node.startPos, litaC_comp->stmt.node.endPos, litaC_comp->body, litaC_this->lita->allocator);
                    
                    
                }
                
            } else {
                if(litaC_comp->end) {
                    {
                        litaC_comp->evaluatedStmt = litaC_preprocessor__Preprocessor_evaluateForFunction(litaC_this, litaC_checker, litaC_comp->end, litaC_false);
                        
                        
                    }
                    
                } 
                
            } 
            
            
            
        }
        
    } else {
        if(litaC_intern__InternedString_equals(&((litaC_comp->type)), &((litaC_intern__STATIC_IF))) || litaC_intern__InternedString_equals(&((litaC_comp->type)), &((litaC_intern__ELSE)))) {
            {
                litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_comp->stmt.node.startPos, "'#static_if' is not allowed in '#if' chains");
                return NULL;
                
                
                
            }
            
        } else {
            if(litaC_intern__InternedString_equals(&((litaC_comp->type)), &((litaC_intern__ELSE_ERROR)))) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_comp->stmt.node.startPos, "%.*s", litaC_comp->expr.length, litaC_comp->expr.buffer);
                    
                    
                }
                
            } 
            
        } 
        
    } 
    
    if(!(litaC_comp->evaluatedStmt)) {
        {
            litaC_comp->evaluatedStmt = litaC_ast_new__NewEmptyStmt(litaC_comp->stmt.node.startPos, litaC_comp->stmt.node.endPos, litaC_this->lita->allocator);
            
            
        }
        
    } 
    
    return litaC_comp->evaluatedStmt;
    
    
}

litaC_void litaC_preprocessor__Preprocessor_preResolveSymbols(litaC_preprocessor__Preprocessor* litaC_this,litaC_checker__TypeChecker* litaC_checker,litaC_bool litaC_isIncrementalBuild) {
    litaC_this->callContext.checker = litaC_checker;
    litaC_this->callContext.resolveSymbols = litaC_false;
    if(litaC_isIncrementalBuild) {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_CheckerContext_ce_(&((litaC_this->preCheckers)));litaC_i += 1) {
                {
                    litaC_preprocessor__CheckerContext litaC_ctx = litaC_std__array__Array_get_cb_CheckerContext_ce_(&((litaC_this->preCheckers)), litaC_i);
                    if(litaC_ctx.module->flags & litaC_module__ModuleFlags_INCREMENTAL_COMPILATION) {
                        {
                            litaC_this->callContext.comp = litaC_ctx.stmt;
                            litaC_preprocessor__Preprocessor_eval(litaC_this, litaC_ctx.stmt);
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_CheckerContext_ce_(&((litaC_this->preCheckers)));litaC_i += 1) {
                {
                    litaC_preprocessor__CheckerContext litaC_ctx = litaC_std__array__Array_get_cb_CheckerContext_ce_(&((litaC_this->preCheckers)), litaC_i);
                    litaC_this->callContext.comp = litaC_ctx.stmt;
                    litaC_preprocessor__Preprocessor_eval(litaC_this, litaC_ctx.stmt);
                    
                    
                }
            }
            
            
        }
    } 
    
    
}

litaC_void litaC_preprocessor__Preprocessor_postResolveSymbols(litaC_preprocessor__Preprocessor* litaC_this,litaC_checker__TypeChecker* litaC_checker,litaC_bool litaC_isIncrementalBuild) {
    litaC_this->callContext.checker = litaC_checker;
    litaC_this->callContext.resolveSymbols = litaC_true;
    if(litaC_isIncrementalBuild) {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_CheckerContext_ce_(&((litaC_this->postCheckers)));litaC_i += 1) {
                {
                    litaC_preprocessor__CheckerContext litaC_ctx = litaC_std__array__Array_get_cb_CheckerContext_ce_(&((litaC_this->postCheckers)), litaC_i);
                    if(litaC_ctx.module->flags & litaC_module__ModuleFlags_INCREMENTAL_COMPILATION) {
                        {
                            litaC_this->callContext.comp = litaC_ctx.stmt;
                            litaC_preprocessor__Preprocessor_eval(litaC_this, litaC_ctx.stmt);
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_CheckerContext_ce_(&((litaC_this->postCheckers)));litaC_i += 1) {
                {
                    litaC_preprocessor__CheckerContext litaC_ctx = litaC_std__array__Array_get_cb_CheckerContext_ce_(&((litaC_this->postCheckers)), litaC_i);
                    litaC_this->callContext.comp = litaC_ctx.stmt;
                    litaC_preprocessor__Preprocessor_eval(litaC_this, litaC_ctx.stmt);
                    
                    
                }
            }
            
            
        }
    } 
    
    
}

litaC_void litaC_preprocessor__Preprocessor_drainQueue(litaC_preprocessor__Preprocessor* litaC_this) {
    while(!(litaC_std__array__Array_empty_cb_ScriptDecl_ce_(&((litaC_this->declQueue))))) {
        {
            litaC_preprocessor__ScriptDecl litaC_scriptDecl = litaC_std__array__Array_pop_cb_ScriptDecl_ce_(&((litaC_this->declQueue)));
            litaC_preprocessor__DeclContext litaC_context = litaC_scriptDecl.ctx;
            litaC_module__Module* litaC_module = litaC_scriptDecl.module;
            litaC_ast__ModuleStmt* litaC_stmts = litaC_scriptDecl.declarations;
            if(!(litaC_stmts)) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_ast__ModuleStmt* litaC_moduleStmt = litaC_module->ast;
            if(litaC_scriptDecl.replacement) {
                {
                    if(litaC_std__array__Array_size_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)))) {
                        {
                            litaC_std__array__Array_addAll_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), &((litaC_stmts->declarations)));
                            litaC_checker__TypeChecker_enterModule(litaC_context.checker, litaC_module);
                            
                            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)));litaC_i += 1) {
                                {
                                    litaC_ast__Decl* litaC_decl = litaC_std__array__Array_get_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)), litaC_i);
                                    litaC_intern__InternedString litaC_name = litaC_decl->name.str;
                                    litaC_char litaC_buffer[256] =  {
                                        0
                                    };
                                    if(litaC_decl->stmt.node.kind == litaC_ast__StmtKind_FUNC_DECL) {
                                        {
                                            litaC_ast__FuncDecl* litaC_funcDecl = (litaC_ast__FuncDecl*)litaC_decl;
                                            if(!(litaC_ast__FuncDecl_getName(litaC_funcDecl, litaC_buffer))) {
                                                {
                                                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_context.comp->stmt.node.startPos, "symbol '%.*s' could not get declaration method name", litaC_decl->name.str.length, litaC_decl->name.str.buffer);
                                                    continue;
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                            litaC_name = litaC_intern__Strings_internCopy(&((litaC_this->lita->strings)), litaC_buffer, -(1));
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    litaC_symbols__Symbol* litaC_sym = litaC_checker__TypeChecker_getTypeByName(litaC_context.checker, litaC_name, litaC_checker__SearchType_TYPE);
                                    if(!(litaC_sym)) {
                                        {
                                            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_context.comp->stmt.node.startPos, "symbol '%.*s' not found for replacement", litaC_decl->name.str.length, litaC_decl->name.str.buffer);
                                            continue;
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    litaC_sym->decl = litaC_decl;
                                    litaC_decl->sym = litaC_sym;
                                    litaC_sym->flags |= litaC_symbols__SymbolFlags_IS_FROM_PREPROCESSOR;
                                    litaC_sym->flags |= litaC_symbols__SymbolFlags_IS_INCOMPLETE;
                                    if(litaC_context.resolveSymbols) {
                                        {
                                            litaC_checker__TypeChecker_resolveSymbol(litaC_context.checker, litaC_sym);
                                            litaC_checker__TypeChecker_finishResolveSymbol(litaC_context.checker, litaC_sym);
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    
                                    
                                }
                            }
                            litaC_checker__TypeChecker_leaveModule(litaC_context.checker);
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } else {
                {
                    if(litaC_std__array__Array_size_cb__ptr_ImportDecl_ce_(&((litaC_stmts->imports)))) {
                        {
                            litaC_std__array__Array_addAll_cb__ptr_ImportDecl_ce_(&((litaC_moduleStmt->imports)), &((litaC_stmts->imports)));
                            
                            
                        }
                        
                    } 
                    
                    if(litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_stmts->notes)))) {
                        {
                            litaC_std__array__Array_addAll_cb__ptr_NoteStmt_ce_(&((litaC_moduleStmt->notes)), &((litaC_stmts->notes)));
                            
                            
                        }
                        
                    } 
                    
                    if(litaC_std__array__Array_size_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)))) {
                        {
                            litaC_std__array__Array_addAll_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), &((litaC_stmts->declarations)));
                            litaC_checker__TypeChecker_enterModule(litaC_context.checker, litaC_module);
                            
                            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)));litaC_i += 1) {
                                {
                                    litaC_ast__Decl* litaC_decl = litaC_std__array__Array_get_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)), litaC_i);
                                    litaC_symbols__Symbol* litaC_sym = litaC_checker__TypeChecker_createDeclSymbol(litaC_context.checker, litaC_decl);
                                    if(litaC_sym) {
                                        {
                                            litaC_sym->flags |= litaC_symbols__SymbolFlags_IS_FROM_PREPROCESSOR;
                                            for(litaC_std__map__MapIterator_cb__ptr_const_char_c_ModuleImport_ce_ litaC_it = litaC_std__map__Map_iter_cb__ptr_const_char_c_ModuleImport_ce_(&((litaC_module->importedBy)));litaC_std__map__MapIterator_hasNext_cb__ptr_const_char_c_ModuleImport_ce_(&((litaC_it)));) {
                                                {
                                                    litaC_std__map__MapEntry_cb__ptr_const_char_c_ModuleImport_ce_ litaC_entry = litaC_std__map__MapIterator_next_cb__ptr_const_char_c_ModuleImport_ce_(&((litaC_it)));
                                                    litaC_module__ModuleImport litaC_imp = litaC_entry.value;
                                                    litaC_module__Module_importModuleSymbol(litaC_imp.module, litaC_decl->stmt.node.startPos, litaC_module, litaC_imp.alias, litaC_sym, litaC_sym->name, litaC_imp.isUsing);
                                                    
                                                    
                                                }
                                            }
                                            if(litaC_context.resolveSymbols) {
                                                {
                                                    litaC_checker__TypeChecker_resolveSymbol(litaC_context.checker, litaC_sym);
                                                    litaC_checker__TypeChecker_finishResolveSymbol(litaC_context.checker, litaC_sym);
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    
                                    
                                }
                            }
                            litaC_checker__TypeChecker_leaveModule(litaC_context.checker);
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            } 
            
            
            
        }
    }
    
}

litaC_std__regex__Regex litaC_std__regex__RegexCompile(const litaC_char* litaC_pattern) {
    litaC_std__regex__Regex litaC_result = {0};
    {
        
        
    }
    litaC_result.reg = re_compile(litaC_pattern);
    return litaC_result;
    
    
}

litaC_i32 litaC_std__regex__Regex_match(litaC_std__regex__Regex* litaC_this,const litaC_char* litaC_text,litaC_i32* litaC_matchlength) {
    return re_matchp(litaC_this->reg, litaC_text, litaC_matchlength);
    
    
}

litaC_i32 litaC_std__regex__RegexMatch(const litaC_char* litaC_pattern,const litaC_char* litaC_text,litaC_i32* litaC_matchlength) {
    return re_match(litaC_pattern, litaC_text, litaC_matchlength);
    
    
}

litaC_intern__InternedString litaC_ast_copy__NewTokenNameIntern(litaC_lex__Token litaC_token,litaC_intern__Strings* litaC_strings) {
    if(litaC_token.type != litaC_lex__TokenType_IDENTIFIER && litaC_token.type != litaC_lex__TokenType_STRING) {
        {
            const litaC_char* litaC_text = litaC_lex__tokenText[litaC_token.type];
            return litaC_intern__Strings_internCopy(litaC_strings, litaC_text, strlen(litaC_text));
            
            
            
        }
        
    } 
    
    return litaC_intern__Strings_internCopy(litaC_strings, litaC_token.value.str.buffer, litaC_token.value.str.length);
    
    
}

litaC_std__array__Array_cb__ptr_TypeSpec_ce_ litaC_ast_copy__CopyTypeSpecs(litaC_std__array__Array_cb__ptr_TypeSpec_ce_ litaC_specs,litaC_module__Module* litaC_module) {
    if(litaC_std__array__Array_empty_cb__ptr_TypeSpec_ce_(&((litaC_specs)))) {
        {
            return (litaC_std__array__Array_cb__ptr_TypeSpec_ce_) {
                0
            };
            
            
            
        }
        
    } 
    
    litaC_std__array__Array_cb__ptr_TypeSpec_ce_ litaC_result =  {
        
    };
    litaC_std__array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_result)), litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_specs))), litaC_module->allocator);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_specs)));litaC_i += 1) {
        {
            litaC_ast__TypeSpec* litaC_spec = litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_specs)), litaC_i);
            litaC_std__array__Array_add_cb__ptr_TypeSpec_ce_(&((litaC_result)), litaC_ast_copy__CopyTypeSpec(litaC_spec, litaC_module));
            
            
        }
    }
    return litaC_result;
    
    
}

litaC_ast__TypeSpec* litaC_ast_copy__CopyTypeSpec(litaC_ast__TypeSpec* litaC_spec,litaC_module__Module* litaC_module) {
    if(litaC_spec == NULL) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_ast__TypeSpec* litaC_copy = litaC_ast_new__NewTypeSpec(litaC_spec->kind, litaC_spec->pos, &(litaC_module->typeSpecAllocator));
    litaC_copy->base = litaC_ast_copy__CopyTypeSpec(litaC_spec->base, litaC_module);
    switch(litaC_spec->kind) {
        case litaC_ast__TypeSpecKind_NONE: {
            {
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_ARRAY: {
            {
                litaC_ast__TypeSpec* litaC_originalArray = litaC_spec;
                litaC_ast__TypeSpec* litaC_copyArray = litaC_copy;
                if(litaC_originalArray->numElements) {
                    {
                        litaC_copyArray->numElements = litaC_ast_copy__CopyExpr(litaC_originalArray->numElements, litaC_module);
                        
                        
                    }
                    
                } 
                
                return (litaC_ast__TypeSpec*)litaC_copyArray;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_PTR: 
        case litaC_ast__TypeSpecKind_CONST: {
            {
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_NAME: {
            {
                litaC_ast__TypeSpec* litaC_originalName = litaC_spec;
                litaC_ast__TypeSpec* litaC_copyName = litaC_copy;
                litaC_copyName->name = litaC_originalName->name;
                litaC_copyName->genericArgs = litaC_ast_copy__CopyTypeSpecs(litaC_originalName->genericArgs, litaC_module);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_FUNC_PTR: {
            {
                litaC_ast__TypeSpec* litaC_original = litaC_spec;
                litaC_ast__TypeSpec* litaC_copyFunc = litaC_copy;
                litaC_copyFunc->args = litaC_ast_copy__CopyTypeSpecs(litaC_original->args, litaC_module);
                litaC_copyFunc->ret = litaC_ast_copy__CopyTypeSpec(litaC_original->ret, litaC_module);
                litaC_copyFunc->hasVarargs = litaC_original->hasVarargs;
                litaC_std__array__Array_init_cb_GenericParam_ce_(&((litaC_copyFunc->genericParams)), litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_original->genericParams))), litaC_module->allocator);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_original->genericParams)));litaC_i += 1) {
                    {
                        litaC_ast__GenericParam litaC_param = litaC_std__array__Array_get_cb_GenericParam_ce_(&((litaC_original->genericParams)), litaC_i);
                        litaC_std__array__Array_add_cb_GenericParam_ce_(&((litaC_copyFunc->genericParams)), litaC_param);
                        
                        
                    }
                }
                return litaC_copy;
                
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return NULL;
    
    
}

litaC_ast__Decl* litaC_ast_copy__CopyDecl(litaC_ast__Decl* litaC_decl,litaC_module__Module* litaC_module) {
    if(!(litaC_decl)) {
        return NULL;
        
        
    } 
    
    switch(litaC_decl->stmt.node.kind) {
        case litaC_ast__StmtKind_IMPORT_DECL: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONST_DECL: 
        case litaC_ast__StmtKind_VAR_DECL: {
            {
                litaC_ast__VarDecl* litaC_original = (litaC_ast__VarDecl*)litaC_decl;
                litaC_ast__Decl* litaC_copy = litaC_ast_new__NewVarDecl(litaC_original->decl.stmt.node.startPos, litaC_original->decl.stmt.node.endPos, litaC_original->decl.name, litaC_ast_copy__CopyTypeSpec(litaC_original->typeSpec, litaC_module), litaC_ast_copy__CopyExpr(litaC_original->expr, litaC_module), litaC_module->allocator);
                if(litaC_decl->stmt.node.kind == litaC_ast__StmtKind_CONST_DECL) {
                    {
                        litaC_copy->stmt.node.kind = litaC_ast__StmtKind_CONST_DECL;
                        
                        
                    }
                    
                } 
                
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_STRUCT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: 
        case litaC_ast__StmtKind_TRAIT_DECL: {
            {
                return (litaC_ast__Decl*)litaC_ast_copy__CopyAggregateDecl((litaC_ast__AggregateDecl*)litaC_decl, litaC_module);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: {
            assert(litaC_false);
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                return (litaC_ast__Decl*)litaC_ast_copy__CopyFuncDecl((litaC_ast__FuncDecl*)litaC_decl, litaC_module);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                return (litaC_ast__Decl*)litaC_ast_copy__CopyTypedefDecl((litaC_ast__TypedefDecl*)litaC_decl, litaC_module);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAM_DECL: {
            {
                litaC_ast__ParameterDecl* litaC_original = (litaC_ast__ParameterDecl*)litaC_decl;
                litaC_ast__Decl* litaC_copy = litaC_ast_new__NewParameterDecl(litaC_original->decl.stmt.node.startPos, litaC_original->decl.stmt.node.endPos, litaC_original->decl.name, litaC_ast_copy__CopyTypeSpec(litaC_original->type, litaC_module), litaC_ast_copy__CopyExpr(litaC_original->defaultExpr, litaC_module), litaC_original->decl.attributes.isUsing, litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NATIVE_DECL: {
            {
                return litaC_decl;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_DECL: {
            return litaC_decl;
            
            
            
        }
        default: {
            assert(litaC_false);
            
            
        }
    }
    return NULL;
    
    
}

litaC_std__array__Array_cb_CallArg_ce_ litaC_ast_copy__CopyCallArgs(litaC_std__array__Array_cb_CallArg_ce_* litaC_args,litaC_module__Module* litaC_module) {
    if(litaC_std__array__Array_empty_cb_CallArg_ce_(litaC_args)) {
        {
            return (litaC_std__array__Array_cb_CallArg_ce_) {
                
            };
            
            
            
        }
        
    } 
    
    litaC_std__array__Array_cb_CallArg_ce_ litaC_result = litaC_std__array__ArrayInit_cb_CallArg_ce_(litaC_std__array__Array_size_cb_CallArg_ce_(litaC_args), litaC_module->allocator);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_CallArg_ce_(litaC_args);litaC_i += 1) {
        {
            litaC_ast__CallArg litaC_arg = litaC_std__array__Array_get_cb_CallArg_ce_(litaC_args, litaC_i);
            litaC_ast__Expr* litaC_argExpr = litaC_ast_copy__CopyExpr(litaC_arg.argExpr, litaC_module);
            litaC_std__array__Array_add_cb_CallArg_ce_(&((litaC_result)), (litaC_ast__CallArg) {
                .argExpr = litaC_argExpr,
                .argName = litaC_arg.argName,
                .isDefault = litaC_false
            });
            
            
        }
    }
    return litaC_result;
    
    
}

litaC_std__array__Array_cb__ptr_Expr_ce_ litaC_ast_copy__CopyExprs(litaC_std__array__Array_cb__ptr_Expr_ce_* litaC_exprs,litaC_module__Module* litaC_module) {
    if(litaC_std__array__Array_empty_cb__ptr_Expr_ce_(litaC_exprs)) {
        {
            return (litaC_std__array__Array_cb__ptr_Expr_ce_) {
                
            };
            
            
            
        }
        
    } 
    
    litaC_std__array__Array_cb__ptr_Expr_ce_ litaC_result = litaC_std__array__ArrayInit_cb__ptr_Expr_ce_(litaC_std__array__Array_size_cb__ptr_Expr_ce_(litaC_exprs), litaC_module->allocator);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Expr_ce_(litaC_exprs);litaC_i += 1) {
        {
            litaC_ast__Expr* litaC_copy = litaC_ast_copy__CopyExpr(litaC_std__array__Array_get_cb__ptr_Expr_ce_(litaC_exprs, litaC_i), litaC_module);
            litaC_std__array__Array_add_cb__ptr_Expr_ce_(&((litaC_result)), litaC_copy);
            
            
        }
    }
    return litaC_result;
    
    
}

litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_ast_copy__CopyStmts(litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_stmts,litaC_module__Module* litaC_module) {
    if(litaC_std__array__Array_empty_cb__ptr_Stmt_ce_(litaC_stmts)) {
        {
            return (litaC_std__array__Array_cb__ptr_Stmt_ce_) {
                
            };
            
            
            
        }
        
    } 
    
    litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_result = litaC_std__array__ArrayInit_cb__ptr_Stmt_ce_(litaC_std__array__Array_size_cb__ptr_Stmt_ce_(litaC_stmts), litaC_module->allocator);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Stmt_ce_(litaC_stmts);litaC_i += 1) {
        {
            litaC_ast__Stmt* litaC_copy = litaC_ast_copy__CopyStmt(litaC_std__array__Array_get_cb__ptr_Stmt_ce_(litaC_stmts, litaC_i), litaC_module);
            litaC_std__array__Array_add_cb__ptr_Stmt_ce_(&((litaC_result)), litaC_copy);
            
            
        }
    }
    return litaC_result;
    
    
}

litaC_ast__Expr* litaC_ast_copy__CopyExpr(litaC_ast__Expr* litaC_expr,litaC_module__Module* litaC_module) {
    if(!(litaC_expr)) {
        return NULL;
        
        
    } 
    
    switch(litaC_expr->stmt.node.kind) {
        case litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR: {
            {
                litaC_ast__ArrayDesignationExpr* litaC_original = (litaC_ast__ArrayDesignationExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewArrayDesignationExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->index, litaC_module), litaC_ast_copy__CopyExpr(litaC_original->value, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_INIT_EXPR: {
            {
                litaC_ast__ArrayInitExpr* litaC_original = (litaC_ast__ArrayInitExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewArrayInitExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyTypeSpec(litaC_original->type, litaC_module), litaC_ast_copy__CopyExprs(&((litaC_original->values)), litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BINARY_EXPR: {
            {
                litaC_ast__BinaryExpr* litaC_original = (litaC_ast__BinaryExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewBinaryExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->left, litaC_module), litaC_original->operator, litaC_ast_copy__CopyExpr(litaC_original->right, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BOOLEAN_EXPR: {
            {
                return litaC_expr;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CAST_EXPR: {
            {
                litaC_ast__CastExpr* litaC_original = (litaC_ast__CastExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewCastExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->exprToCast, litaC_module), litaC_ast_copy__CopyTypeSpec(litaC_original->castTo, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CHAR_EXPR: {
            {
                return litaC_expr;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_CALL_EXPR: {
            {
                litaC_ast__FuncCallExpr* litaC_original = (litaC_ast__FuncCallExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewFuncCallExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->object, litaC_module), litaC_ast_copy__CopyCallArgs(&((litaC_original->arguments)), litaC_module), litaC_ast_copy__CopyTypeSpecs(litaC_original->genericArgs, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: {
            {
                litaC_ast__IdentifierExpr* litaC_original = (litaC_ast__IdentifierExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewIdentifierExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyTypeSpec(litaC_original->type, litaC_module), litaC_module->allocator);
                litaC_copy->stmt.node.kind = litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR;
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GET_EXPR: {
            {
                litaC_ast__GetExpr* litaC_original = (litaC_ast__GetExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewGetExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->object, litaC_module), (litaC_ast__IdentifierExpr*)litaC_ast_copy__CopyExpr(&((litaC_original->field->expr)), litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GROUP_EXPR: {
            {
                litaC_ast__GroupExpr* litaC_original = (litaC_ast__GroupExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewGroupExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->groupedExpr, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: {
            {
                litaC_ast__IdentifierExpr* litaC_original = (litaC_ast__IdentifierExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewIdentifierExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyTypeSpec(litaC_original->type, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_INIT_ARG_EXPR: {
            {
                litaC_ast__InitArgExpr* litaC_original = (litaC_ast__InitArgExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewInitArgExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_original->fieldName, litaC_original->argPosition, litaC_ast_copy__CopyExpr(litaC_original->value, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_INIT_EXPR: {
            {
                litaC_ast__InitExpr* litaC_original = (litaC_ast__InitExpr*)litaC_expr;
                litaC_std__array__Array_cb__ptr_InitArgExpr_ce_ litaC_arguments =  {
                    
                };
                if(!(litaC_std__array__Array_empty_cb__ptr_InitArgExpr_ce_(&((litaC_original->arguments))))) {
                    {
                        litaC_std__array__Array_init_cb__ptr_InitArgExpr_ce_(&((litaC_arguments)), litaC_std__array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_original->arguments))), litaC_module->allocator);
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_original->arguments)));litaC_i += 1) {
                    {
                        litaC_ast__InitArgExpr* litaC_copy = (litaC_ast__InitArgExpr*)litaC_ast_copy__CopyExpr(&((litaC_std__array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_original->arguments)), litaC_i)->expr)), litaC_module);
                        litaC_std__array__Array_add_cb__ptr_InitArgExpr_ce_(&((litaC_arguments)), litaC_copy);
                        
                        
                    }
                }
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewInitExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyTypeSpec(litaC_original->type, litaC_module), litaC_arguments, litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NULL_EXPR: {
            {
                return litaC_expr;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NUMBER_EXPR: {
            {
                return litaC_expr;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SET_EXPR: {
            {
                litaC_ast__SetExpr* litaC_original = (litaC_ast__SetExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewSetExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->object, litaC_module), (litaC_ast__IdentifierExpr*)litaC_ast_copy__CopyExpr(&((litaC_original->field->expr)), litaC_module), litaC_original->operator, litaC_ast_copy__CopyExpr(litaC_original->value, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_OFFSET_OF_EXPR: {
            {
                litaC_ast__OffsetOfExpr* litaC_original = (litaC_ast__OffsetOfExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewOffsetOfExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyTypeSpec(litaC_original->type, litaC_module), litaC_original->field, litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SIZE_OF_EXPR: {
            {
                litaC_ast__SizeOfExpr* litaC_original = (litaC_ast__SizeOfExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewSizeOfExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->sizeOfExpr, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_STRING_EXPR: {
            {
                return litaC_expr;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR: {
            {
                litaC_ast__SubscriptGetExpr* litaC_original = (litaC_ast__SubscriptGetExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewSubscriptGetExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->object, litaC_module), litaC_ast_copy__CopyExpr(litaC_original->index, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_SET_EXPR: {
            {
                litaC_ast__SubscriptSetExpr* litaC_original = (litaC_ast__SubscriptSetExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewSubscriptSetExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->object, litaC_module), litaC_ast_copy__CopyExpr(litaC_original->index, litaC_module), litaC_original->operator, litaC_ast_copy__CopyExpr(litaC_original->value, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TERNARY_EXPR: {
            {
                litaC_ast__TernaryExpr* litaC_original = (litaC_ast__TernaryExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewTernaryExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->cond, litaC_module), litaC_ast_copy__CopyExpr(litaC_original->then, litaC_module), litaC_ast_copy__CopyExpr(litaC_original->other, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR: {
            {
                litaC_ast__TypeIdentifierExpr* litaC_original = (litaC_ast__TypeIdentifierExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewTypeIdentifierExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyTypeSpec(litaC_original->type, litaC_module), litaC_original->isBased, litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_OF_EXPR: {
            {
                litaC_ast__TypeOfExpr* litaC_original = (litaC_ast__TypeOfExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewTypeOfExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->typeOfExpr, litaC_module), litaC_ast_copy__CopyTypeSpec(litaC_original->type, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNARY_EXPR: {
            {
                litaC_ast__UnaryExpr* litaC_original = (litaC_ast__UnaryExpr*)litaC_expr;
                litaC_ast__Expr* litaC_copy = litaC_ast_new__NewUnaryExpr(litaC_original->expr.stmt.node.startPos, litaC_original->expr.stmt.node.endPos, litaC_original->operator, litaC_ast_copy__CopyExpr(litaC_original->unaryExpr, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_EXPR: {
            {
                return litaC_expr;
                
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return NULL;
    
    
}

litaC_ast__Stmt* litaC_ast_copy__CopyStmt(litaC_ast__Stmt* litaC_stmt,litaC_module__Module* litaC_module) {
    if(!(litaC_stmt)) {
        return NULL;
        
        
    } 
    
    switch(litaC_stmt->node.kind) {
        case litaC_ast__StmtKind_BLOCK_STMT: {
            {
                litaC_ast__BlockStmt* litaC_original = (litaC_ast__BlockStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewBlockStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_ast_copy__CopyStmts(&((litaC_original->stmts)), litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BREAK_STMT: {
            {
                return litaC_stmt;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_COMP_STMT: {
            {
                litaC_ast__CompStmt* litaC_original = (litaC_ast__CompStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_end = NULL;
                if(litaC_original->end != NULL) {
                    {
                        litaC_end = &(litaC_original->end->stmt);
                        
                        
                    }
                    
                } 
                
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewCompStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_original->type, litaC_original->expr, litaC_ast_copy__CopyStmts(&((litaC_original->body)), litaC_module), (litaC_ast__CompStmt*)litaC_ast_copy__CopyStmt(litaC_end, litaC_module), litaC_original->isScriptLoad, litaC_original->isStatic, litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONTINUE_STMT: {
            {
                return litaC_stmt;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DEFER_STMT: {
            {
                litaC_ast__DeferStmt* litaC_original = (litaC_ast__DeferStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewDeferStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_ast_copy__CopyStmt(litaC_original->deferedStmt, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DO_WHILE_STMT: {
            {
                litaC_ast__DoWhileStmt* litaC_original = (litaC_ast__DoWhileStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewDoWhileStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->cond, litaC_module), litaC_ast_copy__CopyStmt(litaC_original->body, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_EMPTY_STMT: {
            {
                return litaC_stmt;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FOR_STMT: {
            {
                litaC_ast__ForStmt* litaC_original = (litaC_ast__ForStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewForStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_ast_copy__CopyStmt(litaC_original->init, litaC_module), litaC_ast_copy__CopyExpr(litaC_original->cond, litaC_module), litaC_ast_copy__CopyStmt(litaC_original->post, litaC_module), litaC_ast_copy__CopyStmt(litaC_original->body, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_BODY_STMT: {
            {
                litaC_ast__FuncBodyStmt* litaC_original = (litaC_ast__FuncBodyStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewBlockStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_ast_copy__CopyStmts(&((litaC_original->stmts)), litaC_module), litaC_module->allocator);
                litaC_copy->node.kind = litaC_ast__StmtKind_FUNC_BODY_STMT;
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GOTO_STMT: {
            {
                return litaC_stmt;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IF_STMT: {
            {
                litaC_ast__IfStmt* litaC_original = (litaC_ast__IfStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewIfStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->cond, litaC_module), litaC_ast_copy__CopyStmt(litaC_original->then, litaC_module), litaC_ast_copy__CopyStmt(litaC_original->elseStmt, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_LABEL_STMT: {
            {
                return litaC_stmt;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_MODULE_STMT: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NOTE_STMT: {
            {
                return litaC_stmt;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAMETERS_STMT: {
            {
                litaC_ast__ParametersStmt* litaC_original = (litaC_ast__ParametersStmt*)litaC_stmt;
                litaC_std__array__Array_cb__ptr_ParameterDecl_ce_ litaC_params =  {
                    
                };
                if(!(litaC_std__array__Array_empty_cb__ptr_ParameterDecl_ce_(&((litaC_original->params))))) {
                    {
                        litaC_std__array__Array_init_cb__ptr_ParameterDecl_ce_(&((litaC_params)), litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_original->params))), litaC_module->allocator);
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_original->params)));litaC_i += 1) {
                    {
                        litaC_ast__ParameterDecl* litaC_copy = (litaC_ast__ParameterDecl*)litaC_ast_copy__CopyStmt(&((litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_original->params)), litaC_i)->decl.stmt)), litaC_module);
                        litaC_std__array__Array_add_cb__ptr_ParameterDecl_ce_(&((litaC_params)), litaC_copy);
                        
                        
                    }
                }
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewParametersStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_params, litaC_original->isVararg, litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_RETURN_STMT: {
            {
                litaC_ast__ReturnStmt* litaC_original = (litaC_ast__ReturnStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewReturnStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->expr, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SWITCH_CASE_STMT: {
            {
                litaC_ast__SwitchCaseStmt* litaC_original = (litaC_ast__SwitchCaseStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewSwitchCaseStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->cond, litaC_module), litaC_ast_copy__CopyStmt(litaC_original->body, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SWITCH_STMT: {
            {
                litaC_ast__SwitchStmt* litaC_original = (litaC_ast__SwitchStmt*)litaC_stmt;
                litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_ litaC_cases =  {
                    
                };
                if(!(litaC_std__array__Array_empty_cb__ptr_SwitchCaseStmt_ce_(&((litaC_original->cases))))) {
                    {
                        litaC_std__array__Array_init_cb__ptr_SwitchCaseStmt_ce_(&((litaC_cases)), litaC_std__array__Array_size_cb__ptr_SwitchCaseStmt_ce_(&((litaC_original->cases))), litaC_module->allocator);
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_SwitchCaseStmt_ce_(&((litaC_original->cases)));litaC_i += 1) {
                    {
                        litaC_ast__SwitchCaseStmt* litaC_copy = (litaC_ast__SwitchCaseStmt*)litaC_ast_copy__CopyStmt(&((litaC_std__array__Array_get_cb__ptr_SwitchCaseStmt_ce_(&((litaC_original->cases)), litaC_i)->stmt)), litaC_module);
                        litaC_std__array__Array_add_cb__ptr_SwitchCaseStmt_ce_(&((litaC_cases)), litaC_copy);
                        
                        
                    }
                }
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewSwitchStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->cond, litaC_module), litaC_cases, litaC_ast_copy__CopyStmt(litaC_original->defaultStmt, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_FIELD_DECL: 
        case litaC_ast__StmtKind_ENUM_FIELD_ENTRY_DECL: 
        case litaC_ast__StmtKind_STRUCT_FIELD_DECL: 
        case litaC_ast__StmtKind_UNION_FIELD_DECL: 
        case litaC_ast__StmtKind_TRAIT_FIELD_DECL: 
        case litaC_ast__StmtKind_VAR_FIELD_DECL: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_WHILE_STMT: {
            {
                litaC_ast__WhileStmt* litaC_original = (litaC_ast__WhileStmt*)litaC_stmt;
                litaC_ast__Stmt* litaC_copy = litaC_ast_new__NewWhileStmt(litaC_original->stmt.node.startPos, litaC_original->stmt.node.endPos, litaC_ast_copy__CopyExpr(litaC_original->cond, litaC_module), litaC_ast_copy__CopyStmt(litaC_original->body, litaC_module), litaC_module->allocator);
                return litaC_copy;
                
                
                
            }
            
            
        }
        default: {
            {
                if(litaC_ast__IsExpr(&((litaC_stmt->node)))) {
                    {
                        return (litaC_ast__Stmt*)litaC_ast_copy__CopyExpr((litaC_ast__Expr*)litaC_stmt, litaC_module);
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_ast__IsDecl(&((litaC_stmt->node)))) {
                    {
                        return (litaC_ast__Stmt*)litaC_ast_copy__CopyDecl((litaC_ast__Decl*)litaC_stmt, litaC_module);
                        
                        
                        
                    }
                    
                } 
                
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return NULL;
    
    
}

litaC_ast__AggregateDecl* litaC_ast_copy__CopyAggregateDecl(litaC_ast__AggregateDecl* litaC_decl,litaC_module__Module* litaC_module) {
    litaC_ast__AggregateDecl* litaC_copy = (litaC_ast__AggregateDecl*)litaC_ast_new__NewAggregateDecl(litaC_decl->decl.declaration.stmt.node.startPos, litaC_decl->decl.declaration.stmt.node.endPos, litaC_decl->decl.declaration.stmt.node.kind, litaC_decl->decl.declaration.name, litaC_std__array__Array_copy_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)), litaC_module->allocator), (litaC_std__array__Array_cb_FieldStmt_ce_) {
        
    }, litaC_decl->flags, litaC_module->allocator);
    litaC_copy->decl.declaration.attributes = litaC_decl->decl.declaration.attributes;
    litaC_copy->fields = litaC_std__array__ArrayInit_cb_FieldStmt_ce_(litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_decl->fields))), litaC_module->allocator);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_decl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_decl->fields)), litaC_i);
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        litaC_ast__TraitFieldDecl* litaC_o = litaC_field.traitField;
                        litaC_ast__TraitFieldDecl* litaC_traitField = (litaC_ast__TraitFieldDecl*)litaC_ast_new__NewTraitFieldDecl(litaC_o->decl.stmt.node.startPos, litaC_o->decl.stmt.node.endPos, litaC_o->decl.name, litaC_ast_copy__CopyTypeSpec(litaC_o->type, litaC_module), litaC_o->decl.attributes, litaC_module->allocator);
                        litaC_ast__FieldStmt litaC_copyField =  {
                            .kind = litaC_ast__StmtKind_TRAIT_FIELD_DECL,
                            .traitField = litaC_traitField
                        };
                        litaC_std__array__Array_add_cb_FieldStmt_ce_(&((litaC_copy->fields)), litaC_copyField);
                        litaC_ast__Node_becomeParentOf_cb_TraitFieldDecl_ce_(&((litaC_copy->decl.declaration.stmt.node)), litaC_traitField);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_o = litaC_field.varField;
                        litaC_ast__VarFieldDecl* litaC_varField = (litaC_ast__VarFieldDecl*)litaC_ast_new__NewVarFieldDecl(litaC_o->decl.stmt.node.startPos, litaC_o->decl.stmt.node.endPos, litaC_o->decl.name, litaC_ast_copy__CopyTypeSpec(litaC_o->type, litaC_module), litaC_o->decl.attributes, litaC_ast_copy__CopyExpr(litaC_o->defaultExpr, litaC_module), litaC_module->allocator);
                        litaC_ast__FieldStmt litaC_copyField =  {
                            .kind = litaC_ast__StmtKind_VAR_FIELD_DECL,
                            .varField = litaC_varField
                        };
                        litaC_std__array__Array_add_cb_FieldStmt_ce_(&((litaC_copy->fields)), litaC_copyField);
                        litaC_ast__Node_becomeParentOf_cb_VarFieldDecl_ce_(&((litaC_copy->decl.declaration.stmt.node)), litaC_varField);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                    {
                        litaC_ast__FieldStmt litaC_copyField =  {
                            .kind = litaC_ast__StmtKind_ENUM_FIELD_DECL,
                            .enumField = litaC_field.enumField
                        };
                        litaC_std__array__Array_add_cb_FieldStmt_ce_(&((litaC_copy->fields)), litaC_copyField);
                        litaC_ast__Node_becomeParentOf_cb_EnumDecl_ce_(&((litaC_copy->decl.declaration.stmt.node)), litaC_field.enumField);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                        litaC_ast__FieldStmt litaC_copyField =  {
                            .kind = litaC_field.kind,
                            .aggregateField = litaC_ast_copy__CopyAggregateDecl(litaC_aggField, litaC_module)
                        };
                        litaC_std__array__Array_add_cb_FieldStmt_ce_(&((litaC_copy->fields)), litaC_copyField);
                        litaC_ast__Node_becomeParentOf_cb_AggregateDecl_ce_(&((litaC_copy->decl.declaration.stmt.node)), litaC_copyField.aggregateField);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_POISON_EXPR: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        assert(litaC_false);
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    return litaC_copy;
    
    
}

litaC_ast__FuncDecl* litaC_ast_copy__CopyFuncDecl(litaC_ast__FuncDecl* litaC_decl,litaC_module__Module* litaC_module) {
    litaC_ast__Decl* litaC_copy = litaC_ast_new__NewFuncDecl(litaC_decl->decl.declaration.stmt.node.startPos, litaC_decl->decl.declaration.stmt.node.endPos, litaC_decl->decl.declaration.name, litaC_std__array__Array_copy_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)), litaC_module->allocator), litaC_ast_copy__CopyParameters(*((litaC_decl->params)), litaC_module), litaC_ast_copy__CopyStmt(litaC_decl->body, litaC_module), litaC_ast_copy__CopyTypeSpec(litaC_decl->returnType, litaC_module), litaC_decl->flags, litaC_module->allocator);
    litaC_copy->attributes = litaC_decl->decl.declaration.attributes;
    return (litaC_ast__FuncDecl*)litaC_copy;
    
    
}

litaC_ast__ParametersStmt* litaC_ast_copy__CopyParameters(litaC_ast__ParametersStmt litaC_params,litaC_module__Module* litaC_module) {
    litaC_std__array__Array_cb__ptr_ParameterDecl_ce_ litaC_paramDecls =  {
        
    };
    litaC_std__array__Array_init_cb__ptr_ParameterDecl_ce_(&((litaC_paramDecls)), litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_params.params))), litaC_module->allocator);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_params.params)));litaC_i += 1) {
        {
            litaC_ast__ParameterDecl* litaC_decl = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_params.params)), litaC_i);
            litaC_ast__ParameterDecl* litaC_copy = (litaC_ast__ParameterDecl*)litaC_ast_new__NewParameterDecl(litaC_decl->decl.stmt.node.startPos, litaC_decl->decl.stmt.node.endPos, litaC_decl->decl.name, litaC_ast_copy__CopyTypeSpec(litaC_decl->type, litaC_module), litaC_ast_copy__CopyExpr(litaC_decl->defaultExpr, litaC_module), litaC_decl->decl.attributes.isUsing, litaC_module->allocator);
            litaC_copy->decl.attributes = litaC_decl->decl.attributes;
            litaC_std__array__Array_add_cb__ptr_ParameterDecl_ce_(&((litaC_paramDecls)), litaC_copy);
            
            
        }
    }
    litaC_ast__Stmt* litaC_paramsCopy = litaC_ast_new__NewParametersStmt(litaC_params.stmt.node.startPos, litaC_params.stmt.node.endPos, litaC_paramDecls, litaC_params.isVararg, litaC_module->allocator);
    return (litaC_ast__ParametersStmt*)litaC_paramsCopy;
    
    
}

litaC_ast__TypedefDecl* litaC_ast_copy__CopyTypedefDecl(litaC_ast__TypedefDecl* litaC_decl,litaC_module__Module* litaC_module) {
    litaC_ast__Decl* litaC_copy = litaC_ast_new__NewTypedefDecl(litaC_decl->decl.declaration.stmt.node.startPos, litaC_decl->decl.declaration.stmt.node.endPos, litaC_decl->decl.declaration.name, litaC_std__array__Array_copy_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)), litaC_module->allocator), litaC_ast_copy__CopyTypeSpec(litaC_decl->type, litaC_module), litaC_module->allocator);
    litaC_copy->attributes = litaC_decl->decl.declaration.attributes;
    return (litaC_ast__TypedefDecl*)litaC_copy;
    
    
}

litaC_void litaC_ast_copy__AstInsertText(litaC_ast__Node* litaC_node,const litaC_char* litaC_text,litaC_i32 litaC_index,litaC_module__Module* litaC_module,litaC_lita__Lita* litaC_lita) {
    litaC_parser__Parser litaC_parser = litaC_parser__ParserInit(litaC_node->startPos.filename, litaC_text, strlen(litaC_text), litaC_module, litaC_lita);
    litaC_ast__Stmt* litaC_stmt = litaC_parser__Parser_statement(&((litaC_parser)));
    litaC_ast_copy__AstInsert(litaC_node, litaC_stmt, litaC_index, litaC_module, litaC_lita);
    
}


litaC_void litaC_ast_copy__AstInsert(litaC_ast__Node* litaC_node,litaC_ast__Stmt* litaC_stmt,litaC_i32 litaC_index,litaC_module__Module* litaC_module,litaC_lita__Lita* litaC_lita) {
    switch(litaC_node->kind) {
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                litaC_ast__FuncDecl* litaC_funcDecl = (litaC_ast__FuncDecl*)litaC_node;
                if(!(litaC_funcDecl->body)) {
                    {
                        litaC_funcDecl->body = litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_funcDecl->decl.declaration.stmt.node)), litaC_stmt);
                        
                        
                    }
                    
                } else {
                    {
                        if(litaC_funcDecl->body->node.kind == litaC_ast__StmtKind_FUNC_BODY_STMT) {
                            {
                                litaC_ast__FuncBodyStmt* litaC_body = (litaC_ast__FuncBodyStmt*)litaC_funcDecl->body;
                                litaC_std__array__Array_insertAt_cb__ptr_Stmt_ce_(&((litaC_body->stmts)), litaC_index, litaC_stmt);
                                litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(&((litaC_body->stmt.node)), litaC_stmt);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_stmts = litaC_std__array__ArrayInit_cb__ptr_Stmt_ce_(8, litaC_module->allocator);
                                if(litaC_index) {
                                    {
                                        litaC_std__array__Array_add_cb__ptr_Stmt_ce_(&((litaC_stmts)), litaC_funcDecl->body);
                                        litaC_std__array__Array_add_cb__ptr_Stmt_ce_(&((litaC_stmts)), litaC_stmt);
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        litaC_std__array__Array_add_cb__ptr_Stmt_ce_(&((litaC_stmts)), litaC_stmt);
                                        litaC_std__array__Array_add_cb__ptr_Stmt_ce_(&((litaC_stmts)), litaC_funcDecl->body);
                                        
                                        
                                    }
                                } 
                                
                                litaC_funcDecl->body = litaC_ast_new__NewFuncBodyStmt((litaC_index) ? litaC_funcDecl->body->node.startPos : litaC_stmt->node.startPos, (litaC_index) ? litaC_stmt->node.endPos : litaC_funcDecl->body->node.endPos, litaC_stmts, litaC_module->allocator);
                                
                                
                            }
                        } 
                        
                        
                        
                    }
                } 
                
                break;
                
                
            }
            
            
        }
        default: {
            {
                printf("Assert AstInsert: %s\n", litaC_ast__StmtKindAsStr(litaC_node->kind));
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    
}

const litaC_char* litaC_ast_copy__AstAddImport(litaC_lita__Lita* litaC_lita,litaC_checker__TypeChecker* litaC_checker,litaC_module__Module* litaC_module,litaC_module__Module* litaC_importModule) {
    static 
    litaC_i32 litaC_moduleNameIndex = {0};
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_ImportDecl_ce_(&((litaC_module->ast->imports)));litaC_i += 1) {
        {
            litaC_ast__ImportDecl* litaC_importStmt = litaC_std__array__Array_get_cb__ptr_ImportDecl_ce_(&((litaC_module->ast->imports)), litaC_i);
            if(!(litaC_importStmt->moduleId)) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(strncmp(litaC_importStmt->moduleId->filename, litaC_importModule->id.filename, _MAX_PATH) == 0) {
                {
                    if(litaC_importStmt->alias.token.type == litaC_lex__TokenType_IDENTIFIER) {
                        {
                            return litaC_lex__Token_asString(&((litaC_importStmt->alias.token)));
                            
                            
                            
                        }
                        
                    } else {
                        {
                            return NULL;
                            
                            
                            
                        }
                    } 
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_ast__Identifier litaC_name =  {
        .str = litaC_importModule->id.name,
        .token =  {
            .type = litaC_lex__TokenType_IDENTIFIER,
            .pos = litaC_module->ast->stmt.node.startPos,
            .value =  {
                .str = litaC_importModule->id.name.view
            }
        }
    };
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(16, litaC_lita->allocator);
    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "____%d", litaC_moduleNameIndex += 1);
    litaC_ast__Identifier litaC_alias =  {
        .str = litaC_intern__Strings_internCopy(&((litaC_lita->strings)), litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_sb.length),
        .token =  {
            .type = litaC_lex__TokenType_IDENTIFIER,
            .pos = litaC_module->ast->stmt.node.startPos,
            .value =  {
                .str = litaC_std__string_view__StringViewInit(litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_sb.length)
            }
        }
    };
    litaC_ast__ImportDecl* litaC_importStmt = (litaC_ast__ImportDecl*)litaC_ast_new__NewImportDecl(litaC_module->ast->stmt.node.startPos, litaC_module->ast->stmt.node.startPos, litaC_name, litaC_alias, litaC_false, litaC_lita->allocator);
    litaC_importStmt->moduleId = &(litaC_importModule->id);
    litaC_std__array__Array_add_cb__ptr_ImportDecl_ce_(&((litaC_module->ast->imports)), litaC_importStmt);
    litaC_checker__TypeChecker_enterModule(litaC_checker, litaC_module);
    
    litaC_checker__TypeChecker_createImportSymbols(litaC_checker, litaC_importStmt);
    {
        const litaC_char* ___result = litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb)));
        litaC_checker__TypeChecker_leaveModule(litaC_checker);
        return ___result;
        
    }
    
    litaC_checker__TypeChecker_leaveModule(litaC_checker);
    
}

litaC_void litaC_checker__TypeChecker_init(litaC_checker__TypeChecker* litaC_this,litaC_lita__Lita* litaC_lita) {
    litaC_this->lita = litaC_lita;
    litaC_this->current = NULL;
    litaC_std__array__Array_init_cb__ptr_Module_ce_(&((litaC_this->moduleStack)), 64, litaC_lita->allocator);
    litaC_std__array__Array_init_cb__ptr_TypeInfo_ce_(&((litaC_this->funcDeclStack)), 64, litaC_lita->allocator);
    litaC_std__array__Array_init_cb__ptr_Symbol_ce_(&((litaC_this->pendingValues)), 128, litaC_lita->allocator);
    litaC_std__array__Array_init_cb__ptr_Symbol_ce_(&((litaC_this->symbolTypes)), 256, litaC_lita->allocator);
    litaC_std__array__Array_init_cb__ptr_Symbol_ce_(&((litaC_this->symbolFuncs)), 256, litaC_lita->allocator);
    litaC_std__array__Array_init_cb__ptr_Symbol_ce_(&((litaC_this->symbolTraits)), 64, litaC_lita->allocator);
    litaC_std__array__Array_init_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)), 128, litaC_lita->allocator);
    litaC_std__array__Array_init_cb__ptr_Symbol_ce_(&((litaC_this->genericTemplates)), 64, litaC_lita->allocator);
    litaC_this->genericContext.callsite = NULL;
    litaC_std__map__Map_init_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_this->interfaceImpls)), (litaC_std__array__Array_cb_i64_ce_) {
        
    }, 128, litaC_std__map__PtrHashFn_cb_i64_ce_, litaC_std__map__PtrEqualFn_cb_i64_ce_, litaC_lita->allocator, 0);
    litaC_this->bypassing = litaC_false;
    litaC_this->typeCache = &(litaC_lita->typeCache);
    litaC_this->mainEntry = NULL;
    memset(litaC_this->labels, 0, litaC_checker__MAX_LABELS * sizeof(litaC_checker__LabelInfo));
    litaC_this->numOfLabels = 0;
    
}


litaC_symbols__ProgramSymbols litaC_checker__TypeChecker_typeCheck(litaC_checker__TypeChecker* litaC_this,litaC_module__Module* litaC_root,litaC_i32 litaC_flags) {
    if(litaC_root->flags & litaC_module__ModuleFlags_TYPE_CHECKED) {
        {
            goto exit;
            
            
            
        }
        
    } 
    
    litaC_root->flags |= litaC_module__ModuleFlags_TYPE_CHECKED;
    litaC_checker__TypeChecker_createModuleSymbols(litaC_this, litaC_root);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Decl_ce_(&((litaC_root->ast->declarations)));litaC_i += 1) {
        {
            litaC_ast__Decl* litaC_decl = litaC_std__array__Array_get_cb__ptr_Decl_ce_(&((litaC_root->ast->declarations)), litaC_i);
            if(litaC_decl->sym && litaC_decl->stmt.node.kind == litaC_ast__StmtKind_FUNC_DECL && litaC_intern__InternedString_equals(&((litaC_decl->sym->name)), &((litaC_intern__MAIN)))) {
                {
                    litaC_this->mainEntry = litaC_decl->sym;
                    litaC_this->mainEntry->flags |= litaC_symbols__SymbolFlags_IS_MAIN;
                    break;
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_bool litaC_isIncrementalBuild = (litaC_root->flags & litaC_module__ModuleFlags_INCREMENTAL_COMPILATION) > 0;
    litaC_preprocessor__Preprocessor_preResolveSymbols(&((litaC_this->lita->preprocessor)), litaC_this, litaC_isIncrementalBuild);
    if(litaC_this->lita->options->instrument && !(litaC_phase_result__PhaseResult_hasErrors(&((litaC_this->lita->result))))) {
        {
            litaC_instrument__Instrument(litaC_this->lita, litaC_this);
            
            
        }
        
    } 
    
    litaC_checker__TypeChecker_resolveSymbols(litaC_this);
    litaC_preprocessor__Preprocessor_postResolveSymbols(&((litaC_this->lita->preprocessor)), litaC_this, litaC_isIncrementalBuild);
    if(!((litaC_flags & litaC_checker__TypeCheckerFlags_DISABLE_TRAIT_WRAPPERS))) {
        {
            litaC_checker__TypeChecker_enterModule(litaC_this, litaC_root);
            {
                litaC_std__array__Array_cb__ptr_Decl_ce_ litaC_traitDecls = litaC_traits__CreateTraitWrappers(litaC_this);
                litaC_this->bypassing = litaC_true;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Decl_ce_(&((litaC_traitDecls)));litaC_i += 1) {
                    {
                        litaC_ast__Decl* litaC_decl = litaC_std__array__Array_get_cb__ptr_Decl_ce_(&((litaC_traitDecls)), litaC_i);
                        litaC_symbols__Symbol* litaC_sym = litaC_checker__TypeChecker_createDeclSymbol(litaC_this, litaC_decl);
                        if(litaC_sym == NULL) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        litaC_checker__TypeChecker_resolveSymbol(litaC_this, litaC_sym);
                        litaC_checker__TypeChecker_finishResolveSymbol(litaC_this, litaC_sym);
                        
                        
                    }
                }
                litaC_this->bypassing = litaC_false;
                
                
            }
            litaC_checker__TypeChecker_leaveModule(litaC_this);
            
            
        }
        
    } 
    
    if(!(litaC_phase_result__PhaseResult_hasErrors(&((litaC_this->lita->result))))) {
        {
            litaC_introspection__Introspect litaC_introspect =  {
                .lita = litaC_this->lita
            };
            litaC_introspection__Introspect_generate(&((litaC_introspect)), litaC_this);
            
            
        }
        
    } 
    
    exit:;
    
    return (litaC_symbols__ProgramSymbols) {
        .root = litaC_root,
        .values = litaC_this->pendingValues,
        .symbolTypes = litaC_this->symbolTypes,
        .symbolFuncs = litaC_this->symbolFuncs,
        .mainEntry = litaC_this->mainEntry,
        .interfaceImpls = litaC_this->interfaceImpls
    };
    
    
}

LITAC_INLINE 
litaC_i32 litaC_checker__TypeChecker_errors(litaC_checker__TypeChecker* litaC_this) {
    return litaC_std__array__Array_size_cb_PhaseError_ce_(&((litaC_this->lita->result.errors)));
    
    
}

litaC_bool litaC_checker__TypeChecker_checkTrait(litaC_checker__TypeChecker* litaC_this,litaC_std__string_buffer__StringBuffer* litaC_sb,litaC_types__TypeInfo* litaC_a,litaC_types__TypeInfo* litaC_b,const litaC_char* litaC_description) {
    if(litaC_types__IsTraitLike(litaC_a)) {
        {
            litaC_types__TypeInfo* litaC_aTrait = litaC_types__TypeInfo_getBaseType(litaC_a);
            if(litaC_types__IsPtr(litaC_a)) {
                {
                    if(!(litaC_types__IsPtrTrait(litaC_b))) {
                        {
                            litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, "'", 1);
                            litaC_types__TypeInfo_toString(litaC_b, litaC_sb, litaC_false);
                            litaC_std__string_buffer__StringBuffer_appendStr(litaC_sb, litaC_description);
                            litaC_types__TypeInfo_toString(litaC_a, litaC_sb, litaC_false);
                            litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, "'", 1);
                            litaC_std__string_buffer__StringBuffer_appendStr(litaC_sb, "; assigned trait pointers can only be assigned from a trait type and not an implementation type");
                            return litaC_true;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            if(!(litaC_types__IsPtr(litaC_b)) && litaC_types__IsAggregate(litaC_b)) {
                {
                    litaC_types__TypeInfo* litaC_aggInfo = litaC_types__TypeInfo_getBaseType(litaC_b);
                    if(litaC_types__TypeInfo_implementsTrait(litaC_aggInfo, litaC_aTrait, litaC_this)) {
                        {
                            litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, "'", 1);
                            litaC_types__TypeInfo_toString(litaC_b, litaC_sb, litaC_false);
                            litaC_std__string_buffer__StringBuffer_appendStr(litaC_sb, litaC_description);
                            litaC_types__TypeInfo_toString(litaC_a, litaC_sb, litaC_false);
                            litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, "'", 1);
                            litaC_std__string_buffer__StringBuffer_appendStr(litaC_sb, "; assigned trait implementations must be pointers: e.g. '*");
                            litaC_types__TypeInfo_toString(litaC_b, litaC_sb, litaC_false);
                            litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, "'", 1);
                            return litaC_true;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } else {
                {
                    litaC_types__TypeInfo* litaC_aggInfo = litaC_types__TypeInfo_getBaseType(litaC_b);
                    if(!(litaC_types__TypeInfo_implementsTrait(litaC_aggInfo, litaC_aTrait, litaC_this))) {
                        {
                            litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, "'", 1);
                            litaC_types__TypeInfo_toString(litaC_b, litaC_sb, litaC_false);
                            litaC_std__string_buffer__StringBuffer_appendStr(litaC_sb, litaC_description);
                            litaC_types__TypeInfo_toString(litaC_a, litaC_sb, litaC_false);
                            litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, "'; '", 4);
                            litaC_types__TypeInfo_toString(litaC_b, litaC_sb, litaC_false);
                            litaC_std__string_buffer__StringBuffer_appendStr(litaC_sb, "' doesn't implement all of '");
                            litaC_types__TypeInfo_toString(litaC_a, litaC_sb, litaC_false);
                            litaC_std__string_buffer__StringBuffer_appendStr(litaC_sb, "' trait methods");
                            return litaC_true;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            } 
            
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_bool litaC_checker__TypeChecker_checkCastability(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_src,litaC_types__TypeInfo* litaC_a,litaC_types__TypeInfo* litaC_b) {
    if(litaC_a == NULL || litaC_b == NULL) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_types__TypeInfo_canCastTo(litaC_a, litaC_b, litaC_this))) {
        {
            litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
            if(litaC_checker__TypeChecker_checkTrait(litaC_this, &((litaC_sb)), litaC_a, litaC_b, "' can't be casted to '")) {
                {
                    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_src, &((litaC_sb)));
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
            litaC_types__TypeInfo_toString(litaC_a, &((litaC_sb)), litaC_false);
            litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), "' can't be casted to '");
            litaC_types__TypeInfo_toString(litaC_b, &((litaC_sb)), litaC_false);
            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
            litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_src, &((litaC_sb)));
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker__TypeChecker_checkAssignability(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_src,litaC_types__TypeInfo* litaC_a,litaC_types__TypeInfo* litaC_b,litaC_bool litaC_allowDecay) {
    if(litaC_a == NULL || litaC_b == NULL) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_types__TypeInfo_isAssignable(litaC_a, litaC_b, litaC_this, litaC_allowDecay, litaC_true)) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    if(litaC_types__IsTraitLike(litaC_a)) {
        {
            litaC_types__TypeInfo* litaC_aTrait = litaC_types__TypeInfo_getBaseType(litaC_a);
            if(!(litaC_types__IsPtr(litaC_b))) {
                {
                    litaC_types__TypeInfo* litaC_aggInfo = litaC_types__TypeInfo_getBaseType(litaC_b);
                    if(litaC_types__TypeInfo_implementsTrait(litaC_aggInfo, litaC_aTrait, litaC_this)) {
                        {
                            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
                            litaC_types__TypeInfo_toString(litaC_b, &((litaC_sb)), litaC_false);
                            litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), "' can't be assigned to '");
                            litaC_types__TypeInfo_toString(litaC_a, &((litaC_sb)), litaC_false);
                            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
                            litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), "; assigned trait implementations must be pointers: e.g. '*");
                            litaC_types__TypeInfo_toString(litaC_b, &((litaC_sb)), litaC_false);
                            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
                            litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_src, &((litaC_sb)));
                            return litaC_false;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_types__TypeInfo_toString(litaC_b, &((litaC_sb)), litaC_false);
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), "' can't be assigned to '");
    litaC_types__TypeInfo_toString(litaC_a, &((litaC_sb)), litaC_false);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_src, &((litaC_sb)));
    return litaC_false;
    
    
}

litaC_bool litaC_checker__TypeChecker_checkDeclarability(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_src,litaC_types__TypeInfo* litaC_a,litaC_types__TypeInfo* litaC_b) {
    if(litaC_a == NULL || litaC_b == NULL) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_types__TypeInfo_isDeclarable(litaC_a, litaC_b, litaC_this))) {
        {
            litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
            if(litaC_checker__TypeChecker_checkTrait(litaC_this, &((litaC_sb)), litaC_a, litaC_b, "' can't be assigned to '")) {
                {
                    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_src, &((litaC_sb)));
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
            litaC_types__TypeInfo_toString(litaC_b, &((litaC_sb)), litaC_false);
            litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), "' can't be assigned to '");
            litaC_types__TypeInfo_toString(litaC_a, &((litaC_sb)), litaC_false);
            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
            litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_src, &((litaC_sb)));
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker__TypeChecker_checkTypeCompatibility(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_src,litaC_types__TypeInfo* litaC_a,litaC_types__TypeInfo* litaC_b,litaC_bool litaC_allowPtrArithmetic) {
    if(litaC_a == NULL || litaC_b == NULL) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_types__TypeInfo_isAssignable(litaC_a, litaC_b, litaC_this, litaC_true, litaC_allowPtrArithmetic))) {
        {
            litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
            if(litaC_checker__TypeChecker_checkTrait(litaC_this, &((litaC_sb)), litaC_a, litaC_b, "' is not of type '")) {
                {
                    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_src, &((litaC_sb)));
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
            litaC_types__TypeInfo_toString(litaC_b, &((litaC_sb)), litaC_false);
            litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), "' is not of type '");
            litaC_types__TypeInfo_toString(litaC_a, &((litaC_sb)), litaC_false);
            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
            litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_src, &((litaC_sb)));
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker__TypeChecker_checkNote(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_src,litaC_types__TypeInfo* litaC_a) {
    if(litaC_a == NULL) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_types__IsFieldAccessible(litaC_a))) {
        {
            litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
            litaC_types__TypeInfo_toString(litaC_a, &((litaC_sb)), litaC_false);
            litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), "' must be either a struct, union or enum");
            litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_src, &((litaC_sb)));
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_void litaC_checker__TypeChecker_createModuleSymbols(litaC_checker__TypeChecker* litaC_this,litaC_module__Module* litaC_module) {
    if(!(litaC_module->ast)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_checker__TypeChecker_enterModule(litaC_this, litaC_module);
    
    if(!(litaC_this->lita->options->testsOnly)) {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Decl_ce_(&((litaC_module->ast->declarations)));) {
                {
                    litaC_ast__Decl* litaC_decl = litaC_std__array__Array_get_cb__ptr_Decl_ce_(&((litaC_module->ast->declarations)), litaC_i);
                    if(litaC_ast__Decl_hasNote(litaC_decl, "test")) {
                        {
                            litaC_std__array__Array_removeAt_cb__ptr_Decl_ce_(&((litaC_module->ast->declarations)), litaC_i);
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_i += 1;
                            
                            
                        }
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Decl_ce_(&((litaC_module->ast->declarations)));litaC_i += 1) {
        {
            litaC_ast__Decl* litaC_decl = litaC_std__array__Array_get_cb__ptr_Decl_ce_(&((litaC_module->ast->declarations)), litaC_i);
            litaC_checker__TypeChecker_createDeclSymbol(litaC_this, litaC_decl);
            
            
        }
    }
    if((litaC_module->flags & litaC_module__ModuleFlags_TYPE_IMPORTED)) {
        {
            litaC_checker__TypeChecker_leaveModule(litaC_this);
            return;
            
            
            
        }
        
    } 
    
    litaC_module->flags |= litaC_module__ModuleFlags_TYPE_IMPORTED;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_ImportDecl_ce_(&((litaC_module->ast->imports)));litaC_i += 1) {
        {
            litaC_ast__ImportDecl* litaC_imp = litaC_std__array__Array_get_cb__ptr_ImportDecl_ce_(&((litaC_module->ast->imports)), litaC_i);
            litaC_checker__TypeChecker_createImportSymbols(litaC_this, litaC_imp);
            
            
        }
    }
    litaC_checker__TypeChecker_resolveNotes(litaC_this, &((litaC_module->ast->notes)));
    litaC_checker__TypeChecker_leaveModule(litaC_this);
    
}

litaC_symbols__Symbol* litaC_checker__TypeChecker_createDeclSymbol(litaC_checker__TypeChecker* litaC_this,litaC_ast__Decl* litaC_decl) {
    assert(litaC_decl != NULL);
    if(litaC_decl->sym) {
        {
            return litaC_decl->sym;
            
            
            
        }
        
    } 
    
    litaC_intern__InternedString litaC_name = litaC_intern__EMPTY_STR;
    if(litaC_decl->name.token.type == litaC_lex__TokenType_IDENTIFIER) {
        {
            litaC_name = litaC_decl->name.str;
            
            
        }
        
    } else {
        {
            litaC_char litaC_buffer[256] =  {
                
            };
            litaC_std__string__String litaC_nameStr = litaC_std__string__StringInit(litaC_buffer, litaC_symbols__MAX_SYMBOL_NAME, 0);
            litaC_std__string__String_format(&((litaC_nameStr)), "anon_%d", litaC_this->randomNameIndex);
            litaC_name = litaC_intern__Strings_internCopy(&((litaC_this->lita->strings)), litaC_std__string__String_cStr(litaC_nameStr), litaC_nameStr.length);
            litaC_this->randomNameIndex += 1;
            
            
        }
    } 
    
    litaC_symbols__Symbol* litaC_sym = NULL;
    if(litaC_decl->stmt.node.kind != litaC_ast__StmtKind_FUNC_DECL) {
        {
            litaC_sym = litaC_symbols__Scope_addSymbol(&((litaC_this->current->symbols)), litaC_name, litaC_this->current, litaC_decl, litaC_symbols__SymbolFlags_IS_INCOMPLETE);
            if(!(litaC_sym)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    switch(litaC_decl->stmt.node.kind) {
        case litaC_ast__StmtKind_CONST_DECL: 
        case litaC_ast__StmtKind_VAR_DECL: {
            {
                litaC_ast__VarDecl* litaC_varDecl = (litaC_ast__VarDecl*)litaC_decl;
                litaC_bool litaC_isValid = litaC_false;
                litaC_bool litaC_hasNotes = litaC_ast__Decl_hasNotes(&((litaC_varDecl->decl)));
                if(litaC_ast__Expr_isConstExpr(litaC_varDecl->expr) || litaC_ast__Decl_hasNote(&((litaC_varDecl->decl)), "foreign")) {
                    {
                        litaC_this->lita->result.enabled = litaC_false;
                        litaC_types__TypeInfo* litaC_type = litaC_checker_decl__TypeChecker_resolveValueDecl(litaC_this, litaC_varDecl);
                        litaC_isValid = litaC_type != NULL;
                        litaC_this->lita->result.enabled = litaC_true;
                        if(litaC_isValid) {
                            {
                                if(!(litaC_hasNotes)) {
                                    {
                                        litaC_checker__TypeChecker_resolveSymbol(litaC_this, litaC_sym);
                                        litaC_checker__TypeChecker_finishResolveSymbol(litaC_this, litaC_sym);
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        litaC_sym->type = litaC_type;
                                        
                                        
                                    }
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_isValid) || litaC_hasNotes) {
                    {
                        litaC_std__array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->pendingValues)), litaC_sym);
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                litaC_ast__FuncDecl* litaC_funcDecl = (litaC_ast__FuncDecl*)litaC_decl;
                if(litaC_funcDecl->flags & litaC_ast__FuncFlags_IS_METHOD) {
                    {
                        litaC_char litaC_buffer[256] =  {
                            
                        };
                        if(!(litaC_ast__FuncDecl_getName(litaC_funcDecl, litaC_buffer))) {
                            {
                                litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_decl->stmt.node.startPos, "invalid function name or invalid method caller type");
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_name = litaC_intern__Strings_internCopy(&((litaC_this->lita->strings)), litaC_buffer, -(1));
                        
                        
                    }
                    
                } 
                
                litaC_sym = litaC_symbols__Scope_addSymbol(&((litaC_this->current->symbols)), litaC_name, litaC_this->current, litaC_decl, litaC_symbols__SymbolFlags_IS_INCOMPLETE);
                if(!(litaC_sym)) {
                    {
                        goto err;
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_std__array__Array_empty_cb_GenericParam_ce_(&((litaC_funcDecl->decl.genericParams))))) {
                    {
                        litaC_sym->flags |= litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE;
                        litaC_std__array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->genericTemplates)), litaC_sym);
                        
                        
                    }
                    
                } 
                
                litaC_sym->type = litaC_types_new__TypeCache_newFuncTypeInfo(litaC_this->typeCache, litaC_sym, litaC_funcDecl);
                litaC_std__array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->symbolFuncs)), litaC_sym);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: {
            {
                litaC_std__array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->symbolTypes)), litaC_sym);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NOTE_DECL: {
            {
                litaC_checker__TypeChecker_resolveSymbol(litaC_this, litaC_sym);
                litaC_checker__TypeChecker_finishResolveSymbol(litaC_this, litaC_sym);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_aggDecl = (litaC_ast__AggregateDecl*)litaC_decl;
                if(!(litaC_std__array__Array_empty_cb_GenericParam_ce_(&((litaC_aggDecl->decl.genericParams))))) {
                    {
                        litaC_sym->flags |= litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE;
                        litaC_std__array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->genericTemplates)), litaC_sym);
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_aggDecl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__FieldStmt* litaC_field = &(litaC_aggDecl->fields.elements[litaC_i]);
                        switch(litaC_field->kind) {
                            case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                {
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                {
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                {
                                    litaC_symbols__Symbol* litaC_sym = litaC_checker__TypeChecker_createDeclSymbol(litaC_this, &((litaC_field->enumField->decl)));
                                    litaC_field->enumField->decl.sym = litaC_sym;
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                            case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                                {
                                    if(!((litaC_aggDecl->decl.declaration.sym->flags & litaC_symbols__SymbolFlags_IS_FROM_GENERIC_TEMPLATE))) {
                                        {
                                            litaC_field->aggregateField->decl.declaration.sym = litaC_checker__TypeChecker_createDeclSymbol(litaC_this, &((litaC_field->aggregateField->decl.declaration)));
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_POISON_EXPR: {
                                {
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            default: {
                                {
                                    assert(litaC_false);
                                    
                                    
                                }
                                
                                
                            }
                        }
                        
                        
                    }
                }
                litaC_std__array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->symbolTypes)), litaC_sym);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                litaC_ast__TypedefDecl* litaC_typedefDecl = (litaC_ast__TypedefDecl*)litaC_decl;
                if(!(litaC_std__array__Array_empty_cb_GenericParam_ce_(&((litaC_typedefDecl->decl.genericParams))))) {
                    {
                        litaC_sym->flags |= litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE;
                        
                        
                    }
                    
                } 
                
                litaC_std__array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->symbolTypes)), litaC_sym);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_DECL: {
            {
                break;
                
                
            }
            
            
        }
        default: {
            {
                litaC_ast_print__PrintStmt((litaC_ast__Stmt*)litaC_decl, 0);
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return litaC_sym;
    
    err:;
    
    return NULL;
    
    
}

litaC_void litaC_checker__TypeChecker_enterModule(litaC_checker__TypeChecker* litaC_this,litaC_module__Module* litaC_module) {
    litaC_std__array__Array_push_cb__ptr_Module_ce_(&((litaC_this->moduleStack)), litaC_module);
    litaC_this->current = litaC_module;
    
}

litaC_void litaC_checker__TypeChecker_leaveModule(litaC_checker__TypeChecker* litaC_this) {
    if(litaC_std__array__Array_size_cb__ptr_Module_ce_(&((litaC_this->moduleStack)))) {
        {
            litaC_std__array__Array_pop_cb__ptr_Module_ce_(&((litaC_this->moduleStack)));
            if(litaC_std__array__Array_size_cb__ptr_Module_ce_(&((litaC_this->moduleStack)))) {
                {
                    litaC_this->current = litaC_std__array__Array_last_cb__ptr_Module_ce_(&((litaC_this->moduleStack)));
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    
}

litaC_symbols__Scope* litaC_checker__TypeChecker_currentScope(litaC_checker__TypeChecker* litaC_this) {
    return litaC_this->current->currentScope;
    
    
}

litaC_void litaC_checker__TypeChecker_pushScope(litaC_checker__TypeChecker* litaC_this,litaC_symbols__Scope* litaC_scope) {
    litaC_symbols__Scope_init(litaC_scope, litaC_symbols__ScopeKind_FUNC, litaC_checker__TypeChecker_currentScope(litaC_this), &((litaC_this->lita->result)), litaC_this->current, litaC_this->current->allocator);
    litaC_this->current->currentScope = litaC_scope;
    
}

litaC_void litaC_checker__TypeChecker_popScope(litaC_checker__TypeChecker* litaC_this) {
    if(litaC_checker__TypeChecker_currentScope(litaC_this)) {
        {
            litaC_this->current->currentScope = litaC_this->current->currentScope->parent;
            
            
        }
        
    } 
    
    
}

litaC_bool litaC_checker__TypeChecker_isGenericParamType(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypeSpec* litaC_name) {
    for(litaC_i32 litaC_k = 0;litaC_k < litaC_std__array__Array_size_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));litaC_k += 1) {
        {
            litaC_std__array__Array_cb_GenericParam_ce_* litaC_params = &(litaC_this->genericParamStack.elements[litaC_k]);
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_GenericParam_ce_(litaC_params);litaC_i += 1) {
                {
                    litaC_ast__GenericParam litaC_param = litaC_std__array__Array_get_cb_GenericParam_ce_(litaC_params, litaC_i);
                    assert(litaC_param.name.token.type == litaC_lex__TokenType_IDENTIFIER);
                    if(litaC_intern__InternedString_equals(&((litaC_param.name.str)), &((litaC_name->name)))) {
                        {
                            return litaC_true;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_void litaC_checker__TypeChecker_createImportSymbols(litaC_checker__TypeChecker* litaC_this,litaC_ast__ImportDecl* litaC_imp) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_ImportDecl_ce_(&((litaC_this->current->ast->imports)));litaC_i += 1) {
        {
            litaC_ast__ImportDecl* litaC_other = litaC_std__array__Array_get_cb__ptr_ImportDecl_ce_(&((litaC_this->current->ast->imports)), litaC_i);
            if(litaC_imp == litaC_other) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_intern__InternedString_equals(&((litaC_other->decl.name.str)), &((litaC_imp->decl.name.str)))) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_imp->decl.stmt.node.startPos, "duplicate import of module '%.*s'", litaC_imp->decl.name.str.length, litaC_imp->decl.name.str.buffer);
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    if(!(litaC_imp->moduleId)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_module__Module* litaC_module = litaC_lita__Lita_getModule(litaC_this->lita, litaC_imp->moduleId->filename);
    if(!(litaC_module)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_imp->decl.stmt.node.startPos, "could not find module '%s'", litaC_imp->moduleId->filename);
            goto err;
            
            
            
        }
        
    } 
    
    if(litaC_module == litaC_this->current) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(!((litaC_module->flags & litaC_module__ModuleFlags_TYPE_RESOLVED))) {
        {
            litaC_module->flags |= litaC_module__ModuleFlags_TYPE_RESOLVED;
            litaC_checker__TypeChecker_createModuleSymbols(litaC_this, litaC_module);
            
            
        }
        
    } 
    
    litaC_module__Module_importModule(litaC_this->current, litaC_imp, litaC_module);
    err:;
    
    return;
    
    
}

litaC_void litaC_checker__TypeChecker_resolveSymbols(litaC_checker__TypeChecker* litaC_this) {
    {
        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_this->symbolTypes)));litaC_i += 1) {
            {
                litaC_symbols__Symbol* litaC_symbol = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_this->symbolTypes)), litaC_i);
                litaC_checker__TypeChecker_resolveSymbol(litaC_this, litaC_symbol);
                
                
            }
        }
        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_this->symbolTypes)));litaC_i += 1) {
            {
                litaC_symbols__Symbol* litaC_symbol = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_this->symbolTypes)), litaC_i);
                litaC_checker__TypeChecker_finishResolveSymbol(litaC_this, litaC_symbol);
                
                
            }
        }
        
        
    }
    {
        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_this->symbolFuncs)));litaC_i += 1) {
            {
                litaC_symbols__Symbol* litaC_symbol = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_this->symbolFuncs)), litaC_i);
                litaC_checker__TypeChecker_resolveSymbol(litaC_this, litaC_symbol);
                
                
            }
        }
        
        
    }
    {
        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_this->pendingValues)));litaC_i += 1) {
            {
                litaC_symbols__Symbol* litaC_symbol = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_this->pendingValues)), litaC_i);
                litaC_checker__TypeChecker_finishResolveSymbol(litaC_this, litaC_symbol);
                
                
            }
        }
        
        
    }
    {
        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_this->symbolFuncs)));litaC_i += 1) {
            {
                litaC_symbols__Symbol* litaC_symbol = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_this->symbolFuncs)), litaC_i);
                litaC_checker__TypeChecker_finishResolveSymbol(litaC_this, litaC_symbol);
                
                
            }
        }
        
        
    }
    
}

litaC_void litaC_checker__TypeChecker_resolveSymbol(litaC_checker__TypeChecker* litaC_this,litaC_symbols__Symbol* litaC_sym) {
    if(litaC_sym->state == litaC_symbols__SymbolState_RESOLVED || litaC_sym->state == litaC_symbols__SymbolState_ERROR) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_sym->state == litaC_symbols__SymbolState_RESOLVING) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_sym->decl->stmt.node.startPos, "cyclic dependency found with '%.*s'", litaC_sym->name.length, litaC_sym->name.buffer);
            goto err;
            
            
            
        }
        
    } 
    
    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_MARKED_RESET) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_checker__TypeChecker_enterModule(litaC_this, litaC_sym->declared);
    
    litaC_sym->state = litaC_symbols__SymbolState_RESOLVING;
    switch(litaC_sym->kind) {
        case litaC_symbols__SymbolKind_TYPE: {
            {
                switch(litaC_sym->decl->stmt.node.kind) {
                    case litaC_ast__StmtKind_ENUM_DECL: {
                        {
                            litaC_ast__EnumDecl* litaC_enumDecl = (litaC_ast__EnumDecl*)litaC_sym->decl;
                            litaC_sym->type = (litaC_types__TypeInfo*)litaC_types_new__TypeCache_newEnumTypeInfo(litaC_this->typeCache, litaC_sym, litaC_enumDecl);
                            break;
                            
                            
                        }
                        
                        
                    }
                    case litaC_ast__StmtKind_TYPEDEF_DECL: {
                        {
                            litaC_ast__TypedefDecl* litaC_typedefDecl = (litaC_ast__TypedefDecl*)litaC_sym->decl;
                            litaC_bool litaC_hasGenerics = !(litaC_std__array__Array_empty_cb_GenericParam_ce_(&((litaC_typedefDecl->decl.genericParams))));
                            if(litaC_hasGenerics) {
                                {
                                    litaC_std__array__Array_add_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)), litaC_typedefDecl->decl.genericParams);
                                    
                                    
                                }
                                
                            } 
                            
                            
                            litaC_types__TypeInfo* litaC_aliasedType = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_typedefDecl->type, litaC_checker__SearchType_TYPE);
                            if(!(litaC_aliasedType)) {
                                {
                                    goto err;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            if(litaC_ast__Decl_hasNote(&((litaC_typedefDecl->decl.declaration)), "foreign") && litaC_aliasedType->kind == litaC_types__TypeKind_VOID) {
                                {
                                    litaC_aliasedType = litaC_types_new__TypeCache_newForeignTypeInfo(litaC_this->typeCache, litaC_sym);
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_sym->type = litaC_aliasedType;
                            if(litaC_hasGenerics) {
                                {
                                    litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                    
                                    
                                }
                                
                            } 
                            ;
                            break;
                            if(litaC_hasGenerics) {
                                {
                                    litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                    
                                    
                                }
                                
                            } 
                            ;
                            
                            
                        }
                        
                        
                    }
                    case litaC_ast__StmtKind_NOTE_DECL: 
                    case litaC_ast__StmtKind_TRAIT_DECL: 
                    case litaC_ast__StmtKind_STRUCT_DECL: 
                    case litaC_ast__StmtKind_UNION_DECL: {
                        {
                            litaC_ast__AggregateDecl* litaC_aggregateDecl = (litaC_ast__AggregateDecl*)litaC_sym->decl;
                            litaC_sym->type = (litaC_types__TypeInfo*)litaC_types_new__TypeCache_newAggregateTypeInfo(litaC_this->typeCache, litaC_sym, litaC_aggregateDecl);
                            break;
                            
                            
                        }
                        
                        
                    }
                    case litaC_ast__StmtKind_POISON_DECL: {
                        {
                            goto err;
                            
                            
                            
                        }
                        
                        
                    }
                    default: {
                        {
                            litaC_common__Info("StmtKind %.*s %d %s\n", litaC_sym->name.length, litaC_sym->name.buffer, litaC_sym->decl->stmt.node.kind, litaC_ast__StmtKindAsStr(litaC_sym->decl->stmt.node.kind));
                            assert(litaC_false);
                            
                            
                        }
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_symbols__SymbolKind_VAR: {
            {
                if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_CONSTANT) {
                    {
                        litaC_ast__VarDecl* litaC_decl = (litaC_ast__VarDecl*)litaC_sym->decl;
                        if(litaC_decl && litaC_decl->expr && litaC_decl->expr->operand.isConst) {
                            {
                                litaC_sym->val = litaC_decl->expr->operand.val;
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                if(!((litaC_sym->flags & litaC_symbols__SymbolFlags_IS_LOCAL))) {
                    {
                        litaC_std__array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->pendingValues)), litaC_sym);
                        litaC_checker__TypeChecker_leaveModule(litaC_this);
                        return;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_symbols__SymbolKind_FUNC: {
            {
                litaC_ast__FuncDecl* litaC_funcDecl = (litaC_ast__FuncDecl*)litaC_sym->decl;
                litaC_types__TypeInfo* litaC_funcInfo = litaC_types_new__TypeCache_newFuncTypeInfo(litaC_this->typeCache, litaC_sym, litaC_funcDecl);
                litaC_bool litaC_hasGenerics = !(litaC_std__array__Array_empty_cb_GenericParam_ce_(&((litaC_funcDecl->decl.genericParams))));
                if(litaC_hasGenerics) {
                    {
                        litaC_std__array__Array_add_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)), litaC_funcDecl->decl.genericParams);
                        
                        
                    }
                    
                } 
                
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcDecl->params->params)));litaC_i += 1) {
                    {
                        litaC_ast__ParameterDecl* litaC_param = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcDecl->params->params)), litaC_i);
                        litaC_param->typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_param->type, litaC_checker__SearchType_TYPE);
                        if(!(litaC_param->typeInfo)) {
                            {
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                litaC_types__TypeInfo* litaC_retType = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_funcDecl->returnType, litaC_checker__SearchType_TYPE);
                if(!(litaC_retType)) {
                    {
                        goto err;
                        
                        
                        
                    }
                    
                } 
                
                litaC_funcInfo->returnType = litaC_types_new__TypeCache_typeDecay(litaC_this->typeCache, litaC_retType);
                litaC_sym->type = (litaC_types__TypeInfo*)litaC_funcInfo;
                if(litaC_hasGenerics) {
                    {
                        litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                        
                        
                    }
                    
                } 
                ;
                break;
                if(litaC_hasGenerics) {
                    {
                        litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                        
                        
                    }
                    
                } 
                ;
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    litaC_sym->state = litaC_symbols__SymbolState_RESOLVED;
    litaC_checker__TypeChecker_leaveModule(litaC_this);
    return;
    
    err:;
    
    litaC_sym->state = litaC_symbols__SymbolState_ERROR;
    if(!(litaC_sym->type)) {
        {
            litaC_sym->type = &(litaC_types__POISON_TYPE);
            
            
        }
        
    } 
    
    litaC_checker__TypeChecker_leaveModule(litaC_this);
    return;
    
    litaC_checker__TypeChecker_leaveModule(litaC_this);
    
}

litaC_void litaC_checker__TypeChecker_finishResolveSymbol(litaC_checker__TypeChecker* litaC_this,litaC_symbols__Symbol* litaC_sym) {
    if(!((litaC_sym->flags & litaC_symbols__SymbolFlags_IS_INCOMPLETE))) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_MARKED_RESET) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_checker__TypeChecker_enterModule(litaC_this, litaC_sym->declared);
    
    litaC_sym->flags &= ~(litaC_symbols__SymbolFlags_IS_INCOMPLETE);
    switch(litaC_sym->decl->stmt.node.kind) {
        case litaC_ast__StmtKind_NOTE_DECL: 
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_aggDecl = (litaC_ast__AggregateDecl*)litaC_sym->decl;
                litaC_checker_decl__TypeChecker_resolveAggregateDecl(litaC_this, litaC_aggDecl);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: {
            {
                litaC_ast__EnumDecl* litaC_enumDecl = (litaC_ast__EnumDecl*)litaC_sym->decl;
                litaC_checker_decl__TypeChecker_resolveEnumDecl(litaC_this, litaC_enumDecl);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                litaC_ast__TypedefDecl* litaC_typedefDecl = (litaC_ast__TypedefDecl*)litaC_sym->decl;
                litaC_checker_decl__TypeChecker_resolveTypedefDecl(litaC_this, litaC_typedefDecl);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                if((litaC_sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE)) {
                    {
                        litaC_checker__TypeChecker_leaveModule(litaC_this);
                        return;
                        
                        
                        
                    }
                    
                } 
                
                litaC_ast__FuncDecl* litaC_funcDecl = (litaC_ast__FuncDecl*)litaC_sym->decl;
                litaC_checker_decl__TypeChecker_resolveFuncDecl(litaC_this, litaC_funcDecl);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONST_DECL: 
        case litaC_ast__StmtKind_VAR_DECL: {
            {
                litaC_ast__VarDecl* litaC_varDecl = (litaC_ast__VarDecl*)litaC_sym->decl;
                litaC_sym->type = litaC_checker_decl__TypeChecker_resolveValueDecl(litaC_this, litaC_varDecl);
                litaC_sym->state = litaC_symbols__SymbolState_RESOLVED;
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_DECL: {
            {
                litaC_sym->state = litaC_symbols__SymbolState_RESOLVED;
                break;
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    litaC_checker__TypeChecker_leaveModule(litaC_this);
    
}

litaC_symbols__Symbol* litaC_checker__TypeChecker_getType(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypeSpec* litaC_spec,litaC_checker__SearchType litaC_searchType) {
    assert(litaC_spec != NULL);
    return litaC_checker__TypeChecker_getTypeByName(litaC_this, litaC_spec->name, litaC_searchType);
    
    
}

litaC_symbols__Symbol* litaC_checker__TypeChecker_getTypeByName(litaC_checker__TypeChecker* litaC_this,litaC_intern__InternedString litaC_typeName,litaC_checker__SearchType litaC_searchType) {
    litaC_symbols__Symbol* litaC_type = litaC_checker__GetTypeFromModule(litaC_this->current, litaC_typeName, litaC_searchType);
    if(!(litaC_type)) {
        {
            if(litaC_this->genericContext.callsite) {
                {
                    litaC_type = litaC_checker__GetTypeFromModule(litaC_this->genericContext.callsite, litaC_typeName, litaC_searchType);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(!(litaC_type) && litaC_this->bypassing) {
        {
            litaC_std__string_view__StringView litaC_name = litaC_typeName.view;
            litaC_i32 litaC_index = litaC_std__string_view__StringView_lastIndexOfAt(litaC_name, "::", -(1), -(1));
            if(litaC_index < 0) {
                {
                    return NULL;
                    
                    
                    
                }
                
            } 
            
            litaC_std__string_view__StringView litaC_modulePath = litaC_module__ToModulePath(litaC_std__string_view__StringView_substring(litaC_name, 0, litaC_index));
            litaC_char litaC_filename[_MAX_PATH] =  {
                0
            };
            if(!(litaC_lita__FindModulePath(litaC_this->lita, litaC_modulePath, litaC_filename))) {
                {
                    return NULL;
                    
                    
                    
                }
                
            } 
            
            litaC_module__Module* litaC_module = litaC_lita__Lita_getModule(litaC_this->lita, litaC_filename);
            assert(litaC_module != NULL);
            litaC_std__string_view__StringView litaC_namePart = litaC_std__string_view__StringView_substring(litaC_name, litaC_index + 2, -(1));
            litaC_intern__InternedString litaC_namePartType = litaC_intern__Strings_internCopy(&((litaC_this->lita->strings)), litaC_namePart.buffer, litaC_namePart.length);
            return litaC_checker__GetTypeFromModule(litaC_module, litaC_namePartType, litaC_searchType);
            
            
            
        }
        
    } 
    
    return litaC_type;
    
    
}

litaC_symbols__Symbol* litaC_checker__GetTypeFromModule(litaC_module__Module* litaC_module,litaC_intern__InternedString litaC_typeName,litaC_checker__SearchType litaC_searchType) {
    litaC_symbols__Symbol* litaC_type = NULL;
    switch(litaC_searchType) {
        case litaC_checker__SearchType_FUNC: {
            litaC_type = litaC_module__Module_getFuncType(litaC_module, litaC_typeName);
            break;
            
            
        }
        case litaC_checker__SearchType_NOTE: {
            litaC_type = litaC_module__Module_getNoteType(litaC_module, litaC_typeName);
            break;
            
            
        }
        default: {
            litaC_type = litaC_module__Module_getType(litaC_module, litaC_typeName);
            break;
            
            
        }
    }
    return litaC_type;
    
    
}

litaC_bool litaC_checker__TypeChecker_implementsTrait(litaC_checker__TypeChecker* litaC_this,litaC_types__TypeInfo* litaC_agg,litaC_types__TypeInfo* litaC_iface) {
    assert(litaC_agg != NULL);
    assert(litaC_iface != NULL);
    if(litaC_agg->typeid == litaC_iface->typeid) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    if(litaC_std__map__Map_contains_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_this->interfaceImpls)), litaC_iface->typeid)) {
        {
            litaC_std__array__Array_cb_i64_ce_* litaC_impls = litaC_std__map__Map_getPtr_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_this->interfaceImpls)), litaC_iface->typeid);
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_i64_ce_(litaC_impls);litaC_i += 1) {
                {
                    if(litaC_std__array__Array_get_cb_i64_ce_(litaC_impls, litaC_i) == litaC_agg->typeid) {
                        {
                            return litaC_true;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } 
    
    litaC_symbols__Symbol* litaC_symbols[2048] =  {
        
    };
    litaC_i32 litaC_numOfMethods = litaC_module__Module_getMethodsForType(litaC_this->current, litaC_agg, litaC_symbols);
    litaC_i32 litaC_numOfTraitFns = litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_iface->aggDecl->fields)));
    if(litaC_numOfMethods < litaC_numOfTraitFns) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_matchedCount = 0;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_numOfTraitFns;litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_iface->aggDecl->fields)), litaC_i);
            assert(litaC_field.typeInfo);
            assert(litaC_field.typeInfo->kind == litaC_types__TypeKind_FUNC_PTR);
            assert(litaC_field.kind == litaC_ast__StmtKind_TRAIT_FIELD_DECL);
            const litaC_char* litaC_functionName = litaC_lex__Token_asString(&((litaC_field.traitField->decl.name.token)));
            litaC_types__TypeInfo* litaC_traitFn = litaC_field.typeInfo;
            for(litaC_i32 litaC_index = 0;litaC_index < litaC_numOfMethods;litaC_index += 1) {
                {
                    litaC_symbols__Symbol* litaC_sym = litaC_symbols[litaC_index];
                    litaC_std__string_view__StringView litaC_str = litaC_sym->name.view;
                    litaC_i32 litaC_start = litaC_std__string_view__StringView_indexOf(litaC_str, "_", -(1));
                    if(litaC_start < 0) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    litaC_i32 litaC_end = litaC_std__string_view__StringView_indexOf(litaC_str, "<", -(1));
                    if(litaC_std__string_view__StringView_equals(litaC_std__string_view__StringView_substring(litaC_str, litaC_start + 1, litaC_end), litaC_functionName, -(1))) {
                        {
                            if(litaC_types__IsFuncImpl(litaC_traitFn, litaC_sym->type, litaC_this)) {
                                {
                                    litaC_matchedCount += 1;
                                    break;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
    }
    litaC_bool litaC_isImpl = litaC_matchedCount == litaC_numOfTraitFns;
    if(litaC_isImpl) {
        {
            if(!(litaC_std__map__Map_contains_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_this->interfaceImpls)), litaC_iface->typeid))) {
                {
                    litaC_std__array__Array_cb_i64_ce_ litaC_impls = litaC_std__array__ArrayInit_cb_i64_ce_(32, litaC_this->lita->allocator);
                    litaC_std__map__Map_put_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_this->interfaceImpls)), litaC_iface->typeid, litaC_impls);
                    
                    
                }
                
            } 
            
            litaC_std__array__Array_cb_i64_ce_* litaC_impls = litaC_std__map__Map_getPtr_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_this->interfaceImpls)), litaC_iface->typeid);
            litaC_std__array__Array_add_cb_i64_ce_(litaC_impls, litaC_agg->typeid);
            
            
        }
        
    } 
    
    return litaC_isImpl;
    
    
}

litaC_types__TypeInfo* litaC_checker__TypeChecker_resolveNoteTypeSpec(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypeSpec* litaC_spec) {
    if(!(litaC_spec)) {
        {
            return &(litaC_types__VOID_TYPE);
            
            
            
        }
        
    } 
    
    if(litaC_spec->typeInfo && litaC_spec->typeInfo->kind != litaC_types__TypeKind_POISON) {
        {
            return litaC_spec->typeInfo;
            
            
            
        }
        
    } 
    
    if(litaC_checker__TypeChecker_isGenericParamType(litaC_this, litaC_spec)) {
        {
            litaC_spec->typeInfo = litaC_types_new__TypeCache_newGenericParamTypeInfo(litaC_this->typeCache, litaC_spec->name);
            return litaC_spec->typeInfo;
            
            
            
        }
        
    } 
    
    litaC_symbols__Symbol* litaC_sym = litaC_checker__TypeChecker_getType(litaC_this, litaC_spec, litaC_checker__SearchType_NOTE);
    if(!(litaC_sym) || !(litaC_sym->type)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_spec->pos, "unknown note type '%.*s'", litaC_spec->name.length, litaC_spec->name.buffer);
            goto err;
            
            
            
        }
        
    } 
    
    if(!((litaC_sym->flags & litaC_symbols__SymbolFlags_IS_NOTE))) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_spec->pos, "'%.*s' is not a note type", litaC_spec->name.length, litaC_spec->name.buffer);
            goto err;
            
            
            
        }
        
    } 
    
    litaC_spec->typeInfo = litaC_sym->type;
    litaC_lsp__references__ReferenceDatabase_addTypeReference(&((litaC_this->lita->references)), litaC_spec);
    return litaC_spec->typeInfo;
    
    err:;
    
    if(!(litaC_spec->typeInfo)) {
        {
            litaC_spec->typeInfo = &(litaC_types__POISON_TYPE);
            
            
        }
        
    } 
    
    return &(litaC_types__POISON_TYPE);
    
    
}

litaC_types__TypeInfo* litaC_checker__TypeChecker_resolveTypeSpec(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypeSpec* litaC_spec,litaC_checker__SearchType litaC_searchType) {
    if(!(litaC_spec)) {
        {
            return &(litaC_types__VOID_TYPE);
            
            
            
        }
        
    } 
    
    if(litaC_spec->typeInfo && litaC_spec->typeInfo->kind != litaC_types__TypeKind_POISON) {
        {
            return litaC_spec->typeInfo;
            
            
            
        }
        
    } 
    
    switch(litaC_spec->kind) {
        case litaC_ast__TypeSpecKind_NAME: {
            {
                litaC_ast__TypeSpec* litaC_nameSpec = litaC_spec;
                if(litaC_checker__TypeChecker_isGenericParamType(litaC_this, litaC_nameSpec)) {
                    {
                        litaC_nameSpec->typeInfo = litaC_types_new__TypeCache_newGenericParamTypeInfo(litaC_this->typeCache, litaC_nameSpec->name);
                        return litaC_nameSpec->typeInfo;
                        
                        
                        
                    }
                    
                } 
                
                litaC_symbols__Symbol* litaC_sym = litaC_checker__TypeChecker_getType(litaC_this, litaC_nameSpec, litaC_searchType);
                if(!(litaC_sym)) {
                    {
                        litaC_sym = litaC_symbols__Scope_lookup(litaC_checker__TypeChecker_currentScope(litaC_this), litaC_nameSpec->name, litaC_true);
                        if(!(litaC_sym)) {
                            {
                                litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_spec->pos, "unknown type '%.*s'", litaC_nameSpec->name.length, litaC_nameSpec->name.buffer);
                                goto err;
                                
                                
                                
                            }
                            
                        } else {
                            if(litaC_sym->type && litaC_types__IsFuncLike(litaC_sym->type)) {
                                {
                                    litaC_spec->typeInfo = litaC_sym->type;
                                    return litaC_spec->typeInfo;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                if(!((litaC_sym->flags & litaC_symbols__SymbolFlags_IS_TYPE)) && !(litaC_types__IsFuncLike(litaC_sym->type))) {
                    {
                        litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_spec->pos, "'%.*s' must be a type", litaC_nameSpec->name.length, litaC_nameSpec->name.buffer);
                        goto err;
                        
                        
                        
                    }
                    
                } 
                
                litaC_checker__TypeChecker_resolveSymbol(litaC_this, litaC_sym);
                if(!(litaC_std__array__Array_empty_cb__ptr_TypeSpec_ce_(&((litaC_nameSpec->genericArgs))))) {
                    {
                        litaC_sym = litaC_generics__CreateTypeFromGenericTemplate(litaC_this, litaC_sym, litaC_nameSpec);
                        if(!(litaC_sym)) {
                            {
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                litaC_spec->typeInfo = litaC_sym->type;
                litaC_lsp__references__ReferenceDatabase_addTypeReference(&((litaC_this->lita->references)), litaC_spec);
                return litaC_spec->typeInfo;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_CONST: {
            {
                litaC_ast__TypeSpec* litaC_constSpec = litaC_spec;
                litaC_types__TypeInfo* litaC_constOf = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_constSpec->base, litaC_checker__SearchType_TYPE);
                litaC_spec->typeInfo = litaC_types_new__TypeCache_newConstTypeInfo(litaC_this->typeCache, litaC_constOf);
                return litaC_spec->typeInfo;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_PTR: {
            {
                litaC_ast__TypeSpec* litaC_ptrSpec = litaC_spec;
                litaC_types__TypeInfo* litaC_ptrOf = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_ptrSpec->base, litaC_checker__SearchType_TYPE);
                litaC_spec->typeInfo = litaC_types_new__TypeCache_newPtrTypeInfo(litaC_this->typeCache, litaC_ptrOf);
                return litaC_spec->typeInfo;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_ARRAY: {
            {
                litaC_ast__TypeSpec* litaC_arraySpec = litaC_spec;
                litaC_types__TypeInfo* litaC_arrayOf = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_arraySpec->base, litaC_checker__SearchType_TYPE);
                litaC_usize litaC_length = 0;
                litaC_bool litaC_isLengthDefined = litaC_false;
                if(litaC_arraySpec->numElements) {
                    {
                        litaC_ast__Expr* litaC_expr = litaC_arraySpec->numElements;
                        if(!(litaC_checker_expr__TypeChecker_resolveConstExpr(litaC_this, litaC_expr))) {
                            {
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        if(!(litaC_types__IsInteger(litaC_expr->operand.typeInfo))) {
                            {
                                litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, "array size expression must be an integer type");
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_isLengthDefined = litaC_true;
                        if(litaC_expr->stmt.node.kind == litaC_ast__StmtKind_IDENTIFIER_EXPR) {
                            {
                                litaC_ast__IdentifierExpr* litaC_idExpr = (litaC_ast__IdentifierExpr*)litaC_expr;
                                if(litaC_idExpr->sym && (litaC_idExpr->sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN)) {
                                    {
                                        litaC_isLengthDefined = litaC_false;
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_isLengthDefined) {
                            {
                                litaC_length = litaC_expr->operand.val.intValue;
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                litaC_spec->typeInfo = (litaC_types__TypeInfo*)litaC_types_new__TypeCache_newArrayTypeInfo(litaC_this->typeCache, litaC_arrayOf, litaC_length, litaC_arraySpec->numElements, litaC_isLengthDefined);
                return litaC_spec->typeInfo;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_FUNC_PTR: {
            {
                litaC_ast__TypeSpec* litaC_funcPtrSpec = litaC_spec;
                litaC_std__array__Array_cb__ptr_TypeInfo_ce_ litaC_paramDecls =  {
                    
                };
                if(!(litaC_std__array__Array_empty_cb__ptr_TypeSpec_ce_(&((litaC_funcPtrSpec->args))))) {
                    {
                        litaC_std__array__Array_init_cb__ptr_TypeInfo_ce_(&((litaC_paramDecls)), litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_funcPtrSpec->args))), litaC_this->lita->allocator);
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_funcPtrSpec->args)));litaC_i += 1) {
                            {
                                litaC_ast__TypeSpec* litaC_arg = litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_funcPtrSpec->args)), litaC_i);
                                litaC_types__TypeInfo* litaC_typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_arg, litaC_checker__SearchType_TYPE);
                                litaC_std__array__Array_add_cb__ptr_TypeInfo_ce_(&((litaC_paramDecls)), litaC_typeInfo);
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                litaC_types__TypeInfo* litaC_returnType = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_funcPtrSpec->ret, litaC_checker__SearchType_TYPE);
                litaC_spec->typeInfo = (litaC_types__TypeInfo*)litaC_types_new__TypeCache_newFuncPtrTypeInfo(litaC_this->typeCache, litaC_funcPtrSpec->genericParams, litaC_returnType, litaC_paramDecls, litaC_funcPtrSpec->hasVarargs);
                return litaC_spec->typeInfo;
                
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    err:;
    
    if(!(litaC_spec->typeInfo)) {
        {
            litaC_spec->typeInfo = &(litaC_types__POISON_TYPE);
            
            
        }
        
    } 
    
    return &(litaC_types__POISON_TYPE);
    
    
}

litaC_symbols__Symbol* litaC_checker__TypeChecker_addSymbol(litaC_checker__TypeChecker* litaC_this,litaC_ast__Decl* litaC_decl,litaC_types__TypeInfo* litaC_typeInfo) {
    assert(litaC_decl->name.token.type == litaC_lex__TokenType_IDENTIFIER);
    litaC_symbols__Symbol* litaC_sym = litaC_symbols__Scope_addSymbol(litaC_this->current->currentScope, litaC_decl->name.str, litaC_this->current, litaC_decl, 0);
    if(litaC_sym) {
        {
            litaC_sym->type = litaC_typeInfo;
            litaC_checker__TypeChecker_resolveSymbol(litaC_this, litaC_sym);
            litaC_lsp__references__ReferenceDatabase_addSymbolReference(&((litaC_this->lita->references)), litaC_sym, litaC_decl->stmt.node.startPos);
            
            
        }
        
    } 
    
    return litaC_sym;
    
    
}

litaC_void litaC_checker__TypeChecker_addTypeToScope(litaC_checker__TypeChecker* litaC_this,litaC_ast__Decl* litaC_decl,litaC_symbols__Scope* litaC_scope,litaC_types__TypeInfo* litaC_baseType,litaC_types__TypeInfo* litaC_currentType) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_currentType->aggDecl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_currentType->aggDecl->fields)), litaC_i);
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                        if(litaC_varField->decl.name.token.type != litaC_lex__TokenType_IDENTIFIER) {
                            {
                                break;
                                
                                
                            }
                            
                        } 
                        
                        litaC_ast__Decl* litaC_varDecl = litaC_ast_new__NewVarDecl(litaC_decl->stmt.node.startPos, litaC_decl->stmt.node.endPos, litaC_decl->name, litaC_varField->type, NULL, litaC_this->lita->allocator);
                        litaC_varDecl->sym = litaC_symbols__Scope_addSymbol(litaC_scope, litaC_varField->decl.name.str, litaC_this->current, litaC_varDecl, litaC_symbols__SymbolFlags_IS_USING);
                        litaC_varDecl->sym->type = litaC_field.typeInfo;
                        litaC_varDecl->sym->usingParent = litaC_decl->sym;
                        litaC_checker__TypeChecker_resolveSymbol(litaC_this, litaC_varDecl->sym);
                        if(litaC_varField->decl.attributes.isUsing) {
                            {
                                litaC_types__TypeInfo* litaC_fieldBaseType = litaC_types__TypeInfo_getBaseType(litaC_field.typeInfo);
                                if(litaC_fieldBaseType->kind == litaC_types__TypeKind_POISON) {
                                    {
                                        break;
                                        
                                        
                                    }
                                    
                                } 
                                
                                assert(litaC_types__IsAggregate(litaC_fieldBaseType));
                                litaC_checker__TypeChecker_addTypeToScope(litaC_this, litaC_decl, litaC_scope, litaC_baseType, litaC_fieldBaseType);
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: 
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: 
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: 
                case litaC_ast__StmtKind_POISON_EXPR: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        assert(litaC_false);
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    
}

litaC_bool litaC_checker__TypeChecker_resolveNotes(litaC_checker__TypeChecker* litaC_this,litaC_std__array__Array_cb__ptr_NoteStmt_ce_* litaC_notes) {
    if(!(litaC_notes) || litaC_std__array__Array_empty_cb__ptr_NoteStmt_ce_(litaC_notes)) {
        return litaC_true;
        
        
    } 
    
    litaC_bool litaC_success = litaC_true;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(litaC_notes);litaC_i += 1) {
        {
            litaC_ast__NoteStmt* litaC_note = litaC_std__array__Array_get_cb__ptr_NoteStmt_ce_(litaC_notes, litaC_i);
            assert(litaC_note->type != NULL);
            litaC_types__TypeInfo* litaC_typeInfo = litaC_checker__TypeChecker_resolveNoteTypeSpec(litaC_this, litaC_note->type);
            if(litaC_typeInfo->kind == litaC_types__TypeKind_POISON) {
                {
                    litaC_success = litaC_false;
                    continue;
                    
                    
                }
                
            } 
            
            if(!(litaC_checker__TypeChecker_checkNote(litaC_this, litaC_note->stmt.node.startPos, litaC_typeInfo))) {
                {
                    litaC_success = litaC_false;
                    continue;
                    
                    
                }
                
            } 
            
            assert(litaC_types__IsAggregate(litaC_typeInfo));
            litaC_types__TypeInfo* litaC_aggInfo = litaC_typeInfo;
            for(litaC_i32 litaC_j = 0;litaC_j < litaC_std__array__Array_size_cb_CallArg_ce_(&((litaC_note->arguments)));litaC_j += 1) {
                {
                    litaC_ast__CallArg litaC_arg = litaC_std__array__Array_get_cb_CallArg_ce_(&((litaC_note->arguments)), litaC_j);
                    if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, &((litaC_arg.argExpr->stmt))))) {
                        {
                            litaC_success = litaC_false;
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    if(litaC_arg.argName.str.length == 0) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    litaC_ast__FieldStmt litaC_field = litaC_types__TypeInfo_getField(litaC_aggInfo, litaC_arg.argName.str);
                    if(litaC_field.kind == litaC_ast__StmtKind_POISON_EXPR) {
                        {
                            litaC_checker_expr__TypeChecker_errorNoField(litaC_this, litaC_arg.argExpr, litaC_typeInfo, litaC_arg.argName.str);
                            litaC_success = litaC_false;
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    if(!(litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_arg.argName.token.pos, litaC_field.typeInfo, litaC_arg.argExpr->operand.typeInfo, litaC_true))) {
                        {
                            litaC_success = litaC_false;
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
    }
    return litaC_success;
    
    
}

litaC_bool litaC_checker__TypeChecker_resolveStmt(litaC_checker__TypeChecker* litaC_this,litaC_ast__Stmt* litaC_stmt) {
    if(!(litaC_stmt)) {
        return litaC_true;
        
        
    } 
    
    switch(litaC_stmt->node.kind) {
        case litaC_ast__StmtKind_IMPORT_DECL: 
        case litaC_ast__StmtKind_CONST_DECL: 
        case litaC_ast__StmtKind_VAR_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: 
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_NOTE_DECL: 
        case litaC_ast__StmtKind_ENUM_DECL: 
        case litaC_ast__StmtKind_FUNC_DECL: 
        case litaC_ast__StmtKind_TYPEDEF_DECL: 
        case litaC_ast__StmtKind_PARAM_DECL: 
        case litaC_ast__StmtKind_NATIVE_DECL: 
        case litaC_ast__StmtKind_POISON_DECL: {
            {
                return litaC_checker_decl__TypeChecker_resolveDecl(litaC_this, (litaC_ast__Decl*)litaC_stmt);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BLOCK_STMT: {
            {
                litaC_ast__BlockStmt* litaC_body = (litaC_ast__BlockStmt*)litaC_stmt;
                litaC_checker__TypeChecker_pushScope(litaC_this, &((litaC_symbols__Scope) {
                    
                }));
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Stmt_ce_(&((litaC_body->stmts)));litaC_i += 1) {
                    {
                        litaC_ast__Stmt* litaC_s = litaC_std__array__Array_get_cb__ptr_Stmt_ce_(&((litaC_body->stmts)), litaC_i);
                        if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_s))) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    litaC_checker__TypeChecker_popScope(litaC_this);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                {
                    litaC_bool ___result = litaC_true;
                    litaC_checker__TypeChecker_popScope(litaC_this);
                    return ___result;
                    
                }
                
                litaC_checker__TypeChecker_popScope(litaC_this);
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BREAK_STMT: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_COMP_STMT: {
            {
                litaC_ast__CompStmt* litaC_compStmt = (litaC_ast__CompStmt*)litaC_stmt;
                if(litaC_compStmt->isStatic) {
                    {
                        litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_stmts = litaC_compStmt->body;
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Stmt_ce_(&((litaC_stmts)));litaC_i += 1) {
                            {
                                litaC_ast__Stmt* litaC_s = litaC_std__array__Array_get_cb__ptr_Stmt_ce_(&((litaC_stmts)), litaC_i);
                                if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_s))) {
                                    {
                                        return litaC_false;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                        }
                        litaC_checker__TypeChecker_pushScope(litaC_this, &((litaC_symbols__Scope) {
                            
                        }));
                        
                        if(litaC_compStmt->end && !(litaC_checker__TypeChecker_resolveStmt(litaC_this, &((litaC_compStmt->end->stmt))))) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    litaC_checker__TypeChecker_popScope(litaC_this);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        {
                            litaC_bool ___result = litaC_true;
                            litaC_checker__TypeChecker_popScope(litaC_this);
                            return ___result;
                            
                        }
                        
                        litaC_checker__TypeChecker_popScope(litaC_this);
                        
                        
                    }
                    
                } 
                
                litaC_ast__Stmt* litaC_stmt = litaC_preprocessor__Preprocessor_evaluateForFunction(&((litaC_this->lita->preprocessor)), litaC_this, litaC_compStmt, litaC_true);
                if(!(litaC_stmt)) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_stmt);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONTINUE_STMT: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DEFER_STMT: {
            {
                litaC_ast__DeferStmt* litaC_deferStmt = (litaC_ast__DeferStmt*)litaC_stmt;
                if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_deferStmt->deferedStmt))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DO_WHILE_STMT: {
            {
                litaC_ast__DoWhileStmt* litaC_whileStmt = (litaC_ast__DoWhileStmt*)litaC_stmt;
                {
                    litaC_checker__TypeChecker_pushScope(litaC_this, &((litaC_symbols__Scope) {
                        
                    }));
                    
                    if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_whileStmt->body))) {
                        {
                            {
                                litaC_bool ___result = litaC_false;
                                litaC_checker__TypeChecker_popScope(litaC_this);
                                return ___result;
                                
                            }
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_checker__TypeChecker_popScope(litaC_this);
                    
                    
                }
                if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_whileStmt->cond))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_EMPTY_STMT: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FOR_STMT: {
            {
                litaC_ast__ForStmt* litaC_forStmt = (litaC_ast__ForStmt*)litaC_stmt;
                litaC_checker__TypeChecker_pushScope(litaC_this, &((litaC_symbols__Scope) {
                    
                }));
                
                if(litaC_forStmt->init && !(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_forStmt->init))) {
                    {
                        {
                            litaC_bool ___result = litaC_false;
                            litaC_checker__TypeChecker_popScope(litaC_this);
                            return ___result;
                            
                        }
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_forStmt->cond && !(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_forStmt->cond))) {
                    {
                        {
                            litaC_bool ___result = litaC_false;
                            litaC_checker__TypeChecker_popScope(litaC_this);
                            return ___result;
                            
                        }
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_forStmt->post && !(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_forStmt->post))) {
                    {
                        {
                            litaC_bool ___result = litaC_false;
                            litaC_checker__TypeChecker_popScope(litaC_this);
                            return ___result;
                            
                        }
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_forStmt->body))) {
                    {
                        {
                            litaC_bool ___result = litaC_false;
                            litaC_checker__TypeChecker_popScope(litaC_this);
                            return ___result;
                            
                        }
                        
                        
                        
                    }
                    
                } 
                
                {
                    litaC_bool ___result = litaC_true;
                    litaC_checker__TypeChecker_popScope(litaC_this);
                    return ___result;
                    
                }
                
                litaC_checker__TypeChecker_popScope(litaC_this);
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_BODY_STMT: {
            {
                litaC_ast__FuncBodyStmt* litaC_body = (litaC_ast__FuncBodyStmt*)litaC_stmt;
                litaC_bool litaC_success = litaC_true;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Stmt_ce_(&((litaC_body->stmts)));litaC_i += 1) {
                    {
                        litaC_ast__Stmt* litaC_s = litaC_std__array__Array_get_cb__ptr_Stmt_ce_(&((litaC_body->stmts)), litaC_i);
                        if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_s))) {
                            {
                                litaC_success = litaC_false;
                                break;
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                return litaC_success;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GOTO_STMT: {
            {
                litaC_ast__GotoStmt* litaC_gotoStmt = (litaC_ast__GotoStmt*)litaC_stmt;
                if(litaC_gotoStmt->label.token.type != litaC_lex__TokenType_IDENTIFIER) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_this->numOfLabels;litaC_i += 1) {
                    {
                        litaC_checker__LabelInfo* litaC_label = &(litaC_this->labels[litaC_i]);
                        if(litaC_intern__InternedString_equals(&((litaC_gotoStmt->label.str)), &((litaC_label->name)))) {
                            {
                                litaC_label->stmt = litaC_stmt;
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                litaC_checker__LabelInfo* litaC_labelName = &(litaC_this->labels[litaC_this->numOfLabels]);
                litaC_labelName->name = litaC_gotoStmt->label.str;
                litaC_labelName->stmt = litaC_stmt;
                litaC_labelName->defined = litaC_false;
                litaC_this->numOfLabels += 1;
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IF_STMT: {
            {
                litaC_ast__IfStmt* litaC_ifStmt = (litaC_ast__IfStmt*)litaC_stmt;
                if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_ifStmt->cond))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                {
                    litaC_checker__TypeChecker_pushScope(litaC_this, &((litaC_symbols__Scope) {
                        
                    }));
                    
                    if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_ifStmt->then))) {
                        {
                            {
                                litaC_bool ___result = litaC_false;
                                litaC_checker__TypeChecker_popScope(litaC_this);
                                return ___result;
                                
                            }
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_checker__TypeChecker_popScope(litaC_this);
                    
                    
                }
                if(litaC_ifStmt->elseStmt) {
                    {
                        litaC_checker__TypeChecker_pushScope(litaC_this, &((litaC_symbols__Scope) {
                            
                        }));
                        
                        if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_ifStmt->elseStmt))) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    litaC_checker__TypeChecker_popScope(litaC_this);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_checker__TypeChecker_popScope(litaC_this);
                        
                        
                    }
                    
                } 
                
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_LABEL_STMT: {
            {
                litaC_ast__LabelStmt* litaC_labelStmt = (litaC_ast__LabelStmt*)litaC_stmt;
                if(litaC_labelStmt->label.token.type != litaC_lex__TokenType_IDENTIFIER) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_this->numOfLabels >= litaC_checker__MAX_LABELS) {
                    {
                        litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_labelStmt->stmt.node.startPos, "max number of labels reached");
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_this->numOfLabels;litaC_i += 1) {
                    {
                        litaC_checker__LabelInfo* litaC_label = &(litaC_this->labels[litaC_i]);
                        if(litaC_intern__InternedString_equals(&((litaC_labelStmt->label.str)), &((litaC_label->name)))) {
                            {
                                litaC_label->defined = litaC_true;
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                litaC_checker__LabelInfo* litaC_labelName = &(litaC_this->labels[litaC_this->numOfLabels]);
                litaC_labelName->name = litaC_labelStmt->label.str;
                litaC_labelName->defined = litaC_true;
                litaC_labelName->stmt = NULL;
                litaC_this->numOfLabels += 1;
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_MODULE_STMT: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NOTE_STMT: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAMETERS_STMT: {
            {
                litaC_ast__ParametersStmt* litaC_params = (litaC_ast__ParametersStmt*)litaC_stmt;
                litaC_bool litaC_hasDefault = litaC_false;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_params->params)));litaC_i += 1) {
                    {
                        litaC_ast__ParameterDecl* litaC_param = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_params->params)), litaC_i);
                        if(!(litaC_checker_decl__TypeChecker_resolveParamDecl(litaC_this, litaC_param))) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_param->defaultExpr) {
                            {
                                litaC_hasDefault = litaC_true;
                                
                                
                            }
                            
                        } else {
                            if(litaC_hasDefault) {
                                {
                                    litaC_ast__FuncDecl* litaC_parentDecl = (litaC_ast__FuncDecl*)litaC_params->stmt.node.parent;
                                    assert(litaC_parentDecl != NULL);
                                    assert(litaC_parentDecl->decl.declaration.stmt.node.kind == litaC_ast__StmtKind_FUNC_DECL);
                                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_parentDecl->decl.declaration.stmt.node.startPos, "'%.*s' must have default arguments defined last", litaC_parentDecl->decl.declaration.name.str.length, litaC_parentDecl->decl.declaration.name.str.buffer);
                                    return litaC_false;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                        } 
                        
                        
                        
                    }
                }
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_RETURN_STMT: {
            {
                litaC_ast__ReturnStmt* litaC_ret = (litaC_ast__ReturnStmt*)litaC_stmt;
                litaC_i32 litaC_count = litaC_checker__TypeChecker_errors(litaC_this);
                litaC_types__TypeInfo* litaC_currentFuncDecl = litaC_std__array__Array_last_cb__ptr_TypeInfo_ce_(&((litaC_this->funcDeclStack)));
                if(!(litaC_currentFuncDecl)) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_ret->expr) {
                    {
                        if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_ret->expr))) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_ret->expr = litaC_checker_expr__TypeChecker_coerceTypeWithUsing(litaC_this, litaC_ret->expr, litaC_ret->expr->operand.typeInfo, litaC_currentFuncDecl->returnType);
                        litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_ret->expr->stmt.node.startPos, litaC_currentFuncDecl->returnType, litaC_ret->expr->operand.typeInfo, litaC_true);
                        litaC_ret->expr->expectedType = litaC_currentFuncDecl->returnType;
                        if(litaC_currentFuncDecl->returnType && litaC_currentFuncDecl->returnType->kind == litaC_types__TypeKind_GENERIC_PARAM) {
                            {
                                if(litaC_ret->expr->operand.typeInfo && litaC_ret->expr->operand.typeInfo->kind != litaC_types__TypeKind_GENERIC_PARAM) {
                                    {
                                        litaC_currentFuncDecl->returnType = litaC_ret->expr->operand.typeInfo;
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } else {
                    {
                        litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_ret->stmt.node.startPos, litaC_currentFuncDecl->returnType, &(litaC_types__VOID_TYPE), litaC_true);
                        if(litaC_currentFuncDecl->returnType && litaC_currentFuncDecl->returnType->kind == litaC_types__TypeKind_GENERIC_PARAM) {
                            {
                                litaC_currentFuncDecl->returnType = &(litaC_types__VOID_TYPE);
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                } 
                
                return litaC_count == litaC_checker__TypeChecker_errors(litaC_this);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SWITCH_CASE_STMT: {
            {
                litaC_ast__SwitchCaseStmt* litaC_caseStmt = (litaC_ast__SwitchCaseStmt*)litaC_stmt;
                if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_caseStmt->cond))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_caseStmt->body))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SWITCH_STMT: {
            {
                litaC_ast__SwitchStmt* litaC_switchStmt = (litaC_ast__SwitchStmt*)litaC_stmt;
                if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_switchStmt->cond))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_SwitchCaseStmt_ce_(&((litaC_switchStmt->cases)));litaC_i += 1) {
                    {
                        litaC_ast__SwitchCaseStmt* litaC_caseStmt = litaC_std__array__Array_get_cb__ptr_SwitchCaseStmt_ce_(&((litaC_switchStmt->cases)), litaC_i);
                        if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, &((litaC_caseStmt->stmt))))) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                if(litaC_switchStmt->defaultStmt) {
                    {
                        if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_switchStmt->defaultStmt))) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_FIELD_DECL: 
        case litaC_ast__StmtKind_ENUM_FIELD_ENTRY_DECL: 
        case litaC_ast__StmtKind_STRUCT_FIELD_DECL: 
        case litaC_ast__StmtKind_UNION_FIELD_DECL: 
        case litaC_ast__StmtKind_TRAIT_FIELD_DECL: 
        case litaC_ast__StmtKind_VAR_FIELD_DECL: {
            {
                assert(litaC_false);
                return litaC_false;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_WHILE_STMT: {
            {
                litaC_ast__WhileStmt* litaC_whileStmt = (litaC_ast__WhileStmt*)litaC_stmt;
                if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_whileStmt->cond))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                litaC_checker__TypeChecker_pushScope(litaC_this, &((litaC_symbols__Scope) {
                    
                }));
                
                if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_whileStmt->body))) {
                    {
                        {
                            litaC_bool ___result = litaC_false;
                            litaC_checker__TypeChecker_popScope(litaC_this);
                            return ___result;
                            
                        }
                        
                        
                        
                    }
                    
                } 
                
                {
                    litaC_bool ___result = litaC_true;
                    litaC_checker__TypeChecker_popScope(litaC_this);
                    return ___result;
                    
                }
                
                litaC_checker__TypeChecker_popScope(litaC_this);
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR: 
        case litaC_ast__StmtKind_ARRAY_INIT_EXPR: 
        case litaC_ast__StmtKind_BINARY_EXPR: 
        case litaC_ast__StmtKind_BOOLEAN_EXPR: 
        case litaC_ast__StmtKind_CAST_EXPR: 
        case litaC_ast__StmtKind_CHAR_EXPR: 
        case litaC_ast__StmtKind_FUNC_CALL_EXPR: 
        case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_GET_EXPR: 
        case litaC_ast__StmtKind_GROUP_EXPR: 
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_INIT_EXPR: 
        case litaC_ast__StmtKind_INIT_ARG_EXPR: 
        case litaC_ast__StmtKind_NULL_EXPR: 
        case litaC_ast__StmtKind_NUMBER_EXPR: 
        case litaC_ast__StmtKind_OFFSET_OF_EXPR: 
        case litaC_ast__StmtKind_SET_EXPR: 
        case litaC_ast__StmtKind_SIZE_OF_EXPR: 
        case litaC_ast__StmtKind_STRING_EXPR: 
        case litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR: 
        case litaC_ast__StmtKind_SUBSCRIPT_SET_EXPR: 
        case litaC_ast__StmtKind_TERNARY_EXPR: 
        case litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_TYPE_OF_EXPR: 
        case litaC_ast__StmtKind_UNARY_EXPR: 
        case litaC_ast__StmtKind_POISON_EXPR: {
            {
                return litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, (litaC_ast__Expr*)litaC_stmt);
                
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_u32 litaC_types_new__Hash(litaC_types_new__ArrayEntry litaC_a) {
    litaC_u32 litaC_add = 3;
    if(litaC_a.arrayOf) {
        {
            litaC_add += (litaC_u32)((litaC_usize)(litaC_a.arrayOf) >> 7);
            
            
        }
        
    } 
    
    litaC_add += (litaC_u32)litaC_a.length;
    return litaC_add;
    
    
}

litaC_bool litaC_types_new__Equals(litaC_types_new__ArrayEntry litaC_a,litaC_types_new__ArrayEntry litaC_b) {
    if(litaC_a.arrayOf && !(litaC_b.arrayOf)) {
        return litaC_false;
        
        
    } 
    
    if(!(litaC_a.arrayOf) && litaC_b.arrayOf) {
        return litaC_false;
        
        
    } 
    
    if(litaC_a.arrayOf && litaC_b.arrayOf) {
        {
            if(litaC_a.arrayOf->typeid != litaC_b.arrayOf->typeid) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    return litaC_a.length == litaC_b.length;
    
    
}

litaC_void litaC_types_new__TypeCache_init(litaC_types_new__TypeCache* litaC_this,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_this->allocator = litaC_allocator;
    litaC_std__bucket_list__BucketList_init_cb_TypeInfo_ce_(&((litaC_this->typeInfos)), 1024 * 2, litaC_this->allocator);
    litaC_std__map__Map_init_cb_i64_c__ptr_TypeInfo_ce_(&((litaC_this->constCache)), NULL, 1024, litaC_std__map__PtrHashFn_cb_i64_ce_, litaC_std__map__PtrEqualFn_cb_i64_ce_, litaC_allocator, 0);
    litaC_std__map__Map_init_cb_i64_c__ptr_TypeInfo_ce_(&((litaC_this->ptrCache)), NULL, 1024, litaC_std__map__PtrHashFn_cb_i64_ce_, litaC_std__map__PtrEqualFn_cb_i64_ce_, litaC_allocator, 0);
    litaC_std__map__Map_init_cb_ArrayEntry_c__ptr_TypeInfo_ce_(&((litaC_this->arrayCache)), NULL, 512, litaC_types_new__Hash, litaC_types_new__Equals, litaC_allocator, (litaC_types_new__ArrayEntry) {
        .expr = NULL,
        .arrayOf = NULL,
        .length = 0
    });
    litaC_this->genericCache = litaC_intern__InternMap_cb__ptr_TypeInfo_ce_(NULL, 128, litaC_allocator);
    
}

litaC_types__TypeInfo* litaC_types_new__TypeCache_newTypeInfo(litaC_types_new__TypeCache* litaC_this) {
    litaC_std__bucket_list__BucketList_add_cb_TypeInfo_ce_(&((litaC_this->typeInfos)), (litaC_types__TypeInfo) {
        
    });
    litaC_types__TypeInfo* litaC_type = litaC_std__bucket_list__BucketList_lastPtr_cb_TypeInfo_ce_(&((litaC_this->typeInfos)));
    litaC_type->typeid = litaC_types__NextTypeId();
    return litaC_type;
    
    
}

litaC_types__TypeInfo* litaC_types_new__TypeCache_newGenericParamTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_intern__InternedString litaC_name) {
    litaC_types__TypeInfo* litaC_type = litaC_std__map__Map_get_cb_InternedString_c__ptr_TypeInfo_ce_(&((litaC_this->genericCache)), litaC_name);
    if(!(litaC_type)) {
        {
            litaC_type = litaC_types_new__TypeCache_newTypeInfo(litaC_this);
            litaC_type->kind = litaC_types__TypeKind_GENERIC_PARAM;
            litaC_type->name = litaC_name;
            litaC_type->sym = NULL;
            litaC_std__map__Map_put_cb_InternedString_c__ptr_TypeInfo_ce_(&((litaC_this->genericCache)), litaC_name, litaC_type);
            
            
        }
        
    } 
    
    return litaC_type;
    
    
}

litaC_types__TypeInfo* litaC_types_new__TypeCache_newFuncTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_symbols__Symbol* litaC_sym,litaC_ast__FuncDecl* litaC_funcDecl) {
    litaC_types__TypeInfo* litaC_type = (litaC_sym->type != NULL) ? litaC_sym->type : litaC_types_new__TypeCache_newTypeInfo(litaC_this);
    litaC_type->kind = litaC_types__TypeKind_FUNC;
    litaC_type->name = litaC_sym->name;
    litaC_type->sym = litaC_sym;
    litaC_type->funcDecl = litaC_funcDecl;
    litaC_type->returnType = NULL;
    return litaC_type;
    
    
}

litaC_types__TypeInfo* litaC_types_new__TypeCache_newArrayTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_types__TypeInfo* litaC_arrayOf,litaC_usize litaC_length,litaC_ast__Expr* litaC_numOfElements,litaC_bool litaC_isLengthDefined) {
    litaC_types_new__ArrayEntry litaC_entry =  {
        .arrayOf = litaC_arrayOf,
        .expr = litaC_numOfElements,
        .length = litaC_length
    };
    litaC_types__TypeInfo* litaC_type = litaC_std__map__Map_get_cb_ArrayEntry_c__ptr_TypeInfo_ce_(&((litaC_this->arrayCache)), litaC_entry);
    if(!(litaC_type) || litaC_type->length != litaC_length || litaC_type->isLengthDefined != litaC_isLengthDefined || litaC_type->numOfElements != litaC_numOfElements) {
        {
            litaC_type = litaC_types_new__TypeCache_newTypeInfo(litaC_this);
            litaC_type->kind = litaC_types__TypeKind_ARRAY;
            litaC_type->arrayOf = litaC_arrayOf;
            litaC_type->length = litaC_length;
            litaC_type->numOfElements = litaC_numOfElements;
            litaC_type->isLengthDefined = litaC_isLengthDefined;
            litaC_std__map__Map_put_cb_ArrayEntry_c__ptr_TypeInfo_ce_(&((litaC_this->arrayCache)), litaC_entry, litaC_type);
            
            
        }
        
    } 
    
    return litaC_type;
    
    
}

litaC_types__TypeInfo* litaC_types_new__TypeCache_newFuncPtrTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_std__array__Array_cb_GenericParam_ce_ litaC_genericParams,litaC_types__TypeInfo* litaC_returnType,litaC_std__array__Array_cb__ptr_TypeInfo_ce_ litaC_paramDecls,litaC_bool litaC_hasVarargs) {
    litaC_types__TypeInfo* litaC_type = litaC_types_new__TypeCache_newTypeInfo(litaC_this);
    litaC_type->kind = litaC_types__TypeKind_FUNC_PTR;
    litaC_type->genericParams = litaC_genericParams;
    litaC_type->returnType = litaC_returnType;
    litaC_type->paramDecls = litaC_paramDecls;
    litaC_type->hasVarargs = litaC_hasVarargs;
    return litaC_type;
    
    
}

litaC_types__TypeInfo* litaC_types_new__TypeCache_newAggregateTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_symbols__Symbol* litaC_sym,litaC_ast__AggregateDecl* litaC_decl) {
    litaC_types__TypeInfo* litaC_type = (litaC_sym->type != NULL) ? litaC_sym->type : litaC_types_new__TypeCache_newTypeInfo(litaC_this);
    switch(litaC_decl->decl.declaration.stmt.node.kind) {
        case litaC_ast__StmtKind_TRAIT_DECL: {
            {
                litaC_type->kind = litaC_types__TypeKind_TRAIT;
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNION_DECL: {
            {
                litaC_type->kind = litaC_types__TypeKind_UNION;
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NOTE_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: {
            {
                litaC_type->kind = litaC_types__TypeKind_STRUCT;
                break;
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    litaC_type->name = litaC_sym->name;
    litaC_type->aggDecl = litaC_decl;
    litaC_type->sym = litaC_sym;
    return litaC_type;
    
    
}

litaC_types__TypeInfo* litaC_types_new__TypeCache_newEnumTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_symbols__Symbol* litaC_sym,litaC_ast__EnumDecl* litaC_enumDecl) {
    litaC_types__TypeInfo* litaC_type = (litaC_sym->type != NULL) ? litaC_sym->type : litaC_types_new__TypeCache_newTypeInfo(litaC_this);
    litaC_type->kind = litaC_types__TypeKind_ENUM;
    litaC_type->name = litaC_sym->name;
    litaC_type->enumDecl = litaC_enumDecl;
    litaC_type->sym = litaC_sym;
    return litaC_type;
    
    
}

litaC_types__TypeInfo* litaC_types_new__TypeCache_newForeignTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_symbols__Symbol* litaC_sym) {
    litaC_types__TypeInfo* litaC_type = (litaC_sym->type != NULL) ? litaC_sym->type : litaC_types_new__TypeCache_newTypeInfo(litaC_this);
    litaC_type->kind = litaC_types__TypeKind_I64;
    litaC_type->name = litaC_sym->name;
    litaC_type->sym = litaC_sym;
    return litaC_type;
    
    
}

litaC_types__TypeInfo* litaC_types_new__TypeCache_newConstTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_types__TypeInfo* litaC_base) {
    if(litaC_base->kind == litaC_types__TypeKind_CONST) {
        {
            return litaC_base;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_type = litaC_std__map__Map_get_cb_i64_c__ptr_TypeInfo_ce_(&((litaC_this->constCache)), litaC_base->typeid);
    if(!(litaC_type)) {
        {
            litaC_type = litaC_types_new__TypeCache_newTypeInfo(litaC_this);
            litaC_type->kind = litaC_types__TypeKind_CONST;
            litaC_type->constOf = litaC_base;
            litaC_std__map__Map_put_cb_i64_c__ptr_TypeInfo_ce_(&((litaC_this->constCache)), litaC_base->typeid, litaC_type);
            
            
        }
        
    } 
    
    return litaC_type;
    
    
}

litaC_types__TypeInfo* litaC_types_new__TypeCache_newPtrTypeInfo(litaC_types_new__TypeCache* litaC_this,litaC_types__TypeInfo* litaC_base) {
    litaC_types__TypeInfo* litaC_type = litaC_std__map__Map_get_cb_i64_c__ptr_TypeInfo_ce_(&((litaC_this->ptrCache)), litaC_base->typeid);
    if(!(litaC_type)) {
        {
            litaC_type = litaC_types_new__TypeCache_newTypeInfo(litaC_this);
            litaC_type->kind = litaC_types__TypeKind_PTR;
            litaC_type->ptrOf = litaC_base;
            litaC_std__map__Map_put_cb_i64_c__ptr_TypeInfo_ce_(&((litaC_this->ptrCache)), litaC_base->typeid, litaC_type);
            
            
        }
        
    } 
    
    return litaC_type;
    
    
}

litaC_types__TypeInfo* litaC_types_new__TypeCache_typeDecay(litaC_types_new__TypeCache* litaC_this,litaC_types__TypeInfo* litaC_type) {
    if(!(litaC_type)) {
        return NULL;
        
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__TypeInfo* litaC_arrayInfo = litaC_type;
                return litaC_types_new__TypeCache_newPtrTypeInfo(litaC_this, litaC_types_new__TypeCache_typeDecay(litaC_this, litaC_arrayInfo->arrayOf));
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC: {
            {
                litaC_types__TypeInfo* litaC_funcInfo = litaC_type;
                return litaC_types__TypeInfo_asPtr(litaC_funcInfo, litaC_this);
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_type;
                
                
                
            }
            
            
        }
    }
    
}

litaC_u32 litaC_intern__InternHashFn(litaC_intern__InternedString litaC_a) {
    litaC_u32 litaC_hash = (litaC_u32)(((litaC_usize)litaC_a.addr) % 4294967291U);
    return litaC_hash;
    
    
}

litaC_bool litaC_intern__InternEqualFn(litaC_intern__InternedString litaC_a,litaC_intern__InternedString litaC_b) {
    return litaC_a.addr == litaC_b.addr;
    
    
}

litaC_void litaC_intern__Strings_init(litaC_intern__Strings* litaC_this,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_this->allocator = litaC_allocator;
    litaC_this->length = 0;
    litaC_this->capacity = 0;
    litaC_this->keys = NULL;
    litaC_this->values = NULL;
    litaC_intern__Strings_grow(litaC_this, 4096);
    litaC_intern__Strings_internConstant(litaC_this, "void", 4, &(litaC_intern__VOID));
    litaC_intern__Strings_internConstant(litaC_this, "null", 4, &(litaC_intern__NULL));
    litaC_intern__Strings_internConstant(litaC_this, "bool", 4, &(litaC_intern__BOOL));
    litaC_intern__Strings_internConstant(litaC_this, "char", 4, &(litaC_intern__CHAR));
    litaC_intern__Strings_internConstant(litaC_this, "i8", 2, &(litaC_intern__I8));
    litaC_intern__Strings_internConstant(litaC_this, "u8", 2, &(litaC_intern__U8));
    litaC_intern__Strings_internConstant(litaC_this, "i16", 3, &(litaC_intern__I16));
    litaC_intern__Strings_internConstant(litaC_this, "u16", 3, &(litaC_intern__U16));
    litaC_intern__Strings_internConstant(litaC_this, "i32", 3, &(litaC_intern__I32));
    litaC_intern__Strings_internConstant(litaC_this, "u32", 3, &(litaC_intern__U32));
    litaC_intern__Strings_internConstant(litaC_this, "i64", 3, &(litaC_intern__I64));
    litaC_intern__Strings_internConstant(litaC_this, "u64", 3, &(litaC_intern__U64));
    litaC_intern__Strings_internConstant(litaC_this, "f32", 3, &(litaC_intern__F32));
    litaC_intern__Strings_internConstant(litaC_this, "f64", 3, &(litaC_intern__F64));
    litaC_intern__Strings_internConstant(litaC_this, "usize", 5, &(litaC_intern__USIZE));
    litaC_intern__Strings_internConstant(litaC_this, "const", 5, &(litaC_intern__CONST));
    litaC_intern__Strings_internConstant(litaC_this, "*const char", 11, &(litaC_intern__STRING));
    litaC_intern__Strings_internConstant(litaC_this, "generic_param", 13, &(litaC_intern__GENERIC_PARAM));
    litaC_intern__Strings_internConstant(litaC_this, "<poison>", 8, &(litaC_intern__POISON));
    litaC_intern__Strings_internConstant(litaC_this, "builtin", 7, &(litaC_intern__BUILTIN));
    litaC_intern__Strings_internConstant(litaC_this, "main", 4, &(litaC_intern__MAIN));
    litaC_intern__Strings_internConstant(litaC_this, "numOfTypeInfos", 15, &(litaC_intern__NUM_OF_TYPE_INFOS));
    litaC_intern__Strings_internConstant(litaC_this, "typeInfos", 9, &(litaC_intern__TYPE_INFOS));
    litaC_intern__Strings_internConstant(litaC_this, "ProfileTag", 10, &(litaC_intern__PROFILE_TAG));
    litaC_intern__Strings_internConstant(litaC_this, "profileEntries", 15, &(litaC_intern__PROFILE_ENTRIES));
    litaC_intern__Strings_internConstant(litaC_this, "if", 2, &(litaC_intern__IF));
    litaC_intern__Strings_internConstant(litaC_this, "static_if", 9, &(litaC_intern__STATIC_IF));
    litaC_intern__Strings_internConstant(litaC_this, "else", 4, &(litaC_intern__ELSE));
    litaC_intern__Strings_internConstant(litaC_this, "elseif", 6, &(litaC_intern__ELSEIF));
    litaC_intern__Strings_internConstant(litaC_this, "precheck", 8, &(litaC_intern__PRECHECK));
    litaC_intern__Strings_internConstant(litaC_this, "postcheck", 9, &(litaC_intern__POSTCHECK));
    litaC_intern__Strings_internConstant(litaC_this, "postparse", 9, &(litaC_intern__POSTPARSE));
    litaC_intern__Strings_internConstant(litaC_this, "end", 3, &(litaC_intern__END));
    litaC_intern__Strings_internConstant(litaC_this, "else_error", 10, &(litaC_intern__ELSE_ERROR));
    litaC_intern__Strings_internConstant(litaC_this, "include", 7, &(litaC_intern__INCLUDE));
    litaC_intern__Strings_internConstant(litaC_this, "raw", 3, &(litaC_intern__RAW));
    litaC_intern__Strings_internConstant(litaC_this, "inline", 6, &(litaC_intern__INLINE));
    litaC_intern__Strings_internConstant(litaC_this, "noinline", 8, &(litaC_intern__NOINLINE));
    litaC_intern__Strings_internConstant(litaC_this, "static", 6, &(litaC_intern__STATIC));
    litaC_intern__Strings_internConstant(litaC_this, "atomic", 6, &(litaC_intern__ATOMIC));
    litaC_intern__Strings_internConstant(litaC_this, "register", 8, &(litaC_intern__REGISTER));
    litaC_intern__Strings_internConstant(litaC_this, "threadlocal", 11, &(litaC_intern__THREADLOCAL));
    litaC_intern__Strings_internConstant(litaC_this, "export", 6, &(litaC_intern__EXPORT));
    litaC_intern__Strings_internConstant(litaC_this, "packed", 6, &(litaC_intern__PACKED));
    litaC_intern__Strings_internConstant(litaC_this, "cc", 2, &(litaC_intern__CC));
    litaC_intern__Strings_internConstant(litaC_this, "cFile", 5, &(litaC_intern__CFILE));
    litaC_intern__Strings_internConstant(litaC_this, "cInclude", 8, &(litaC_intern__CINCLUDE));
    litaC_intern__Strings_internConstant(litaC_this, "foreign", 7, &(litaC_intern__FOREIGN));
    litaC_intern__Strings_internConstant(litaC_this, "alias", 5, &(litaC_intern__ALIAS));
    litaC_intern__Strings_internConstant(litaC_this, "asStr", 5, &(litaC_intern__ASSTR));
    litaC_intern__Strings_internConstant(litaC_this, "toStr", 5, &(litaC_intern__TOSTR));
    litaC_intern__Strings_internConstant(litaC_this, "compiler_option", 15, &(litaC_intern__COMPILER_OPTION));
    
}

litaC_void litaC_intern__Strings_free(litaC_intern__Strings* litaC_this) {
    litaC_std__mem__Allocator_free(litaC_this->allocator, litaC_this->keys);
    litaC_std__mem__Allocator_free(litaC_this->allocator, litaC_this->values);
    litaC_this->length = 0;
    litaC_this->capacity = 0;
    
}

litaC_void litaC_intern__Strings_internConstant(litaC_intern__Strings* litaC_this,const litaC_char* litaC_string,litaC_i32 litaC_length,litaC_intern__InternedString* litaC_intern) {
    litaC_intern__InternedString litaC_str = litaC_intern__Strings_intern(litaC_this, litaC_string, litaC_length);
    litaC_intern->buffer = litaC_str.buffer;
    litaC_intern->length = litaC_str.length;
    
}

litaC_intern__InternedString litaC_intern__Strings_internStringView(litaC_intern__Strings* litaC_this,litaC_std__string_view__StringView* litaC_string) {
    return litaC_intern__Strings_internCopy(litaC_this, litaC_string->buffer, litaC_string->length);
    
    
}


litaC_intern__InternedString litaC_intern__Strings_intern(litaC_intern__Strings* litaC_this,const litaC_char* litaC_string,litaC_i32 litaC_length) {
    litaC_std__string_view__StringView litaC_view =  {
        .buffer = litaC_string,
        .length = litaC_length
    };
    litaC_intern__InternedString litaC_result = litaC_intern__Strings_get(litaC_this, &((litaC_view)));
    if(litaC_result.length == 0) {
        {
            litaC_result = (litaC_intern__InternedString) {
                .buffer = litaC_string,
                .length = litaC_view.length
            };
            litaC_intern__Strings_put(litaC_this, litaC_view, litaC_result);
            
            
        }
        
    } 
    
    return litaC_result;
    
    
}


litaC_intern__InternedString litaC_intern__Strings_internCopy(litaC_intern__Strings* litaC_this,const litaC_char* litaC_string,litaC_i32 litaC_length) {
    litaC_std__string_view__StringView litaC_view =  {
        .buffer = litaC_string,
        .length = ((litaC_length < 0)) ? strlen(litaC_string) : litaC_length
    };
    litaC_length = litaC_view.length;
    litaC_intern__InternedString litaC_result = litaC_intern__Strings_get(litaC_this, &((litaC_view)));
    if(litaC_result.length == 0) {
        {
            litaC_char* litaC_copy = (litaC_char*)litaC_std__mem__Allocator_alloc(litaC_this->allocator, sizeof(litaC_char) * litaC_length);
            memcpy(litaC_copy, litaC_string, litaC_length);
            litaC_result = (litaC_intern__InternedString) {
                .buffer = litaC_copy,
                .length = litaC_length
            };
            litaC_intern__Strings_put(litaC_this, litaC_result.view, litaC_result);
            
            
        }
        
    } 
    
    return litaC_result;
    
    
}

litaC_void litaC_intern__Strings_put(litaC_intern__Strings* litaC_this,litaC_std__string_view__StringView litaC_key,litaC_intern__InternedString litaC_value) {
    if(litaC_this->length >= (litaC_this->capacity * 0.55)) {
        {
            litaC_intern__Strings_grow(litaC_this, 2 * litaC_this->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_std__string_view__StringView_hash(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_this->capacity - 1;
            litaC_std__string_view__StringView litaC_k = litaC_this->keys[litaC_i];
            if(litaC_k.length == 0) {
                {
                    litaC_this->length += 1;
                    litaC_this->keys[litaC_i] = litaC_key;
                    litaC_this->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_k.length == litaC_key.length && strncmp(litaC_key.buffer, litaC_k.buffer, litaC_key.length) == 0) {
                    {
                        litaC_this->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_i32 litaC_intern__Strings_size(litaC_intern__Strings* litaC_this) {
    return litaC_this->length;
    
    
}

litaC_intern__InternedString litaC_intern__Strings_get(litaC_intern__Strings* litaC_this,litaC_std__string_view__StringView* litaC_key) {
    if(litaC_this->length == 0) {
        {
            return litaC_intern__EMPTY_STR;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_std__string_view__StringView_hash(*((litaC_key)));
    for(;;) {
        {
            litaC_i &= litaC_this->capacity - 1;
            litaC_std__string_view__StringView litaC_k = litaC_this->keys[litaC_i];
            if(litaC_k.length == litaC_key->length && strncmp(litaC_key->buffer, litaC_k.buffer, litaC_key->length) == 0) {
                {
                    return litaC_this->values[litaC_i];
                    
                    
                    
                }
                
            } else {
                if(litaC_k.length == 0) {
                    {
                        return litaC_intern__EMPTY_STR;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_intern__EMPTY_STR;
    
    
}

litaC_void litaC_intern__Strings_grow(litaC_intern__Strings* litaC_this,litaC_i32 litaC_newlength) {
    litaC_std__string_view__StringView* litaC_oldKeys = litaC_this->keys;
    litaC_intern__InternedString* litaC_oldValues = litaC_this->values;
    litaC_i32 litaC_oldCapacity = litaC_this->capacity;
    litaC_this->keys = (litaC_std__string_view__StringView*)litaC_std__mem__Allocator_calloc(litaC_this->allocator, litaC_newlength, sizeof(litaC_std__string_view__StringView));
    litaC_this->values = (litaC_intern__InternedString*)litaC_std__mem__Allocator_calloc(litaC_this->allocator, litaC_newlength, sizeof(litaC_intern__InternedString));
    litaC_this->capacity = litaC_newlength;
    litaC_this->length = 0;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_oldCapacity;litaC_i += 1) {
        {
            if(litaC_oldKeys[litaC_i].buffer) {
                {
                    litaC_intern__Strings_put(litaC_this, litaC_oldKeys[litaC_i], litaC_oldValues[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_std__mem__Allocator_free(litaC_this->allocator, litaC_oldKeys);
    litaC_std__mem__Allocator_free(litaC_this->allocator, litaC_oldValues);
    
}

LITAC_INLINE 
litaC_bool litaC_intern__InternedString_equalsStr(litaC_intern__InternedString* litaC_this,const litaC_char* litaC_other) {
    return strncmp(litaC_this->buffer, litaC_other, litaC_this->length) == 0;
    
    
}

LITAC_INLINE 
litaC_bool litaC_intern__InternedString_equals(litaC_intern__InternedString* litaC_this,litaC_intern__InternedString* litaC_other) {
    return litaC_this->addr == litaC_other->addr;
    
    
}

LITAC_INLINE 
litaC_bool litaC_intern__InternedString_empty(litaC_intern__InternedString* litaC_this) {
    return litaC_this->buffer == NULL || litaC_this->length == 0;
    
    
}

litaC_std__string_view__StringView litaC_intern__InternedString_asStringView(litaC_intern__InternedString* litaC_this) {
    return (litaC_std__string_view__StringView) {
        .buffer = litaC_this->buffer,
        .length = litaC_this->length
    };
    
    
}

litaC_void litaC_ast_print__PrintTypeSpec(litaC_ast__TypeSpec* litaC_spec) {
    if(litaC_spec == NULL) {
        {
            return;
            
            
            
        }
        
    } 
    
    switch(litaC_spec->kind) {
        case litaC_ast__TypeSpecKind_NONE: {
            {
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_ARRAY: {
            {
                litaC_ast__TypeSpec* litaC_array = litaC_spec;
                printf("[");
                if(litaC_array->numElements) {
                    {
                        litaC_ast_print__PrintStmt(&((litaC_array->numElements->stmt)), 0);
                        
                        
                    }
                    
                } 
                
                printf("]");
                litaC_ast_print__PrintTypeSpec(litaC_array->base);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_PTR: {
            {
                litaC_ast__TypeSpec* litaC_ptr = litaC_spec;
                printf("*");
                litaC_ast_print__PrintTypeSpec(litaC_ptr->base);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_CONST: {
            {
                litaC_ast__TypeSpec* litaC_c = litaC_spec;
                printf("const ");
                litaC_ast_print__PrintTypeSpec(litaC_c->base);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_NAME: {
            {
                litaC_ast__TypeSpec* litaC_name = litaC_spec;
                printf("%.*s", litaC_name->name.length, litaC_name->name.buffer);
                if(!(litaC_std__array__Array_empty_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs))))) {
                    {
                        printf("<");
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    printf(",");
                                    
                                } 
                                
                                litaC_ast_print__PrintTypeSpec(litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)), litaC_i));
                                
                                
                            }
                        }
                        printf(">");
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_FUNC_PTR: {
            {
                litaC_ast__TypeSpec* litaC_fn = litaC_spec;
                printf("func");
                if(!(litaC_std__array__Array_empty_cb_GenericParam_ce_(&((litaC_fn->genericParams))))) {
                    {
                        printf("<");
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_fn->genericParams)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    {
                                        printf(",");
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_ast_print__PrintName(litaC_std__array__Array_get_cb_GenericParam_ce_(&((litaC_fn->genericParams)), litaC_i).name.token);
                                
                                
                            }
                        }
                        printf(">");
                        
                        
                    }
                    
                } 
                
                printf("(");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_fn->args)));litaC_i += 1) {
                    {
                        if(litaC_i > 0) {
                            printf(",");
                            
                        } 
                        
                        litaC_ast_print__PrintTypeSpec(litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_fn->args)), litaC_i));
                        
                        
                    }
                }
                printf(") : ");
                litaC_ast_print__PrintTypeSpec(litaC_fn->ret);
                return;
                
                
                
            }
            
            
        }
        default: {
            {
                litaC_common__Panic("Invalid TypeSpecKind: '%d'\n", litaC_spec->kind);
                
                
            }
            
            
        }
    }
    
}

litaC_void litaC_ast_print__PrintName(litaC_lex__Token litaC_tok) {
    if(litaC_tok.type != litaC_lex__TokenType_ERROR) {
        {
            printf("%.*s", litaC_tok.value.str.length, litaC_tok.value.str.buffer);
            
            
        }
        
    } 
    
    
}

litaC_void litaC_ast_print__Printf(litaC_i32 litaC_indent,const litaC_char* litaC_format,...) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_indent;litaC_i += 1) {
        {
            printf("    ");
            
            
        }
    }
    va_list litaC_args = {0};
    va_start(litaC_args, litaC_format);
    vprintf(litaC_format, litaC_args);
    va_end(litaC_args);
    
}

litaC_void litaC_ast_print__PrintStmt(litaC_ast__Stmt* litaC_s,litaC_i32 litaC_indent) {
    if(!(litaC_s)) {
        return;
        
        
    } 
    
    switch(litaC_s->node.kind) {
        case litaC_ast__StmtKind_IMPORT_DECL: {
            {
                litaC_ast__ImportDecl* litaC_decl = (litaC_ast__ImportDecl*)litaC_s;
                litaC_ast_print__Printf(0, "import '");
                litaC_ast_print__PrintName(litaC_decl->decl.name.token);
                printf("'");
                if(litaC_decl->alias.token.type == litaC_lex__TokenType_IDENTIFIER) {
                    {
                        litaC_ast_print__Printf(0, " as ");
                        litaC_ast_print__PrintName(litaC_decl->alias.token);
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONST_DECL: 
        case litaC_ast__StmtKind_VAR_DECL: {
            {
                litaC_ast__VarDecl* litaC_decl = (litaC_ast__VarDecl*)litaC_s;
                if(!(litaC_std__array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.attributes.notes))))) {
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.attributes.notes)));litaC_i += 1) {
                            {
                                litaC_ast_print__PrintStmt(&((litaC_std__array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.attributes.notes)), litaC_i)->stmt)), litaC_indent);
                                printf("\n");
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                if(litaC_decl->decl.stmt.node.kind == litaC_ast__StmtKind_CONST_DECL) {
                    {
                        litaC_ast_print__Printf(litaC_indent, "const ");
                        
                        
                    }
                    
                } else {
                    {
                        litaC_ast_print__Printf(litaC_indent, "var ");
                        
                        
                    }
                } 
                
                litaC_ast_print__PrintName(litaC_decl->decl.name.token);
                if(litaC_decl->typeSpec != NULL) {
                    {
                        printf(": ");
                        litaC_ast_print__PrintTypeSpec(litaC_decl->typeSpec);
                        
                        
                    }
                    
                } 
                
                if(litaC_decl->expr != NULL) {
                    {
                        printf(" = ");
                        litaC_ast_print__PrintStmt(&((litaC_decl->expr->stmt)), 0);
                        
                        
                    }
                    
                } 
                
                printf(";");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_STRUCT_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_decl = (litaC_ast__AggregateDecl*)litaC_s;
                if(!(litaC_std__array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes))))) {
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes)));litaC_i += 1) {
                            {
                                litaC_ast_print__PrintStmt(&((litaC_std__array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes)), litaC_i)->stmt)), litaC_indent);
                                printf("\n");
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                litaC_ast_print__Printf(litaC_indent, "");
                if(litaC_decl->decl.declaration.attributes.visibility == litaC_ast__Visibility_PUBLIC) {
                    {
                        printf("public ");
                        
                        
                    }
                    
                } else {
                    if(litaC_decl->decl.declaration.attributes.visibility == litaC_ast__Visibility_INTERNAL) {
                        {
                            printf("internal ");
                            
                            
                        }
                        
                    } 
                    
                } 
                
                printf("struct ");
                litaC_ast_print__PrintName(litaC_decl->decl.declaration.name.token);
                if(!(litaC_std__array__Array_empty_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams))))) {
                    {
                        printf("<");
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    litaC_ast_print__Printf(litaC_indent, ",");
                                    
                                } 
                                
                                litaC_ast__Identifier litaC_t = litaC_std__array__Array_get_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)), litaC_i).name;
                                printf("%.*s", litaC_t.str.length, litaC_t.str.buffer);
                                
                                
                            }
                        }
                        printf(">");
                        
                        
                    }
                    
                } 
                
                printf(" {\n");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_decl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_decl->fields)), litaC_i);
                        switch(litaC_field.kind) {
                            case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                {
                                    litaC_ast_print__PrintStmt((litaC_ast__Stmt*)litaC_field.enumField, litaC_indent + 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_STRUCT_FIELD_DECL: 
                            case litaC_ast__StmtKind_UNION_FIELD_DECL: {
                                {
                                    litaC_ast_print__PrintStmt((litaC_ast__Stmt*)litaC_field.aggregateField, litaC_indent + 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                {
                                    litaC_ast_print__PrintStmt(&((litaC_field.varField->decl.stmt)), litaC_indent + 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                {
                                    litaC_ast_print__PrintStmt(&((litaC_field.traitField->decl.stmt)), litaC_indent + 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            default: {
                                {
                                    
                                    
                                }
                                
                                
                            }
                        }
                        printf("\n");
                        
                        
                    }
                }
                litaC_ast_print__Printf(litaC_indent, "}");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNION_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_decl = (litaC_ast__AggregateDecl*)litaC_s;
                if(!(litaC_std__array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes))))) {
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes)));litaC_i += 1) {
                            {
                                litaC_ast_print__PrintStmt(&((litaC_std__array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes)), litaC_i)->stmt)), litaC_indent);
                                printf("\n");
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                litaC_ast_print__Printf(litaC_indent, "");
                if(litaC_decl->decl.declaration.attributes.visibility == litaC_ast__Visibility_PUBLIC) {
                    {
                        printf("public ");
                        
                        
                    }
                    
                } else {
                    if(litaC_decl->decl.declaration.attributes.visibility == litaC_ast__Visibility_INTERNAL) {
                        {
                            printf("internal ");
                            
                            
                        }
                        
                    } 
                    
                } 
                
                printf("union ");
                litaC_ast_print__PrintName(litaC_decl->decl.declaration.name.token);
                if(!(litaC_std__array__Array_empty_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams))))) {
                    {
                        printf("<");
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    litaC_ast_print__Printf(litaC_indent, ",");
                                    
                                } 
                                
                                litaC_ast__Identifier litaC_t = litaC_std__array__Array_get_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)), litaC_i).name;
                                printf("%.*s", litaC_t.str.length, litaC_t.str.buffer);
                                
                                
                            }
                        }
                        printf(">");
                        
                        
                    }
                    
                } 
                
                printf(" {\n");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_decl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_decl->fields)), litaC_i);
                        switch(litaC_field.kind) {
                            case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                {
                                    litaC_ast_print__PrintStmt((litaC_ast__Stmt*)litaC_field.enumField, litaC_indent + 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_STRUCT_FIELD_DECL: 
                            case litaC_ast__StmtKind_UNION_FIELD_DECL: {
                                {
                                    litaC_ast_print__PrintStmt((litaC_ast__Stmt*)litaC_field.aggregateField, litaC_indent + 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                {
                                    litaC_ast_print__PrintStmt(&((litaC_field.varField->decl.stmt)), litaC_indent + 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                {
                                    litaC_ast_print__PrintStmt(&((litaC_field.traitField->decl.stmt)), litaC_indent + 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            default: {
                                {
                                    
                                    
                                }
                                
                                
                            }
                        }
                        printf("\n");
                        
                        
                    }
                }
                litaC_ast_print__Printf(litaC_indent, "}");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TRAIT_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_decl = (litaC_ast__AggregateDecl*)litaC_s;
                if(!(litaC_std__array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes))))) {
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes)));litaC_i += 1) {
                            {
                                litaC_ast_print__PrintStmt(&((litaC_std__array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes)), litaC_i)->stmt)), litaC_indent);
                                printf("\n");
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                litaC_ast_print__Printf(litaC_indent, "");
                if(litaC_decl->decl.declaration.attributes.visibility == litaC_ast__Visibility_PUBLIC) {
                    {
                        printf("public ");
                        
                        
                    }
                    
                } else {
                    if(litaC_decl->decl.declaration.attributes.visibility == litaC_ast__Visibility_INTERNAL) {
                        {
                            printf("internal ");
                            
                            
                        }
                        
                    } 
                    
                } 
                
                printf("trait ");
                litaC_ast_print__PrintName(litaC_decl->decl.declaration.name.token);
                if(!(litaC_std__array__Array_empty_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams))))) {
                    {
                        printf("<");
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    litaC_ast_print__Printf(litaC_indent, ",");
                                    
                                } 
                                
                                litaC_ast__Identifier litaC_t = litaC_std__array__Array_get_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)), litaC_i).name;
                                printf("%.*s", litaC_t.str.length, litaC_t.str.buffer);
                                
                                
                            }
                        }
                        printf(">");
                        
                        
                    }
                    
                } 
                
                printf(" {\n");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_decl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_decl->fields)), litaC_i);
                        switch(litaC_field.kind) {
                            case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                {
                                    litaC_ast_print__PrintStmt((litaC_ast__Stmt*)litaC_field.traitField, litaC_indent + 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            default: {
                                {
                                    
                                    
                                }
                                
                                
                            }
                        }
                        printf("\n");
                        
                        
                    }
                }
                litaC_ast_print__Printf(litaC_indent, "}");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: {
            {
                litaC_ast__EnumDecl* litaC_decl = (litaC_ast__EnumDecl*)litaC_s;
                if(!(litaC_std__array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.attributes.notes))))) {
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.attributes.notes)));litaC_i += 1) {
                            {
                                litaC_ast_print__PrintStmt(&((litaC_std__array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.attributes.notes)), litaC_i)->stmt)), litaC_indent);
                                printf("\n");
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                litaC_ast_print__Printf(litaC_indent, "");
                if(litaC_decl->decl.attributes.visibility == litaC_ast__Visibility_PUBLIC) {
                    {
                        printf("public ");
                        
                        
                    }
                    
                } else {
                    if(litaC_decl->decl.attributes.visibility == litaC_ast__Visibility_INTERNAL) {
                        {
                            printf("internal ");
                            
                            
                        }
                        
                    } 
                    
                } 
                
                printf("enum ");
                litaC_ast_print__PrintName(litaC_decl->decl.name.token);
                printf(" {\n");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_decl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__EnumFieldEntryDecl* litaC_field = litaC_std__array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_decl->fields)), litaC_i);
                        litaC_ast_print__PrintStmt(&((litaC_field->decl.stmt)), litaC_indent + 1);
                        printf(",\n");
                        
                        
                    }
                }
                litaC_ast_print__Printf(litaC_indent, "}");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                litaC_ast__FuncDecl* litaC_decl = (litaC_ast__FuncDecl*)litaC_s;
                if(!(litaC_std__array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes))))) {
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes)));litaC_i += 1) {
                            {
                                litaC_ast_print__PrintStmt(&((litaC_std__array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes)), litaC_i)->stmt)), litaC_indent);
                                printf("\n");
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                if(litaC_decl->decl.declaration.attributes.visibility == litaC_ast__Visibility_PUBLIC) {
                    {
                        litaC_ast_print__Printf(litaC_indent, "public ");
                        
                        
                    }
                    
                } else {
                    if(litaC_decl->decl.declaration.attributes.visibility == litaC_ast__Visibility_INTERNAL) {
                        {
                            litaC_ast_print__Printf(litaC_indent, "internal ");
                            
                            
                        }
                        
                    } 
                    
                } 
                
                litaC_ast_print__Printf(litaC_indent, "func ");
                litaC_ast_print__PrintName(litaC_decl->decl.declaration.name.token);
                if(!(litaC_std__array__Array_empty_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams))))) {
                    {
                        litaC_ast_print__Printf(litaC_indent, "<");
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    litaC_ast_print__Printf(litaC_indent, ",");
                                    
                                } 
                                
                                litaC_ast__Identifier litaC_t = litaC_std__array__Array_get_cb_GenericParam_ce_(&((litaC_decl->decl.genericParams)), litaC_i).name;
                                litaC_ast_print__Printf(litaC_indent, "%.*s", litaC_t.str.length, litaC_t.str.buffer);
                                
                                
                            }
                        }
                        litaC_ast_print__Printf(litaC_indent, ">");
                        
                        
                    }
                    
                } 
                
                litaC_ast_print__Printf(litaC_indent, "(");
                if(litaC_decl->params) {
                    {
                        litaC_ast_print__PrintStmt(&((litaC_decl->params->stmt)), 0);
                        
                        
                    }
                    
                } 
                
                litaC_ast_print__Printf(litaC_indent, ")");
                if(litaC_decl->returnType) {
                    {
                        litaC_ast_print__Printf(litaC_indent, " : ");
                        litaC_ast_print__PrintTypeSpec(litaC_decl->returnType);
                        
                        
                    }
                    
                } 
                
                if(litaC_decl->body) {
                    {
                        printf("\n");
                        litaC_ast_print__PrintStmt(litaC_decl->body, litaC_indent);
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                litaC_ast__TypedefDecl* litaC_decl = (litaC_ast__TypedefDecl*)litaC_s;
                if(!(litaC_std__array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes))))) {
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes)));litaC_i += 1) {
                            {
                                litaC_ast_print__PrintStmt(&((litaC_std__array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.declaration.attributes.notes)), litaC_i)->stmt)), litaC_indent);
                                printf("\n");
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                if(litaC_decl->decl.declaration.attributes.visibility == litaC_ast__Visibility_PUBLIC) {
                    {
                        litaC_ast_print__Printf(litaC_indent, "public ");
                        
                        
                    }
                    
                } else {
                    if(litaC_decl->decl.declaration.attributes.visibility == litaC_ast__Visibility_INTERNAL) {
                        {
                            litaC_ast_print__Printf(litaC_indent, "internal ");
                            
                            
                        }
                        
                    } 
                    
                } 
                
                litaC_ast_print__Printf(litaC_indent, "typedef ");
                litaC_ast_print__PrintTypeSpec(litaC_decl->type);
                printf(" as ");
                litaC_ast_print__PrintName(litaC_decl->decl.declaration.name.token);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAM_DECL: {
            {
                litaC_ast__ParameterDecl* litaC_decl = (litaC_ast__ParameterDecl*)litaC_s;
                if(!(litaC_std__array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.attributes.notes))))) {
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.attributes.notes)));litaC_i += 1) {
                            {
                                litaC_ast_print__PrintStmt(&((litaC_std__array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_decl->decl.attributes.notes)), litaC_i)->stmt)), litaC_indent);
                                printf("\n");
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                litaC_ast_print__PrintName(litaC_decl->decl.name.token);
                litaC_ast_print__Printf(litaC_indent, ": ");
                litaC_ast_print__PrintTypeSpec(litaC_decl->type);
                if(litaC_decl->defaultExpr) {
                    {
                        litaC_ast_print__Printf(litaC_indent, " = ");
                        litaC_ast_print__PrintStmt(&((litaC_decl->defaultExpr->stmt)), 0);
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_DECL: {
            {
                litaC_ast_print__Printf(litaC_indent, "<poison_decl>");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BLOCK_STMT: {
            {
                litaC_ast__BlockStmt* litaC_stmt = (litaC_ast__BlockStmt*)litaC_s;
                litaC_ast_print__Printf(litaC_indent - 1, "{\n");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)));litaC_i += 1) {
                    {
                        litaC_ast__Stmt* litaC_n = litaC_std__array__Array_get_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)), litaC_i);
                        litaC_ast_print__PrintStmt(litaC_n, litaC_indent + 1);
                        if(litaC_ast__IsExpr(&((litaC_n->node)))) {
                            {
                                printf(";\n");
                                
                                
                            }
                            
                        } else {
                            {
                                printf("\n");
                                
                                
                            }
                        } 
                        
                        
                        
                    }
                }
                printf("\n");
                litaC_ast_print__Printf(litaC_indent - 1, "}");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BREAK_STMT: {
            {
                litaC_ast_print__Printf(litaC_indent, "break");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONTINUE_STMT: {
            {
                litaC_ast_print__Printf(litaC_indent, "continue");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DEFER_STMT: {
            {
                litaC_ast__DeferStmt* litaC_stmt = (litaC_ast__DeferStmt*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "defer ");
                litaC_ast_print__PrintStmt(litaC_stmt->deferedStmt, litaC_indent);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DO_WHILE_STMT: {
            {
                litaC_ast__DoWhileStmt* litaC_stmt = (litaC_ast__DoWhileStmt*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "do\n");
                litaC_ast_print__PrintStmt(litaC_stmt->body, litaC_indent + 1);
                litaC_ast_print__Printf(litaC_indent, "\nwhile(");
                litaC_ast_print__PrintStmt(&((litaC_stmt->cond->stmt)), 0);
                litaC_ast_print__Printf(0, ")");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_EMPTY_STMT: {
            {
                printf("\n");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_FIELD_ENTRY_DECL: {
            {
                litaC_ast__EnumFieldEntryDecl* litaC_stmt = (litaC_ast__EnumFieldEntryDecl*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "");
                litaC_ast_print__PrintName(litaC_stmt->decl.name.token);
                if(litaC_stmt->value) {
                    {
                        printf(" = ");
                        litaC_ast_print__PrintStmt(&((litaC_stmt->value->stmt)), 0);
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FOR_STMT: {
            {
                litaC_ast__ForStmt* litaC_stmt = (litaC_ast__ForStmt*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "for(");
                if(litaC_stmt->init) {
                    {
                        litaC_ast_print__PrintStmt(litaC_stmt->init, 0);
                        
                        
                    }
                    
                } 
                
                printf(";");
                if(litaC_stmt->cond) {
                    {
                        litaC_ast_print__PrintStmt(&((litaC_stmt->cond->stmt)), 0);
                        
                        
                    }
                    
                } 
                
                printf(";");
                if(litaC_stmt->post) {
                    {
                        litaC_ast_print__PrintStmt(litaC_stmt->post, 0);
                        
                        
                    }
                    
                } 
                
                printf(")\n");
                if(litaC_stmt->body) {
                    {
                        litaC_ast_print__PrintStmt(litaC_stmt->body, litaC_indent + 1);
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_BODY_STMT: {
            {
                litaC_ast__FuncBodyStmt* litaC_stmt = (litaC_ast__FuncBodyStmt*)litaC_s;
                litaC_ast_print__Printf(litaC_indent - 1, "{\n");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)));litaC_i += 1) {
                    {
                        litaC_ast__Stmt* litaC_n = litaC_std__array__Array_get_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)), litaC_i);
                        litaC_ast_print__PrintStmt(litaC_n, litaC_indent + 1);
                        if(litaC_ast__IsExpr(&((litaC_n->node)))) {
                            {
                                printf(";\n");
                                
                                
                            }
                            
                        } else {
                            {
                                printf("\n");
                                
                                
                            }
                        } 
                        
                        
                        
                    }
                }
                printf("\n");
                litaC_ast_print__Printf(litaC_indent - 1, "}");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GOTO_STMT: {
            {
                litaC_ast__GotoStmt* litaC_stmt = (litaC_ast__GotoStmt*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "goto ");
                litaC_ast_print__PrintName(litaC_stmt->label.token);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IF_STMT: {
            {
                litaC_ast__IfStmt* litaC_stmt = (litaC_ast__IfStmt*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "if(");
                litaC_ast_print__PrintStmt(&((litaC_stmt->cond->stmt)), 0);
                printf(") \n");
                litaC_ast_print__PrintStmt(litaC_stmt->then, litaC_indent + 1);
                printf("\n");
                if(litaC_stmt->elseStmt) {
                    {
                        litaC_ast_print__Printf(litaC_indent, "else \n");
                        litaC_ast_print__PrintStmt(litaC_stmt->elseStmt, litaC_indent + 1);
                        
                        
                    }
                    
                } 
                
                printf("\n");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_LABEL_STMT: {
            {
                litaC_ast__LabelStmt* litaC_stmt = (litaC_ast__LabelStmt*)litaC_s;
                printf(":");
                litaC_ast_print__PrintName(litaC_stmt->label.token);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_MODULE_STMT: {
            {
                litaC_ast__ModuleStmt* litaC_stmt = (litaC_ast__ModuleStmt*)litaC_s;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_ImportDecl_ce_(&((litaC_stmt->imports)));litaC_i += 1) {
                    {
                        litaC_ast_print__PrintStmt((litaC_ast__Stmt*)litaC_std__array__Array_get_cb__ptr_ImportDecl_ce_(&((litaC_stmt->imports)), litaC_i), 0);
                        litaC_ast_print__Printf(litaC_indent, "\n");
                        
                        
                    }
                }
                printf("\n");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_stmt->notes)));litaC_i += 1) {
                    {
                        litaC_ast_print__PrintStmt(&((litaC_std__array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_stmt->notes)), litaC_i)->stmt)), 0);
                        litaC_ast_print__Printf(litaC_indent, ";\n");
                        
                        
                    }
                }
                printf("\n");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Decl_ce_(&((litaC_stmt->declarations)));litaC_i += 1) {
                    {
                        litaC_ast_print__PrintStmt((litaC_ast__Stmt*)litaC_std__array__Array_get_cb__ptr_Decl_ce_(&((litaC_stmt->declarations)), litaC_i), 0);
                        litaC_ast_print__Printf(litaC_indent, "\n");
                        printf("\n");
                        
                        
                    }
                }
                printf("\n");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NOTE_STMT: {
            {
                litaC_ast__NoteStmt* litaC_stmt = (litaC_ast__NoteStmt*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "@");
                litaC_ast_print__PrintTypeSpec(litaC_stmt->type);
                if(!(litaC_std__array__Array_empty_cb_CallArg_ce_(&((litaC_stmt->arguments))))) {
                    {
                        printf("(");
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_CallArg_ce_(&((litaC_stmt->arguments)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    printf(", ");
                                    
                                } 
                                
                                printf("'");
                                printf("'");
                                
                                
                            }
                        }
                        printf(")");
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAMETERS_STMT: {
            {
                litaC_ast__ParametersStmt* litaC_stmt = (litaC_ast__ParametersStmt*)litaC_s;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_stmt->params)));litaC_i += 1) {
                    {
                        if(litaC_i > 0) {
                            printf(", ");
                            
                        } 
                        
                        litaC_ast_print__PrintStmt((litaC_ast__Stmt*)litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_stmt->params)), litaC_i), 0);
                        
                        
                    }
                }
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_RETURN_STMT: {
            {
                litaC_ast__ReturnStmt* litaC_stmt = (litaC_ast__ReturnStmt*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "return");
                if(litaC_stmt->expr) {
                    {
                        printf(" ");
                        litaC_ast_print__PrintStmt(&((litaC_stmt->expr->stmt)), 0);
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
            {
                litaC_ast__TraitFieldDecl* litaC_stmt = (litaC_ast__TraitFieldDecl*)litaC_s;
                if(!(litaC_std__array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_stmt->decl.attributes.notes))))) {
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_stmt->decl.attributes.notes)));litaC_i += 1) {
                            {
                                litaC_ast_print__PrintStmt(&((litaC_std__array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_stmt->decl.attributes.notes)), litaC_i)->stmt)), litaC_indent);
                                printf("\n");
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                litaC_ast_print__Printf(litaC_indent, "");
                litaC_ast_print__PrintName(litaC_stmt->decl.name.token);
                printf(": ");
                litaC_ast_print__PrintTypeSpec(litaC_stmt->type);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_VAR_FIELD_DECL: {
            {
                litaC_ast__VarFieldDecl* litaC_stmt = (litaC_ast__VarFieldDecl*)litaC_s;
                if(!(litaC_std__array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_stmt->decl.attributes.notes))))) {
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_stmt->decl.attributes.notes)));litaC_i += 1) {
                            {
                                litaC_ast_print__PrintStmt(&((litaC_std__array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_stmt->decl.attributes.notes)), litaC_i)->stmt)), litaC_indent);
                                printf("\n");
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                litaC_ast_print__Printf(litaC_indent, "");
                litaC_ast_print__PrintName(litaC_stmt->decl.name.token);
                printf(": ");
                litaC_ast_print__PrintTypeSpec(litaC_stmt->type);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_WHILE_STMT: {
            {
                litaC_ast__WhileStmt* litaC_stmt = (litaC_ast__WhileStmt*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "while(");
                litaC_ast_print__PrintStmt(&((litaC_stmt->cond->stmt)), 0);
                litaC_ast_print__Printf(0, ")\n");
                litaC_ast_print__PrintStmt(litaC_stmt->body, litaC_indent);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR: {
            {
                litaC_ast__ArrayDesignationExpr* litaC_expr = (litaC_ast__ArrayDesignationExpr*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "[");
                litaC_ast_print__PrintStmt(&((litaC_expr->index->stmt)), 0);
                litaC_ast_print__Printf(0, "] = ");
                litaC_ast_print__PrintStmt(&((litaC_expr->value->stmt)), 0);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_INIT_EXPR: {
            {
                litaC_ast__ArrayInitExpr* litaC_expr = (litaC_ast__ArrayInitExpr*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "[]");
                litaC_ast_print__PrintTypeSpec(litaC_expr->type);
                litaC_ast_print__Printf(0, "{\n");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Expr_ce_(&((litaC_expr->values)));litaC_i += 1) {
                    {
                        litaC_ast__Expr* litaC_v = litaC_std__array__Array_get_cb__ptr_Expr_ce_(&((litaC_expr->values)), litaC_i);
                        if(litaC_i > 0) {
                            litaC_ast_print__Printf(0, ",\n");
                            
                        } 
                        
                        litaC_ast_print__PrintStmt(&((litaC_v->stmt)), litaC_indent + 1);
                        
                        
                    }
                }
                litaC_ast_print__Printf(litaC_indent, "}\n");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BINARY_EXPR: {
            {
                litaC_ast__BinaryExpr* litaC_expr = (litaC_ast__BinaryExpr*)litaC_s;
                litaC_ast_print__PrintStmt(&((litaC_expr->left->stmt)), litaC_indent);
                printf(" %s ", litaC_lex__tokenText[litaC_expr->operator]);
                litaC_ast_print__PrintStmt(&((litaC_expr->right->stmt)), 0);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BOOLEAN_EXPR: {
            {
                litaC_ast__BooleanExpr* litaC_expr = (litaC_ast__BooleanExpr*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "%s", (litaC_expr->boolean) ? "true" : "false");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CHAR_EXPR: {
            {
                litaC_ast__CharExpr* litaC_expr = (litaC_ast__CharExpr*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "'%c'", (litaC_char)litaC_expr->character.value.intValue);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GET_EXPR: {
            {
                litaC_ast__GetExpr* litaC_expr = (litaC_ast__GetExpr*)litaC_s;
                litaC_ast_print__PrintStmt(&((litaC_expr->object->stmt)), litaC_indent);
                printf(".");
                litaC_ast_print__PrintStmt(&((litaC_expr->field->expr.stmt)), 0);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GROUP_EXPR: {
            {
                litaC_ast__GroupExpr* litaC_expr = (litaC_ast__GroupExpr*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "(");
                litaC_ast_print__PrintStmt(&((litaC_expr->groupedExpr->stmt)), 0);
                litaC_ast_print__Printf(0, ")");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: {
            {
                litaC_ast__IdentifierExpr* litaC_expr = (litaC_ast__IdentifierExpr*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "%.*s", litaC_expr->type->name.length, litaC_expr->type->name.buffer);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NULL_EXPR: {
            {
                printf("null");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NUMBER_EXPR: {
            {
                litaC_ast__NumberExpr* litaC_expr = (litaC_ast__NumberExpr*)litaC_s;
                switch(litaC_expr->number.type) {
                    case litaC_lex__TokenType_INT_NUMBER: {
                        {
                            litaC_ast_print__Printf(litaC_indent, "%llu", litaC_expr->number.value.intValue);
                            break;
                            
                            
                        }
                        
                        
                    }
                    case litaC_lex__TokenType_FLOAT_NUMBER: {
                        {
                            litaC_ast_print__Printf(litaC_indent, "%f", litaC_expr->number.value.floatValue);
                            break;
                            
                            
                        }
                        
                        
                    }
                    default: {
                        {
                            
                            
                        }
                        
                        
                    }
                }
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_STRING_EXPR: {
            {
                litaC_ast__StringExpr* litaC_expr = (litaC_ast__StringExpr*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "\"%.*s\"", litaC_expr->string.value.str.length, litaC_expr->string.value.str.buffer);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TERNARY_EXPR: {
            {
                litaC_ast__TernaryExpr* litaC_expr = (litaC_ast__TernaryExpr*)litaC_s;
                litaC_ast_print__Printf(litaC_indent, "(");
                litaC_ast_print__PrintStmt(&((litaC_expr->cond->stmt)), 0);
                printf(") ? ");
                litaC_ast_print__PrintStmt(&((litaC_expr->then->stmt)), 0);
                printf(" : ");
                litaC_ast_print__PrintStmt(&((litaC_expr->other->stmt)), 0);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_EXPR: {
            {
                litaC_ast_print__Printf(litaC_indent, "<poison_expr>");
                return;
                
                
                
            }
            
            
        }
        default: {
            {
                litaC_ast_print__Printf(litaC_indent, "<%s:%d Not Implemented>", litaC_ast__StmtKindAsStr(litaC_s->node.kind), litaC_s->node.kind);
                return;
                
                
                
            }
            
            
        }
    }
    
}

litaC_void litaC_generics__GetGenericName(litaC_checker__TypeChecker* litaC_checker,litaC_ast__TypeSpec* litaC_type,litaC_std__string__String* litaC_str) {
    if(litaC_type == NULL) {
        {
            return;
            
            
            
        }
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_ast__TypeSpecKind_ARRAY: {
            {
                litaC_std__string__String_append(litaC_str, "[]");
                litaC_generics__GetGenericName(litaC_checker, litaC_type->base, litaC_str);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_PTR: {
            {
                litaC_std__string__String_append(litaC_str, "*");
                litaC_generics__GetGenericName(litaC_checker, litaC_type->base, litaC_str);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_CONST: {
            {
                litaC_std__string__String_append(litaC_str, "const ");
                litaC_generics__GetGenericName(litaC_checker, litaC_type->base, litaC_str);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_NAME: {
            {
                litaC_ast__TypeSpec* litaC_name = litaC_type;
                litaC_bool litaC_nameSet = litaC_false;
                if(!(litaC_type->typeInfo)) {
                    {
                        litaC_symbols__Symbol* litaC_unaliasedType = litaC_checker__TypeChecker_getType(litaC_checker, litaC_name, litaC_checker__SearchType_TYPE);
                        if(litaC_unaliasedType) {
                            {
                                litaC_types__TypeInfo* litaC_type = litaC_unaliasedType->type;
                                if(litaC_type && !(litaC_intern__InternedString_empty(&((litaC_type->name))))) {
                                    {
                                        litaC_std__string__String_appendStrn(litaC_str, litaC_type->name.buffer, litaC_type->name.length);
                                        litaC_nameSet = litaC_true;
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } else {
                    {
                        litaC_std__string__String_append(litaC_str, "%.*s", litaC_type->typeInfo->name.length, litaC_type->typeInfo->name.buffer);
                        return;
                        
                        
                        
                    }
                } 
                
                if(!(litaC_nameSet)) {
                    {
                        litaC_std__string__String_appendStrn(litaC_str, litaC_name->name.buffer, litaC_name->name.length);
                        
                        
                    }
                    
                } 
                
                if(litaC_std__array__Array_empty_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)))) {
                    {
                        return;
                        
                        
                        
                    }
                    
                } 
                
                litaC_std__string__String_append(litaC_str, "<");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)));litaC_i += 1) {
                    {
                        if(litaC_i > 0) {
                            {
                                litaC_std__string__String_append(litaC_str, ",");
                                
                                
                            }
                            
                        } 
                        
                        litaC_ast__TypeSpec* litaC_arg = litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)), litaC_i);
                        litaC_generics__GetGenericName(litaC_checker, litaC_arg, litaC_str);
                        
                        
                    }
                }
                litaC_std__string__String_append(litaC_str, ">");
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_FUNC_PTR: {
            {
                litaC_std__string__String_append(litaC_str, "func(");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_type->args)));litaC_i += 1) {
                    {
                        if(litaC_i > 0) {
                            {
                                litaC_std__string__String_append(litaC_str, ",");
                                
                                
                            }
                            
                        } 
                        
                        litaC_ast__TypeSpec* litaC_arg = litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_type->args)), litaC_i);
                        litaC_generics__GetGenericName(litaC_checker, litaC_arg, litaC_str);
                        
                        
                    }
                }
                litaC_std__string__String_append(litaC_str, "):");
                if(litaC_type->ret) {
                    {
                        litaC_generics__GetGenericName(litaC_checker, litaC_type->ret, litaC_str);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_std__string__String_append(litaC_str, "void");
                        
                        
                    }
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_NONE: 
        default: {
            
            
        }
    }
    
}

litaC_symbols__Symbol* litaC_generics__CreateTypeFromGenericTemplate(litaC_checker__TypeChecker* litaC_checker,litaC_symbols__Symbol* litaC_sym,litaC_ast__TypeSpec* litaC_name) {
    assert(litaC_sym != NULL);
    litaC_bool litaC_isNewContext = litaC_checker->genericContext.callsite == NULL;
    if(litaC_isNewContext) {
        {
            litaC_checker->genericContext.callsite = litaC_checker->current;
            
            
        }
        
    } 
    
    
    litaC_char litaC_buffer[1024] = {0};
    litaC_std__string__String litaC_genericName = litaC_std__string__StringInit(litaC_buffer, litaC_generics__MAX_GENERIC_NAME, 0);
    litaC_generics__GetGenericName(litaC_checker, litaC_name, &((litaC_genericName)));
    litaC_intern__InternedString litaC_newNameStr = litaC_intern__Strings_internCopy(&((litaC_checker->lita->strings)), litaC_std__string__String_cStrConst(litaC_genericName), litaC_genericName.length);
    litaC_symbols__Symbol* litaC_genericSym = litaC_std__map__Map_get_cb_InternedString_c__ptr_Symbol_ce_(litaC_checker->current->genericSymbols, litaC_newNameStr);
    litaC_module__Module* litaC_module = litaC_checker->current;
    if(litaC_genericSym && litaC_genericSym->flags & litaC_symbols__SymbolFlags_IS_MARKED_RESET) {
        {
            litaC_genericSym = NULL;
            
            
        }
        
    } 
    
    if(!(litaC_genericSym)) {
        {
            litaC_ast__GenericDecl* litaC_genericDecl = litaC_generics__CreateDecl(litaC_sym, &((litaC_name->genericArgs)), litaC_module);
            if(!(litaC_genericDecl)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_genericSym = litaC_symbols__Scope_addSymbol(&((litaC_checker->current->symbols)), litaC_newNameStr, litaC_sym->declared, &((litaC_genericDecl->declaration)), litaC_symbols__SymbolFlags_IS_INCOMPLETE | litaC_symbols__SymbolFlags_IS_FROM_GENERIC_TEMPLATE);
            if(!(litaC_genericSym)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_genericSym->genericCallsiteModule = litaC_checker->current;
            litaC_genericSym->genericParams = litaC_std__array__Array_copy_cb_GenericParam_ce_(&((litaC_genericDecl->genericParams)), litaC_checker->lita->allocator);
            litaC_std__map__Map_put_cb_InternedString_c__ptr_Symbol_ce_(litaC_checker->current->genericSymbols, litaC_newNameStr, litaC_genericSym);
            if(litaC_genericSym->decl->stmt.node.kind == litaC_ast__StmtKind_FUNC_DECL) {
                {
                    litaC_std__array__Array_add_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)), litaC_genericSym);
                    
                    
                }
                
            } else {
                {
                    litaC_std__array__Array_add_cb__ptr_Symbol_ce_(&((litaC_checker->symbolTypes)), litaC_genericSym);
                    
                    
                }
            } 
            
            if(litaC_generics__HasGenericParam(litaC_checker, &((litaC_name->genericArgs)))) {
                {
                    litaC_genericSym->flags |= litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE;
                    litaC_ast__GenericDecl* litaC_originalDecl = (litaC_ast__GenericDecl*)litaC_sym->decl;
                    litaC_genericDecl->genericParams = litaC_std__array__Array_copy_cb_GenericParam_ce_(&((litaC_originalDecl->genericParams)), litaC_checker->lita->allocator);
                    
                    
                }
                
            } else {
                {
                    litaC_i32 litaC_removed = 0;
                    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)));litaC_i += 1) {
                        {
                            litaC_i32 litaC_index = litaC_i - litaC_removed;
                            if(litaC_index < litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_genericDecl->genericParams)))) {
                                {
                                    litaC_std__array__Array_removeAt_cb_GenericParam_ce_(&((litaC_genericDecl->genericParams)), litaC_index);
                                    litaC_removed += 1;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                    }
                    
                    
                }
            } 
            
            litaC_i32 litaC_numOfGenericArgs = litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)));
            litaC_std__array__Array_init_cb__ptr_TypeInfo_ce_(&((litaC_genericSym->genericArgs)), litaC_numOfGenericArgs, litaC_checker->lita->allocator);
            litaC_bool litaC_isValidArgs = litaC_true;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_numOfGenericArgs;litaC_i += 1) {
                {
                    litaC_ast__TypeSpec* litaC_arg = litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)), litaC_i);
                    litaC_types__TypeInfo* litaC_typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_checker, litaC_arg, litaC_checker__SearchType_TYPE);
                    if(!(litaC_typeInfo) || litaC_typeInfo->kind == litaC_types__TypeKind_POISON) {
                        {
                            litaC_isValidArgs = litaC_false;
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__array__Array_add_cb__ptr_TypeInfo_ce_(&((litaC_genericSym->genericArgs)), litaC_arg->typeInfo);
                    
                    
                }
            }
            if(!(litaC_isValidArgs)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } else {
        {
            litaC_bool litaC_isValidArgs = litaC_true;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)));litaC_i += 1) {
                {
                    litaC_ast__TypeSpec* litaC_arg = litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)), litaC_i);
                    litaC_types__TypeInfo* litaC_typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_checker, litaC_arg, litaC_checker__SearchType_TYPE);
                    if(!(litaC_typeInfo) || litaC_typeInfo->kind == litaC_types__TypeKind_POISON) {
                        {
                            litaC_isValidArgs = litaC_false;
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            if(!(litaC_isValidArgs)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    } 
    
    assert(litaC_genericSym != NULL);
    litaC_checker__TypeChecker_resolveSymbol(litaC_checker, litaC_genericSym);
    litaC_checker__TypeChecker_finishResolveSymbol(litaC_checker, litaC_genericSym);
    litaC_name->typeInfo = litaC_genericSym->type;
    if(litaC_types__IsGenericCapable(litaC_genericSym->type) && litaC_sym->type) {
        {
            litaC_types__TypeInfo* litaC_genericType = litaC_genericSym->type;
            litaC_genericType->genericTypeid = litaC_sym->type->typeid;
            
            
        }
        
    } 
    
    {
        litaC_symbols__Symbol* ___result = litaC_genericSym;
        if(litaC_isNewContext) {
            litaC_checker->genericContext.callsite = NULL;
            
        } 
        ;
        return ___result;
        
    }
    
    err:;
    
    {
        litaC_symbols__Symbol* ___result = NULL;
        if(litaC_isNewContext) {
            litaC_checker->genericContext.callsite = NULL;
            
        } 
        ;
        return ___result;
        
    }
    
    if(litaC_isNewContext) {
        litaC_checker->genericContext.callsite = NULL;
        
    } 
    ;
    
}

litaC_ast__GenericDecl* litaC_generics__CreateDecl(litaC_symbols__Symbol* litaC_sym,litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_genericArgs,litaC_module__Module* litaC_module) {
    litaC_ast__GenericDecl* litaC_genericDecl = NULL;
    switch(litaC_sym->decl->stmt.node.kind) {
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                litaC_genericDecl = litaC_generics__CreateFuncDecl((litaC_ast__FuncDecl*)litaC_sym->decl, litaC_genericArgs, litaC_module);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: {
            {
                litaC_genericDecl = litaC_generics__CreateAggregateDecl((litaC_ast__AggregateDecl*)litaC_sym->decl, litaC_genericArgs, litaC_module);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                litaC_genericDecl = litaC_generics__CreateTypedefDecl((litaC_ast__TypedefDecl*)litaC_sym->decl, litaC_genericArgs, litaC_module);
                break;
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return litaC_genericDecl;
    
    
}

litaC_ast__GenericDecl* litaC_generics__CreateAggregateDecl(litaC_ast__AggregateDecl* litaC_aggDecl,litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_genericArgs,litaC_module__Module* litaC_module) {
    litaC_ast__AggregateDecl* litaC_copy = litaC_ast_copy__CopyAggregateDecl(litaC_aggDecl, litaC_module);
    litaC_generics__Template litaC_template =  {
        .genericParams = &(litaC_aggDecl->decl.genericParams),
        .genericArgs = litaC_genericArgs
    };
    litaC_generics__ReplaceTypes(&(litaC_template), &((litaC_copy->decl.declaration.stmt.node)));
    return (litaC_ast__GenericDecl*)litaC_copy;
    
    
}

litaC_ast__GenericDecl* litaC_generics__CreateFuncDecl(litaC_ast__FuncDecl* litaC_funcDecl,litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_genericArgs,litaC_module__Module* litaC_module) {
    litaC_ast__FuncDecl* litaC_copy = litaC_ast_copy__CopyFuncDecl(litaC_funcDecl, litaC_module);
    litaC_generics__Template litaC_template =  {
        .genericParams = &(litaC_funcDecl->decl.genericParams),
        .genericArgs = litaC_genericArgs
    };
    litaC_generics__ReplaceTypes(&(litaC_template), &((litaC_copy->decl.declaration.stmt.node)));
    return (litaC_ast__GenericDecl*)litaC_copy;
    
    
}

litaC_ast__GenericDecl* litaC_generics__CreateTypedefDecl(litaC_ast__TypedefDecl* litaC_typedefDecl,litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_genericArgs,litaC_module__Module* litaC_module) {
    litaC_ast__TypedefDecl* litaC_copy = litaC_ast_copy__CopyTypedefDecl(litaC_typedefDecl, litaC_module);
    litaC_generics__Template litaC_template =  {
        .genericParams = &(litaC_typedefDecl->decl.genericParams),
        .genericArgs = litaC_genericArgs
    };
    litaC_generics__ReplaceTypes(&(litaC_template), &((litaC_copy->decl.declaration.stmt.node)));
    return (litaC_ast__GenericDecl*)litaC_copy;
    
    
}

litaC_ast__TypeSpec* litaC_generics__Template_replaceTypeSpec(litaC_generics__Template* litaC_this,litaC_ast__TypeSpec* litaC_type) {
    if(!(litaC_type)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_ast__TypeSpecKind_NONE: {
            {
                return NULL;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_ARRAY: {
            {
                litaC_type->base = litaC_generics__Template_replaceTypeSpec(litaC_this, litaC_type->base);
                return litaC_type;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_CONST: {
            {
                litaC_type->base = litaC_generics__Template_replaceTypeSpec(litaC_this, litaC_type->base);
                return litaC_type;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_PTR: {
            {
                litaC_type->base = litaC_generics__Template_replaceTypeSpec(litaC_this, litaC_type->base);
                return litaC_type;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_FUNC_PTR: {
            {
                litaC_ast__TypeSpec* litaC_funcPtr = litaC_type;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_funcPtr->args)));litaC_i += 1) {
                    {
                        litaC_std__array__Array_set_cb__ptr_TypeSpec_ce_(&((litaC_funcPtr->args)), litaC_i, litaC_generics__Template_replaceTypeSpec(litaC_this, litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_funcPtr->args)), litaC_i)));
                        
                        
                    }
                }
                litaC_funcPtr->ret = litaC_generics__Template_replaceTypeSpec(litaC_this, litaC_funcPtr->ret);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_funcPtr->genericParams)));) {
                    {
                        litaC_bool litaC_isRemoved = litaC_false;
                        litaC_ast__GenericParam litaC_genParam = litaC_std__array__Array_get_cb_GenericParam_ce_(&((litaC_funcPtr->genericParams)), litaC_i);
                        for(litaC_i32 litaC_j = 0;litaC_j < litaC_std__array__Array_size_cb_GenericParam_ce_(litaC_this->genericParams);litaC_j += 1) {
                            {
                                litaC_ast__GenericParam litaC_param = litaC_std__array__Array_get_cb_GenericParam_ce_(litaC_this->genericParams, litaC_j);
                                if(litaC_intern__InternedString_equals(&((litaC_param.name.str)), &((litaC_genParam.name.str)))) {
                                    {
                                        litaC_std__array__Array_removeAt_cb_GenericParam_ce_(&((litaC_funcPtr->genericParams)), litaC_i);
                                        litaC_isRemoved = litaC_true;
                                        break;
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                        }
                        if(!(litaC_isRemoved)) {
                            {
                                litaC_i += 1;
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                return litaC_type;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_NAME: {
            {
                litaC_ast__TypeSpec* litaC_name = litaC_type;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)));litaC_i += 1) {
                    {
                        litaC_std__array__Array_set_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)), litaC_i, litaC_generics__Template_replaceTypeSpec(litaC_this, litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)), litaC_i)));
                        
                        
                    }
                }
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_GenericParam_ce_(litaC_this->genericParams);litaC_i += 1) {
                    {
                        litaC_ast__GenericParam litaC_param = litaC_std__array__Array_get_cb_GenericParam_ce_(litaC_this->genericParams, litaC_i);
                        if(litaC_intern__InternedString_equals(&((litaC_param.name.str)), &((litaC_name->name)))) {
                            {
                                if(litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(litaC_this->genericArgs)) {
                                    {
                                        return litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(litaC_this->genericArgs, litaC_i);
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                return litaC_type;
                
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return NULL;
    
    
}

litaC_bool litaC_generics__ReplaceTypes(litaC_generics__Template* litaC_template,litaC_ast__Node* litaC_ast) {
    if(!(litaC_ast)) {
        return litaC_true;
        
        
    } 
    
    switch(litaC_ast->kind) {
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_aggDecl = (litaC_ast__AggregateDecl*)litaC_ast;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_aggDecl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_aggDecl->fields)), litaC_i);
                        switch(litaC_field.kind) {
                            case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                {
                                    litaC_ast__TraitFieldDecl* litaC_traitField = litaC_field.traitField;
                                    litaC_traitField->type = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_traitField->type);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                {
                                    litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                                    litaC_varField->type = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_varField->type);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                {
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                            case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                                {
                                    litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                                    litaC_generics__ReplaceTypes(litaC_template, &((litaC_aggField->decl.declaration.stmt.node)));
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_POISON_EXPR: {
                                {
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            default: {
                                {
                                    assert(litaC_false);
                                    
                                    
                                }
                                
                                
                            }
                        }
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                litaC_ast__FuncDecl* litaC_funcDecl = (litaC_ast__FuncDecl*)litaC_ast;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcDecl->params->params)));litaC_i += 1) {
                    {
                        litaC_ast__ParameterDecl* litaC_param = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcDecl->params->params)), litaC_i);
                        litaC_param->type = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_param->type);
                        if(litaC_param->defaultExpr) {
                            {
                                litaC_generics__ReplaceTypes(litaC_template, &((litaC_param->defaultExpr->stmt.node)));
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                litaC_funcDecl->returnType = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_funcDecl->returnType);
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_funcDecl->body->node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IMPORT_DECL: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONST_DECL: 
        case litaC_ast__StmtKind_VAR_DECL: {
            {
                litaC_ast__VarDecl* litaC_decl = (litaC_ast__VarDecl*)litaC_ast;
                litaC_decl->typeSpec = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_decl->typeSpec);
                if(litaC_decl->expr) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_decl->expr->stmt.node)));
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                litaC_ast__TypedefDecl* litaC_decl = (litaC_ast__TypedefDecl*)litaC_ast;
                litaC_decl->type = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_decl->type);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: 
        case litaC_ast__StmtKind_PARAM_DECL: 
        case litaC_ast__StmtKind_NATIVE_DECL: 
        case litaC_ast__StmtKind_POISON_DECL: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BLOCK_STMT: {
            {
                litaC_ast__BlockStmt* litaC_body = (litaC_ast__BlockStmt*)litaC_ast;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Stmt_ce_(&((litaC_body->stmts)));litaC_i += 1) {
                    {
                        litaC_ast__Stmt* litaC_s = litaC_std__array__Array_get_cb__ptr_Stmt_ce_(&((litaC_body->stmts)), litaC_i);
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_s->node)));
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BREAK_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_COMP_STMT: {
            {
                litaC_ast__CompStmt* litaC_comp = (litaC_ast__CompStmt*)litaC_ast;
                if(litaC_comp->evaluatedStmt) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_comp->evaluatedStmt->node)));
                        
                        
                    }
                    
                } 
                
                if(litaC_comp->end) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_comp->end->stmt.node)));
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Stmt_ce_(&((litaC_comp->body)));litaC_i += 1) {
                    {
                        litaC_ast__Stmt* litaC_s = litaC_std__array__Array_get_cb__ptr_Stmt_ce_(&((litaC_comp->body)), litaC_i);
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_s->node)));
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONTINUE_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DEFER_STMT: {
            {
                litaC_ast__DeferStmt* litaC_deferStmt = (litaC_ast__DeferStmt*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_deferStmt->deferedStmt->node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DO_WHILE_STMT: {
            {
                litaC_ast__DoWhileStmt* litaC_whileStmt = (litaC_ast__DoWhileStmt*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_whileStmt->body->node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_whileStmt->cond->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_EMPTY_STMT: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FOR_STMT: {
            {
                litaC_ast__ForStmt* litaC_forStmt = (litaC_ast__ForStmt*)litaC_ast;
                if(litaC_forStmt->init) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_forStmt->init->node)));
                        
                        
                    }
                    
                } 
                
                if(litaC_forStmt->cond) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_forStmt->cond->stmt.node)));
                        
                        
                    }
                    
                } 
                
                if(litaC_forStmt->post) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_forStmt->post->node)));
                        
                        
                    }
                    
                } 
                
                if(litaC_forStmt->body) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_forStmt->body->node)));
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_BODY_STMT: {
            {
                litaC_ast__FuncBodyStmt* litaC_body = (litaC_ast__FuncBodyStmt*)litaC_ast;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Stmt_ce_(&((litaC_body->stmts)));litaC_i += 1) {
                    {
                        litaC_ast__Stmt* litaC_s = litaC_std__array__Array_get_cb__ptr_Stmt_ce_(&((litaC_body->stmts)), litaC_i);
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_s->node)));
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GOTO_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IF_STMT: {
            {
                litaC_ast__IfStmt* litaC_ifStmt = (litaC_ast__IfStmt*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_ifStmt->cond->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_ifStmt->then->node)));
                if(litaC_ifStmt->elseStmt) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_ifStmt->elseStmt->node)));
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_LABEL_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_MODULE_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NOTE_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAMETERS_STMT: {
            {
                litaC_ast__ParametersStmt* litaC_params = (litaC_ast__ParametersStmt*)litaC_ast;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_params->params)));litaC_i += 1) {
                    {
                        litaC_ast__ParameterDecl* litaC_param = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_params->params)), litaC_i);
                        litaC_generics__ReplaceTypes(litaC_template, (litaC_ast__Node*)litaC_param);
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_RETURN_STMT: {
            {
                litaC_ast__ReturnStmt* litaC_stmt = (litaC_ast__ReturnStmt*)litaC_ast;
                if(litaC_stmt->expr) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_stmt->expr->stmt.node)));
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SWITCH_CASE_STMT: {
            {
                litaC_ast__SwitchCaseStmt* litaC_caseStmt = (litaC_ast__SwitchCaseStmt*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_caseStmt->cond->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_caseStmt->body->node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SWITCH_STMT: {
            {
                litaC_ast__SwitchStmt* litaC_switchStmt = (litaC_ast__SwitchStmt*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_switchStmt->cond->stmt.node)));
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_SwitchCaseStmt_ce_(&((litaC_switchStmt->cases)));litaC_i += 1) {
                    {
                        litaC_ast__SwitchCaseStmt* litaC_caseStmt = litaC_std__array__Array_get_cb__ptr_SwitchCaseStmt_ce_(&((litaC_switchStmt->cases)), litaC_i);
                        litaC_generics__ReplaceTypes(litaC_template, (litaC_ast__Node*)litaC_caseStmt);
                        
                        
                    }
                }
                if(litaC_switchStmt->defaultStmt) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_switchStmt->defaultStmt->node)));
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_FIELD_DECL: 
        case litaC_ast__StmtKind_ENUM_FIELD_ENTRY_DECL: 
        case litaC_ast__StmtKind_STRUCT_FIELD_DECL: 
        case litaC_ast__StmtKind_UNION_FIELD_DECL: 
        case litaC_ast__StmtKind_TRAIT_FIELD_DECL: 
        case litaC_ast__StmtKind_VAR_FIELD_DECL: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_WHILE_STMT: {
            {
                litaC_ast__WhileStmt* litaC_whileStmt = (litaC_ast__WhileStmt*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_whileStmt->cond->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_whileStmt->body->node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR: {
            {
                litaC_ast__ArrayDesignationExpr* litaC_expr = (litaC_ast__ArrayDesignationExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->index->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->value->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_INIT_EXPR: {
            {
                litaC_ast__ArrayInitExpr* litaC_expr = (litaC_ast__ArrayInitExpr*)litaC_ast;
                litaC_expr->type = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_expr->type);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Expr_ce_(&((litaC_expr->values)));litaC_i += 1) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_std__array__Array_get_cb__ptr_Expr_ce_(&((litaC_expr->values)), litaC_i)->stmt.node)));
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BINARY_EXPR: {
            {
                litaC_ast__BinaryExpr* litaC_expr = (litaC_ast__BinaryExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->left->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->right->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BOOLEAN_EXPR: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CAST_EXPR: {
            {
                litaC_ast__CastExpr* litaC_expr = (litaC_ast__CastExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->exprToCast->stmt.node)));
                litaC_expr->castTo = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_expr->castTo);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CHAR_EXPR: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_CALL_EXPR: {
            {
                litaC_ast__FuncCallExpr* litaC_expr = (litaC_ast__FuncCallExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->object->stmt.node)));
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)));litaC_i += 1) {
                    {
                        litaC_ast__TypeSpec* litaC_arg = litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)), litaC_i);
                        litaC_arg = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_arg);
                        litaC_std__array__Array_set_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)), litaC_i, litaC_arg);
                        
                        
                    }
                }
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_CallArg_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, &((litaC_std__array__Array_get_cb_CallArg_ce_(&((litaC_expr->arguments)), litaC_i).argExpr->stmt.node)));
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: {
            {
                litaC_ast__IdentifierExpr* litaC_expr = (litaC_ast__IdentifierExpr*)litaC_ast;
                litaC_expr->type = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_expr->type);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GET_EXPR: {
            {
                litaC_ast__GetExpr* litaC_expr = (litaC_ast__GetExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->object->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, (litaC_ast__Node*)litaC_expr->field);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GROUP_EXPR: {
            {
                litaC_ast__GroupExpr* litaC_expr = (litaC_ast__GroupExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->groupedExpr->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: {
            {
                litaC_ast__IdentifierExpr* litaC_expr = (litaC_ast__IdentifierExpr*)litaC_ast;
                litaC_expr->type = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_expr->type);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_INIT_EXPR: {
            {
                litaC_ast__InitExpr* litaC_expr = (litaC_ast__InitExpr*)litaC_ast;
                litaC_expr->type = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_expr->type);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)));litaC_i += 1) {
                    {
                        litaC_ast__TypeSpec* litaC_arg = litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)), litaC_i);
                        litaC_arg = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_arg);
                        litaC_std__array__Array_set_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)), litaC_i, litaC_arg);
                        
                        
                    }
                }
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
                    {
                        litaC_generics__ReplaceTypes(litaC_template, (litaC_ast__Node*)litaC_std__array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)), litaC_i));
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_INIT_ARG_EXPR: {
            {
                litaC_ast__InitArgExpr* litaC_expr = (litaC_ast__InitArgExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->value->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NULL_EXPR: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NUMBER_EXPR: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_OFFSET_OF_EXPR: {
            {
                litaC_ast__OffsetOfExpr* litaC_expr = (litaC_ast__OffsetOfExpr*)litaC_ast;
                litaC_expr->type = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_expr->type);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SET_EXPR: {
            {
                litaC_ast__SetExpr* litaC_expr = (litaC_ast__SetExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->object->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, (litaC_ast__Node*)litaC_expr->field);
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->value->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SIZE_OF_EXPR: {
            {
                litaC_ast__SizeOfExpr* litaC_expr = (litaC_ast__SizeOfExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->sizeOfExpr->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_STRING_EXPR: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR: {
            {
                litaC_ast__SubscriptGetExpr* litaC_expr = (litaC_ast__SubscriptGetExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->object->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->index->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_SET_EXPR: {
            {
                litaC_ast__SubscriptSetExpr* litaC_expr = (litaC_ast__SubscriptSetExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->object->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->index->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->value->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TERNARY_EXPR: {
            {
                litaC_ast__TernaryExpr* litaC_expr = (litaC_ast__TernaryExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->cond->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->then->stmt.node)));
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->other->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR: {
            {
                litaC_ast__TypeIdentifierExpr* litaC_expr = (litaC_ast__TypeIdentifierExpr*)litaC_ast;
                litaC_expr->type = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_expr->type);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_OF_EXPR: {
            {
                litaC_ast__TypeOfExpr* litaC_expr = (litaC_ast__TypeOfExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->typeOfExpr->stmt.node)));
                litaC_expr->type = litaC_generics__Template_replaceTypeSpec(litaC_template, litaC_expr->type);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNARY_EXPR: {
            {
                litaC_ast__UnaryExpr* litaC_expr = (litaC_ast__UnaryExpr*)litaC_ast;
                litaC_generics__ReplaceTypes(litaC_template, &((litaC_expr->unaryExpr->stmt.node)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_EXPR: {
            {
                break;
                
                
            }
            
            
        }
        default: {
            {
                printf("Statement Kind: %s\n", litaC_ast__StmtKindAsStr(litaC_ast->kind));
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return litaC_true;
    
    
}

litaC_bool litaC_generics__HasGenericParam(litaC_checker__TypeChecker* litaC_checker,litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_genericArgs) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(litaC_genericArgs);litaC_i += 1) {
        {
            litaC_ast__TypeSpec* litaC_arg = litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(litaC_genericArgs, litaC_i);
            litaC_ast__TypeSpec* litaC_name = litaC_ast__TypeSpec_getBaseType(litaC_arg);
            if(litaC_name && litaC_name->kind == litaC_ast__TypeSpecKind_NAME) {
                {
                    if(litaC_checker__TypeChecker_isGenericParamType(litaC_checker, litaC_name)) {
                        {
                            return litaC_true;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_void litaC_introspection__Introspect_generate(litaC_introspection__Introspect* litaC_this,litaC_checker__TypeChecker* litaC_checker) {
    if(litaC_this->lita->options->typeOption == litaC_lita__TypeInfoOption_NONE) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_char litaC_filename[_MAX_PATH] =  {
        0
    };
    litaC_std__string_view__StringView litaC_moduleName = litaC_std__string_view__StringViewInit("type", -(1));
    if(!(litaC_lita__FindModulePath(litaC_this->lita, litaC_moduleName, litaC_filename))) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), (litaC_lex__SrcPos) {
                
            }, "could not find builtin module 'type' on the system path.");
            return;
            
            
            
        }
        
    } 
    
    litaC_module__Module* litaC_module = litaC_lita__Lita_getModule(litaC_this->lita, litaC_filename);
    if(!(litaC_module)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(2048 * 8, litaC_this->lita->allocator);
    litaC_std__string_buffer__StringBuffer litaC_scratch = litaC_std__string_buffer__StringBufferInit(1024, litaC_this->lita->allocator);
    litaC_bool litaC_onlyTagged = litaC_this->lita->options->typeOption == litaC_lita__TypeInfoOption_TAGGED;
    litaC_i64 litaC_maxTypes = litaC_types__NextTypeId();
    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "\n    public const numOfTypeInfos : usize = %llu_u64;\n    public const typeInfos: **TypeInfo = [%llu]*TypeInfo {\n    ", litaC_maxTypes, litaC_maxTypes);
    if(litaC_onlyTagged) {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)));litaC_i += 1) {
                {
                    litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)), litaC_i);
                    if(litaC_ast__Decl_hasNote(litaC_sym->decl, "typeinfo")) {
                        {
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_checker->symbolTypes)));litaC_i += 1) {
                {
                    litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_checker->symbolTypes)), litaC_i);
                    if(litaC_ast__Decl_hasNote(litaC_sym->decl, "typeinfo")) {
                        {
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)));litaC_i += 1) {
                {
                    litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)), litaC_i);
                    litaC_types__TypeInfo* litaC_type = litaC_sym->type;
                    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    if(!(litaC_type) || litaC_type->kind != litaC_types__TypeKind_FUNC) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    litaC_introspection__Introspect_emitFunc(litaC_this, &((litaC_sb)), &((litaC_scratch)), litaC_sym);
                    
                    
                }
            }
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_checker->symbolTypes)));litaC_i += 1) {
                {
                    litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_checker->symbolTypes)), litaC_i);
                    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_ALIAS) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    litaC_introspection__Introspect_emitType(litaC_this, &((litaC_sb)), &((litaC_scratch)), litaC_sym);
                    
                    
                }
            }
            
            
        }
    } 
    
    {
        for(litaC_std__map__MapIterator_cb_ArrayEntry_c__ptr_TypeInfo_ce_ litaC_it = litaC_std__map__Map_iter_cb_ArrayEntry_c__ptr_TypeInfo_ce_(&((litaC_checker->typeCache->arrayCache)));litaC_std__map__MapIterator_hasNext_cb_ArrayEntry_c__ptr_TypeInfo_ce_(&((litaC_it)));) {
            {
                litaC_std__map__MapEntry_cb_ArrayEntry_c__ptr_TypeInfo_ce_ litaC_entry = litaC_std__map__MapIterator_next_cb_ArrayEntry_c__ptr_TypeInfo_ce_(&((litaC_it)));
                litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), (litaC_types__TypeInfo*)litaC_entry.value);
                
                
            }
        }
        for(litaC_std__map__MapIterator_cb_i64_c__ptr_TypeInfo_ce_ litaC_it = litaC_std__map__Map_iter_cb_i64_c__ptr_TypeInfo_ce_(&((litaC_checker->typeCache->ptrCache)));litaC_std__map__MapIterator_hasNext_cb_i64_c__ptr_TypeInfo_ce_(&((litaC_it)));) {
            {
                litaC_std__map__MapEntry_cb_i64_c__ptr_TypeInfo_ce_ litaC_entry = litaC_std__map__MapIterator_next_cb_i64_c__ptr_TypeInfo_ce_(&((litaC_it)));
                litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), (litaC_types__TypeInfo*)litaC_entry.value);
                
                
            }
        }
        for(litaC_std__map__MapIterator_cb_i64_c__ptr_TypeInfo_ce_ litaC_it = litaC_std__map__Map_iter_cb_i64_c__ptr_TypeInfo_ce_(&((litaC_checker->typeCache->constCache)));litaC_std__map__MapIterator_hasNext_cb_i64_c__ptr_TypeInfo_ce_(&((litaC_it)));) {
            {
                litaC_std__map__MapEntry_cb_i64_c__ptr_TypeInfo_ce_ litaC_entry = litaC_std__map__MapIterator_next_cb_i64_c__ptr_TypeInfo_ce_(&((litaC_it)));
                litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), (litaC_types__TypeInfo*)litaC_entry.value);
                
                
            }
        }
        
        
    }
    {
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__BOOL_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__CHAR_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__I8_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__U8_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__I16_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__U16_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__I32_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__U32_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__I64_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__U64_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__F32_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__F64_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__USIZE_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__NULL_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__VOID_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__STR_TYPE)));
        litaC_introspection__Introspect_emitPrimitiveType(litaC_this, &((litaC_sb)), &((litaC_types__POISON_TYPE)));
        
        
    }
    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "\n};");
    litaC_parser__Parser litaC_parser = litaC_parser__ParserInit(litaC_module->id.filename, litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_sb.length, litaC_module, litaC_this->lita);
    litaC_ast__ModuleStmt* litaC_stmts = litaC_parser__Parser_parseModule(&((litaC_parser)));
    if(litaC_stmts) {
        {
            litaC_checker__TypeChecker_enterModule(litaC_checker, litaC_module);
            
            assert(litaC_std__array__Array_size_cb__ptr_Decl_ce_(&((litaC_stmts->declarations))) == 2);
            {
                litaC_ast__Decl* litaC_numDecl = litaC_std__array__Array_get_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)), 0);
                assert(litaC_numDecl->stmt.node.kind == litaC_ast__StmtKind_CONST_DECL);
                litaC_types__TypeInfo* litaC_typeInfo = litaC_checker_decl__TypeChecker_resolveValueDecl(litaC_checker, (litaC_ast__VarDecl*)litaC_numDecl);
                assert(litaC_typeInfo != NULL);
                litaC_symbols__Symbol* litaC_existingDecl = litaC_module__Module_getType(litaC_module, litaC_intern__NUM_OF_TYPE_INFOS);
                assert(litaC_existingDecl != NULL);
                litaC_numDecl->sym = litaC_existingDecl;
                litaC_existingDecl->decl = litaC_numDecl;
                
                
            }
            {
                litaC_ast__Decl* litaC_typesDecl = litaC_std__array__Array_get_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)), 1);
                assert(litaC_typesDecl->stmt.node.kind == litaC_ast__StmtKind_CONST_DECL);
                litaC_checker->bypassing = litaC_true;
                litaC_types__TypeInfo* litaC_typeInfo = litaC_checker_decl__TypeChecker_resolveValueDecl(litaC_checker, (litaC_ast__VarDecl*)litaC_typesDecl);
                litaC_checker->bypassing = litaC_false;
                if(!(litaC_typeInfo)) {
                    {
                        if(litaC_phase_result__PhaseResult_hasErrors(&((litaC_checker->lita->result)))) {
                            {
                                litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(16, NULL);
                                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_PhaseError_ce_(&((litaC_checker->lita->result.errors)));litaC_i += 1) {
                                    {
                                        litaC_phase_result__PhaseError litaC_error = litaC_std__array__Array_get_cb_PhaseError_ce_(&((litaC_checker->lita->result.errors)), litaC_i);
                                        litaC_error_codes__PrintError(&((litaC_sb)), litaC_error);
                                        
                                        
                                    }
                                }
                                printf("ERRORS: \n%s\n", litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb))));
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                assert(litaC_typeInfo != NULL);
                litaC_symbols__Symbol* litaC_existingDecl = litaC_module__Module_getType(litaC_module, litaC_intern__TYPE_INFOS);
                assert(litaC_existingDecl != NULL);
                litaC_typesDecl->sym = litaC_existingDecl;
                litaC_existingDecl->decl = litaC_typesDecl;
                litaC_existingDecl->type = litaC_typeInfo;
                
                
            }
            litaC_checker__TypeChecker_leaveModule(litaC_checker);
            
            
        }
        
    } 
    
    
}

litaC_void litaC_introspection__Introspect_emitFunc(litaC_introspection__Introspect* litaC_this,litaC_std__string_buffer__StringBuffer* litaC_sb,litaC_std__string_buffer__StringBuffer* litaC_scratch,litaC_symbols__Symbol* litaC_sym) {
    litaC_types__TypeInfo* litaC_type = litaC_sym->type;
    assert(litaC_type->kind == litaC_types__TypeKind_FUNC);
    litaC_types__TypeInfo* litaC_funcInfo = litaC_type;
    litaC_bool litaC_isVararg = litaC_funcInfo->funcDecl->params->isVararg;
    litaC_i64 litaC_returnTypeid = litaC_funcInfo->returnType->typeid;
    litaC_i32 litaC_numOfParams = litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)));
    {
        litaC_std__string_buffer__StringBuffer_clear(litaC_scratch);
        if(litaC_numOfParams) {
            {
                litaC_std__string_buffer__StringBuffer_append(litaC_scratch, "[]ParamInfo {");
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_numOfParams;litaC_i += 1) {
                    {
                        litaC_ast__ParameterDecl* litaC_param = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)), litaC_i);
                        litaC_std__string_buffer__StringBuffer_append(litaC_scratch, "\n                    ParamInfo {\n                        .name = \"%.*s\",\n                        .type = %llu,\n                        .modifiers = Modifiers.%s,\n                    },\n                ", litaC_param->decl.name.str.length, litaC_param->decl.name.str.buffer, litaC_param->type->typeInfo->typeid, ((litaC_param->decl.attributes.isUsing)) ? "Using" : "None");
                        
                        
                    }
                }
                litaC_std__string_buffer__StringBuffer_append(litaC_scratch, "}");
                
                
            }
            
        } else {
            {
                litaC_std__string_buffer__StringBuffer_append(litaC_scratch, "null");
                
                
            }
        } 
        
        
        
    }
    litaC_std__string_buffer__StringBuffer_append(litaC_sb, "\n        [%llu] = &TypeInfo {\n            .kind = TypeKind.FUNC,\n            .name = \"%.*s\",\n            .id = %llu,\n            .funcType = funcType {\n                .isVararg = %s,\n                .returnType = %llu,\n                .params = %s,\n                .numOfParams = %d\n            }\n        },\n    ", litaC_type->typeid, litaC_sym->name.length, litaC_sym->name.buffer, litaC_type->typeid, (litaC_isVararg) ? "true" : "false", litaC_returnTypeid, litaC_std__string_buffer__StringBuffer_cStr(litaC_scratch), litaC_numOfParams);
    
}

litaC_void litaC_introspection__Introspect_emitType(litaC_introspection__Introspect* litaC_this,litaC_std__string_buffer__StringBuffer* litaC_sb,litaC_std__string_buffer__StringBuffer* litaC_scratch,litaC_symbols__Symbol* litaC_sym) {
    litaC_std__string_buffer__StringBuffer_clear(litaC_scratch);
    litaC_types__TypeInfo* litaC_type = litaC_sym->type;
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_ENUM: {
            {
                litaC_types__TypeInfo* litaC_enumInfo = litaC_type;
                litaC_ast__EnumDecl* litaC_decl = litaC_enumInfo->enumDecl;
                litaC_i32 litaC_numOfFields = litaC_std__array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_decl->fields)));
                if(litaC_numOfFields) {
                    {
                        litaC_std__string_buffer__StringBuffer_append(litaC_scratch, "[]EnumFieldInfo {");
                        litaC_i32 litaC_value = 0;
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_numOfFields;litaC_i += 1) {
                            {
                                litaC_ast__EnumFieldEntryDecl* litaC_field = litaC_std__array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_decl->fields)), litaC_i);
                                if(litaC_field->value) {
                                    {
                                        if(litaC_field->value->operand.isConst) {
                                            {
                                                litaC_value = (litaC_i32)litaC_field->value->operand.val.intValue;
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_std__string_buffer__StringBuffer_append(litaC_scratch, "\n                        EnumFieldInfo {\n                            .name = \"%.*s\",\n                            .value = %d,\n                        },\n                    ", litaC_field->decl.name.str.length, litaC_field->decl.name.str.buffer, litaC_value);
                                litaC_value += 1;
                                
                                
                            }
                        }
                        litaC_std__string_buffer__StringBuffer_append(litaC_scratch, "}");
                        
                        
                    }
                    
                } else {
                    {
                        litaC_std__string_buffer__StringBuffer_append(litaC_scratch, "null");
                        
                        
                    }
                } 
                
                litaC_intern__InternedString litaC_name = litaC_type->sym->name;
                litaC_std__string_buffer__StringBuffer_append(litaC_sb, "\n                [%llu] = &TypeInfo {\n                    .kind = TypeKind.%s,\n                    .name = \"%.*s\",\n                    .id = %llu,\n                    .enumType = enumType {\n                        .fields = %s,\n                        .numOfFields = %d\n                    }\n                },\n            ", litaC_type->typeid, litaC_types__TypeKindAsStr(litaC_type->kind), litaC_name.length, litaC_name.buffer, litaC_type->typeid, litaC_std__string_buffer__StringBuffer_cStr(litaC_scratch), litaC_numOfFields);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_TRAIT: 
        case litaC_types__TypeKind_UNION: 
        case litaC_types__TypeKind_STRUCT: {
            {
                litaC_types__TypeInfo* litaC_aggInfo = litaC_type;
                litaC_ast__AggregateDecl* litaC_decl = litaC_aggInfo->aggDecl;
                litaC_i32 litaC_numOfFields = litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_decl->fields)));
                if(litaC_decl->flags & litaC_ast__AggregateFlags_IS_ANONYMOUS) {
                    {
                        return;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_numOfFields) {
                    {
                        litaC_std__string_buffer__StringBuffer_append(litaC_scratch, "[]FieldInfo {");
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_numOfFields;litaC_i += 1) {
                            {
                                litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_decl->fields)), litaC_i);
                                switch(litaC_field.kind) {
                                    case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                        {
                                            litaC_ast__TraitFieldDecl* litaC_traitField = litaC_field.traitField;
                                            if(litaC_traitField->decl.name.token.type != litaC_lex__TokenType_IDENTIFIER) {
                                                {
                                                    break;
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                            litaC_i64 litaC_typeid = ((litaC_field.typeInfo)) ? litaC_field.typeInfo->typeid : 0L;
                                            litaC_std__string_buffer__StringBuffer_append(litaC_scratch, "\n                                FieldInfo {\n                                    .kind = FieldInfoKind.VAR_FIELD,\n                                    .name = \"%.*s\",\n                                    .type = %llu,\n                                    .modifiers = Modifiers.%s,\n                                    .offset = offsetof(%.*s::%.*s, %.*s)\n                                },\n                            ", litaC_traitField->decl.name.str.length, litaC_traitField->decl.name.str.buffer, litaC_typeid, "None", litaC_sym->declared->id.name.length, litaC_sym->declared->id.name.buffer, litaC_type->name.length, litaC_type->name.buffer, litaC_traitField->decl.name.str.length, litaC_traitField->decl.name.str.buffer);
                                            break;
                                            
                                            
                                        }
                                        
                                        
                                    }
                                    case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                        {
                                            litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                                            if(litaC_varField->decl.name.token.type != litaC_lex__TokenType_IDENTIFIER) {
                                                {
                                                    break;
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                            litaC_i64 litaC_typeid = ((litaC_field.typeInfo)) ? litaC_field.typeInfo->typeid : 0L;
                                            litaC_std__string_buffer__StringBuffer_append(litaC_scratch, "\n                                FieldInfo {\n                                    .kind = FieldInfoKind.VAR_FIELD,\n                                    .name = \"%.*s\",\n                                    .type = %llu,\n                                    .modifiers = Modifiers.%s,\n                                    .offset = offsetof(%.*s::%.*s, %.*s)\n                                },\n                            ", litaC_varField->decl.name.str.length, litaC_varField->decl.name.str.buffer, litaC_typeid, ((litaC_varField->decl.attributes.isUsing)) ? "Using" : "None", litaC_sym->declared->id.name.length, litaC_sym->declared->id.name.buffer, litaC_type->name.length, litaC_type->name.buffer, litaC_varField->decl.name.str.length, litaC_varField->decl.name.str.buffer);
                                            break;
                                            
                                            
                                        }
                                        
                                        
                                    }
                                    case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                        {
                                            litaC_ast__EnumDecl* litaC_enumField = litaC_field.enumField;
                                            if(litaC_enumField->decl.name.token.type != litaC_lex__TokenType_IDENTIFIER) {
                                                {
                                                    break;
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                            litaC_std__string_buffer__StringBuffer_append(litaC_scratch, "\n                                FieldInfo {\n                                    .kind = FieldInfoKind.ENUM_FIELD,\n                                    .name = \"%.*s\",\n                                    .type = %llu,\n                                    .modifiers = Modifiers.%s,\n                                },\n                            ", litaC_enumField->decl.name.str.length, litaC_enumField->decl.name.str.buffer, litaC_enumField->decl.sym->type->typeid, ((litaC_enumField->decl.attributes.isUsing)) ? "Using" : "None");
                                            break;
                                            
                                            
                                        }
                                        
                                        
                                    }
                                    case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                                    case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                                        {
                                            litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                                            const char* litaC_fieldType = (litaC_field.kind == litaC_ast__StmtKind_STRUCT_FIELD_DECL) ? "STRUCT_FIELD" : "UNION_FIELD";
                                            if(litaC_aggField->decl.declaration.name.token.type == litaC_lex__TokenType_IDENTIFIER) {
                                                {
                                                    litaC_std__string_buffer__StringBuffer_append(litaC_scratch, "\n                                    FieldInfo {\n                                        .kind = FieldInfoKind.%s,\n                                        .name = \"%.*s\",\n                                        .type = %llu,\n                                        .modifiers = Modifiers.%s,\n                                    },\n                                ", litaC_fieldType, litaC_aggField->decl.declaration.name.str.length, litaC_aggField->decl.declaration.name.str.buffer, litaC_aggField->decl.declaration.sym->type->typeid, ((litaC_aggField->decl.declaration.attributes.isUsing)) ? "Using" : "None");
                                                    break;
                                                    
                                                    
                                                }
                                                
                                            } else {
                                                if(litaC_aggField->decl.declaration.name.token.type == litaC_lex__TokenType_VOID) {
                                                    {
                                                        litaC_std__string_buffer__StringBuffer_append(litaC_scratch, "\n                                    FieldInfo {\n                                        .kind = FieldInfoKind.%s,\n                                        .name = null,\n                                        .type = %llu,\n                                        .modifiers = Modifiers.%s,\n                                    },\n                                ", litaC_fieldType, litaC_aggField->decl.declaration.sym->type->typeid, ((litaC_aggField->decl.declaration.attributes.isUsing)) ? "Using" : "None");
                                                        
                                                        
                                                    }
                                                    
                                                } 
                                                
                                            } 
                                            
                                            break;
                                            
                                            
                                        }
                                        
                                        
                                    }
                                    case litaC_ast__StmtKind_POISON_EXPR: {
                                        {
                                            break;
                                            
                                            
                                        }
                                        
                                        
                                    }
                                    default: {
                                        {
                                            assert(litaC_false);
                                            
                                            
                                        }
                                        
                                        
                                    }
                                }
                                
                                
                            }
                        }
                        litaC_std__string_buffer__StringBuffer_append(litaC_scratch, "}");
                        
                        
                    }
                    
                } else {
                    {
                        litaC_std__string_buffer__StringBuffer_append(litaC_scratch, "null");
                        
                        
                    }
                } 
                
                litaC_intern__InternedString litaC_name = litaC_type->sym->name;
                litaC_std__string_buffer__StringBuffer_append(litaC_sb, "\n                [%llu] = &TypeInfo {\n                    .kind = TypeKind.%s,\n                    .name = \"%.*s\",\n                    .id = %llu,\n                    .aggType = aggType {\n                        .fields = %s,\n                        .numOfFields = %d\n                    }\n                },\n            ", litaC_type->typeid, litaC_types__TypeKindAsStr(litaC_type->kind), litaC_name.length, litaC_name.buffer, litaC_type->typeid, litaC_std__string_buffer__StringBuffer_cStr(litaC_scratch), litaC_numOfFields);
                break;
                
                
            }
            
            
        }
        default: {
            {
                
                
            }
            
            
        }
    }
    
}

litaC_void litaC_introspection__Introspect_emitPrimitiveType(litaC_introspection__Introspect* litaC_this,litaC_std__string_buffer__StringBuffer* litaC_sb,litaC_types__TypeInfo* litaC_type) {
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_BOOL: 
        case litaC_types__TypeKind_CHAR: 
        case litaC_types__TypeKind_I8: 
        case litaC_types__TypeKind_U8: 
        case litaC_types__TypeKind_I16: 
        case litaC_types__TypeKind_U16: 
        case litaC_types__TypeKind_I32: 
        case litaC_types__TypeKind_U32: 
        case litaC_types__TypeKind_I64: 
        case litaC_types__TypeKind_U64: 
        case litaC_types__TypeKind_F32: 
        case litaC_types__TypeKind_F64: 
        case litaC_types__TypeKind_USIZE: 
        case litaC_types__TypeKind_NULL: 
        case litaC_types__TypeKind_STR: 
        case litaC_types__TypeKind_VOID: {
            {
                litaC_std__string_buffer__StringBuffer_append(litaC_sb, "\n                [%llu] = &TypeInfo {\n                    .kind = TypeKind.%s,\n                    .name = \"%.*s\",\n                    .id = %llu\n                },\n            ", litaC_type->typeid, litaC_types__TypeKindAsStr(litaC_type->kind), litaC_type->name.length, litaC_type->name.buffer, litaC_type->typeid);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__TypeInfo* litaC_arrayType = litaC_type;
                litaC_std__string_buffer__StringBuffer_append(litaC_sb, "\n                [%llu] = &TypeInfo {\n                    .kind = TypeKind.%s,\n                    .name = null,\n                    .id = %llu,\n                    .arrayType = arrayType {\n                        .length = %llu,\n                        .arrayOfType: %llu\n                    }\n                },\n            ", litaC_type->typeid, litaC_types__TypeKindAsStr(litaC_type->kind), litaC_type->typeid, litaC_arrayType->length, litaC_arrayType->arrayOf->typeid);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__TypeInfo* litaC_ptrType = litaC_type;
                litaC_std__string_buffer__StringBuffer_append(litaC_sb, "\n                [%llu] = &TypeInfo {\n                    .kind = TypeKind.%s,\n                    .name = null,\n                    .id = %llu,\n                    .ptrType = ptrType {\n                        .ptrOfType: %llu\n                    }\n                },\n            ", litaC_type->typeid, litaC_types__TypeKindAsStr(litaC_type->kind), litaC_type->typeid, litaC_ptrType->ptrOf->typeid);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__TypeInfo* litaC_constType = litaC_type;
                litaC_std__string_buffer__StringBuffer_append(litaC_sb, "\n                [%llu] = &TypeInfo {\n                    .kind = TypeKind.%s,\n                    .name = null,\n                    .id = %llu,\n                    .constType = constType {\n                        .constOfType: %llu\n                    }\n                },\n            ", litaC_type->typeid, litaC_types__TypeKindAsStr(litaC_type->kind), litaC_type->typeid, litaC_constType->constOf->typeid);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                break;
                
                
            }
            
            
        }
        default: {
            {
                
                
            }
            
            
        }
    }
    
}

litaC_bool litaC_checker_decl__TypeChecker_resolveDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__Decl* litaC_decl) {
    assert(litaC_decl != NULL);
    switch(litaC_decl->stmt.node.kind) {
        case litaC_ast__StmtKind_IMPORT_DECL: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONST_DECL: 
        case litaC_ast__StmtKind_VAR_DECL: {
            {
                litaC_types__TypeInfo* litaC_type = litaC_checker_decl__TypeChecker_resolveValueDecl(litaC_this, (litaC_ast__VarDecl*)litaC_decl);
                if(!(litaC_type)) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                litaC_checker__TypeChecker_addSymbol(litaC_this, litaC_decl, litaC_type);
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NOTE_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_aggDecl = (litaC_ast__AggregateDecl*)litaC_decl;
                return litaC_checker_decl__TypeChecker_resolveNoteDecl(litaC_this, litaC_aggDecl);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_aggDecl = (litaC_ast__AggregateDecl*)litaC_decl;
                return litaC_checker_decl__TypeChecker_resolveAggregateDecl(litaC_this, litaC_aggDecl);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: {
            {
                litaC_ast__EnumDecl* litaC_enumDecl = (litaC_ast__EnumDecl*)litaC_decl;
                return litaC_checker_decl__TypeChecker_resolveEnumDecl(litaC_this, litaC_enumDecl);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                litaC_ast__FuncDecl* litaC_funcDecl = (litaC_ast__FuncDecl*)litaC_decl;
                return litaC_checker_decl__TypeChecker_resolveFuncDecl(litaC_this, litaC_funcDecl);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                litaC_ast__TypedefDecl* litaC_typedefDecl = (litaC_ast__TypedefDecl*)litaC_decl;
                return litaC_checker_decl__TypeChecker_resolveTypedefDecl(litaC_this, litaC_typedefDecl);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAM_DECL: {
            {
                litaC_ast__ParameterDecl* litaC_paramDecl = (litaC_ast__ParameterDecl*)litaC_decl;
                return litaC_checker_decl__TypeChecker_resolveParamDecl(litaC_this, litaC_paramDecl);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NATIVE_DECL: 
        case litaC_ast__StmtKind_POISON_DECL: {
            {
                break;
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_types__TypeInfo* litaC_checker_decl__TypeChecker_resolveValueDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__VarDecl* litaC_decl) {
    
    if(!(litaC_decl->expr) && litaC_decl->decl.stmt.node.kind == litaC_ast__StmtKind_CONST_DECL) {
        {
            if(!(litaC_ast__Decl_hasNote(&((litaC_decl->decl)), "foreign"))) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_decl->decl.stmt.node.startPos, "const declaration must have an assignment (unless it is '@foreign')");
                    {
                        litaC_types__TypeInfo* ___result = NULL;
                        litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_decl->decl.stmt.node.startPos, litaC_decl->decl.sym);
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(litaC_this->lita->result.enabled && !(litaC_checker__TypeChecker_resolveNotes(litaC_this, &((litaC_decl->decl.attributes.notes))))) {
        {
            {
                litaC_types__TypeInfo* ___result = NULL;
                litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_decl->decl.stmt.node.startPos, litaC_decl->decl.sym);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_declaredType = NULL;
    litaC_types__TypeInfo* litaC_inferredType = NULL;
    if(litaC_decl->typeSpec) {
        {
            litaC_declaredType = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_decl->typeSpec, litaC_checker__SearchType_TYPE);
            
            
        }
        
    } 
    
    if(litaC_decl->expr) {
        {
            if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_decl->expr))) {
                {
                    {
                        litaC_types__TypeInfo* ___result = NULL;
                        litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_decl->decl.stmt.node.startPos, litaC_decl->decl.sym);
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            litaC_ast__Operand litaC_op = litaC_decl->expr->operand;
            if(litaC_decl->expr->stmt.node.kind == litaC_ast__StmtKind_ARRAY_INIT_EXPR || litaC_decl->expr->stmt.node.kind == litaC_ast__StmtKind_INIT_EXPR) {
                {
                    litaC_inferredType = litaC_op.typeInfo;
                    
                    
                }
                
            } else {
                if(litaC_op.typeInfo->kind == litaC_types__TypeKind_NULL && litaC_declaredType == NULL) {
                    {
                        litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_decl->expr->stmt.node.startPos, "invalid variable declaration, can't infer type from 'null' for '%.*s' variable", litaC_decl->decl.name.str.length, litaC_decl->decl.name.str.buffer);
                        {
                            litaC_types__TypeInfo* ___result = NULL;
                            litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_decl->decl.stmt.node.startPos, litaC_decl->decl.sym);
                            return ___result;
                            
                        }
                        
                        
                        
                    }
                    
                } else {
                    {
                        litaC_inferredType = litaC_types_new__TypeCache_typeDecay(litaC_this->typeCache, litaC_decl->expr->operand.typeInfo);
                        if(litaC_declaredType) {
                            {
                                litaC_decl->expr = litaC_checker_expr__TypeChecker_coerceTypeWithUsing(litaC_this, litaC_decl->expr, litaC_inferredType, litaC_declaredType);
                                litaC_inferredType = litaC_types_new__TypeCache_typeDecay(litaC_this->typeCache, litaC_decl->expr->operand.typeInfo);
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                } 
                
            } 
            
            litaC_decl->expr->expectedType = (litaC_declaredType) ? litaC_declaredType : litaC_inferredType;
            
            
        }
        
    } 
    
    if(litaC_declaredType && litaC_inferredType) {
        {
            if(!(litaC_checker__TypeChecker_checkDeclarability(litaC_this, litaC_decl->expr->stmt.node.startPos, litaC_declaredType, litaC_inferredType))) {
                {
                    {
                        litaC_types__TypeInfo* ___result = litaC_false;
                        litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_decl->decl.stmt.node.startPos, litaC_decl->decl.sym);
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_resultType = (litaC_declaredType) ? litaC_declaredType : litaC_inferredType;
    if(!(litaC_resultType)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_decl->decl.stmt.node.startPos, "invalid variable declaration, can't infer type for '%.*s' variable", litaC_decl->decl.name.str.length, litaC_decl->decl.name.str.buffer);
            
            
        }
        
    } 
    
    {
        litaC_types__TypeInfo* ___result = litaC_resultType;
        litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_decl->decl.stmt.node.startPos, litaC_decl->decl.sym);
        return ___result;
        
    }
    
    litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_decl->decl.stmt.node.startPos, litaC_decl->decl.sym);
    
}

litaC_bool litaC_checker_decl__TypeChecker_checkAnonAggregateFieldDuplicate(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_ast__FieldStmt litaC_field,litaC_i32 litaC_index) {
    litaC_i32 litaC_errors = litaC_checker__TypeChecker_errors(litaC_this);
    switch(litaC_field.kind) {
        case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
            {
                litaC_ast__TraitFieldDecl* litaC_traitField = litaC_field.traitField;
                if(litaC_traitField->decl.name.token.type != litaC_lex__TokenType_IDENTIFIER) {
                    {
                        break;
                        
                        
                    }
                    
                } 
                
                litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_this, litaC_aggDecl, litaC_traitField->decl.name.str, litaC_index);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_VAR_FIELD_DECL: {
            {
                litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                if(litaC_varField->decl.name.token.type != litaC_lex__TokenType_IDENTIFIER) {
                    {
                        break;
                        
                        
                    }
                    
                } 
                
                litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_this, litaC_aggDecl, litaC_varField->decl.name.str, litaC_index);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
            {
                litaC_ast__EnumDecl* litaC_enumField = litaC_field.enumField;
                if(litaC_enumField->decl.name.token.type != litaC_lex__TokenType_IDENTIFIER) {
                    {
                        break;
                        
                        
                    }
                    
                } 
                
                litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_this, litaC_aggDecl, litaC_enumField->decl.name.str, litaC_index);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNION_FIELD_DECL: 
        case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                if(litaC_aggField->decl.declaration.name.token.type == litaC_lex__TokenType_IDENTIFIER) {
                    {
                        litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_this, litaC_aggDecl, litaC_aggField->decl.declaration.name.str, litaC_index);
                        break;
                        
                        
                    }
                    
                } else {
                    if(litaC_aggField->decl.declaration.name.token.type == litaC_lex__TokenType_VOID) {
                        {
                            for(litaC_i32 litaC_j = 0;litaC_j < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_aggField->fields)));litaC_j += 1) {
                                {
                                    litaC_ast__FieldStmt litaC_anonymousField = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_aggField->fields)), litaC_j);
                                    litaC_checker_decl__TypeChecker_checkAnonAggregateFieldDuplicate(litaC_this, litaC_aggDecl, litaC_anonymousField, litaC_index);
                                    
                                    
                                }
                            }
                            
                            
                        }
                        
                    } 
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_EXPR: {
            {
                break;
                
                
            }
            
            
        }
        default: {
            {
                litaC_common__Info("Field Kind: %s\n", litaC_ast__StmtKindAsStr(litaC_field.kind));
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    return litaC_checker__TypeChecker_errors(litaC_this) == litaC_errors;
    
    
}

litaC_void litaC_checker_decl__TypeChecker_errorInvalidMemberForTrait(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_intern__InternedString litaC_fieldName,litaC_lex__SrcPos litaC_pos) {
    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_pos, "invalid member '%.*s', only function pointers are allowed for traits", litaC_fieldName.length, litaC_fieldName.buffer);
    
}

litaC_void litaC_checker_decl__TypeChecker_errorUsingMember(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_intern__InternedString litaC_fieldName,litaC_lex__SrcPos litaC_pos) {
    if(litaC_aggDecl->decl.declaration.name.str.length) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_pos, "invalid 'using' member '%.*s' in '%.*s', only aggregate types (or pointer to an aggregate) are allowed", litaC_fieldName.length, litaC_fieldName.buffer, litaC_aggDecl->decl.declaration.name.str.length, litaC_aggDecl->decl.declaration.name.str.buffer);
            
            
        }
        
    } else {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_pos, "invalid 'using' member '%.*s', only aggregate types (or pointer to an aggregate) are allowed", litaC_fieldName.length, litaC_fieldName.buffer);
            
            
        }
    } 
    
    
}

litaC_void litaC_checker_decl__TypeChecker_errorUsingParameter(litaC_checker__TypeChecker* litaC_this,litaC_ast__ParameterDecl* litaC_paramDecl) {
    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_paramDecl->decl.stmt.node.startPos, "invalid 'using' parameter '%.*s', only aggregate types (or pointer to an aggregate) are allowed", litaC_paramDecl->decl.name.str.length, litaC_paramDecl->decl.name.str.buffer);
    
}

litaC_void litaC_checker_decl__TypeChecker_errorDuplicateMember(litaC_checker__TypeChecker* litaC_this,litaC_ast__Decl* litaC_aggDecl,litaC_intern__InternedString litaC_fieldName,litaC_lex__SrcPos litaC_pos) {
    if(litaC_aggDecl->name.str.length) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_pos, "duplicate member '%.*s' in '%.*s'", litaC_fieldName.length, litaC_fieldName.buffer, litaC_aggDecl->name.str.length, litaC_aggDecl->name.str.buffer);
            
            
        }
        
    } else {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_pos, "duplicate member '%.*s'", litaC_fieldName.length, litaC_fieldName.buffer);
            
            
        }
    } 
    
    
}

litaC_bool litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_intern__InternedString litaC_fieldName,litaC_i32 litaC_index) {
    litaC_bool litaC_isValid = litaC_true;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_aggDecl->fields)));litaC_i += 1) {
        {
            if(litaC_index == litaC_i) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_aggDecl->fields)), litaC_i);
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        litaC_ast__TraitFieldDecl* litaC_traitField = litaC_field.traitField;
                        if(litaC_traitField->decl.name.token.type != litaC_lex__TokenType_IDENTIFIER) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_intern__InternedString_equals(&((litaC_traitField->decl.name.str)), &((litaC_fieldName)))) {
                            {
                                litaC_checker_decl__TypeChecker_errorDuplicateMember(litaC_this, &((litaC_aggDecl->decl.declaration)), litaC_fieldName, litaC_traitField->decl.stmt.node.startPos);
                                litaC_isValid = litaC_false;
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                        if(litaC_varField->decl.name.token.type != litaC_lex__TokenType_IDENTIFIER) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_intern__InternedString_equals(&((litaC_varField->decl.name.str)), &((litaC_fieldName)))) {
                            {
                                litaC_checker_decl__TypeChecker_errorDuplicateMember(litaC_this, &((litaC_aggDecl->decl.declaration)), litaC_fieldName, litaC_varField->decl.stmt.node.startPos);
                                litaC_isValid = litaC_false;
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                    {
                        litaC_ast__EnumDecl* litaC_enumField = litaC_field.enumField;
                        if(litaC_enumField->decl.name.token.type != litaC_lex__TokenType_IDENTIFIER) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_intern__InternedString_equals(&((litaC_enumField->decl.name.str)), &((litaC_fieldName)))) {
                            {
                                litaC_checker_decl__TypeChecker_errorDuplicateMember(litaC_this, &((litaC_aggDecl->decl.declaration)), litaC_fieldName, litaC_enumField->decl.stmt.node.startPos);
                                litaC_isValid = litaC_false;
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                        if(litaC_aggField->decl.declaration.name.token.type == litaC_lex__TokenType_IDENTIFIER) {
                            {
                                if(litaC_intern__InternedString_equals(&((litaC_aggField->decl.declaration.name.str)), &((litaC_fieldName)))) {
                                    {
                                        litaC_checker_decl__TypeChecker_errorDuplicateMember(litaC_this, &((litaC_aggDecl->decl.declaration)), litaC_fieldName, litaC_aggField->decl.declaration.stmt.node.startPos);
                                        litaC_isValid = litaC_false;
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } else {
                            if(litaC_aggField->decl.declaration.name.token.type == litaC_lex__TokenType_VOID) {
                                {
                                    litaC_isValid = litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_this, litaC_aggField, litaC_fieldName, -(1)) && litaC_isValid;
                                    
                                    
                                }
                                
                            } 
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_POISON_EXPR: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        assert(litaC_false);
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    return litaC_isValid;
    
    
}

litaC_bool litaC_checker_decl__TypeChecker_resolveNoteDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_noteDecl) {
    
    litaC_i32 litaC_errors = litaC_checker__TypeChecker_errors(litaC_this);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_noteDecl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt* litaC_field = &(litaC_noteDecl->fields.elements[litaC_i]);
            switch(litaC_field->kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: 
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: 
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        {
                            litaC_bool ___result = litaC_false;
                            litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_noteDecl->decl.declaration.stmt.node.startPos, litaC_noteDecl->decl.declaration.sym);
                            return ___result;
                            
                        }
                        
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = litaC_field->varField;
                        litaC_field->typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_varField->type, litaC_checker__SearchType_TYPE);
                        assert(litaC_field->typeInfo);
                        if(litaC_varField->defaultExpr) {
                            {
                                if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_varField->defaultExpr))) {
                                    {
                                        {
                                            litaC_bool ___result = litaC_false;
                                            litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_noteDecl->decl.declaration.stmt.node.startPos, litaC_noteDecl->decl.declaration.sym);
                                            return ___result;
                                            
                                        }
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_checker__TypeChecker_checkDeclarability(litaC_this, litaC_varField->defaultExpr->stmt.node.startPos, litaC_field->typeInfo, litaC_varField->defaultExpr->operand.typeInfo);
                                
                                
                            }
                            
                        } 
                        
                        litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_this, litaC_noteDecl, litaC_varField->decl.name.str, litaC_i);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_POISON_EXPR: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        assert(litaC_false);
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    litaC_checker_decl__TypeChecker_addFieldReferences(litaC_this, litaC_noteDecl, litaC_noteDecl->decl.declaration.sym->type, 0);
    {
        litaC_bool ___result = litaC_checker__TypeChecker_errors(litaC_this) == litaC_errors;
        litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_noteDecl->decl.declaration.stmt.node.startPos, litaC_noteDecl->decl.declaration.sym);
        return ___result;
        
    }
    
    litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_noteDecl->decl.declaration.stmt.node.startPos, litaC_noteDecl->decl.declaration.sym);
    
}

litaC_bool litaC_checker_decl__TypeChecker_resolveAggregateDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl) {
    
    litaC_i32 litaC_errors = litaC_checker__TypeChecker_errors(litaC_this);
    litaC_i32 litaC_hasGenerics = litaC_aggDecl->decl.declaration.sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE;
    if(litaC_hasGenerics) {
        {
            litaC_std__array__Array_add_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)), litaC_aggDecl->decl.genericParams);
            
            
        }
        
    } 
    
    
    if(!(litaC_checker__TypeChecker_resolveNotes(litaC_this, &((litaC_aggDecl->decl.declaration.attributes.notes))))) {
        {
            {
                litaC_bool ___result = litaC_false;
                if(litaC_hasGenerics) {
                    {
                        litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                        
                        
                    }
                    
                } 
                ;
                litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_isTrait = litaC_aggDecl->decl.declaration.sym->flags & litaC_symbols__SymbolFlags_IS_TRAIT;
    litaC_module__Module* litaC_module = litaC_this->current;
    if(litaC_isTrait && !((litaC_aggDecl->decl.declaration.sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE))) {
        {
            litaC_std__array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->symbolTraits)), litaC_aggDecl->decl.declaration.sym);
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_aggDecl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt* litaC_field = &(litaC_aggDecl->fields.elements[litaC_i]);
            switch(litaC_field->kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        assert(litaC_isTrait);
                        litaC_ast__TraitFieldDecl* litaC_traitField = litaC_field->traitField;
                        litaC_field->typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_traitField->type, litaC_checker__SearchType_TYPE);
                        assert(litaC_field->typeInfo);
                        if(!(litaC_checker__TypeChecker_resolveNotes(litaC_this, &((litaC_traitField->decl.attributes.notes))))) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    if(litaC_hasGenerics) {
                                        {
                                            litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                            
                                            
                                        }
                                        
                                    } 
                                    ;
                                    litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_field->typeInfo->kind != litaC_types__TypeKind_FUNC_PTR) {
                            {
                                litaC_checker_decl__TypeChecker_errorInvalidMemberForTrait(litaC_this, litaC_aggDecl, litaC_traitField->decl.name.str, litaC_traitField->decl.stmt.node.startPos);
                                {
                                    litaC_bool ___result = litaC_false;
                                    if(litaC_hasGenerics) {
                                        {
                                            litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                            
                                            
                                        }
                                        
                                    } 
                                    ;
                                    litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_types__TypeInfo* litaC_traitFn = litaC_field->typeInfo;
                        litaC_traitFn->isTrait = litaC_true;
                        litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_this, litaC_aggDecl, litaC_traitField->decl.name.str, litaC_i);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = litaC_field->varField;
                        litaC_field->typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_varField->type, litaC_checker__SearchType_TYPE);
                        assert(litaC_field->typeInfo);
                        if(!(litaC_checker__TypeChecker_resolveNotes(litaC_this, &((litaC_varField->decl.attributes.notes))))) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    if(litaC_hasGenerics) {
                                        {
                                            litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                            
                                            
                                        }
                                        
                                    } 
                                    ;
                                    litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_isTrait) {
                            {
                                litaC_checker_decl__TypeChecker_errorInvalidMemberForTrait(litaC_this, litaC_aggDecl, litaC_varField->decl.name.str, litaC_varField->decl.stmt.node.startPos);
                                {
                                    litaC_bool ___result = litaC_false;
                                    if(litaC_hasGenerics) {
                                        {
                                            litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                            
                                            
                                        }
                                        
                                    } 
                                    ;
                                    litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_varField->defaultExpr) {
                            {
                                if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_varField->defaultExpr))) {
                                    {
                                        {
                                            litaC_bool ___result = litaC_false;
                                            if(litaC_hasGenerics) {
                                                {
                                                    litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                                    
                                                    
                                                }
                                                
                                            } 
                                            ;
                                            litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                            return ___result;
                                            
                                        }
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_checker__TypeChecker_checkDeclarability(litaC_this, litaC_varField->defaultExpr->stmt.node.startPos, litaC_field->typeInfo, litaC_varField->defaultExpr->operand.typeInfo);
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_varField->decl.attributes.isUsing) {
                            {
                                if(!(litaC_types__IsAggregate(litaC_field->typeInfo)) && !(litaC_types__IsPtrAggregate(litaC_field->typeInfo))) {
                                    {
                                        litaC_checker_decl__TypeChecker_errorUsingMember(litaC_this, litaC_aggDecl, litaC_varField->decl.name.str, litaC_varField->decl.stmt.node.startPos);
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_this, litaC_aggDecl, litaC_varField->decl.name.str, litaC_i);
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                    {
                        if(litaC_isTrait) {
                            {
                                litaC_checker_decl__TypeChecker_errorInvalidMemberForTrait(litaC_this, litaC_aggDecl, litaC_field->enumField->decl.name.str, litaC_field->enumField->decl.stmt.node.startPos);
                                {
                                    litaC_bool ___result = litaC_false;
                                    if(litaC_hasGenerics) {
                                        {
                                            litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                            
                                            
                                        }
                                        
                                    } 
                                    ;
                                    litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_symbols__Symbol* litaC_sym = litaC_field->enumField->decl.sym;
                        if(!(litaC_sym)) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    if(litaC_hasGenerics) {
                                        {
                                            litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                            
                                            
                                        }
                                        
                                    } 
                                    ;
                                    litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_sym->flags |= litaC_symbols__SymbolFlags_IS_INCOMPLETE;
                        litaC_checker__TypeChecker_resolveSymbol(litaC_this, litaC_sym);
                        litaC_field->typeInfo = litaC_sym->type;
                        if(!(litaC_field->typeInfo)) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    if(litaC_hasGenerics) {
                                        {
                                            litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                            
                                            
                                        }
                                        
                                    } 
                                    ;
                                    litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        if(!(litaC_checker__TypeChecker_resolveNotes(litaC_this, &((litaC_field->enumField->decl.attributes.notes))))) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    if(litaC_hasGenerics) {
                                        {
                                            litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                            
                                            
                                        }
                                        
                                    } 
                                    ;
                                    litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_field->enumField->decl.name.token.type == litaC_lex__TokenType_IDENTIFIER) {
                            {
                                litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_this, litaC_aggDecl, litaC_field->enumField->decl.name.str, litaC_i);
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        if(litaC_isTrait) {
                            {
                                litaC_checker_decl__TypeChecker_errorInvalidMemberForTrait(litaC_this, litaC_aggDecl, litaC_field->aggregateField->decl.declaration.name.str, litaC_field->aggregateField->decl.declaration.stmt.node.startPos);
                                {
                                    litaC_bool ___result = litaC_false;
                                    if(litaC_hasGenerics) {
                                        {
                                            litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                            
                                            
                                        }
                                        
                                    } 
                                    ;
                                    litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_symbols__Symbol* litaC_sym = litaC_field->aggregateField->decl.declaration.sym;
                        if(litaC_aggDecl->decl.declaration.sym->flags & litaC_symbols__SymbolFlags_IS_FROM_GENERIC_TEMPLATE) {
                            {
                                litaC_intern__InternedString litaC_nameStr = litaC_field->aggregateField->decl.declaration.name.str;
                                litaC_sym = litaC_checker__TypeChecker_getTypeByName(litaC_this, litaC_nameStr, litaC_checker__SearchType_TYPE);
                                if(!(litaC_sym)) {
                                    {
                                        litaC_sym = litaC_checker__TypeChecker_createDeclSymbol(litaC_this, &((litaC_field->aggregateField->decl.declaration)));
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_ast__TypeSpec* litaC_nameSpec = litaC_ast_new__NewNameTypeSpecIntern(litaC_field->aggregateField->decl.declaration.stmt.node.startPos, litaC_nameStr, &(litaC_module->typeSpecAllocator));
                                litaC_std__array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_nameSpec->genericArgs)), litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_field->aggregateField->decl.genericParams))), litaC_module->allocator);
                                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_field->aggregateField->decl.genericParams)));litaC_i += 1) {
                                    {
                                        litaC_ast__GenericParam litaC_genericParam = litaC_std__array__Array_get_cb_GenericParam_ce_(&((litaC_field->aggregateField->decl.genericParams)), litaC_i);
                                        assert(litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_aggDecl->decl.declaration.sym->genericParams))) == litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_aggDecl->decl.declaration.sym->genericArgs))));
                                        for(litaC_i32 litaC_j = 0;litaC_j < litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_aggDecl->decl.declaration.sym->genericParams)));litaC_j += 1) {
                                            {
                                                litaC_ast__GenericParam litaC_parentGenericParam = litaC_std__array__Array_get_cb_GenericParam_ce_(&((litaC_aggDecl->decl.declaration.sym->genericParams)), litaC_j);
                                                if(litaC_intern__InternedString_equals(&((litaC_parentGenericParam.name.str)), &((litaC_genericParam.name.str)))) {
                                                    {
                                                        litaC_std__array__Array_add_cb__ptr_TypeSpec_ce_(&((litaC_nameSpec->genericArgs)), litaC_types__TypeInfo_asTypeSpec(litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_aggDecl->decl.declaration.sym->genericArgs)), litaC_j), litaC_module));
                                                        break;
                                                        
                                                        
                                                    }
                                                    
                                                } 
                                                
                                                
                                                
                                            }
                                        }
                                        
                                        
                                    }
                                }
                                litaC_sym = litaC_generics__CreateTypeFromGenericTemplate(litaC_this, litaC_sym, litaC_nameSpec);
                                if(!(litaC_sym)) {
                                    {
                                        {
                                            litaC_bool ___result = litaC_false;
                                            if(litaC_hasGenerics) {
                                                {
                                                    litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                                    
                                                    
                                                }
                                                
                                            } 
                                            ;
                                            litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                            return ___result;
                                            
                                        }
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_sym->flags |= litaC_symbols__SymbolFlags_IS_INCOMPLETE;
                                
                                
                            }
                            
                        } 
                        
                        if(!(litaC_sym)) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    if(litaC_hasGenerics) {
                                        {
                                            litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                            
                                            
                                        }
                                        
                                    } 
                                    ;
                                    litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_field->aggregateField->decl.declaration.sym = litaC_sym;
                        if(!(litaC_checker__TypeChecker_resolveNotes(litaC_this, &((litaC_field->aggregateField->decl.declaration.attributes.notes))))) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    if(litaC_hasGenerics) {
                                        {
                                            litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                            
                                            
                                        }
                                        
                                    } 
                                    ;
                                    litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_checker__TypeChecker_resolveSymbol(litaC_this, litaC_sym);
                        litaC_checker__TypeChecker_finishResolveSymbol(litaC_this, litaC_sym);
                        litaC_field->typeInfo = litaC_sym->type;
                        if(!(litaC_field->typeInfo)) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    if(litaC_hasGenerics) {
                                        {
                                            litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                            
                                            
                                        }
                                        
                                    } 
                                    ;
                                    litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_field->aggregateField->decl.declaration.name.token.type == litaC_lex__TokenType_IDENTIFIER) {
                            {
                                litaC_checker_decl__TypeChecker_checkAggregateFieldDuplicate(litaC_this, litaC_aggDecl, litaC_field->aggregateField->decl.declaration.name.str, litaC_i);
                                
                                
                            }
                            
                        } else {
                            {
                                for(litaC_i32 litaC_j = 0;litaC_j < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_field->aggregateField->fields)));litaC_j += 1) {
                                    {
                                        litaC_ast__FieldStmt litaC_anonymousField = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_field->aggregateField->fields)), litaC_j);
                                        litaC_checker_decl__TypeChecker_checkAnonAggregateFieldDuplicate(litaC_this, litaC_aggDecl, litaC_anonymousField, litaC_i);
                                        
                                        
                                    }
                                }
                                
                                
                            }
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_POISON_EXPR: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        assert(litaC_false);
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    litaC_checker_decl__TypeChecker_addFieldReferences(litaC_this, litaC_aggDecl, litaC_aggDecl->decl.declaration.sym->type, 0);
    {
        litaC_bool ___result = litaC_checker__TypeChecker_errors(litaC_this) == litaC_errors;
        if(litaC_hasGenerics) {
            {
                litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                
                
            }
            
        } 
        ;
        litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
        return ___result;
        
    }
    
    if(litaC_hasGenerics) {
        {
            litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
            
            
        }
        
    } 
    ;
    litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_aggDecl->decl.declaration.stmt.node.startPos, litaC_aggDecl->decl.declaration.sym);
    
}

litaC_i32 litaC_checker_decl__TypeChecker_addFieldReferences(litaC_checker__TypeChecker* litaC_this,litaC_ast__AggregateDecl* litaC_aggDecl,litaC_types__TypeInfo* litaC_parentTypeInfo,litaC_i32 litaC_position) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_aggDecl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt* litaC_field = &(litaC_aggDecl->fields.elements[litaC_i]);
            if(!(litaC_field->typeInfo)) {
                {
                    litaC_position += 1;
                    continue;
                    
                    
                }
                
            } 
            
            switch(litaC_field->kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        litaC_lsp__references__ReferenceDatabase_addFieldReference(&((litaC_this->lita->references)), litaC_field->traitField->decl.stmt.node.startPos, litaC_parentTypeInfo, litaC_position);
                        litaC_position += 1;
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = litaC_field->varField;
                        litaC_lsp__references__ReferenceDatabase_addFieldReference(&((litaC_this->lita->references)), litaC_field->varField->decl.stmt.node.startPos, litaC_parentTypeInfo, litaC_position);
                        if(litaC_varField->decl.attributes.isUsing) {
                            {
                                if(litaC_types__IsAggregate(litaC_field->typeInfo) || litaC_types__IsPtrAggregate(litaC_field->typeInfo)) {
                                    {
                                        litaC_types__TypeInfo* litaC_aggInfo = litaC_types__TypeInfo_getBaseType(litaC_field->typeInfo);
                                        litaC_position += litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_aggInfo->aggDecl->fields)));
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_position += 1;
                                
                                
                            }
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                    {
                        litaC_lsp__references__ReferenceDatabase_addFieldReference(&((litaC_this->lita->references)), litaC_field->enumField->decl.stmt.node.startPos, litaC_parentTypeInfo, litaC_position);
                        litaC_position += 1;
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        if(litaC_field->aggregateField->decl.declaration.name.token.type == litaC_lex__TokenType_IDENTIFIER) {
                            {
                                litaC_lsp__references__ReferenceDatabase_addFieldReference(&((litaC_this->lita->references)), litaC_field->aggregateField->decl.declaration.stmt.node.startPos, litaC_parentTypeInfo, litaC_position);
                                litaC_position += 1;
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_position = litaC_checker_decl__TypeChecker_addFieldReferences(litaC_this, litaC_field->aggregateField, litaC_parentTypeInfo, litaC_position);
                                
                                
                            }
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_POISON_EXPR: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        assert(litaC_false);
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    return litaC_position;
    
    
}

litaC_bool litaC_checker_decl__TypeChecker_checkEnumFieldDuplicate(litaC_checker__TypeChecker* litaC_this,litaC_ast__EnumDecl* litaC_enumDecl,litaC_ast__EnumFieldEntryDecl* litaC_field,litaC_i32 litaC_index) {
    litaC_bool litaC_hasDuplicates = litaC_false;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_enumDecl->fields)));litaC_i += 1) {
        {
            if(litaC_i == litaC_index) {
                continue;
                
            } 
            
            litaC_ast__EnumFieldEntryDecl* litaC_other = litaC_std__array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_enumDecl->fields)), litaC_i);
            if(litaC_intern__InternedString_equals(&((litaC_other->decl.name.str)), &((litaC_field->decl.name.str)))) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_other->decl.stmt.node.startPos, "duplicate member '%.*s'", litaC_field->decl.name.str.length, litaC_field->decl.name.str.buffer);
                    litaC_hasDuplicates = litaC_true;
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return !(litaC_hasDuplicates);
    
    
}

litaC_bool litaC_checker_decl__TypeChecker_resolveEnumDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__EnumDecl* litaC_enumDecl) {
    
    litaC_i32 litaC_errors = litaC_checker__TypeChecker_errors(litaC_this);
    if(!(litaC_checker__TypeChecker_resolveNotes(litaC_this, &((litaC_enumDecl->decl.attributes.notes))))) {
        {
            {
                litaC_bool ___result = litaC_false;
                litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_enumDecl->decl.stmt.node.startPos, litaC_enumDecl->decl.sym);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_parentTypeInfo = litaC_enumDecl->decl.sym->type;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_enumDecl->fields)));litaC_i += 1) {
        {
            litaC_ast__EnumFieldEntryDecl* litaC_field = litaC_std__array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_enumDecl->fields)), litaC_i);
            if(!(litaC_checker__TypeChecker_resolveNotes(litaC_this, &((litaC_field->decl.attributes.notes))))) {
                {
                    {
                        litaC_bool ___result = litaC_false;
                        litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_enumDecl->decl.stmt.node.startPos, litaC_enumDecl->decl.sym);
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            if(litaC_field->value) {
                {
                    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_field->value))) {
                        {
                            {
                                litaC_bool ___result = litaC_false;
                                litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_enumDecl->decl.stmt.node.startPos, litaC_enumDecl->decl.sym);
                                return ___result;
                                
                            }
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_types__TypeInfo* litaC_typeInfo = litaC_field->value->operand.typeInfo;
                    litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_field->value->stmt.node.startPos, litaC_typeInfo, &(litaC_types__I32_TYPE), litaC_true);
                    
                    
                }
                
            } 
            
            litaC_checker_decl__TypeChecker_checkEnumFieldDuplicate(litaC_this, litaC_enumDecl, litaC_field, litaC_i);
            litaC_lsp__references__ReferenceDatabase_addFieldReference(&((litaC_this->lita->references)), litaC_field->decl.stmt.node.startPos, litaC_parentTypeInfo, litaC_i);
            
            
        }
    }
    {
        litaC_bool ___result = litaC_checker__TypeChecker_errors(litaC_this) == litaC_errors;
        litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_enumDecl->decl.stmt.node.startPos, litaC_enumDecl->decl.sym);
        return ___result;
        
    }
    
    litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_enumDecl->decl.stmt.node.startPos, litaC_enumDecl->decl.sym);
    
}

litaC_void litaC_checker_decl__TypeChecker_checkLabels(litaC_checker__TypeChecker* litaC_this) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_this->numOfLabels;litaC_i += 1) {
        {
            litaC_checker__LabelInfo* litaC_label = &(litaC_this->labels[litaC_i]);
            if(!(litaC_label->defined)) {
                {
                    assert(litaC_label->stmt != NULL);
                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_label->stmt->node.startPos, "'%.*s' label not found", litaC_label->name.length, litaC_label->name.buffer);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

litaC_bool litaC_checker_decl__TypeChecker_resolveFuncDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncDecl* litaC_funcDecl) {
    
    litaC_i32 litaC_errors = litaC_checker__TypeChecker_errors(litaC_this);
    litaC_checker__TypeChecker_enterModule(litaC_this, litaC_funcDecl->decl.declaration.sym->declared);
    
    litaC_checker__TypeChecker_pushScope(litaC_this, &(((litaC_symbols__Scope) {
        
    })));
    
    litaC_std__array__Array_add_cb__ptr_TypeInfo_ce_(&((litaC_this->funcDeclStack)), litaC_funcDecl->decl.declaration.sym->type);
    
    litaC_i32 litaC_hasGenerics = litaC_funcDecl->decl.declaration.sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE;
    if(litaC_hasGenerics) {
        {
            litaC_std__array__Array_add_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)), litaC_funcDecl->decl.genericParams);
            
            
        }
        
    } 
    
    
    if(!(litaC_checker__TypeChecker_resolveNotes(litaC_this, &((litaC_funcDecl->decl.declaration.attributes.notes))))) {
        {
            {
                litaC_bool ___result = litaC_false;
                if(litaC_hasGenerics) {
                    {
                        litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                        
                        
                    }
                    
                } 
                ;
                litaC_std__array__Array_pop_cb__ptr_TypeInfo_ce_(&((litaC_this->funcDeclStack)));
                litaC_checker__TypeChecker_popScope(litaC_this);
                litaC_checker__TypeChecker_leaveModule(litaC_this);
                litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_funcDecl->decl.declaration.stmt.node.startPos, litaC_funcDecl->decl.declaration.sym);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    if(!(litaC_funcDecl->params) || !(litaC_checker__TypeChecker_resolveStmt(litaC_this, &((litaC_funcDecl->params->stmt))))) {
        {
            {
                litaC_bool ___result = litaC_false;
                if(litaC_hasGenerics) {
                    {
                        litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                        
                        
                    }
                    
                } 
                ;
                litaC_std__array__Array_pop_cb__ptr_TypeInfo_ce_(&((litaC_this->funcDeclStack)));
                litaC_checker__TypeChecker_popScope(litaC_this);
                litaC_checker__TypeChecker_leaveModule(litaC_this);
                litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_funcDecl->decl.declaration.stmt.node.startPos, litaC_funcDecl->decl.declaration.sym);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    if(litaC_funcDecl->body) {
        {
            litaC_this->numOfLabels = 0;
            if(!(litaC_checker__TypeChecker_resolveStmt(litaC_this, litaC_funcDecl->body))) {
                {
                    {
                        litaC_bool ___result = litaC_false;
                        if(litaC_hasGenerics) {
                            {
                                litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                                
                                
                            }
                            
                        } 
                        ;
                        litaC_std__array__Array_pop_cb__ptr_TypeInfo_ce_(&((litaC_this->funcDeclStack)));
                        litaC_checker__TypeChecker_popScope(litaC_this);
                        litaC_checker__TypeChecker_leaveModule(litaC_this);
                        litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_funcDecl->decl.declaration.stmt.node.startPos, litaC_funcDecl->decl.declaration.sym);
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            litaC_checker_decl__TypeChecker_checkLabels(litaC_this);
            
            
        }
        
    } 
    
    {
        litaC_bool ___result = litaC_checker__TypeChecker_errors(litaC_this) == litaC_errors;
        if(litaC_hasGenerics) {
            {
                litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
                
                
            }
            
        } 
        ;
        litaC_std__array__Array_pop_cb__ptr_TypeInfo_ce_(&((litaC_this->funcDeclStack)));
        litaC_checker__TypeChecker_popScope(litaC_this);
        litaC_checker__TypeChecker_leaveModule(litaC_this);
        litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_funcDecl->decl.declaration.stmt.node.startPos, litaC_funcDecl->decl.declaration.sym);
        return ___result;
        
    }
    
    if(litaC_hasGenerics) {
        {
            litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(&((litaC_this->genericParamStack)));
            
            
        }
        
    } 
    ;
    litaC_std__array__Array_pop_cb__ptr_TypeInfo_ce_(&((litaC_this->funcDeclStack)));
    litaC_checker__TypeChecker_popScope(litaC_this);
    litaC_checker__TypeChecker_leaveModule(litaC_this);
    litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_funcDecl->decl.declaration.stmt.node.startPos, litaC_funcDecl->decl.declaration.sym);
    
}

litaC_bool litaC_checker_decl__TypeChecker_resolveParamDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__ParameterDecl* litaC_paramDecl) {
    assert(litaC_paramDecl != NULL);
    
    litaC_i32 litaC_errors = litaC_checker__TypeChecker_errors(litaC_this);
    if(!(litaC_checker__TypeChecker_resolveNotes(litaC_this, &((litaC_paramDecl->decl.attributes.notes))))) {
        {
            {
                litaC_bool ___result = litaC_false;
                litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_paramDecl->decl.stmt.node.startPos, litaC_paramDecl->decl.sym);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    if(litaC_paramDecl->defaultExpr) {
        {
            if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_paramDecl->defaultExpr))) {
                {
                    {
                        litaC_bool ___result = litaC_false;
                        litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_paramDecl->decl.stmt.node.startPos, litaC_paramDecl->decl.sym);
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_paramDecl->type, litaC_checker__SearchType_TYPE);
    if(!(litaC_typeInfo) || litaC_typeInfo == &(litaC_types__POISON_TYPE)) {
        {
            {
                litaC_bool ___result = litaC_false;
                litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_paramDecl->decl.stmt.node.startPos, litaC_paramDecl->decl.sym);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_paramDecl->decl.sym = litaC_checker__TypeChecker_addSymbol(litaC_this, &((litaC_paramDecl->decl)), litaC_typeInfo);
    litaC_paramDecl->typeInfo = litaC_typeInfo;
    if(litaC_paramDecl->decl.attributes.isUsing) {
        {
            if(!(litaC_types__IsAggregateLike(litaC_typeInfo))) {
                {
                    litaC_checker_decl__TypeChecker_errorUsingParameter(litaC_this, litaC_paramDecl);
                    
                    
                }
                
            } else {
                {
                    litaC_types__TypeInfo* litaC_baseType = litaC_types__TypeInfo_getBaseType(litaC_typeInfo);
                    litaC_types__TypeInfo* litaC_aggType = litaC_baseType;
                    litaC_checker__TypeChecker_addTypeToScope(litaC_this, &((litaC_paramDecl->decl)), litaC_this->current->currentScope, litaC_aggType, litaC_aggType);
                    
                    
                }
            } 
            
            
            
        }
        
    } 
    
    {
        litaC_bool ___result = litaC_checker__TypeChecker_errors(litaC_this) == litaC_errors;
        litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_paramDecl->decl.stmt.node.startPos, litaC_paramDecl->decl.sym);
        return ___result;
        
    }
    
    litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_paramDecl->decl.stmt.node.startPos, litaC_paramDecl->decl.sym);
    
}

litaC_bool litaC_checker_decl__TypeChecker_resolveTypedefDecl(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypedefDecl* litaC_typedefDecl) {
    
    if(!(litaC_checker__TypeChecker_resolveNotes(litaC_this, &((litaC_typedefDecl->decl.declaration.attributes.notes))))) {
        {
            {
                litaC_bool ___result = litaC_false;
                litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_typedefDecl->decl.declaration.stmt.node.startPos, litaC_typedefDecl->decl.declaration.sym);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    {
        litaC_bool ___result = litaC_true;
        litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_typedefDecl->decl.declaration.stmt.node.startPos, litaC_typedefDecl->decl.declaration.sym);
        return ___result;
        
    }
    
    litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(&((litaC_this->lita->references)), litaC_typedefDecl->decl.declaration.stmt.node.startPos, litaC_typedefDecl->decl.declaration.sym);
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveConstExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr) {
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_expr->operand.isConst)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, "expected a constant expression");
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr) {
    if(!(litaC_expr)) {
        return litaC_false;
        
        
    } 
    
    
    switch(litaC_expr->stmt.node.kind) {
        case litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveArrayDesignationExpr(litaC_this, (litaC_ast__ArrayDesignationExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_INIT_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveArrayInitExpr(litaC_this, (litaC_ast__ArrayInitExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BINARY_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveBinaryExpr(litaC_this, (litaC_ast__BinaryExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BOOLEAN_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveBooleanExpr(litaC_this, (litaC_ast__BooleanExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CAST_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveCastExpr(litaC_this, (litaC_ast__CastExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CHAR_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveCharExpr(litaC_this, (litaC_ast__CharExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_CALL_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveFuncCallExpr(litaC_this, (litaC_ast__FuncCallExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveFuncIdentifierExpr(litaC_this, (litaC_ast__IdentifierExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GET_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveGetExpr(litaC_this, (litaC_ast__GetExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GROUP_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveGroupExpr(litaC_this, (litaC_ast__GroupExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveIdentiferExpr(litaC_this, (litaC_ast__IdentifierExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_INIT_ARG_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveInitArgExpr(litaC_this, (litaC_ast__InitArgExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_INIT_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveInitExpr(litaC_this, (litaC_ast__InitExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NULL_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveNullExpr(litaC_this, (litaC_ast__NullExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NUMBER_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveNumberExpr(litaC_this, (litaC_ast__NumberExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SET_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveSetExpr(litaC_this, (litaC_ast__SetExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_OFFSET_OF_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveOffsetOfExpr(litaC_this, (litaC_ast__OffsetOfExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SIZE_OF_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveSizeOfExpr(litaC_this, (litaC_ast__SizeOfExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_STRING_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveStringExpr(litaC_this, (litaC_ast__StringExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveSubscriptGetExpr(litaC_this, (litaC_ast__SubscriptGetExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_SET_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveSubscriptSetExpr(litaC_this, (litaC_ast__SubscriptSetExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TERNARY_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveTernaryExpr(litaC_this, (litaC_ast__TernaryExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveTypeIdentifierExpr(litaC_this, (litaC_ast__TypeIdentifierExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_OF_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveTypeOfExpr(litaC_this, (litaC_ast__TypeOfExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNARY_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_checker_expr__TypeChecker_resolveUnaryExpr(litaC_this, (litaC_ast__UnaryExpr*)litaC_expr);
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_EXPR: {
            {
                {
                    litaC_bool ___result = litaC_false;
                    {
                        if(litaC_expr->operand.typeInfo == NULL) {
                            {
                                {
                                    litaC_bool ___result = litaC_false;
                                    return ___result;
                                    
                                }
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
            
        }
        default: {
            {
                litaC_ast_print__PrintStmt((litaC_ast__Stmt*)litaC_expr, 0);
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    {
        litaC_bool ___result = litaC_false;
        {
            if(litaC_expr->operand.typeInfo == NULL) {
                {
                    {
                        litaC_bool ___result = litaC_false;
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        };
        return ___result;
        
    }
    
    {
        if(litaC_expr->operand.typeInfo == NULL) {
            {
                return litaC_false;
                
                
                
            }
            
        } 
        
        
        
    };
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveFuncIdentifierExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__IdentifierExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_types__TypeInfo* litaC_type = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_expr->type, litaC_checker__SearchType_FUNC);
    if(!(litaC_type)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->expr.stmt.node.startPos, "unknown function '%.*s'", litaC_expr->type->name.length, litaC_expr->type->name.buffer);
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_symbols__Symbol* litaC_sym = litaC_type->sym;
    if(litaC_type->kind == litaC_types__TypeKind_FUNC_PTR) {
        {
            litaC_symbols__Symbol* litaC_funcSym = litaC_symbols__Scope_lookup(litaC_checker__TypeChecker_currentScope(litaC_this), litaC_expr->type->name, litaC_true);
            if(litaC_funcSym && litaC_funcSym->type && litaC_funcSym->type->kind == litaC_types__TypeKind_FUNC_PTR) {
                {
                    litaC_sym = litaC_funcSym;
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(!(litaC_sym)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->expr.stmt.node.startPos, "unknown function '%.*s'", litaC_expr->type->name.length, litaC_expr->type->name.buffer);
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_expr->expr.operand.typeInfo = litaC_sym->type;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    litaC_expr->sym = litaC_sym;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_isMethodSyntax(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_std__array__Array_cb_CallArg_ce_* litaC_suppliedArgs) {
    assert(litaC_expr != NULL);
    if(litaC_expr->object->stmt.node.kind != litaC_ast__StmtKind_GET_EXPR) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_ast__GetExpr* litaC_getExpr = (litaC_ast__GetExpr*)litaC_expr->object;
    if(litaC_getExpr->field->expr.operand.typeInfo->kind != litaC_types__TypeKind_FUNC) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_getExpr->flags & litaC_ast__GetExprFlags_IS_METHOD_ARG) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    litaC_getExpr->flags |= litaC_ast__GetExprFlags_IS_METHOD_ARG;
    litaC_std__array__Array_insertAt_cb_CallArg_ce_(litaC_suppliedArgs, 0, (litaC_ast__CallArg) {
        .argExpr = litaC_getExpr->object,
        .isDefault = litaC_false
    });
    return litaC_true;
    
    
}

litaC_ast__Expr* litaC_checker_expr__TypeChecker_coerceTypeWithUsing(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_sourceType,litaC_types__TypeInfo* litaC_targetType) {
    if(!(litaC_types__IsAggregateLike(litaC_targetType))) {
        {
            return litaC_expr;
            
            
            
        }
        
    } 
    
    if(!(litaC_types__IsAggregateLike(litaC_sourceType))) {
        {
            return litaC_expr;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_source = litaC_types__TypeInfo_getBaseType(litaC_sourceType);
    litaC_types__TypeInfo* litaC_target = litaC_types__TypeInfo_getBaseType(litaC_targetType);
    if(litaC_targetType->sym && litaC_targetType->sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
        {
            if(litaC_source->genericTypeid == litaC_target->genericTypeid) {
                {
                    return litaC_expr;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(litaC_source->typeid == litaC_target->typeid) {
        {
            return litaC_expr;
            
            
            
        }
        
    } 
    
    litaC_types__FieldPath litaC_path =  {
        
    };
    if(!(litaC_types__TypeInfo_getFieldPathByType(litaC_source, litaC_target, &(litaC_path)))) {
        {
            return litaC_expr;
            
            
            
        }
        
    } 
    
    litaC_ast__Expr* litaC_originalExpr = litaC_expr;
    litaC_module__Module* litaC_module = litaC_this->current;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_path.numOfFields;litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_path.fields[litaC_i];
            assert(litaC_field.kind == litaC_ast__StmtKind_VAR_FIELD_DECL);
            litaC_intern__InternedString litaC_name = litaC_field.varField->decl.name.str;
            litaC_ast__TypeSpec* litaC_nameTypeSpec = litaC_ast_new__NewNameTypeSpecIntern(litaC_expr->stmt.node.startPos, litaC_name, &(litaC_module->typeSpecAllocator));
            litaC_ast__IdentifierExpr* litaC_idExpr = (litaC_ast__IdentifierExpr*)litaC_ast_new__NewIdentifierExpr(litaC_expr->stmt.node.startPos, litaC_expr->stmt.node.endPos, litaC_nameTypeSpec, litaC_module->allocator);
            litaC_ast__Node* litaC_parentExpr = litaC_expr->stmt.node.parent;
            litaC_expr = litaC_ast_new__NewGetExpr(litaC_expr->stmt.node.startPos, litaC_expr->stmt.node.endPos, litaC_expr, litaC_idExpr, litaC_module->allocator);
            if(litaC_parentExpr) {
                {
                    litaC_ast__Node_becomeParentOf_cb_Expr_ce_(litaC_parentExpr, litaC_expr);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr))) {
        {
            return litaC_originalExpr;
            
            
            
        }
        
    } 
    
    return litaC_expr;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_coerceFuncArgs(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_types__TypeInfo* litaC_funcType,litaC_std__array__Array_cb_CallArg_ce_* litaC_suppliedArgs) {
    assert(litaC_types__IsFuncLike(litaC_funcType));
    if(litaC_funcType->kind == litaC_types__TypeKind_FUNC_PTR) {
        {
            litaC_types__TypeInfo* litaC_funcPtr = litaC_funcType;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcPtr->paramDecls))) && litaC_i < litaC_std__array__Array_size_cb_CallArg_ce_(litaC_suppliedArgs);litaC_i += 1) {
                {
                    litaC_ast__Expr* litaC_argExpr = litaC_std__array__Array_get_cb_CallArg_ce_(litaC_suppliedArgs, litaC_i).argExpr;
                    litaC_types__TypeInfo* litaC_paramInfo = litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_funcPtr->paramDecls)), litaC_i);
                    if(!(litaC_checker_expr__TypeChecker_coerceFuncArg(litaC_this, litaC_expr, litaC_i, litaC_argExpr, litaC_paramInfo, litaC_suppliedArgs))) {
                        {
                            return litaC_false;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            litaC_types__TypeInfo* litaC_funcInfo = litaC_funcType;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params))) && litaC_i < litaC_std__array__Array_size_cb_CallArg_ce_(litaC_suppliedArgs);litaC_i += 1) {
                {
                    litaC_ast__Expr* litaC_argExpr = litaC_std__array__Array_get_cb_CallArg_ce_(litaC_suppliedArgs, litaC_i).argExpr;
                    litaC_types__TypeInfo* litaC_paramInfo = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)), litaC_i)->typeInfo;
                    if(!(litaC_checker_expr__TypeChecker_coerceFuncArg(litaC_this, litaC_expr, litaC_i, litaC_argExpr, litaC_paramInfo, litaC_suppliedArgs))) {
                        {
                            return litaC_false;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_coerceFuncArg(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_i32 litaC_index,litaC_ast__Expr* litaC_argExpr,litaC_types__TypeInfo* litaC_paramInfo,litaC_std__array__Array_cb_CallArg_ce_* litaC_suppliedArgs) {
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_argExpr))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_argInfo = litaC_argExpr->operand.typeInfo;
    if(litaC_argInfo->kind == litaC_types__TypeKind_ARRAY) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    if(!(litaC_types__IsAggregateLike(litaC_argInfo))) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    if(!(litaC_types__IsAggregateLike(litaC_paramInfo)) || litaC_types__IsTraitLike(litaC_paramInfo)) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    litaC_argExpr = litaC_checker_expr__TypeChecker_coerceTypeWithUsing(litaC_this, litaC_argExpr, litaC_argInfo, litaC_paramInfo);
    litaC_argInfo = litaC_argExpr->operand.typeInfo;
    if(litaC_types__IsPtrAggregate(litaC_paramInfo) && (!(litaC_types__IsPtrAggregate(litaC_argInfo)) && litaC_argInfo->kind != litaC_types__TypeKind_NULL)) {
        {
            if(litaC_argExpr->operand.isRightValue) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } 
            
            litaC_ast__Expr* litaC_groupExpr = litaC_ast_new__NewGroupExpr(litaC_argExpr->stmt.node.startPos, litaC_argExpr->stmt.node.endPos, litaC_argExpr, litaC_this->lita->allocator);
            litaC_argExpr = litaC_ast_new__NewUnaryExpr(litaC_argExpr->stmt.node.startPos, litaC_argExpr->stmt.node.endPos, litaC_lex__TokenType_BAND, litaC_groupExpr, litaC_this->lita->allocator);
            if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_argExpr))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } else {
        if(litaC_types__IsAggregate(litaC_paramInfo) && litaC_types__IsPtrAggregate(litaC_argInfo)) {
            {
                litaC_ast__Expr* litaC_groupExpr = litaC_ast_new__NewGroupExpr(litaC_argExpr->stmt.node.startPos, litaC_argExpr->stmt.node.endPos, litaC_argExpr, litaC_this->lita->allocator);
                litaC_argExpr = litaC_ast_new__NewUnaryExpr(litaC_argExpr->stmt.node.startPos, litaC_argExpr->stmt.node.endPos, litaC_lex__TokenType_STAR, litaC_groupExpr, litaC_this->lita->allocator);
                if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_argExpr))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                
                
            }
            
        } else {
            if(litaC_paramInfo->kind == litaC_types__TypeKind_FUNC_PTR && litaC_argInfo->kind == litaC_types__TypeKind_FUNC) {
                {
                    litaC_ast__Expr* litaC_groupExpr = litaC_ast_new__NewGroupExpr(litaC_argExpr->stmt.node.startPos, litaC_argExpr->stmt.node.endPos, litaC_argExpr, litaC_this->lita->allocator);
                    litaC_argExpr = litaC_ast_new__NewUnaryExpr(litaC_argExpr->stmt.node.startPos, litaC_argExpr->stmt.node.endPos, litaC_lex__TokenType_BAND, litaC_groupExpr, litaC_this->lita->allocator);
                    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_argExpr))) {
                        {
                            return litaC_false;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
        } 
        
    } 
    
    litaC_ast__Node_becomeParentOf_cb_Expr_ce_(&((litaC_expr->expr.stmt.node)), litaC_argExpr);
    litaC_ast__CallArg* litaC_callArg = litaC_std__array__Array_getPtr_cb_CallArg_ce_(litaC_suppliedArgs, litaC_index);
    litaC_callArg->argExpr = litaC_argExpr;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_checkNumberOfArgs(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_intern__InternedString litaC_funcName,litaC_i32 litaC_maxNumOfArgs,litaC_bool litaC_hasVarargs,litaC_i32 litaC_numberOfSuppliedArgs,litaC_i32 litaC_numberOfDefaultArgs) {
    assert(litaC_expr != NULL);
    if(litaC_maxNumOfArgs == litaC_numberOfSuppliedArgs) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_minNumOfArgs = litaC_maxNumOfArgs - litaC_numberOfDefaultArgs;
    if(litaC_numberOfSuppliedArgs == litaC_minNumOfArgs) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    if(litaC_minNumOfArgs > litaC_numberOfSuppliedArgs) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->expr.stmt.node.startPos, "'%.*s' called with too few arguments", litaC_funcName.length, litaC_funcName.buffer);
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_hasVarargs) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    if(litaC_maxNumOfArgs < litaC_numberOfSuppliedArgs) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->expr.stmt.node.startPos, "'%.*s' called with too many arguments", litaC_funcName.length, litaC_funcName.buffer);
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_types__TypeInfo* litaC_checker_expr__TypeChecker_inferredType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Identifier litaC_name,litaC_types__TypeInfo* litaC_paramType,litaC_types__TypeInfo* litaC_expectedType) {
    assert(litaC_paramType != NULL);
    assert(litaC_expectedType != NULL);
    if(litaC_intern__InternedString_equals(&((litaC_name.str)), &((litaC_paramType->name)))) {
        {
            return litaC_expectedType;
            
            
            
        }
        
    } 
    
    if(litaC_paramType->kind != litaC_expectedType->kind) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_index = 0;
    if(litaC_paramType->sym && (litaC_paramType->sym->flags & litaC_symbols__SymbolFlags_IS_FROM_GENERIC_TEMPLATE)) {
        {
            litaC_std__array__Array_cb__ptr_TypeInfo_ce_ litaC_genericArgs = litaC_paramType->sym->genericArgs;
            for(;litaC_index < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_genericArgs)));litaC_index += 1) {
                {
                    litaC_types__TypeInfo* litaC_arg = litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_genericArgs)), litaC_index);
                    if(litaC_intern__InternedString_equals(&((litaC_name.str)), &((litaC_arg->name)))) {
                        {
                            break;
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } 
    
    switch(litaC_paramType->kind) {
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__TypeInfo* litaC_arrayInfo = litaC_paramType;
                litaC_types__TypeInfo* litaC_expectedArrayInfo = litaC_expectedType;
                return litaC_checker_expr__TypeChecker_inferredType(litaC_this, litaC_name, litaC_arrayInfo->arrayOf, litaC_expectedArrayInfo->arrayOf);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__TypeInfo* litaC_constInfo = litaC_paramType;
                litaC_types__TypeInfo* litaC_expectedConstInfo = litaC_expectedType;
                return litaC_checker_expr__TypeChecker_inferredType(litaC_this, litaC_name, litaC_constInfo->constOf, litaC_expectedConstInfo->constOf);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__TypeInfo* litaC_ptrInfo = litaC_paramType;
                litaC_types__TypeInfo* litaC_expectedPtrInfo = litaC_expectedType;
                return litaC_checker_expr__TypeChecker_inferredType(litaC_this, litaC_name, litaC_ptrInfo->ptrOf, litaC_expectedPtrInfo->ptrOf);
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_TRAIT: 
        case litaC_types__TypeKind_UNION: 
        case litaC_types__TypeKind_STRUCT: {
            {
                litaC_types__TypeInfo* litaC_aggInfo = litaC_paramType;
                litaC_i32 litaC_size = litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_aggInfo->aggDecl->decl.genericParams)));
                if(litaC_size == 0 || litaC_size <= litaC_index) {
                    {
                        break;
                        
                        
                    }
                    
                } 
                
                litaC_ast__Identifier litaC_genericName = litaC_std__array__Array_get_cb_GenericParam_ce_(&((litaC_aggInfo->aggDecl->decl.genericParams)), litaC_index).name;
                litaC_types__TypeInfo* litaC_expectedAggInfo = litaC_expectedType;
                litaC_char litaC_aggBaseName[256] = {0};
                litaC_char litaC_expectedBaseName[256] = {0};
                litaC_types__TypeInfo_getBaseName(litaC_aggInfo, litaC_aggBaseName, NULL);
                litaC_types__TypeInfo_getBaseName(litaC_expectedAggInfo, litaC_expectedBaseName, NULL);
                if(strcmp(litaC_aggBaseName, litaC_expectedBaseName) == 0) {
                    {
                        litaC_symbols__Symbol* litaC_sym = litaC_expectedAggInfo->sym;
                        litaC_i32 litaC_pSize = litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_sym->genericParams)));
                        if(litaC_pSize) {
                            {
                                for(litaC_i32 litaC_i = 0;litaC_i < litaC_pSize;litaC_i += 1) {
                                    {
                                        litaC_ast__GenericParam litaC_param = litaC_std__array__Array_get_cb_GenericParam_ce_(&((litaC_sym->genericParams)), litaC_i);
                                        if(litaC_intern__InternedString_equals(&((litaC_param.name.str)), &((litaC_genericName.str)))) {
                                            {
                                                return litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_sym->genericArgs)), litaC_i);
                                                
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        
                                        
                                    }
                                }
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                litaC_intern__InternedString litaC_fieldName = litaC_intern__EMPTY_STR;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_aggInfo->aggDecl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_aggInfo->aggDecl->fields)), litaC_i);
                        switch(litaC_field.kind) {
                            case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                {
                                    litaC_ast__TraitFieldDecl* litaC_traitField = litaC_field.traitField;
                                    litaC_fieldName = litaC_traitField->decl.name.str;
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                {
                                    litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                                    litaC_fieldName = litaC_varField->decl.name.str;
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                {
                                    litaC_ast__EnumDecl* litaC_enumField = litaC_field.enumField;
                                    litaC_fieldName = litaC_enumField->decl.name.str;
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                            case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                                {
                                    litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                                    litaC_fieldName = litaC_aggField->decl.declaration.name.str;
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            default: {
                                {
                                    continue;
                                    
                                    
                                }
                                
                                
                            }
                        }
                        litaC_ast__FieldStmt litaC_argumentField = litaC_types__TypeInfo_getField(litaC_expectedAggInfo, litaC_fieldName);
                        if(litaC_argumentField.kind != litaC_ast__StmtKind_POISON_EXPR) {
                            {
                                assert(litaC_field.typeInfo != NULL);
                                litaC_types__TypeInfo* litaC_fieldType = litaC_checker_expr__TypeChecker_inferredType(litaC_this, litaC_genericName, litaC_field.typeInfo, litaC_argumentField.typeInfo);
                                if(litaC_fieldType) {
                                    {
                                        return litaC_fieldType;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                litaC_types__TypeInfo* litaC_funcInfo = litaC_paramType;
                if(litaC_std__array__Array_empty_cb_GenericParam_ce_(&((litaC_funcInfo->genericParams))) || litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_funcInfo->genericParams))) <= litaC_index) {
                    {
                        break;
                        
                        
                    }
                    
                } 
                
                litaC_ast__Identifier litaC_genericName = litaC_std__array__Array_get_cb_GenericParam_ce_(&((litaC_funcInfo->genericParams)), litaC_index).name;
                litaC_types__TypeInfo* litaC_argumentFuncInfo = litaC_expectedType;
                litaC_types__TypeInfo* litaC_retType = litaC_checker_expr__TypeChecker_inferredType(litaC_this, litaC_genericName, litaC_funcInfo->returnType, litaC_argumentFuncInfo->returnType);
                if(litaC_retType) {
                    {
                        return litaC_retType;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcInfo->paramDecls)));litaC_i += 1) {
                    {
                        if(litaC_i < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_argumentFuncInfo->paramDecls)))) {
                            {
                                litaC_types__TypeInfo* litaC_pType = litaC_checker_expr__TypeChecker_inferredType(litaC_this, litaC_genericName, litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_funcInfo->paramDecls)), litaC_i), litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_argumentFuncInfo->paramDecls)), litaC_i));
                                if(litaC_pType) {
                                    {
                                        return litaC_pType;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        default: {
            {
                break;
                
                
            }
            
            
        }
    }
    return NULL;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_checkInferrability(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type) {
    if(litaC_type->kind == litaC_types__TypeKind_FUNC && litaC_type->sym && litaC_type->sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
        {
            litaC_checker_expr__TypeChecker_errorMissingGenericArguments(litaC_this, litaC_expr, litaC_type->sym->name, &(litaC_type->funcDecl->decl.genericParams));
            return litaC_false;
            
            
            
        }
        
    } else {
        if(litaC_type->kind == litaC_types__TypeKind_FUNC_PTR && !(litaC_std__array__Array_empty_cb_GenericParam_ce_(&((litaC_type->genericParams))))) {
            {
                litaC_checker_expr__TypeChecker_errorMissingGenericArguments(litaC_this, litaC_expr, litaC_type->name, &(litaC_type->genericParams));
                return litaC_false;
                
                
                
            }
            
        } 
        
    } 
    
    return litaC_true;
    
    
}

litaC_types__TypeInfo* litaC_checker_expr__TypeChecker_inferFuncCallExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_types__TypeInfo* litaC_funcType,litaC_std__array__Array_cb_CallArg_ce_* litaC_suppliedArgs,litaC_bool litaC_isMethodCall) {
    assert(litaC_types__IsFuncLike(litaC_funcType));
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_CallArg_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
        {
            litaC_ast__CallArg litaC_arg = litaC_std__array__Array_get_cb_CallArg_ce_(&((litaC_expr->arguments)), litaC_i);
            if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_arg.argExpr))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            if(!(litaC_checker_expr__TypeChecker_checkInferrability(litaC_this, litaC_arg.argExpr, litaC_arg.argExpr->operand.typeInfo))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_ast__Expr* litaC_objectExpr = litaC_expr->object;
    if(litaC_isMethodCall) {
        {
            litaC_ast__GetExpr* litaC_getExpr = (litaC_ast__GetExpr*)litaC_expr->object;
            litaC_objectExpr = &(litaC_getExpr->field->expr);
            
            
        }
        
    } 
    
    if(litaC_objectExpr->stmt.node.kind != litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR) {
        {
            return litaC_funcType;
            
            
            
        }
        
    } 
    
    litaC_ast__IdentifierExpr* litaC_funcExpr = (litaC_ast__IdentifierExpr*)litaC_objectExpr;
    litaC_ast__TypeSpec* litaC_nameSpec = litaC_funcExpr->type;
    litaC_nameSpec->typeInfo = NULL;
    litaC_types__TypeInfo* litaC_returnType = NULL;
    litaC_std__array__Array_cb_GenericParam_ce_ litaC_genericParams = {0};
    if(litaC_funcType->kind == litaC_types__TypeKind_FUNC_PTR) {
        {
            litaC_types__TypeInfo* litaC_funcPtr = litaC_funcType;
            litaC_returnType = litaC_funcPtr->returnType;
            litaC_genericParams = litaC_funcPtr->genericParams;
            litaC_i32 litaC_size = litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_genericParams)));
            litaC_std__array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_nameSpec->genericArgs)), litaC_size, litaC_this->lita->allocator);
            litaC_std__array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)), litaC_size, litaC_this->lita->allocator);
            litaC_i32 litaC_suppliedArgsSize = litaC_std__array__Array_size_cb_CallArg_ce_(litaC_suppliedArgs);
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_size;litaC_i += 1) {
                {
                    litaC_ast__GenericParam litaC_genericParam = litaC_std__array__Array_get_cb_GenericParam_ce_(&((litaC_genericParams)), litaC_i);
                    for(litaC_i32 litaC_j = 0;litaC_j < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcPtr->paramDecls)));litaC_j += 1) {
                        {
                            litaC_types__TypeInfo* litaC_paramType = litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_funcPtr->paramDecls)), litaC_j);
                            if(litaC_j >= litaC_suppliedArgsSize) {
                                {
                                    break;
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_types__TypeInfo* litaC_argType = litaC_std__array__Array_get_cb_CallArg_ce_(litaC_suppliedArgs, litaC_j).argExpr->operand.typeInfo;
                            assert(litaC_argType != NULL);
                            assert(litaC_paramType != NULL);
                            litaC_types__TypeInfo* litaC_inferredType = litaC_checker_expr__TypeChecker_inferredType(litaC_this, litaC_genericParam.name, litaC_paramType, litaC_argType);
                            if(litaC_inferredType) {
                                {
                                    litaC_std__array__Array_add_cb__ptr_TypeSpec_ce_(&((litaC_nameSpec->genericArgs)), litaC_types__TypeInfo_asTypeSpec(litaC_inferredType, litaC_this->current));
                                    break;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                    }
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            litaC_types__TypeInfo* litaC_funcInfo = litaC_funcType;
            litaC_returnType = litaC_funcInfo->returnType;
            litaC_genericParams = litaC_funcInfo->funcDecl->decl.genericParams;
            litaC_i32 litaC_size = litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_genericParams)));
            litaC_std__array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_nameSpec->genericArgs)), litaC_size, litaC_this->lita->allocator);
            litaC_std__array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)), litaC_size, litaC_this->lita->allocator);
            litaC_i32 litaC_suppliedArgsSize = litaC_std__array__Array_size_cb_CallArg_ce_(litaC_suppliedArgs);
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_size;litaC_i += 1) {
                {
                    litaC_ast__GenericParam litaC_genericParam = litaC_std__array__Array_get_cb_GenericParam_ce_(&((litaC_genericParams)), litaC_i);
                    for(litaC_i32 litaC_j = 0;litaC_j < litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)));litaC_j += 1) {
                        {
                            litaC_types__TypeInfo* litaC_paramType = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)), litaC_j)->typeInfo;
                            if(litaC_j >= litaC_suppliedArgsSize) {
                                {
                                    break;
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_types__TypeInfo* litaC_argType = litaC_std__array__Array_get_cb_CallArg_ce_(litaC_suppliedArgs, litaC_j).argExpr->operand.typeInfo;
                            assert(litaC_argType != NULL);
                            assert(litaC_paramType != NULL);
                            litaC_types__TypeInfo* litaC_inferredType = litaC_checker_expr__TypeChecker_inferredType(litaC_this, litaC_genericParam.name, litaC_paramType, litaC_argType);
                            if(litaC_inferredType) {
                                {
                                    litaC_std__array__Array_add_cb__ptr_TypeSpec_ce_(&((litaC_nameSpec->genericArgs)), litaC_types__TypeInfo_asTypeSpec(litaC_inferredType, litaC_this->current));
                                    break;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                    }
                    
                    
                }
            }
            
            
        }
    } 
    
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->object))) {
        {
            for(litaC_i32 litaC_i = litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)));litaC_i < litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_genericParams)));litaC_i += 1) {
                {
                    litaC_ast__GenericParam litaC_param = litaC_std__array__Array_get_cb_GenericParam_ce_(&((litaC_genericParams)), litaC_i);
                    litaC_checker_expr__TypeChecker_errorInferGenericParameter(litaC_this, &((litaC_expr->expr)), &(litaC_param));
                    
                    
                }
            }
            goto err;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_type = litaC_expr->object->operand.typeInfo;
    if(!(litaC_types__IsFuncLike(litaC_type))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(litaC_type->sym && litaC_type->sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
        {
            litaC_ast__GenericDecl* litaC_decl = (litaC_ast__GenericDecl*)litaC_type->sym->decl;
            litaC_checker_expr__TypeChecker_errorMissingGenericArguments(litaC_this, &((litaC_funcExpr->expr)), litaC_nameSpec->name, &((litaC_decl->genericParams)));
            goto err;
            
            
            
        }
        
    } 
    
    if(litaC_returnType && litaC_returnType->sym && litaC_returnType->sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
        {
            litaC_bool litaC_isFullyResolved = litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_genericParams))) == litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_nameSpec->genericArgs)));
            if(!(litaC_isFullyResolved)) {
                {
                    litaC_char litaC_buffer[512] = {0};
                    litaC_std__string__String litaC_error = litaC_std__string__StringInit(litaC_buffer, 512, 0);
                    litaC_std__string__String_format(&((litaC_error)), "return type of '%.*s' containing a generic argument that can not be inferred", litaC_returnType->sym->name.length, litaC_returnType->sym->name.buffer);
                    litaC_checker_expr__TypeChecker_errorInferGenericParameters(litaC_this, &((litaC_funcExpr->expr)), &((litaC_genericParams)), litaC_std__string__String_cStr(litaC_error));
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    return litaC_type;
    
    err:;
    
    return &(litaC_types__POISON_TYPE);
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_checkFuncCallArgs(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr,litaC_types__TypeInfo* litaC_funcType,litaC_std__array__Array_cb_CallArg_ce_* litaC_suppliedArgs) {
    assert(litaC_funcType != NULL);
    assert(litaC_types__IsFuncLike(litaC_funcType));
    litaC_i32 litaC_numberOfSuppliedArgs = litaC_std__array__Array_size_cb_CallArg_ce_(litaC_suppliedArgs);
    litaC_bool litaC_success = litaC_true;
    litaC_bool litaC_hasVarargs = litaC_false;
    litaC_i32 litaC_i = 0;
    if(litaC_funcType->kind == litaC_types__TypeKind_FUNC_PTR) {
        {
            litaC_types__TypeInfo* litaC_funcPtr = litaC_funcType;
            litaC_hasVarargs = litaC_funcPtr->hasVarargs;
            for(;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcPtr->paramDecls)));litaC_i += 1) {
                {
                    litaC_types__TypeInfo* litaC_p = litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_funcPtr->paramDecls)), litaC_i);
                    if(litaC_i < litaC_numberOfSuppliedArgs) {
                        {
                            litaC_ast__CallArg* litaC_callArg = litaC_std__array__Array_getPtr_cb_CallArg_ce_(litaC_suppliedArgs, litaC_i);
                            litaC_ast__Expr* litaC_arg = litaC_callArg->argExpr;
                            if(litaC_callArg->argName.token.type == litaC_lex__TokenType_IDENTIFIER) {
                                {
                                    litaC_checker_expr__TypeChecker_errorNamedArgumentsForFuncPtr(litaC_this, litaC_arg);
                                    litaC_success = litaC_false;
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_callArg->index = litaC_i;
                            litaC_success = litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_arg->stmt.node.startPos, litaC_p, litaC_arg->operand.typeInfo, litaC_false) && litaC_success;
                            litaC_arg->expectedType = litaC_p;
                            if(litaC_types__IsTrait(litaC_p) && litaC_arg->operand.isRightValue) {
                                {
                                    litaC_checker_expr__TypeChecker_errorRvalueAssignmentToTrait(litaC_this, litaC_arg, litaC_arg->operand.typeInfo, litaC_p);
                                    litaC_success = litaC_false;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            litaC_types__TypeInfo* litaC_funcInfo = litaC_funcType;
            litaC_bool litaC_hasNamedArg = litaC_false;
            litaC_hasVarargs = litaC_funcInfo->funcDecl->params->isVararg;
            for(;litaC_i < litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)));litaC_i += 1) {
                {
                    litaC_ast__ParameterDecl* litaC_p = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)), litaC_i);
                    if(litaC_i < litaC_numberOfSuppliedArgs) {
                        {
                            litaC_ast__CallArg* litaC_callArg = litaC_std__array__Array_getPtr_cb_CallArg_ce_(litaC_suppliedArgs, litaC_i);
                            litaC_i32 litaC_paramIndex = litaC_i;
                            if(litaC_callArg->argName.token.type == litaC_lex__TokenType_IDENTIFIER) {
                                {
                                    litaC_hasNamedArg = litaC_true;
                                    litaC_paramIndex = -(1);
                                    for(litaC_i32 litaC_index = 0;litaC_index < litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)));litaC_index += 1) {
                                        {
                                            litaC_ast__ParameterDecl* litaC_param = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)), litaC_index);
                                            if(litaC_intern__InternedString_equals(&((litaC_param->decl.name.str)), &((litaC_callArg->argName.str)))) {
                                                {
                                                    litaC_paramIndex = litaC_index;
                                                    litaC_p = litaC_param;
                                                    break;
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                            
                                            
                                        }
                                    }
                                    if(litaC_paramIndex < 0) {
                                        {
                                            litaC_checker_expr__TypeChecker_errorInvalidNamedArgument(litaC_this, litaC_callArg->argName.token.pos, &((litaC_callArg->argName.str)), litaC_funcInfo);
                                            litaC_success = litaC_false;
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    
                                    
                                }
                                
                            } else {
                                if(litaC_hasNamedArg) {
                                    {
                                        if(!(litaC_intern__InternedString_equals(&((litaC_p->decl.name.str)), &((litaC_callArg->argName.str))))) {
                                            {
                                                litaC_checker_expr__TypeChecker_errorFixedArgumentAfterNamed(litaC_this, litaC_callArg->argExpr);
                                                litaC_success = litaC_false;
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                            } 
                            
                            litaC_ast__Expr* litaC_arg = litaC_callArg->argExpr;
                            litaC_callArg->index = litaC_paramIndex;
                            litaC_success = litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_arg->stmt.node.startPos, litaC_p->typeInfo, litaC_arg->operand.typeInfo, litaC_false) && litaC_success;
                            litaC_arg->expectedType = litaC_p->typeInfo;
                            if(litaC_types__IsTrait(litaC_p->typeInfo) && litaC_arg->operand.isRightValue) {
                                {
                                    litaC_checker_expr__TypeChecker_errorRvalueAssignmentToTrait(litaC_this, litaC_arg, litaC_arg->operand.typeInfo, litaC_p->typeInfo);
                                    litaC_success = litaC_false;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            for(litaC_i32 litaC_index = 0;litaC_index < litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)));litaC_index += 1) {
                {
                    litaC_ast__ParameterDecl* litaC_param = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)), litaC_index);
                    if(litaC_param->defaultExpr) {
                        {
                            litaC_bool litaC_hasValue = litaC_false;
                            for(litaC_i32 litaC_j = 0;litaC_j < litaC_std__array__Array_size_cb_CallArg_ce_(litaC_suppliedArgs);litaC_j += 1) {
                                {
                                    litaC_ast__CallArg* litaC_callArg = litaC_std__array__Array_getPtr_cb_CallArg_ce_(litaC_suppliedArgs, litaC_j);
                                    if(litaC_callArg->index == litaC_index) {
                                        {
                                            litaC_hasValue = litaC_true;
                                            break;
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    
                                    
                                }
                            }
                            if(!(litaC_hasValue)) {
                                {
                                    litaC_std__array__Array_add_cb_CallArg_ce_(litaC_suppliedArgs, (litaC_ast__CallArg) {
                                        .argExpr = litaC_param->defaultExpr,
                                        .index = litaC_index,
                                        .isDefault = litaC_true
                                    });
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
    } 
    
    if(litaC_hasVarargs) {
        {
            for(;litaC_i < litaC_numberOfSuppliedArgs;litaC_i += 1) {
                {
                    litaC_ast__CallArg* litaC_arg = litaC_std__array__Array_getPtr_cb_CallArg_ce_(litaC_suppliedArgs, litaC_i);
                    litaC_arg->index = litaC_i;
                    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_arg->argExpr))) {
                        {
                            return litaC_false;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } 
    
    return litaC_success;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveFuncCallExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__FuncCallExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_i32 litaC_errors = litaC_checker__TypeChecker_errors(litaC_this);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->object))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_objectType = litaC_expr->object->operand.typeInfo;
    if(!(litaC_types__IsFuncLike(litaC_objectType))) {
        {
            litaC_checker_expr__TypeChecker_errorNonFuncType(litaC_this, litaC_expr->object, litaC_objectType);
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_bool litaC_isMethod = litaC_false;
    litaC_i32 litaC_numberOfDefaultArgs = 0;
    litaC_std__array__Array_cb_CallArg_ce_ litaC_suppliedArgs = litaC_std__array__ArrayInit_cb_CallArg_ce_(litaC_std__array__Array_size_cb_CallArg_ce_(&((litaC_expr->arguments))) + 1, litaC_this->lita->allocator);
    litaC_std__array__Array_addAll_cb_CallArg_ce_(&((litaC_suppliedArgs)), &((litaC_expr->arguments)));
    litaC_bool litaC_hasVarargs = litaC_false;
    litaC_i32 litaC_maxNumOfArgs = 0;
    litaC_types__TypeInfo* litaC_returnType = NULL;
    litaC_std__array__Array_cb_GenericParam_ce_ litaC_genericParams = {0};
    if(litaC_objectType->kind == litaC_types__TypeKind_FUNC) {
        {
            litaC_types__TypeInfo* litaC_funcInfo = litaC_objectType;
            litaC_isMethod = (litaC_funcInfo->funcDecl->flags & litaC_ast__FuncFlags_IS_METHOD);
            if(!(litaC_funcInfo->funcDecl->params)) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_maxNumOfArgs = litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)));
            litaC_hasVarargs = litaC_funcInfo->funcDecl->params->isVararg;
            litaC_returnType = litaC_funcInfo->returnType;
            litaC_genericParams = litaC_funcInfo->funcDecl->decl.genericParams;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)));litaC_i += 1) {
                {
                    litaC_ast__ParameterDecl* litaC_p = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)), litaC_i);
                    if(litaC_p->defaultExpr) {
                        {
                            litaC_numberOfDefaultArgs += 1;
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            litaC_types__TypeInfo* litaC_funcPtr = litaC_objectType;
            litaC_maxNumOfArgs = litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcPtr->paramDecls)));
            litaC_hasVarargs = litaC_funcPtr->hasVarargs;
            litaC_returnType = litaC_funcPtr->returnType;
            litaC_genericParams = litaC_funcPtr->genericParams;
            if(litaC_expr->object->stmt.node.kind == litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR) {
                {
                    litaC_ast__IdentifierExpr* litaC_idExpr = (litaC_ast__IdentifierExpr*)litaC_expr->object;
                    litaC_funcPtr->name = litaC_idExpr->type->name;
                    
                    
                }
                
            } else {
                if(litaC_expr->object->stmt.node.kind == litaC_ast__StmtKind_GET_EXPR) {
                    {
                        litaC_ast__GetExpr* litaC_getExpr = (litaC_ast__GetExpr*)litaC_expr->object;
                        litaC_funcPtr->name = litaC_getExpr->field->type->name;
                        
                        
                    }
                    
                } 
                
            } 
            
            
            
        }
    } 
    
    litaC_bool litaC_isMethodCall = litaC_isMethod && litaC_checker_expr__TypeChecker_isMethodSyntax(litaC_this, litaC_expr, &(litaC_suppliedArgs));
    litaC_i32 litaC_numberOfSuppliedArgs = litaC_std__array__Array_size_cb_CallArg_ce_(&((litaC_suppliedArgs)));
    if(!(litaC_checker_expr__TypeChecker_checkNumberOfArgs(litaC_this, litaC_expr, litaC_objectType->name, litaC_maxNumOfArgs, litaC_hasVarargs, litaC_numberOfSuppliedArgs, litaC_numberOfDefaultArgs))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_coerceFuncArgs(litaC_this, litaC_expr, litaC_objectType, &((litaC_suppliedArgs))))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_std__array__Array_empty_cb_GenericParam_ce_(&((litaC_genericParams))))) {
        {
            if(litaC_std__array__Array_empty_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)))) {
                {
                    litaC_objectType = litaC_checker_expr__TypeChecker_inferFuncCallExpr(litaC_this, litaC_expr, litaC_objectType, &((litaC_suppliedArgs)), litaC_isMethodCall);
                    if(litaC_objectType == &(litaC_types__POISON_TYPE) || !(litaC_objectType)) {
                        {
                            return litaC_false;
                            
                            
                            
                        }
                        
                    } 
                    
                    assert(litaC_types__IsFuncLike(litaC_objectType));
                    if(litaC_objectType->kind == litaC_types__TypeKind_FUNC) {
                        {
                            litaC_types__TypeInfo* litaC_funcInfo = litaC_objectType;
                            litaC_returnType = litaC_funcInfo->returnType;
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_types__TypeInfo* litaC_funcPtr = litaC_objectType;
                            litaC_returnType = litaC_funcPtr->returnType;
                            
                            
                        }
                    } 
                    
                    
                    
                }
                
            } else {
                {
                    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)));litaC_i += 1) {
                        {
                            litaC_ast__TypeSpec* litaC_arg = litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)), litaC_i);
                            litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_arg, litaC_checker__SearchType_TYPE);
                            
                            
                        }
                    }
                    
                    
                }
            } 
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_checkFuncCallArgs(litaC_this, litaC_expr, litaC_objectType, &((litaC_suppliedArgs))))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    assert(litaC_returnType != NULL);
    litaC_std__array__Array_sort_cb_CallArg_ce_(&((litaC_suppliedArgs)), litaC_ast__CallArgSort);
    litaC_expr->arguments = *(litaC_ast__Node_becomeParentOfChildrenCallArgs(&((litaC_expr->expr.stmt.node)), &((litaC_suppliedArgs))));
    litaC_expr->expr.operand.typeInfo = litaC_returnType;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    return litaC_errors == litaC_checker__TypeChecker_errors(litaC_this);
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveBooleanExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__BooleanExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_expr->expr.operand.typeInfo = &(litaC_types__BOOL_TYPE);
    litaC_expr->expr.operand.isConst = litaC_true;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    litaC_expr->expr.operand.val.intValue = litaC_expr->boolean;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveCharExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__CharExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_expr->expr.operand.typeInfo = &(litaC_types__CHAR_TYPE);
    litaC_expr->expr.operand.isConst = litaC_true;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    litaC_expr->expr.operand.val = litaC_expr->character.value;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveNullExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__NullExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_expr->expr.operand.typeInfo = &(litaC_types__NULL_TYPE);
    litaC_expr->expr.operand.isConst = litaC_true;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveNumberExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__NumberExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_expr->expr.operand.typeInfo = litaC_expr->number.typeInfo;
    litaC_expr->expr.operand.isConst = litaC_true;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    litaC_expr->expr.operand.val = litaC_expr->number.value;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveStringExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__StringExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_expr->expr.operand.typeInfo = &(litaC_types__STR_TYPE);
    litaC_expr->expr.operand.isConst = litaC_true;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    litaC_expr->expr.operand.val = litaC_expr->string.value;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveSubscriptSetExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__SubscriptSetExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->object))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->index))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->value))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_baseObj = NULL;
    litaC_types__TypeInfo* litaC_objectType = litaC_expr->object->operand.typeInfo;
    switch(litaC_objectType->kind) {
        case litaC_types__TypeKind_STR: {
            {
                litaC_checker_expr__TypeChecker_errorSetIndexingConstType(litaC_this, litaC_expr->object, litaC_objectType);
                return litaC_false;
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__TypeInfo* litaC_ptrInfo = litaC_objectType;
                litaC_baseObj = litaC_ptrInfo->ptrOf;
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__TypeInfo* litaC_arrayInfo = litaC_objectType;
                litaC_baseObj = litaC_arrayInfo->arrayOf;
                break;
                
                
            }
            
            
        }
        default: {
            {
                litaC_checker_expr__TypeChecker_errorNonIndexableType(litaC_this, litaC_expr->object, litaC_objectType);
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    if(litaC_baseObj->kind == litaC_types__TypeKind_CONST) {
        {
            litaC_checker_expr__TypeChecker_errorSetIndexingConstType(litaC_this, litaC_expr->object, litaC_objectType);
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_indexType = litaC_expr->index->operand.typeInfo;
    if(!(litaC_types__IsInteger(litaC_indexType))) {
        {
            litaC_checker_expr__TypeChecker_errorIndexType(litaC_this, litaC_expr->index, litaC_indexType);
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_expr->value->stmt.node.startPos, litaC_baseObj, litaC_expr->value->operand.typeInfo, litaC_true))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_types__IsTrait(litaC_baseObj) && litaC_expr->value->operand.isRightValue) {
        {
            litaC_checker_expr__TypeChecker_errorRvalueAssignmentToTrait(litaC_this, litaC_expr->value, litaC_expr->value->operand.typeInfo, litaC_baseObj);
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_expr->expr.operand.typeInfo = litaC_expr->value->operand.typeInfo;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveSubscriptGetExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__SubscriptGetExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->object))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->index))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_baseObj = NULL;
    litaC_types__TypeInfo* litaC_objectType = litaC_expr->object->operand.typeInfo;
    switch(litaC_objectType->kind) {
        case litaC_types__TypeKind_STR: {
            {
                litaC_baseObj = &(litaC_types__CHAR_TYPE);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__TypeInfo* litaC_ptrInfo = litaC_objectType;
                litaC_baseObj = litaC_ptrInfo->ptrOf;
                if(litaC_baseObj->kind == litaC_types__TypeKind_CONST) {
                    {
                        litaC_types__TypeInfo* litaC_constInfo = litaC_baseObj;
                        litaC_baseObj = litaC_constInfo->constOf;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__TypeInfo* litaC_arrayInfo = litaC_objectType;
                litaC_baseObj = litaC_arrayInfo->arrayOf;
                if(litaC_baseObj->kind == litaC_types__TypeKind_CONST) {
                    {
                        litaC_types__TypeInfo* litaC_constInfo = litaC_baseObj;
                        litaC_baseObj = litaC_constInfo->constOf;
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        default: {
            {
                litaC_checker_expr__TypeChecker_errorNonIndexableType(litaC_this, litaC_expr->object, litaC_objectType);
                return litaC_false;
                
                
                
            }
            
            
        }
    }
    litaC_types__TypeInfo* litaC_indexType = litaC_expr->index->operand.typeInfo;
    if(!(litaC_types__IsInteger(litaC_indexType))) {
        {
            litaC_checker_expr__TypeChecker_errorIndexType(litaC_this, litaC_expr->index, litaC_indexType);
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_expr->expr.operand.typeInfo = litaC_baseObj;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveInitArgExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__InitArgExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_expr->expr.operand.typeInfo = &(litaC_types__NULL_TYPE);
    if(litaC_expr->value) {
        {
            if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->value))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_expr->expr.operand = litaC_expr->value->operand;
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_addDefaultArguments(litaC_checker__TypeChecker* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_ast__InitExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    assert(litaC_types__IsAggregate(litaC_type));
    litaC_types__TypeInfo* litaC_aggInfo = litaC_type;
    litaC_std__array__Array_cb__ptr_InitArgExpr_ce_ litaC_defaultArgs =  {
        
    };
    litaC_std__array__Array_init_cb__ptr_InitArgExpr_ce_(&((litaC_defaultArgs)), litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_aggInfo->aggDecl->fields))), litaC_this->lita->allocator);
    for(litaC_i32 litaC_position = 0;litaC_position < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_aggInfo->aggDecl->fields)));litaC_position += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_aggInfo->aggDecl->fields)), litaC_position);
            if(litaC_field.kind != litaC_ast__StmtKind_VAR_FIELD_DECL) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(!(litaC_field.varField->defaultExpr)) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_bool litaC_byName = litaC_false;
            litaC_bool litaC_byPos = litaC_false;
            litaC_bool litaC_hasNamedArgs = litaC_false;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
                {
                    litaC_ast__InitArgExpr* litaC_arg = litaC_std__array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)), litaC_i);
                    if(litaC_arg->fieldName.token.type == litaC_lex__TokenType_IDENTIFIER) {
                        {
                            litaC_hasNamedArgs = litaC_true;
                            if(litaC_intern__InternedString_equals(&((litaC_arg->fieldName.str)), &((litaC_field.varField->decl.name.str)))) {
                                {
                                    litaC_byName = litaC_true;
                                    break;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } else {
                        if(litaC_arg->argPosition == litaC_position) {
                            {
                                litaC_byPos = litaC_true;
                                break;
                                
                                
                            }
                            
                        } 
                        
                    } 
                    
                    
                    
                }
            }
            if(!(litaC_byName) && !((!(litaC_hasNamedArgs) && litaC_byPos))) {
                {
                    litaC_ast__InitArgExpr* litaC_arg = (litaC_ast__InitArgExpr*)litaC_ast_new__NewInitArgExpr(litaC_expr->expr.stmt.node.startPos, litaC_expr->expr.stmt.node.endPos, litaC_field.varField->decl.name, litaC_position, litaC_field.varField->defaultExpr, litaC_this->lita->allocator);
                    litaC_ast__Node_becomeParentOf_cb_InitArgExpr_ce_(&((litaC_expr->expr.stmt.node)), litaC_arg);
                    litaC_std__array__Array_add_cb__ptr_InitArgExpr_ce_(&((litaC_defaultArgs)), litaC_arg);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_defaultArgs)));litaC_i += 1) {
        {
            litaC_ast__InitArgExpr* litaC_arg = litaC_std__array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_defaultArgs)), litaC_i);
            litaC_std__array__Array_add_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)), litaC_arg);
            
            
        }
    }
    return litaC_true;
    
    
}

litaC_void litaC_checker_expr__TypeChecker_addInitArgumentsReferences(litaC_checker__TypeChecker* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_ast__InitExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    if(litaC_types__IsAggregate(litaC_type)) {
        {
            litaC_types__TypeInfo* litaC_aggInfo = litaC_type;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
                {
                    litaC_ast__InitArgExpr* litaC_arg = litaC_std__array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)), litaC_i);
                    if(litaC_arg->fieldName.token.type == litaC_lex__TokenType_IDENTIFIER) {
                        {
                            litaC_intern__InternedString litaC_fieldName = litaC_arg->fieldName.str;
                            litaC_types__FieldPositionResult litaC_fieldResult = litaC_types__TypeInfo_getFieldPosition(litaC_aggInfo, litaC_fieldName);
                            if(litaC_fieldResult.aggInfo) {
                                {
                                    litaC_lsp__references__ReferenceDatabase_addFieldReference(&((litaC_this->lita->references)), litaC_arg->expr.stmt.node.startPos, litaC_fieldResult.aggInfo, litaC_fieldResult.position);
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } 
    
    
}

litaC_bool litaC_checker_expr__IsDecayable(litaC_ast__InitArgExpr* litaC_arg) {
    if(!(litaC_arg->value)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_arg->value->stmt.node.kind == litaC_ast__StmtKind_ARRAY_INIT_EXPR || litaC_arg->value->stmt.node.kind == litaC_ast__StmtKind_STRING_EXPR) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_checkInitArguments(litaC_checker__TypeChecker* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_ast__InitExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_i32 litaC_errors = litaC_checker__TypeChecker_errors(litaC_this);
    if(litaC_types__IsAggregate(litaC_type)) {
        {
            litaC_types__TypeInfo* litaC_aggInfo = litaC_type;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
                {
                    litaC_ast__InitArgExpr* litaC_arg = litaC_std__array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)), litaC_i);
                    litaC_ast__FieldStmt litaC_field = {0};
                    if(litaC_arg->fieldName.token.type == litaC_lex__TokenType_IDENTIFIER) {
                        {
                            litaC_intern__InternedString litaC_fieldName = litaC_arg->fieldName.str;
                            litaC_field = litaC_types__TypeInfo_getField(litaC_aggInfo, litaC_fieldName);
                            if(litaC_field.kind == litaC_ast__StmtKind_POISON_EXPR) {
                                {
                                    litaC_checker_expr__TypeChecker_errorNoField(litaC_this, &((litaC_arg->expr)), litaC_type, litaC_fieldName);
                                    continue;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_field = litaC_types__TypeInfo_getFieldByPosition(litaC_aggInfo, litaC_arg->argPosition);
                            if(litaC_field.kind == litaC_ast__StmtKind_POISON_EXPR) {
                                {
                                    litaC_checker_expr__TypeChecker_errorNoFieldAt(litaC_this, &((litaC_arg->expr)), litaC_type, litaC_arg->argPosition);
                                    continue;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                    } 
                    
                    litaC_checker__TypeChecker_checkAssignability(litaC_this, litaC_arg->expr.stmt.node.startPos, litaC_field.typeInfo, litaC_arg->expr.operand.typeInfo, litaC_checker_expr__IsDecayable(litaC_arg));
                    litaC_arg->expr.expectedType = litaC_field.typeInfo;
                    litaC_arg->value->expectedType = litaC_field.typeInfo;
                    if(litaC_types__IsTrait(litaC_field.typeInfo) && litaC_arg->expr.operand.isRightValue) {
                        {
                            litaC_checker_expr__TypeChecker_errorRvalueAssignmentToTrait(litaC_this, &((litaC_arg->expr)), litaC_arg->expr.operand.typeInfo, litaC_field.typeInfo);
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        if(litaC_type->kind == litaC_types__TypeKind_ARRAY) {
            {
                litaC_types__TypeInfo* litaC_arrayInfo = litaC_type;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
                    {
                        litaC_ast__InitArgExpr* litaC_arg = litaC_std__array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)), litaC_i);
                        litaC_checker__TypeChecker_checkAssignability(litaC_this, litaC_arg->expr.stmt.node.startPos, litaC_arrayInfo->arrayOf, litaC_arg->expr.operand.typeInfo, litaC_checker_expr__IsDecayable(litaC_arg));
                        litaC_arg->expr.expectedType = litaC_arrayInfo->arrayOf;
                        litaC_arg->value->expectedType = litaC_arrayInfo->arrayOf;
                        if(litaC_types__IsTrait(litaC_arrayInfo->arrayOf) && litaC_arg->expr.operand.isRightValue) {
                            {
                                litaC_checker_expr__TypeChecker_errorRvalueAssignmentToTrait(litaC_this, &((litaC_arg->expr)), litaC_arg->expr.operand.typeInfo, litaC_arrayInfo->arrayOf);
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                
                
            }
            
        } 
        
    } 
    
    return litaC_checker__TypeChecker_errors(litaC_this) == litaC_errors;
    
    
}

litaC_types__TypeInfo* litaC_checker_expr__TypeChecker_inferInitExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__InitExpr* litaC_expr,litaC_types__TypeInfo* litaC_aggInfo) {
    litaC_i32 litaC_size = litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_aggInfo->aggDecl->decl.genericParams)));
    litaC_std__array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)), litaC_size, litaC_this->lita->allocator);
    litaC_std__array__Array_cb__ptr_TypeInfo_ce_ litaC_suppliedArgs = litaC_std__array__ArrayInit_cb__ptr_TypeInfo_ce_(litaC_std__array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments))), litaC_this->lita->allocator);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
        {
            litaC_ast__InitArgExpr* litaC_arg = litaC_std__array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)), litaC_i);
            litaC_types__TypeInfo* litaC_type = litaC_arg->expr.operand.typeInfo;
            if(!(litaC_type)) {
                {
                    litaC_checker_expr__TypeChecker_errorInferGenericParameters(litaC_this, &((litaC_expr->expr)), &((litaC_aggInfo->aggDecl->decl.genericParams)), NULL);
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_std__array__Array_add_cb__ptr_TypeInfo_ce_(&((litaC_suppliedArgs)), litaC_type);
            
            
        }
    }
    if(!(litaC_expr->type)) {
        {
            return (litaC_types__TypeInfo*)litaC_aggInfo;
            
            
            
        }
        
    } 
    
    litaC_std__array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_expr->type->genericArgs)), litaC_size, litaC_this->lita->allocator);
    litaC_expr->type->typeInfo = NULL;
    for(litaC_i32 litaC_genericIndex = 0;litaC_genericIndex < litaC_size;litaC_genericIndex += 1) {
        {
            litaC_ast__GenericParam litaC_genericParam = litaC_std__array__Array_get_cb_GenericParam_ce_(&((litaC_aggInfo->aggDecl->decl.genericParams)), litaC_genericIndex);
            for(litaC_i32 litaC_fieldIndex = 0;litaC_fieldIndex < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_aggInfo->aggDecl->fields)));litaC_fieldIndex += 1) {
                {
                    litaC_types__TypeInfo* litaC_paramType = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_aggInfo->aggDecl->fields)), litaC_fieldIndex).typeInfo;
                    if(!(litaC_paramType)) {
                        {
                            litaC_checker_expr__TypeChecker_errorInferGenericParameter(litaC_this, &((litaC_expr->expr)), &((litaC_genericParam)));
                            goto err;
                            
                            
                            
                        }
                        
                    } 
                    
                    if(litaC_fieldIndex >= litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_suppliedArgs)))) {
                        {
                            break;
                            
                            
                        }
                        
                    } 
                    
                    litaC_types__TypeInfo* litaC_inferredType = litaC_checker_expr__TypeChecker_inferredType(litaC_this, litaC_genericParam.name, litaC_paramType, litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_suppliedArgs)), litaC_fieldIndex));
                    if(litaC_inferredType) {
                        {
                            litaC_std__array__Array_add_cb__ptr_TypeSpec_ce_(&((litaC_expr->type->genericArgs)), litaC_types__TypeInfo_asTypeSpec(litaC_inferredType, litaC_this->current));
                            break;
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
    }
    litaC_types__TypeInfo* litaC_type = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_expr->type, litaC_checker__SearchType_TYPE);
    if(!(litaC_type)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(litaC_type->sym && (litaC_type->sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE)) {
        {
            litaC_ast__GenericDecl* litaC_decl = (litaC_ast__GenericDecl*)litaC_type->sym->decl;
            litaC_checker_expr__TypeChecker_errorMissingGenericArguments(litaC_this, &((litaC_expr->expr)), litaC_expr->type->name, &((litaC_decl->genericParams)));
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_type;
    
    err:;
    
    return &(litaC_types__POISON_TYPE);
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveInitExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__InitExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_types__TypeInfo* litaC_type = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_expr->type, litaC_checker__SearchType_TYPE);
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_types__IsAggregate(litaC_type)) && litaC_type->kind != litaC_types__TypeKind_ARRAY) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->expr.stmt.node.startPos, "only struct, union or array can use initialization syntax");
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_types__IsAggregate(litaC_type)) {
        {
            if(!(litaC_checker_expr__TypeChecker_addDefaultArguments(litaC_this, litaC_type, litaC_expr))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
        {
            litaC_ast__InitArgExpr* litaC_arg = litaC_std__array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)), litaC_i);
            if(!(litaC_checker_expr__TypeChecker_resolveInitArgExpr(litaC_this, litaC_arg))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    if(litaC_types__IsAggregate(litaC_type)) {
        {
            litaC_types__TypeInfo* litaC_aggInfo = litaC_type;
            if(!(litaC_std__array__Array_empty_cb_GenericParam_ce_(&((litaC_aggInfo->aggDecl->decl.genericParams)))) && litaC_std__array__Array_empty_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)))) {
                {
                    litaC_type = litaC_checker_expr__TypeChecker_inferInitExpr(litaC_this, litaC_expr, litaC_aggInfo);
                    if(litaC_type->kind == litaC_types__TypeKind_POISON) {
                        {
                            return litaC_false;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_checker_expr__TypeChecker_addInitArgumentsReferences(litaC_this, litaC_type, litaC_expr);
    litaC_expr->expr.operand.typeInfo = litaC_type;
    return litaC_checker_expr__TypeChecker_checkInitArguments(litaC_this, litaC_type, litaC_expr);
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveSetExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__SetExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->object))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->value))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_expr->field)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_objectTypeInfo = litaC_expr->object->operand.typeInfo;
    if(litaC_objectTypeInfo->kind == litaC_types__TypeKind_ENUM) {
        {
            litaC_checker_expr__TypeChecker_errorEnumFieldSet(litaC_this, litaC_expr->object, litaC_objectTypeInfo, litaC_expr->field->type->name);
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_types__IsFieldAccessible(litaC_objectTypeInfo))) {
        {
            litaC_checker_expr__TypeChecker_errorNoFieldAccess(litaC_this, litaC_expr->object, litaC_objectTypeInfo, litaC_expr->field->type->name);
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_info = litaC_types__TypeInfo_getBaseType(litaC_objectTypeInfo);
    assert(litaC_info != NULL);
    assert(litaC_info->kind == litaC_types__TypeKind_STRUCT || litaC_info->kind == litaC_types__TypeKind_UNION);
    litaC_types__TypeInfo* litaC_aggInfo = litaC_info;
    litaC_ast__FieldStmt litaC_field = litaC_types__TypeInfo_getField(litaC_aggInfo, litaC_expr->field->type->name);
    if(litaC_field.kind == litaC_ast__StmtKind_POISON_EXPR) {
        {
            litaC_field = litaC_types__TypeInfo_getFieldWithUsing(litaC_aggInfo, litaC_expr->field->type->name);
            if(litaC_field.kind == litaC_ast__StmtKind_POISON_EXPR) {
                {
                    litaC_checker_expr__TypeChecker_errorNoField(litaC_this, &((litaC_expr->field->expr)), litaC_objectTypeInfo, litaC_expr->field->type->name);
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_expr->flags |= litaC_ast__GetExprFlags_IS_USING;
            
            
        }
        
    } 
    
    litaC_types__FieldPositionResult litaC_fieldResult = litaC_types__TypeInfo_getFieldPosition(litaC_aggInfo, litaC_expr->field->type->name);
    if(litaC_fieldResult.aggInfo) {
        {
            litaC_lsp__references__ReferenceDatabase_addFieldReference(&((litaC_this->lita->references)), litaC_expr->field->type->pos, litaC_fieldResult.aggInfo, litaC_fieldResult.position);
            
            
        }
        
    } 
    
    litaC_expr->field->expr.operand.typeInfo = litaC_field.typeInfo;
    litaC_expr->expr.operand.typeInfo = litaC_field.typeInfo;
    if(litaC_types__IsTrait(litaC_field.typeInfo) && litaC_expr->value->operand.isRightValue) {
        {
            litaC_checker_expr__TypeChecker_errorRvalueAssignmentToTrait(litaC_this, litaC_expr->value, litaC_expr->value->operand.typeInfo, litaC_field.typeInfo);
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_expr->expr.stmt.node.startPos, litaC_field.typeInfo, litaC_expr->value->operand.typeInfo, litaC_true);
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveTernaryExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__TernaryExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->cond))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_condType = litaC_expr->cond->operand.typeInfo;
    if(!(litaC_types__IsBooleanable(litaC_condType))) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->cond->stmt.node.startPos, "must be a boolean expression");
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->then))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->other))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_expr->expr.operand.typeInfo = litaC_expr->then->operand.typeInfo;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    return litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_expr->expr.stmt.node.startPos, litaC_expr->then->operand.typeInfo, litaC_expr->other->operand.typeInfo, litaC_true);
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveTypeIdentifierExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypeIdentifierExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_types__TypeInfo* litaC_type = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_expr->type, litaC_checker__SearchType_TYPE);
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_expr->isBased) {
        {
            litaC_type = litaC_types__TypeInfo_getBaseType(litaC_type);
            
            
        }
        
    } 
    
    litaC_expr->sym = litaC_type->sym;
    litaC_expr->expr.operand.typeInfo = litaC_type;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    litaC_expr->expr.operand.isConst = litaC_true;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveTypeOfExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__TypeOfExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(litaC_expr->typeOfExpr) {
        {
            if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->typeOfExpr))) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_types__TypeInfo* litaC_type = litaC_expr->typeOfExpr->operand.typeInfo;
            litaC_expr->expr.operand.val.intValue = litaC_type->typeid;
            
            
        }
        
    } else {
        {
            litaC_types__TypeInfo* litaC_type = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_expr->type, litaC_checker__SearchType_TYPE);
            if(!(litaC_type)) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_expr->expr.operand.val.intValue = litaC_type->typeid;
            
            
        }
    } 
    
    litaC_expr->expr.operand.typeInfo = &(litaC_types__U64_TYPE);
    litaC_expr->expr.operand.isRightValue = litaC_true;
    litaC_expr->expr.operand.isConst = litaC_true;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveOffsetOfExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__OffsetOfExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_types__TypeInfo* litaC_type = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_expr->type, litaC_checker__SearchType_TYPE);
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_types__IsAggregate(litaC_type))) {
        {
            litaC_checker_expr__TypeChecker_errorNonAggregateType(litaC_this, &((litaC_expr->expr)), litaC_type);
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_expr->field.token.type != litaC_lex__TokenType_IDENTIFIER) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_intern__InternedString litaC_fieldName = litaC_expr->field.str;
    litaC_types__TypeInfo* litaC_aggInfo = litaC_type;
    litaC_ast__FieldStmt litaC_fieldStmt = litaC_types__TypeInfo_getField(litaC_aggInfo, litaC_fieldName);
    if(litaC_fieldStmt.kind == litaC_ast__StmtKind_POISON_EXPR) {
        {
            litaC_checker_expr__TypeChecker_errorNoField(litaC_this, &((litaC_expr->expr)), litaC_type, litaC_fieldName);
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_expr->expr.operand.typeInfo = &(litaC_types__USIZE_TYPE);
    litaC_expr->expr.operand.isRightValue = litaC_true;
    litaC_expr->expr.operand.isConst = litaC_true;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveSizeOfExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__SizeOfExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->sizeOfExpr))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_expr->expr.operand.typeInfo = &(litaC_types__USIZE_TYPE);
    litaC_expr->expr.operand.isRightValue = litaC_true;
    litaC_expr->expr.operand.isConst = litaC_true;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_checkMethodExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__GetExpr* litaC_expr,litaC_types__TypeInfo* litaC_type) {
    assert(litaC_expr != NULL);
    if(!(litaC_type) || litaC_type->kind == litaC_types__TypeKind_FUNC_PTR) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_expr->flags & litaC_ast__GetExprFlags_IS_METHOD_CALL) {
        {
            litaC_symbols__Symbol* litaC_funcSym = litaC_checker__TypeChecker_getType(litaC_this, litaC_expr->field->type, litaC_checker__SearchType_FUNC);
            if(!(litaC_funcSym)) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            if(litaC_funcSym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
                {
                    litaC_types__TypeInfo* litaC_typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_expr->field->type, litaC_checker__SearchType_FUNC);
                    if(!(litaC_typeInfo)) {
                        {
                            return litaC_false;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_expr->field->expr.operand.typeInfo = litaC_typeInfo;
                    litaC_expr->expr.operand.typeInfo = litaC_typeInfo;
                    
                    
                }
                
            } 
            
            return litaC_true;
            
            
            
        }
        
    } 
    
    litaC_types__MethodResult litaC_methodResult = litaC_types__TypeInfo_getMethod(litaC_type, &((litaC_this->lita->strings)), litaC_this->current, litaC_expr->field->type->name);
    if(!(litaC_methodResult.symbol) && litaC_this->genericContext.callsite) {
        {
            litaC_methodResult = litaC_types__TypeInfo_getMethod(litaC_type, &((litaC_this->lita->strings)), litaC_this->genericContext.callsite, litaC_expr->field->type->name);
            
            
        }
        
    } 
    
    litaC_symbols__Symbol* litaC_funcSym = litaC_methodResult.symbol;
    if(litaC_funcSym) {
        {
            litaC_types__TypeInfo* litaC_typeInfo = litaC_funcSym->type;
            if(!((litaC_expr->flags & litaC_ast__GetExprFlags_IS_METHOD_CALL))) {
                {
                    litaC_expr->flags |= litaC_ast__GetExprFlags_IS_METHOD_CALL;
                    litaC_expr->field->type->name = litaC_methodResult.name;
                    
                    
                }
                
            } 
            
            if(litaC_funcSym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
                {
                    litaC_typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_expr->field->type, litaC_checker__SearchType_FUNC);
                    if(!(litaC_typeInfo)) {
                        {
                            return litaC_false;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            litaC_lsp__references__ReferenceDatabase_addTypeReferenceByTypeInfo(&((litaC_this->lita->references)), litaC_expr->field->expr.stmt.node.startPos, litaC_typeInfo);
            litaC_expr->field->expr.operand.typeInfo = litaC_typeInfo;
            litaC_expr->expr.operand.typeInfo = litaC_typeInfo;
            return litaC_true;
            
            
            
        }
        
    } 
    
    if(litaC_types__IsAggregate(litaC_type)) {
        {
            litaC_types__TypeInfo* litaC_aggInfo = litaC_type;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_aggInfo->aggDecl->fields)));litaC_i += 1) {
                {
                    litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_aggInfo->aggDecl->fields)), litaC_i);
                    if(litaC_field.kind == litaC_ast__StmtKind_VAR_FIELD_DECL) {
                        {
                            litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                            if(litaC_varField->decl.attributes.isUsing) {
                                {
                                    litaC_types__TypeInfo* litaC_baseType = litaC_types__TypeInfo_getBaseType(litaC_field.typeInfo);
                                    if(litaC_types__TypeInfo_strictEquals(litaC_baseType, litaC_aggInfo)) {
                                        {
                                            continue;
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    if(litaC_checker_expr__TypeChecker_checkMethodExpr(litaC_this, litaC_expr, litaC_baseType)) {
                                        {
                                            return litaC_true;
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveGetExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__GetExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->object))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_expr->field)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_objectTypeInfo = litaC_expr->object->operand.typeInfo;
    if(!(litaC_types__IsFieldAccessible(litaC_objectTypeInfo))) {
        {
            litaC_types__TypeInfo* litaC_info = litaC_types__TypeInfo_getBaseType(litaC_objectTypeInfo);
            if(!(litaC_checker_expr__TypeChecker_checkMethodExpr(litaC_this, litaC_expr, litaC_info))) {
                {
                    litaC_checker_expr__TypeChecker_errorNoFieldAccess(litaC_this, litaC_expr->object, litaC_objectTypeInfo, litaC_expr->field->type->name);
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            return litaC_true;
            
            
            
        }
        
    } 
    
    if(litaC_objectTypeInfo->kind == litaC_types__TypeKind_ENUM) {
        {
            litaC_types__TypeInfo* litaC_enumInfo = litaC_objectTypeInfo;
            litaC_ast__EnumFieldEntryDecl* litaC_field = litaC_types__TypeInfo_getEnumField(litaC_enumInfo, litaC_expr->field->type->name);
            if(!(litaC_field)) {
                {
                    litaC_checker_expr__TypeChecker_errorNoField(litaC_this, &((litaC_expr->field->expr)), litaC_objectTypeInfo, litaC_expr->field->type->name);
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_lsp__references__ReferenceDatabase_addFieldReference(&((litaC_this->lita->references)), litaC_expr->field->type->pos, litaC_enumInfo, litaC_types__TypeInfo_getEnumFieldIndex(litaC_enumInfo, litaC_expr->field->type->name));
            litaC_expr->flags |= litaC_ast__GetExprFlags_IS_ENUM;
            litaC_expr->expr.operand.typeInfo = &(litaC_types__I32_TYPE);
            litaC_expr->expr.operand.isConst = litaC_true;
            litaC_expr->expr.operand.isRightValue = litaC_true;
            return litaC_true;
            
            
            
        }
        
    } else {
        {
            litaC_types__TypeInfo* litaC_info = litaC_types__TypeInfo_getBaseType(litaC_objectTypeInfo);
            assert(litaC_info != NULL);
            assert(litaC_types__IsAggregate(litaC_info));
            litaC_types__TypeInfo* litaC_aggInfo = litaC_info;
            litaC_ast__FieldStmt litaC_field = litaC_types__TypeInfo_getField(litaC_aggInfo, litaC_expr->field->type->name);
            if(litaC_field.kind != litaC_ast__StmtKind_POISON_EXPR) {
                {
                    litaC_lsp__references__ReferenceDatabase_addFieldReference(&((litaC_this->lita->references)), litaC_expr->field->type->pos, litaC_aggInfo, litaC_types__TypeInfo_getFieldIndex(litaC_aggInfo, litaC_expr->field->type->name));
                    litaC_expr->field->expr.operand.typeInfo = litaC_field.typeInfo;
                    litaC_expr->expr.operand.typeInfo = litaC_field.typeInfo;
                    if(litaC_aggInfo->kind == litaC_types__TypeKind_TRAIT && litaC_expr->field->expr.stmt.node.kind != litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR) {
                        {
                            litaC_types__TypeInfo* litaC_funcPtr = (litaC_types__TypeInfo*)litaC_types__AsTraitFuncPtr(litaC_field.typeInfo, litaC_expr->field->type->name, litaC_this->typeCache);
                            litaC_expr->field->expr.operand.typeInfo = litaC_funcPtr;
                            litaC_expr->expr.operand.typeInfo = litaC_funcPtr;
                            
                            
                        }
                        
                    } 
                    
                    return litaC_true;
                    
                    
                    
                }
                
            } 
            
            litaC_field = litaC_types__TypeInfo_getFieldWithUsing(litaC_aggInfo, litaC_expr->field->type->name);
            if(litaC_field.kind != litaC_ast__StmtKind_POISON_EXPR) {
                {
                    litaC_types__FieldPositionResult litaC_fieldResult = litaC_types__TypeInfo_getFieldPosition(litaC_aggInfo, litaC_expr->field->type->name);
                    if(litaC_fieldResult.aggInfo) {
                        {
                            litaC_lsp__references__ReferenceDatabase_addFieldReference(&((litaC_this->lita->references)), litaC_expr->field->type->pos, litaC_fieldResult.aggInfo, litaC_fieldResult.position);
                            
                            
                        }
                        
                    } 
                    
                    litaC_expr->flags |= litaC_ast__GetExprFlags_IS_USING;
                    litaC_expr->field->expr.operand.typeInfo = litaC_field.typeInfo;
                    litaC_expr->expr.operand.typeInfo = litaC_field.typeInfo;
                    if(litaC_fieldResult.aggInfo->kind == litaC_types__TypeKind_TRAIT && litaC_expr->field->expr.stmt.node.kind != litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR) {
                        {
                            litaC_types__TypeInfo* litaC_funcPtr = (litaC_types__TypeInfo*)litaC_types__AsTraitFuncPtr(litaC_field.typeInfo, litaC_expr->field->type->name, litaC_this->typeCache);
                            litaC_expr->field->expr.operand.typeInfo = litaC_funcPtr;
                            litaC_expr->expr.operand.typeInfo = litaC_funcPtr;
                            
                            
                        }
                        
                    } 
                    
                    return litaC_true;
                    
                    
                    
                }
                
            } 
            
            if(litaC_checker_expr__TypeChecker_checkMethodExpr(litaC_this, litaC_expr, litaC_aggInfo)) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    } 
    
    litaC_checker_expr__TypeChecker_errorNoField(litaC_this, &((litaC_expr->field->expr)), litaC_objectTypeInfo, litaC_expr->field->type->name);
    return litaC_false;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveGroupExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__GroupExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->groupedExpr))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_expr->expr.operand = litaC_expr->groupedExpr->operand;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveUnaryExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__UnaryExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->unaryExpr))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_type = litaC_expr->unaryExpr->operand.typeInfo;
    assert(litaC_type != NULL);
    switch(litaC_expr->operator) {
        case litaC_lex__TokenType_STAR: {
            {
                switch(litaC_type->kind) {
                    case litaC_types__TypeKind_PTR: {
                        {
                            litaC_types__TypeInfo* litaC_info = litaC_type;
                            if(litaC_info->ptrOf->kind == litaC_types__TypeKind_CONST) {
                                {
                                    litaC_types__TypeInfo* litaC_constInfo = litaC_info->ptrOf;
                                    litaC_expr->expr.operand.typeInfo = litaC_constInfo->constOf;
                                    
                                    
                                }
                                
                            } else {
                                {
                                    litaC_expr->expr.operand.typeInfo = litaC_info->ptrOf;
                                    
                                    
                                }
                            } 
                            
                            break;
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_STR: {
                        {
                            litaC_expr->expr.operand.typeInfo = &(litaC_types__CHAR_TYPE);
                            break;
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_ARRAY: {
                        {
                            litaC_types__TypeInfo* litaC_info = litaC_type;
                            if(litaC_info->arrayOf->kind == litaC_types__TypeKind_CONST) {
                                {
                                    litaC_types__TypeInfo* litaC_constInfo = litaC_info->arrayOf;
                                    litaC_expr->expr.operand.typeInfo = litaC_constInfo->constOf;
                                    
                                    
                                }
                                
                            } else {
                                {
                                    litaC_expr->expr.operand.typeInfo = litaC_info->arrayOf;
                                    
                                    
                                }
                            } 
                            
                            break;
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_CONST: {
                        {
                            litaC_types__TypeInfo* litaC_constInfo = litaC_type;
                            if(litaC_types__IsPtrLike(litaC_constInfo->constOf)) {
                                {
                                    litaC_expr->expr.operand.typeInfo = litaC_constInfo->constOf;
                                    
                                    
                                }
                                
                            } 
                            
                            break;
                            
                            
                        }
                        
                        
                    }
                    default: {
                        {
                            litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
                            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
                            litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)), litaC_false);
                            litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), "' is not a pointer type");
                            litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->unaryExpr->stmt.node.startPos, &((litaC_sb)));
                            return litaC_false;
                            
                            
                            
                        }
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_lex__TokenType_BAND: {
            {
                if(litaC_type->kind == litaC_types__TypeKind_FUNC) {
                    {
                        litaC_expr->expr.operand.typeInfo = litaC_types__TypeInfo_asPtr(litaC_type, litaC_this->typeCache);
                        litaC_expr->expr.operand.isRightValue = litaC_true;
                        
                        
                    }
                    
                } else {
                    if(litaC_expr->unaryExpr->operand.isRightValue) {
                        {
                            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->unaryExpr->stmt.node.startPos, "lvalue required as unary '&' operand");
                            return litaC_false;
                            
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_expr->expr.operand.typeInfo = litaC_types_new__TypeCache_newPtrTypeInfo(litaC_this->typeCache, litaC_type);
                            
                            
                        }
                    } 
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_lex__TokenType_NOT: {
            {
                if(!(litaC_checker_expr__TypeChecker_checkTruthyness(litaC_this, litaC_expr->unaryExpr, litaC_type))) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                litaC_expr->expr.operand.typeInfo = &(litaC_types__BOOL_TYPE);
                break;
                
                
            }
            
            
        }
        default: {
            {
                litaC_expr->expr.operand = litaC_expr->unaryExpr->operand;
                break;
                
                
            }
            
            
        }
    }
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveCastExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__CastExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_types__TypeInfo* litaC_typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_expr->castTo, litaC_checker__SearchType_TYPE);
    if(!(litaC_typeInfo)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->exprToCast))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_expr->expr.operand.typeInfo = litaC_typeInfo;
    if(!(litaC_checker__TypeChecker_checkCastability(litaC_this, litaC_expr->expr.stmt.node.startPos, litaC_expr->exprToCast->operand.typeInfo, litaC_typeInfo))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveArrayDesignationExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__ArrayDesignationExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->index))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->value))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_ast__Expr_isConstNumberExpr(litaC_expr->index))) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->index->stmt.node.startPos, "array designation must be indexed by a number");
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_expr->index->stmt.node.kind == litaC_ast__StmtKind_IDENTIFIER_EXPR) {
        {
            litaC_ast__IdentifierExpr* litaC_idExpr = (litaC_ast__IdentifierExpr*)litaC_expr->index;
            if(litaC_idExpr->sym != NULL && !((litaC_idExpr->sym->flags & litaC_symbols__SymbolFlags_IS_CONSTANT))) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->index->stmt.node.startPos, "'%.*s' must be a constant", litaC_idExpr->sym->name.length, litaC_idExpr->sym->name.buffer);
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(!(litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_expr->expr.stmt.node.startPos, &(litaC_types__USIZE_TYPE), litaC_expr->index->operand.typeInfo, litaC_true))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_expr->expr.operand = litaC_expr->value->operand;
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveArrayInitExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__ArrayInitExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_types__TypeInfo* litaC_typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_expr->type, litaC_checker__SearchType_TYPE);
    if(!(litaC_typeInfo) || litaC_typeInfo->kind == litaC_types__TypeKind_POISON) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_expr->expr.operand.typeInfo = litaC_typeInfo;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    assert(litaC_typeInfo->kind == litaC_types__TypeKind_ARRAY);
    litaC_types__TypeInfo* litaC_arrayInfo = litaC_typeInfo;
    litaC_types__TypeInfo* litaC_arrayOf = litaC_arrayInfo->arrayOf;
    if(!(litaC_std__array__Array_empty_cb__ptr_Expr_ce_(&((litaC_expr->values))))) {
        {
            if(!(litaC_arrayInfo->numOfElements) && litaC_arrayInfo->length < 1) {
                {
                    litaC_arrayInfo->length = litaC_std__array__Array_size_cb__ptr_Expr_ce_(&((litaC_expr->values)));
                    litaC_arrayInfo->isLengthDefined = litaC_true;
                    
                    
                }
                
            } 
            
            litaC_bool litaC_success = litaC_true;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Expr_ce_(&((litaC_expr->values)));litaC_i += 1) {
                {
                    litaC_ast__Expr* litaC_value = litaC_std__array__Array_get_cb__ptr_Expr_ce_(&((litaC_expr->values)), litaC_i);
                    litaC_value->expectedType = litaC_arrayOf;
                    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_value))) {
                        {
                            litaC_success = litaC_false;
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    if(litaC_value->operand.typeInfo) {
                        {
                            litaC_success = litaC_checker__TypeChecker_checkTypeCompatibility(litaC_this, litaC_value->stmt.node.startPos, litaC_arrayOf, litaC_value->operand.typeInfo, litaC_true) && litaC_success;
                            if(litaC_types__IsTrait(litaC_arrayOf) && litaC_value->operand.isRightValue) {
                                {
                                    litaC_checker_expr__TypeChecker_errorRvalueAssignmentToTrait(litaC_this, litaC_value, litaC_value->operand.typeInfo, litaC_arrayOf);
                                    litaC_success = litaC_false;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            return litaC_success;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveBinaryExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__BinaryExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_i32 litaC_errors = litaC_checker__TypeChecker_errors(litaC_this);
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->left))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(!(litaC_checker_expr__TypeChecker_resolveExpr(litaC_this, litaC_expr->right))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_leftType = litaC_expr->left->operand.typeInfo;
    litaC_types__TypeInfo* litaC_rightType = litaC_expr->right->operand.typeInfo;
    litaC_types__TypeInfo* litaC_targetType = ((litaC_leftType->typeid > litaC_rightType->typeid)) ? litaC_leftType : litaC_rightType;
    switch(litaC_expr->operator) {
        case litaC_lex__TokenType_EQUALS: {
            {
                litaC_expr->right = litaC_checker_expr__TypeChecker_coerceTypeWithUsing(litaC_this, litaC_expr->right, litaC_rightType, litaC_leftType);
                litaC_rightType = litaC_expr->right->operand.typeInfo;
                litaC_checker_expr__TypeChecker_checkConstant(litaC_this, litaC_expr->left);
                litaC_checker__TypeChecker_checkAssignability(litaC_this, litaC_expr->right->stmt.node.startPos, litaC_leftType, litaC_rightType, litaC_false);
                litaC_checker_expr__TypeChecker_checkRightValue(litaC_this, litaC_expr->left);
                break;
                
                
            }
            
            
        }
        case litaC_lex__TokenType_BAND_EQ: 
        case litaC_lex__TokenType_BNOT_EQ: 
        case litaC_lex__TokenType_BOR_EQ: 
        case litaC_lex__TokenType_XOR_EQ: 
        case litaC_lex__TokenType_LSHIFT_EQ: 
        case litaC_lex__TokenType_RSHIFT_EQ: {
            litaC_checker_expr__TypeChecker_checkConstant(litaC_this, litaC_expr->left);
            litaC_checker__TypeChecker_checkAssignability(litaC_this, litaC_expr->right->stmt.node.startPos, litaC_leftType, litaC_rightType, litaC_false);
            litaC_checker_expr__TypeChecker_checkRightValue(litaC_this, litaC_expr->left);
            
            
        }
        case litaC_lex__TokenType_BAND: 
        case litaC_lex__TokenType_BNOT: 
        case litaC_lex__TokenType_BOR: 
        case litaC_lex__TokenType_XOR: 
        case litaC_lex__TokenType_LSHIFT: 
        case litaC_lex__TokenType_RSHIFT: {
            {
                if(!(litaC_types__IsInteger(litaC_leftType))) {
                    {
                        litaC_checker_expr__TypeChecker_errorOperand(litaC_this, litaC_expr->left, litaC_leftType, "left");
                        
                        
                    }
                    
                } 
                
                if(!(litaC_types__IsInteger(litaC_rightType))) {
                    {
                        litaC_checker_expr__TypeChecker_errorOperand(litaC_this, litaC_expr->right, litaC_rightType, "right");
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_lex__TokenType_AND: 
        case litaC_lex__TokenType_OR: {
            {
                litaC_checker_expr__TypeChecker_checkTruthyness(litaC_this, litaC_expr->left, litaC_leftType);
                litaC_checker_expr__TypeChecker_checkTruthyness(litaC_this, litaC_expr->right, litaC_rightType);
                litaC_targetType = &(litaC_types__BOOL_TYPE);
                break;
                
                
            }
            
            
        }
        case litaC_lex__TokenType_EQUALS_EQUALS: 
        case litaC_lex__TokenType_NOT_EQUALS: {
            {
                litaC_checker_expr__TypeChecker_checkTruthyness(litaC_this, litaC_expr->left, litaC_leftType);
                litaC_checker_expr__TypeChecker_checkTruthyness(litaC_this, litaC_expr->right, litaC_rightType);
                litaC_targetType = &(litaC_types__BOOL_TYPE);
                break;
                
                
            }
            
            
        }
        case litaC_lex__TokenType_GREATER_EQUALS: 
        case litaC_lex__TokenType_GREATER_THAN: 
        case litaC_lex__TokenType_LESS_EQUALS: 
        case litaC_lex__TokenType_LESS_THAN: {
            {
                if(!(litaC_types__IsNumberLike(litaC_leftType))) {
                    {
                        litaC_checker_expr__TypeChecker_errorOperand(litaC_this, litaC_expr->left, litaC_leftType, "left");
                        
                        
                    }
                    
                } 
                
                if(!(litaC_types__IsNumberLike(litaC_rightType))) {
                    {
                        litaC_checker_expr__TypeChecker_errorOperand(litaC_this, litaC_expr->right, litaC_rightType, "right");
                        
                        
                    }
                    
                } 
                
                litaC_targetType = &(litaC_types__BOOL_TYPE);
                break;
                
                
            }
            
            
        }
        case litaC_lex__TokenType_MINUS_EQ: 
        case litaC_lex__TokenType_PLUS_EQ: 
        case litaC_lex__TokenType_MOD_EQ: 
        case litaC_lex__TokenType_MUL_EQ: 
        case litaC_lex__TokenType_DIV_EQ: {
            litaC_checker_expr__TypeChecker_checkConstant(litaC_this, litaC_expr->left);
            litaC_checker__TypeChecker_checkAssignability(litaC_this, litaC_expr->right->stmt.node.startPos, litaC_leftType, litaC_rightType, litaC_false);
            
            
        }
        case litaC_lex__TokenType_MINUS: 
        case litaC_lex__TokenType_PLUS: 
        case litaC_lex__TokenType_MOD: 
        case litaC_lex__TokenType_STAR: 
        case litaC_lex__TokenType_SLASH: {
            {
                if(!(litaC_types__IsNumberLike(litaC_leftType))) {
                    {
                        litaC_checker_expr__TypeChecker_errorOperand(litaC_this, litaC_expr->left, litaC_leftType, "left");
                        
                        
                    }
                    
                } 
                
                if(!(litaC_types__IsNumberLike(litaC_rightType))) {
                    {
                        litaC_checker_expr__TypeChecker_errorOperand(litaC_this, litaC_expr->right, litaC_rightType, "right");
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    litaC_expr->expr.operand.typeInfo = litaC_targetType;
    litaC_expr->expr.operand.isConst = litaC_expr->left->operand.isConst && litaC_expr->right->operand.isConst;
    litaC_expr->expr.operand.isRightValue = litaC_true;
    return litaC_checker__TypeChecker_errors(litaC_this) == litaC_errors;
    
    err:;
    
    return litaC_false;
    
    
}

litaC_void litaC_checker_expr__TypeChecker_errorRvalueAssignmentToTrait(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,litaC_types__TypeInfo* litaC_typeTrait) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), "invalid trait assignment from rvalue of type '");
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)), litaC_false);
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), "' to trait type '");
    litaC_types__TypeInfo_toString(litaC_typeTrait, &((litaC_sb)), litaC_false);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorNonIndexableType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), "invalid index into '");
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)), litaC_false);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorSetIndexingConstType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), "invalid read-only assignment to '");
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)), litaC_false);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorIndexType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)), litaC_false);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), " invalid index value");
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorNonAggregateType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)), litaC_false);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), " must be an aggregate type");
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorNonFuncType(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)), litaC_false);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), " must be function type");
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorOperand(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,const litaC_char* litaC_side) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "illegal, %s operand has type '", litaC_side);
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)), litaC_false);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorEnumFieldSet(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,litaC_intern__InternedString litaC_field) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), "can't reassign enum '");
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)), litaC_false);
    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "' field '%.*s'", litaC_field.length, litaC_field.buffer);
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorNoField(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,litaC_intern__InternedString litaC_field) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)), litaC_false);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), " does not have field '%.*s'", litaC_field.length, litaC_field.buffer);
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorNoFieldAt(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,litaC_i32 litaC_position) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)), litaC_false);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), " does not have a field at index '%d'", litaC_position);
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorNoFieldAccess(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type,litaC_intern__InternedString litaC_field) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)), litaC_false);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), " can't be accessed with field '%.*s'", litaC_field.length, litaC_field.buffer);
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorInferGenericParameter(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_ast__GenericParam* litaC_param) {
    assert(litaC_expr != NULL);
    assert(litaC_param != NULL);
    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, "unable to infer generic parameter '%.*s'", litaC_param->name.str.length, litaC_param->name.str.buffer);
    
}

litaC_void litaC_checker_expr__TypeChecker_errorInferGenericParameters(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_std__array__Array_cb_GenericParam_ce_* litaC_params,const litaC_char* litaC_details) {
    assert(litaC_expr != NULL);
    assert(litaC_params != NULL);
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), "unable to infer generic parameters [");
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_GenericParam_ce_(litaC_params);litaC_i += 1) {
        {
            if(litaC_i > 0) {
                {
                    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), ", ", 2);
                    
                    
                }
                
            } 
            
            litaC_ast__GenericParam litaC_p = litaC_std__array__Array_get_cb_GenericParam_ce_(litaC_params, litaC_i);
            litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "'%.*s'", litaC_p.name.str.length, litaC_p.name.str.buffer);
            
            
        }
    }
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "]", 1);
    if(litaC_details) {
        {
            litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), " due to %s", litaC_details);
            
            
        }
        
    } 
    
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorMissingGenericArguments(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_intern__InternedString litaC_typeName,litaC_std__array__Array_cb_GenericParam_ce_* litaC_genericParams) {
    assert(litaC_expr != NULL);
    assert(litaC_genericParams != NULL);
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "'%.*s' is missing generic arguments [", litaC_typeName.length, litaC_typeName.buffer);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_GenericParam_ce_(litaC_genericParams);litaC_i += 1) {
        {
            litaC_ast__GenericParam litaC_param = litaC_std__array__Array_get_cb_GenericParam_ce_(litaC_genericParams, litaC_i);
            if(litaC_i > 0) {
                {
                    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), ", ", 1);
                    
                    
                }
                
            } 
            
            litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "'%.*s'", litaC_param.name.str.length, litaC_param.name.str.buffer);
            
            
        }
    }
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "]", 1);
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorFixedArgumentAfterNamed(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_arg) {
    assert(litaC_arg != NULL);
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(128, litaC_this->lita->allocator);
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), "Named argument specifications must appear after all fixed arguments have been specified");
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_arg->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorNamedArgumentsForFuncPtr(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(128, litaC_this->lita->allocator);
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), "Named arguments are not allowed on function pointers");
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
    
}

litaC_void litaC_checker_expr__TypeChecker_errorInvalidNamedArgument(litaC_checker__TypeChecker* litaC_this,litaC_lex__SrcPos litaC_pos,litaC_intern__InternedString* litaC_name,litaC_types__TypeInfo* litaC_funcInfo) {
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "Invalid named parameter: '%.*s'; no parameter with that name found in 'func %.*s(", litaC_name->length, litaC_name->buffer, litaC_funcInfo->name.length, litaC_funcInfo->name.buffer);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)));litaC_i += 1) {
        {
            litaC_ast__ParameterDecl* litaC_param = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)), litaC_i);
            if(litaC_i > 0) {
                {
                    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), ", ");
                    
                    
                }
                
            } 
            
            litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "%.*s: ", litaC_param->decl.name.str.length, litaC_param->decl.name.str.buffer);
            if(litaC_param->typeInfo) {
                {
                    litaC_types__TypeInfo_toString(litaC_param->typeInfo, &((litaC_sb)), litaC_false);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), ")'");
    litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_pos, &((litaC_sb)));
    
}

litaC_bool litaC_checker_expr__TypeChecker_checkConstant(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_symbols__Symbol* litaC_sym = NULL;
    if(litaC_expr->stmt.node.kind == litaC_ast__StmtKind_IDENTIFIER_EXPR) {
        {
            litaC_ast__IdentifierExpr* litaC_idExpr = (litaC_ast__IdentifierExpr*)litaC_expr;
            litaC_sym = litaC_idExpr->sym;
            if(litaC_sym && (litaC_sym->flags & litaC_symbols__SymbolFlags_IS_TYPE)) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, "can't reassign type '%.*s'", litaC_sym->name.length, litaC_sym->name.buffer);
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(!(litaC_sym)) {
        {
            if(!(litaC_expr->operand.typeInfo)) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, "no type information");
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_sym = litaC_expr->operand.typeInfo->sym;
            if(!(litaC_sym)) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_CONSTANT) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, "can't reassign constant variable '%.*s'", litaC_sym->name.length, litaC_sym->name.buffer);
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_checkTruthyness(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr,litaC_types__TypeInfo* litaC_type) {
    assert(litaC_expr != NULL);
    assert(litaC_type != NULL);
    if(!(litaC_types__IsBooleanable(litaC_type))) {
        {
            litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "'", 1);
            litaC_types__TypeInfo_toString(litaC_type, &((litaC_sb)), litaC_false);
            litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), "' can't be coerced to boolean");
            litaC_phase_result__PhaseResult_addErrorStr(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, &((litaC_sb)));
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_checkRightValue(litaC_checker__TypeChecker* litaC_this,litaC_ast__Expr* litaC_expr) {
    assert(litaC_expr != NULL);
    if(litaC_expr->operand.isRightValue) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->stmt.node.startPos, "rvalue can't be assigned to");
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_checker_expr__TypeChecker_resolveIdentiferExpr(litaC_checker__TypeChecker* litaC_this,litaC_ast__IdentifierExpr* litaC_expr) {
    assert(litaC_expr != NULL);
    litaC_symbols__Symbol* litaC_sym = litaC_symbols__Scope_lookup(litaC_checker__TypeChecker_currentScope(litaC_this), litaC_expr->type->name, litaC_true);
    if(!(litaC_sym)) {
        {
            litaC_sym = litaC_symbols__Scope_lookupFunc(litaC_checker__TypeChecker_currentScope(litaC_this), litaC_expr->type->name);
            if(!(litaC_sym)) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->expr.stmt.node.startPos, "unknown variable '%.*s'", litaC_expr->type->name.length, litaC_expr->type->name.buffer);
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_typeInfo = litaC_sym->type;
    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE && !(litaC_std__array__Array_empty_cb__ptr_TypeSpec_ce_(&((litaC_expr->type->genericArgs))))) {
        {
            litaC_typeInfo = litaC_checker__TypeChecker_resolveTypeSpec(litaC_this, litaC_expr->type, litaC_checker__SearchType_TYPE);
            if(!(litaC_typeInfo) || litaC_typeInfo == &(litaC_types__POISON_TYPE)) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->expr.stmt.node.startPos, "unknown type '%s'", litaC_expr->type->name);
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_sym = litaC_typeInfo->sym;
            
            
        }
        
    } 
    
    litaC_expr->sym = litaC_sym;
    litaC_expr->expr.operand.typeInfo = litaC_typeInfo;
    if(!(litaC_expr->expr.operand.typeInfo)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_expr->expr.stmt.node.startPos, "unknown type or variable '%.*s'", litaC_expr->type->name.length, litaC_expr->type->name.buffer);
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_lsp__references__ReferenceDatabase_addSymbolReference(&((litaC_this->lita->references)), litaC_sym, litaC_expr->expr.stmt.node.startPos);
    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_CONSTANT) {
        {
            litaC_expr->expr.operand.isConst = litaC_true;
            litaC_expr->expr.operand.val = litaC_sym->val;
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_void litaC_error_codes__PrintError(litaC_std__string_buffer__StringBuffer* litaC_sb,litaC_phase_result__PhaseError litaC_error) {
    if(!(litaC_error.pos.lineStart)) {
        {
            litaC_std__string_buffer__StringBuffer_append(litaC_sb, "%s\n", litaC_error.message);
            return;
            
            
            
        }
        
    } 
    
    litaC_std__string_buffer__StringBuffer_append(litaC_sb, "%s:%d:%d error: %s\n", litaC_error.pos.filename, litaC_error.pos.lineNumber, litaC_error.pos.position, litaC_error.message);
    litaC_i32 litaC_len = litaC_lex__SrcPos_getLineLength(&((litaC_error.pos)));
    litaC_i32 litaC_maxLength = MIN(litaC_len, 255);
    litaC_i32 litaC_spaceCount = 0;
    litaC_bool litaC_atStart = litaC_false;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_maxLength;litaC_i += 1) {
        {
            litaC_char litaC_c = litaC_error.pos.lineStart[litaC_i];
            if(litaC_c == '\0') {
                {
                    break;
                    
                    
                }
                
            } 
            
            if((litaC_error.pos.lineStart + litaC_i) == litaC_error.pos.start) {
                {
                    litaC_atStart = litaC_true;
                    
                    
                }
                
            } 
            
            if(litaC_c == '\t') {
                {
                    if(!(litaC_atStart)) {
                        {
                            litaC_spaceCount += 4;
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__string_buffer__StringBuffer_append(litaC_sb, "    ");
                    continue;
                    
                    
                }
                
            } 
            
            litaC_std__string_buffer__StringBuffer_appendChar(litaC_sb, litaC_c);
            if(!(litaC_atStart)) {
                {
                    litaC_spaceCount += 1;
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_std__string_buffer__StringBuffer_append(litaC_sb, "\n");
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_spaceCount;litaC_i += 1) {
        {
            litaC_std__string_buffer__StringBuffer_append(litaC_sb, " ");
            
            
        }
    }
    litaC_std__string_buffer__StringBuffer_append(litaC_sb, "^\n*** %s\n", litaC_error.message);
    
}

litaC_void litaC_lsp__references__ReferenceDatabase_init(litaC_lsp__references__ReferenceDatabase* litaC_this,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_this->allocator = litaC_allocator;
    
#define litaC_INITIAL_SIZE (1024)
    litaC_std__array__Array_init_cb_Reference_ce_(&((litaC_this->typeReferences)), litaC_INITIAL_SIZE, litaC_allocator);
    litaC_std__array__Array_init_cb_FieldReference_ce_(&((litaC_this->fieldReferences)), litaC_INITIAL_SIZE, litaC_allocator);
    litaC_std__map__Map_init_cb_usize_c_Array_cb_SrcPos_ce__ce_(&((litaC_this->symbols)), (litaC_std__array__Array_cb_SrcPos_ce_) {
        
    }, litaC_INITIAL_SIZE, litaC_std__map__PtrHashFn_cb_usize_ce_, litaC_std__map__PtrEqualFn_cb_usize_ce_, litaC_allocator, 0);
    #undef litaC_INITIAL_SIZE
    
}

litaC_void litaC_lsp__references__ReferenceDatabase_addSymbolReference(litaC_lsp__references__ReferenceDatabase* litaC_this,litaC_symbols__Symbol* litaC_symbol,litaC_lex__SrcPos litaC_pos) {
    if(!(litaC_symbol)) {
        return;
        
        
    } 
    
    litaC_usize litaC_ptr = (litaC_usize)litaC_symbol;
    if(!(litaC_std__map__Map_contains_cb_usize_c_Array_cb_SrcPos_ce__ce_(&((litaC_this->symbols)), litaC_ptr))) {
        {
            litaC_std__array__Array_cb_SrcPos_ce_ litaC_locations = litaC_std__array__ArrayInit_cb_SrcPos_ce_(16, litaC_this->allocator);
            litaC_std__map__Map_put_cb_usize_c_Array_cb_SrcPos_ce__ce_(&((litaC_this->symbols)), litaC_ptr, litaC_locations);
            
            
        }
        
    } 
    
    litaC_std__array__Array_cb_SrcPos_ce_* litaC_locations = litaC_std__map__Map_getPtr_cb_usize_c_Array_cb_SrcPos_ce__ce_(&((litaC_this->symbols)), litaC_ptr);
    litaC_std__array__Array_add_cb_SrcPos_ce_(litaC_locations, litaC_pos);
    
}

litaC_void litaC_lsp__references__ReferenceDatabase_addTypeReference(litaC_lsp__references__ReferenceDatabase* litaC_this,litaC_ast__TypeSpec* litaC_type) {
    if(!(litaC_type)) {
        return;
        
        
    } 
    
    litaC_ast__TypeSpec* litaC_base = litaC_ast__TypeSpec_getBaseType(litaC_type);
    if(!(litaC_base)) {
        return;
        
        
    } 
    
    litaC_lsp__references__ReferenceDatabase_addTypeReferenceByTypeInfo(litaC_this, litaC_type->pos, litaC_base->typeInfo);
    
}

litaC_void litaC_lsp__references__ReferenceDatabase_addTypeReferenceBySymbol(litaC_lsp__references__ReferenceDatabase* litaC_this,litaC_lex__SrcPos litaC_srcPos,litaC_symbols__Symbol* litaC_sym) {
    if(litaC_sym && litaC_sym->type) {
        {
            litaC_lsp__references__ReferenceDatabase_addTypeReferenceByTypeInfo(litaC_this, litaC_srcPos, litaC_sym->type);
            
            
        }
        
    } 
    
    
}

litaC_void litaC_lsp__references__ReferenceDatabase_addTypeReferenceByTypeInfo(litaC_lsp__references__ReferenceDatabase* litaC_this,litaC_lex__SrcPos litaC_srcPos,litaC_types__TypeInfo* litaC_typeInfo) {
    if(!(litaC_typeInfo)) {
        return;
        
        
    } 
    
    litaC_typeInfo = litaC_types__TypeInfo_getBaseType(litaC_typeInfo);
    if(litaC_types__IsGenericCapable(litaC_typeInfo)) {
        {
            if(litaC_typeInfo->sym && litaC_typeInfo->sym->flags & litaC_symbols__SymbolFlags_IS_FROM_GENERIC_TEMPLATE) {
                {
                    litaC_types__TypeInfo* litaC_genInfo = litaC_typeInfo;
                    litaC_std__array__Array_add_cb_Reference_ce_(&((litaC_this->typeReferences)), (litaC_lsp__references__Reference) {
                        .type = litaC_genInfo->genericTypeid,
                        .pos = litaC_srcPos
                    });
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_std__array__Array_add_cb_Reference_ce_(&((litaC_this->typeReferences)), (litaC_lsp__references__Reference) {
        .type = litaC_typeInfo->typeid,
        .pos = litaC_srcPos
    });
    
}

litaC_void litaC_lsp__references__ReferenceDatabase_addFieldReference(litaC_lsp__references__ReferenceDatabase* litaC_this,litaC_lex__SrcPos litaC_srcPos,litaC_types__TypeInfo* litaC_parent,litaC_i32 litaC_offset) {
    if(!(litaC_parent)) {
        return;
        
        
    } 
    
    litaC_std__array__Array_add_cb_FieldReference_ce_(&((litaC_this->fieldReferences)), (litaC_lsp__references__FieldReference) {
        .parent = litaC_parent->typeid,
        .offset = litaC_offset,
        .pos = litaC_srcPos
    });
    
}

litaC_std__array__Array_cb_SrcPos_ce_ litaC_lsp__references__ReferenceDatabase_getSymbolReferences(litaC_lsp__references__ReferenceDatabase* litaC_this,litaC_symbols__Symbol* litaC_symbol) {
    if(!(litaC_symbol)) {
        return (litaC_std__array__Array_cb_SrcPos_ce_) {
            
        };
        
        
    } 
    
    litaC_usize litaC_ptr = (litaC_usize)litaC_symbol;
    if(litaC_std__map__Map_contains_cb_usize_c_Array_cb_SrcPos_ce__ce_(&((litaC_this->symbols)), litaC_ptr)) {
        {
            litaC_std__array__Array_cb_SrcPos_ce_ litaC_result = litaC_std__map__Map_get_cb_usize_c_Array_cb_SrcPos_ce__ce_(&((litaC_this->symbols)), litaC_ptr);
            return litaC_result;
            
            
            
        }
        
    } 
    
    return (litaC_std__array__Array_cb_SrcPos_ce_) {
        
    };
    
    
}

litaC_void litaC_lsp__references__ReferenceDatabase_removeLocalSymbolReferences(litaC_lsp__references__ReferenceDatabase* litaC_this,litaC_module__Module* litaC_module) {
    if(!(litaC_module)) {
        return;
        
        
    } 
    
    for(litaC_std__map__MapIterator_cb_usize_c_Array_cb_SrcPos_ce__ce_ litaC_it = litaC_std__map__Map_iter_cb_usize_c_Array_cb_SrcPos_ce__ce_(&((litaC_this->symbols)));litaC_std__map__MapIterator_hasNext_cb_usize_c_Array_cb_SrcPos_ce__ce_(&((litaC_it)));) {
        {
            litaC_std__map__MapEntry_cb_usize_c_Array_cb_SrcPos_ce__ce_ litaC_entry = litaC_std__map__MapIterator_next_cb_usize_c_Array_cb_SrcPos_ce__ce_(&((litaC_it)));
            litaC_symbols__Symbol* litaC_symbol = (litaC_symbols__Symbol*)litaC_entry.key;
            if(litaC_symbol && (litaC_symbol->flags & litaC_symbols__SymbolFlags_IS_LOCAL) && litaC_module__Module_equals(litaC_symbol->declared, litaC_module)) {
                {
                    litaC_std__map__MapIterator_remove_cb_usize_c_Array_cb_SrcPos_ce__ce_(&((litaC_it)));
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

litaC_void litaC_lsp__references__ReferenceDatabase_getTypeReferences(litaC_lsp__references__ReferenceDatabase* litaC_this,litaC_i64 litaC_typeid,litaC_std__array__Array_cb_SrcPos_ce_* litaC_results) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_Reference_ce_(&((litaC_this->typeReferences)));litaC_i += 1) {
        {
            litaC_lsp__references__Reference* litaC_ref = litaC_std__array__Array_getPtr_cb_Reference_ce_(&((litaC_this->typeReferences)), litaC_i);
            if(litaC_ref->type == litaC_typeid) {
                {
                    litaC_std__array__Array_add_cb_SrcPos_ce_(litaC_results, litaC_ref->pos);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

litaC_void litaC_lsp__references__ReferenceDatabase_getFieldReferences(litaC_lsp__references__ReferenceDatabase* litaC_this,litaC_i64 litaC_typeid,litaC_i32 litaC_offset,litaC_std__array__Array_cb_SrcPos_ce_* litaC_results) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldReference_ce_(&((litaC_this->fieldReferences)));litaC_i += 1) {
        {
            litaC_lsp__references__FieldReference* litaC_ref = litaC_std__array__Array_getPtr_cb_FieldReference_ce_(&((litaC_this->fieldReferences)), litaC_i);
            if(litaC_ref->parent == litaC_typeid && litaC_ref->offset == litaC_offset) {
                {
                    litaC_std__array__Array_add_cb_SrcPos_ce_(litaC_results, litaC_ref->pos);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

litaC_void* litaC_std__json__DefaultMakePtrFn(litaC_u64 litaC_type,litaC_std__json__JsonContext* litaC_context,litaC_std__json__JsonNode* litaC_json) {
    return NULL;
    
    
}

litaC_void litaC_std__json__DefaultMakeFn(litaC_u64 litaC_type,litaC_std__json__JsonContext* litaC_context,litaC_std__json__JsonNode* litaC_json,litaC_void* litaC_result) {
    
}

litaC_std__json__JsonContext litaC_std__json__JsonContextInit(litaC_void (*litaC_maker)(litaC_u64,litaC_std__json__JsonContext*,litaC_std__json__JsonNode*,litaC_void*),litaC_void* (*litaC_makerPtr)(litaC_u64,litaC_std__json__JsonContext*,litaC_std__json__JsonNode*),const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_std__json__JsonContext litaC_context =  {
        
    };
    litaC_std__json__JsonContext_init(&((litaC_context)), litaC_maker, litaC_makerPtr, litaC_allocator);
    return litaC_context;
    
    
}

litaC_void litaC_std__json__JsonContext_init(litaC_std__json__JsonContext* litaC_this,litaC_void (*litaC_maker)(litaC_u64,litaC_std__json__JsonContext*,litaC_std__json__JsonNode*,litaC_void*),litaC_void* (*litaC_makerPtr)(litaC_u64,litaC_std__json__JsonContext*,litaC_std__json__JsonNode*),const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_this->allocator = litaC_allocator;
    litaC_this->maker = litaC_maker;
    litaC_this->makerPtr = litaC_makerPtr;
    
}

LITAC_INLINE 
litaC_bool litaC_std__json__JsonNode_isNull(litaC_std__json__JsonNode* litaC_node) {
    return litaC_node->type == litaC_std__json__JsonType_NULL;
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__json__JsonNode_isBool(litaC_std__json__JsonNode* litaC_node) {
    return litaC_node->type == litaC_std__json__JsonType_BOOLEAN;
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__json__JsonNode_isTrue(litaC_std__json__JsonNode* litaC_node) {
    return litaC_node->type == litaC_std__json__JsonType_BOOLEAN && litaC_node->value.boolValue;
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__json__JsonNode_isFalse(litaC_std__json__JsonNode* litaC_node) {
    return !(litaC_std__json__JsonNode_isTrue(litaC_node));
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__json__JsonNode_isNumber(litaC_std__json__JsonNode* litaC_node) {
    return litaC_node->type == litaC_std__json__JsonType_INT_NUMBER || litaC_node->type == litaC_std__json__JsonType_FLOAT_NUMBER;
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__json__JsonNode_isString(litaC_std__json__JsonNode* litaC_node) {
    return litaC_node->type == litaC_std__json__JsonType_STRING;
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__json__JsonNode_isArray(litaC_std__json__JsonNode* litaC_node) {
    return litaC_node->type == litaC_std__json__JsonType_ARRAY;
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__json__JsonNode_isObject(litaC_std__json__JsonNode* litaC_node) {
    return litaC_node->type == litaC_std__json__JsonType_OBJECT;
    
    
}

LITAC_INLINE 
const litaC_char* litaC_std__json__JsonNode_asString(litaC_std__json__JsonNode* litaC_node) {
    return litaC_node->value.strValue;
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__json__JsonNode_asBool(litaC_std__json__JsonNode* litaC_node) {
    return litaC_node->value.boolValue;
    
    
}

LITAC_INLINE 
litaC_f64 litaC_std__json__JsonNode_asNumber(litaC_std__json__JsonNode* litaC_node) {
    return litaC_node->value.doubleValue;
    
    
}

LITAC_INLINE 
litaC_f64 litaC_std__json__JsonNode_asFloat(litaC_std__json__JsonNode* litaC_node) {
    return litaC_node->value.doubleValue;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__json__JsonNode_asInt(litaC_std__json__JsonNode* litaC_node) {
    return (litaC_i32)litaC_node->value.intValue;
    
    
}

LITAC_INLINE 
litaC_i64 litaC_std__json__JsonNode_asLong(litaC_std__json__JsonNode* litaC_node) {
    return (litaC_i64)litaC_node->value.intValue;
    
    
}

LITAC_INLINE 
litaC_std__array__Array_cb__ptr_JsonNode_ce_* litaC_std__json__JsonNode_asArray(litaC_std__json__JsonNode* litaC_node) {
    return litaC_node->value.arrayValue;
    
    
}

LITAC_INLINE 
litaC_std__json__JsonObject* litaC_std__json__JsonNode_asObject(litaC_std__json__JsonNode* litaC_node) {
    return litaC_node->value.objValue;
    
    
}

litaC_std__json__JsonNode* litaC_std__json__CreateJsonNumber(litaC_f64 litaC_value,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__json__JsonNode* litaC_node = litaC_std__mem__new_cb_JsonNode_ce_(litaC_alloc);
    litaC_node->alloc = litaC_alloc;
    litaC_node->type = litaC_std__json__JsonType_FLOAT_NUMBER;
    litaC_node->value = (litaC_std__json__JsonValue) {
        .doubleValue = litaC_value
    };
    return litaC_node;
    
    
}

litaC_std__json__JsonNode* litaC_std__json__CreateJsonIntNumber(litaC_i64 litaC_value,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__json__JsonNode* litaC_node = litaC_std__mem__new_cb_JsonNode_ce_(litaC_alloc);
    litaC_node->alloc = litaC_alloc;
    litaC_node->type = litaC_std__json__JsonType_INT_NUMBER;
    litaC_node->value = (litaC_std__json__JsonValue) {
        .intValue = litaC_value
    };
    return litaC_node;
    
    
}

litaC_std__json__JsonNode* litaC_std__json__CreateJsonFloatNumber(litaC_f64 litaC_value,const litaC_std__mem__Allocator* litaC_alloc) {
    return litaC_std__json__CreateJsonNumber(litaC_value, litaC_alloc);
    
    
}

litaC_std__json__JsonNode* litaC_std__json__CreateJsonString(const litaC_char* litaC_str,litaC_i32 litaC_len,const litaC_std__mem__Allocator* litaC_alloc) {
    if(litaC_str == NULL) {
        {
            return litaC_std__json__JSON_NULL;
            
            
            
        }
        
    } 
    
    if(litaC_len < 0) {
        {
            litaC_len = strlen(litaC_str);
            
            
        }
        
    } 
    
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(litaC_len + 1, litaC_alloc);
    litaC_std__json__EscapeString(&((litaC_sb)), litaC_str, litaC_len);
    return litaC_std__json__CreateJsonStringNoDup(litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_alloc);
    
    
}

litaC_void litaC_std__json__EscapeString(litaC_std__string_buffer__StringBuffer* litaC_buf,const litaC_char* litaC_string,litaC_i32 litaC_length) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_length;litaC_i += 1) {
        {
            litaC_char litaC_c = litaC_string[litaC_i];
            const litaC_char* litaC_escaped = litaC_std__json__escapeStrings[(litaC_u32)litaC_c];
            if(litaC_escaped) {
                {
                    litaC_std__string_buffer__StringBuffer_appendStr(litaC_buf, litaC_escaped);
                    continue;
                    
                    
                }
                
            } else {
                {
                    litaC_std__string_buffer__StringBuffer_appendChar(litaC_buf, litaC_c);
                    
                    
                }
            } 
            
            
            
        }
    }
    
}

litaC_std__json__JsonNode* litaC_std__json__CreateJsonStringNoDup(const litaC_char* litaC_str,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__json__JsonNode* litaC_node = litaC_std__mem__new_cb_JsonNode_ce_(litaC_alloc);
    litaC_node->alloc = litaC_alloc;
    litaC_node->type = litaC_std__json__JsonType_STRING;
    litaC_node->value = (litaC_std__json__JsonValue) {
        .strValue = litaC_str
    };
    return litaC_node;
    
    
}

litaC_std__json__JsonNode* litaC_std__json__CreateJsonArray(const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__json__JsonNode* litaC_node = litaC_std__mem__new_cb_JsonNode_ce_(litaC_alloc);
    litaC_node->alloc = litaC_alloc;
    litaC_node->type = litaC_std__json__JsonType_ARRAY;
    litaC_node->value = (litaC_std__json__JsonValue) {
        .arrayValue = litaC_std__mem__new_cb_Array_cb__ptr_JsonNode_ce__ce_(litaC_alloc)
    };
    litaC_std__array__Array_init_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue, 16, litaC_alloc);
    return litaC_node;
    
    
}

litaC_std__json__JsonNode* litaC_std__json__CreateJsonObject(const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__json__JsonNode* litaC_node = litaC_std__mem__new_cb_JsonNode_ce_(litaC_alloc);
    litaC_node->alloc = litaC_alloc;
    litaC_node->type = litaC_std__json__JsonType_OBJECT;
    litaC_node->value = (litaC_std__json__JsonValue) {
        .objValue = litaC_std__mem__new_cb_JsonObject_ce_(litaC_alloc)
    };
    litaC_std__map__Map_init_cb__ptr_const_char_c_i32_ce_(&((litaC_node->value.objValue->indexes)), -(1), 16, &(litaC_std__map__StrHashFn), &(litaC_std__map__StrEqualFn), litaC_alloc, 0);
    litaC_std__array__Array_init_cb_JsonEntry_ce_(&((litaC_node->value.objValue->values)), 16, litaC_alloc);
    return litaC_node;
    
    
}

litaC_void litaC_std__json__JsonNode_put(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_std__json__JsonNode* litaC_n) {
    if(litaC_node->type != litaC_std__json__JsonType_OBJECT) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_n == NULL) {
        {
            litaC_n = litaC_std__json__JSON_NULL;
            
            
        }
        
    } 
    
    litaC_char* litaC_copy = litaC_std__string__StringClone(litaC_key, strlen(litaC_key), litaC_node->alloc);
    litaC_std__json__JsonEntry litaC_entry =  {
        .key = litaC_copy,
        .value = litaC_n
    };
    litaC_std__array__Array_add_cb_JsonEntry_ce_(&((litaC_node->value.objValue->values)), litaC_entry);
    litaC_std__map__Map_put_cb__ptr_const_char_c_i32_ce_(&((litaC_node->value.objValue->indexes)), litaC_copy, litaC_std__array__Array_size_cb_JsonEntry_ce_(&((litaC_node->value.objValue->values))) - 1);
    
}

litaC_void litaC_std__json__JsonNode_putNoDup(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_std__json__JsonNode* litaC_n) {
    if(litaC_node->type != litaC_std__json__JsonType_OBJECT) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_n == NULL) {
        {
            litaC_n = litaC_std__json__JSON_NULL;
            
            
        }
        
    } 
    
    litaC_std__json__JsonEntry litaC_entry =  {
        .key = litaC_key,
        .value = litaC_n
    };
    litaC_std__array__Array_add_cb_JsonEntry_ce_(&((litaC_node->value.objValue->values)), litaC_entry);
    litaC_std__map__Map_put_cb__ptr_const_char_c_i32_ce_(&((litaC_node->value.objValue->indexes)), litaC_key, litaC_std__array__Array_size_cb_JsonEntry_ce_(&((litaC_node->value.objValue->values))) - 1);
    
}

litaC_void litaC_std__json__JsonNode_putStr(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,const litaC_char* litaC_str,litaC_i32 litaC_len) {
    if(litaC_node->type != litaC_std__json__JsonType_OBJECT) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_str == NULL) {
        {
            litaC_std__json__JsonNode_put(litaC_node, litaC_key, litaC_std__json__JSON_NULL);
            return;
            
            
            
        }
        
    } 
    
    litaC_std__json__JsonNode* litaC_value = litaC_std__json__CreateJsonString(litaC_str, litaC_len, litaC_node->alloc);
    litaC_std__json__JsonNode_put(litaC_node, litaC_key, litaC_value);
    
}

litaC_void litaC_std__json__JsonNode_putNumber(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_f64 litaC_number) {
    if(litaC_node->type != litaC_std__json__JsonType_OBJECT) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_std__json__JsonNode* litaC_value = litaC_std__json__CreateJsonFloatNumber(litaC_number, litaC_node->alloc);
    litaC_std__json__JsonNode_put(litaC_node, litaC_key, litaC_value);
    
}

litaC_void litaC_std__json__JsonNode_putIntNumber(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_i64 litaC_number) {
    if(litaC_node->type != litaC_std__json__JsonType_OBJECT) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_std__json__JsonNode* litaC_value = litaC_std__json__CreateJsonIntNumber(litaC_number, litaC_node->alloc);
    litaC_std__json__JsonNode_put(litaC_node, litaC_key, litaC_value);
    
}

litaC_void litaC_std__json__JsonNode_putFloatNumber(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_f64 litaC_number) {
    if(litaC_node->type != litaC_std__json__JsonType_OBJECT) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_std__json__JsonNode* litaC_value = litaC_std__json__CreateJsonFloatNumber(litaC_number, litaC_node->alloc);
    litaC_std__json__JsonNode_put(litaC_node, litaC_key, litaC_value);
    
}

litaC_void litaC_std__json__JsonNode_putBool(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_bool litaC_b) {
    if(litaC_node->type != litaC_std__json__JsonType_OBJECT) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_std__json__JsonNode_put(litaC_node, litaC_key, (litaC_b) ? litaC_std__json__JSON_TRUE : litaC_std__json__JSON_FALSE);
    
}

litaC_bool litaC_std__json__JsonNode_contains(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key) {
    if(litaC_node->type != litaC_std__json__JsonType_OBJECT) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_std__map__Map_contains_cb__ptr_const_char_c_i32_ce_(&((litaC_node->value.objValue->indexes)), litaC_key);
    
    
}

litaC_std__json__JsonNode* litaC_std__json__JsonNode_get(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key) {
    if(litaC_node->type != litaC_std__json__JsonType_OBJECT) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_index = litaC_std__map__Map_get_cb__ptr_const_char_c_i32_ce_(&((litaC_node->value.objValue->indexes)), litaC_key);
    if(litaC_index < 0) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    return litaC_std__array__Array_get_cb_JsonEntry_ce_(&((litaC_node->value.objValue->values)), litaC_index).value;
    
    
}

litaC_bool litaC_std__json__JsonNode_getBool(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_bool litaC_defaultValue) {
    litaC_std__json__JsonNode* litaC_n = litaC_std__json__JsonNode_get(litaC_node, litaC_key);
    if(!(litaC_n) || !(litaC_std__json__JsonNode_isBool(litaC_n))) {
        {
            return litaC_defaultValue;
            
            
            
        }
        
    } 
    
    return litaC_n->value.boolValue;
    
    
}

litaC_i32 litaC_std__json__JsonNode_getInt(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_i32 litaC_defaultValue) {
    litaC_std__json__JsonNode* litaC_n = litaC_std__json__JsonNode_get(litaC_node, litaC_key);
    if(!(litaC_n)) {
        {
            return litaC_defaultValue;
            
            
            
        }
        
    } 
    
    if(litaC_n->type == litaC_std__json__JsonType_FLOAT_NUMBER) {
        {
            return (litaC_i32)litaC_n->value.doubleValue;
            
            
            
        }
        
    } else {
        if(litaC_n->type == litaC_std__json__JsonType_INT_NUMBER) {
            {
                return (litaC_i32)litaC_n->value.intValue;
                
                
                
            }
            
        } 
        
    } 
    
    return litaC_defaultValue;
    
    
}

litaC_i64 litaC_std__json__JsonNode_getLong(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_i64 litaC_defaultValue) {
    litaC_std__json__JsonNode* litaC_n = litaC_std__json__JsonNode_get(litaC_node, litaC_key);
    if(!(litaC_n) || !(litaC_std__json__JsonNode_isNumber(litaC_n))) {
        {
            return litaC_defaultValue;
            
            
            
        }
        
    } 
    
    if(litaC_n->type == litaC_std__json__JsonType_FLOAT_NUMBER) {
        {
            return (litaC_i64)litaC_n->value.doubleValue;
            
            
            
        }
        
    } else {
        if(litaC_n->type == litaC_std__json__JsonType_INT_NUMBER) {
            {
                return litaC_n->value.intValue;
                
                
                
            }
            
        } 
        
    } 
    
    return litaC_defaultValue;
    
    
}

litaC_f64 litaC_std__json__JsonNode_getFloat(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_f64 litaC_defaultValue) {
    litaC_std__json__JsonNode* litaC_n = litaC_std__json__JsonNode_get(litaC_node, litaC_key);
    if(!(litaC_n)) {
        {
            return litaC_defaultValue;
            
            
            
        }
        
    } 
    
    if(litaC_n->type == litaC_std__json__JsonType_FLOAT_NUMBER) {
        {
            return litaC_n->value.doubleValue;
            
            
            
        }
        
    } else {
        if(litaC_n->type == litaC_std__json__JsonType_INT_NUMBER) {
            {
                return (litaC_f64)litaC_n->value.intValue;
                
                
                
            }
            
        } 
        
    } 
    
    return litaC_defaultValue;
    
    
}

const litaC_char* litaC_std__json__JsonNode_getStr(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,const litaC_char* litaC_defaultValue) {
    litaC_std__json__JsonNode* litaC_n = litaC_std__json__JsonNode_get(litaC_node, litaC_key);
    if(!(litaC_n) || !(litaC_std__json__JsonNode_isString(litaC_n))) {
        {
            return litaC_defaultValue;
            
            
            
        }
        
    } 
    
    return litaC_n->value.strValue;
    
    
}

litaC_char* litaC_std__json__JsonNode_getStrCopy(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key,litaC_char* litaC_str,litaC_i32 litaC_len) {
    litaC_std__json__JsonNode* litaC_n = litaC_std__json__JsonNode_get(litaC_node, litaC_key);
    if(!(litaC_n) || !(litaC_std__json__JsonNode_isString(litaC_n))) {
        {
            return litaC_str;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_srcLen = strlen(litaC_n->value.strValue);
    strncpy(litaC_str, litaC_n->value.strValue, MIN(litaC_srcLen, litaC_len));
    return litaC_str;
    
    
}

litaC_std__json__JsonNode* litaC_std__json__JsonNode_getArray(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key) {
    litaC_std__json__JsonNode* litaC_n = litaC_std__json__JsonNode_get(litaC_node, litaC_key);
    if(!(litaC_n) || !(litaC_std__json__JsonNode_isArray(litaC_n))) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    return litaC_n;
    
    
}

litaC_std__json__JsonNode* litaC_std__json__JsonNode_getObject(litaC_std__json__JsonNode* litaC_node,const litaC_char* litaC_key) {
    litaC_std__json__JsonNode* litaC_n = litaC_std__json__JsonNode_get(litaC_node, litaC_key);
    if(!(litaC_n) || !(litaC_std__json__JsonNode_isObject(litaC_n))) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    return litaC_n;
    
    
}

litaC_void litaC_std__json__JsonNode_add(litaC_std__json__JsonNode* litaC_node,litaC_std__json__JsonNode* litaC_n) {
    if(litaC_node->type == litaC_std__json__JsonType_ARRAY) {
        {
            litaC_std__array__Array_add_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue, litaC_n);
            
            
        }
        
    } 
    
    
}

litaC_std__json__JsonNode* litaC_std__json__JsonNode_at(litaC_std__json__JsonNode* litaC_node,litaC_i32 litaC_index) {
    if(litaC_node->type != litaC_std__json__JsonType_ARRAY) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    return litaC_std__array__Array_get_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue, litaC_index);
    
    
}

litaC_i32 litaC_std__json__JsonNode_size(litaC_std__json__JsonNode* litaC_node) {
    if(litaC_node->type == litaC_std__json__JsonType_ARRAY) {
        {
            return litaC_std__array__Array_size_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue);
            
            
            
        }
        
    } else {
        if(litaC_node->type == litaC_std__json__JsonType_OBJECT) {
            {
                return litaC_std__map__Map_size_cb__ptr_const_char_c_i32_ce_(&((litaC_node->value.objValue->indexes)));
                
                
                
            }
            
        } 
        
    } 
    
    return 0;
    
    
}

litaC_bool litaC_std__json__JsonNode_empty(litaC_std__json__JsonNode* litaC_node) {
    return litaC_std__json__JsonNode_size(litaC_node) == 0;
    
    
}

litaC_std__json__JsonIterator litaC_std__json__JsonNode_iter(litaC_std__json__JsonNode* litaC_node) {
    return (litaC_std__json__JsonIterator) {
        .index = 0,
        .json = litaC_node
    };
    
    
}

litaC_bool litaC_std__json__JsonIterator_hasNext(litaC_std__json__JsonIterator* litaC_this) {
    return litaC_this->index < litaC_std__json__JsonNode_size(litaC_this->json);
    
    
}

litaC_std__json__JsonEntry litaC_std__json__JsonIterator_next(litaC_std__json__JsonIterator* litaC_this) {
    if(litaC_this->index >= litaC_std__json__JsonNode_size(litaC_this->json)) {
        {
            return (litaC_std__json__JsonEntry) {
                .key = NULL,
                .value = NULL
            };
            
            
            
        }
        
    } 
    
    litaC_this->index += 1;
    if(litaC_std__json__JsonNode_isArray(litaC_this->json)) {
        {
            litaC_std__json__JsonNode* litaC_value = litaC_std__json__JsonNode_at(litaC_this->json, litaC_this->index - 1);
            return (litaC_std__json__JsonEntry) {
                .key = NULL,
                .value = litaC_value
            };
            
            
            
        }
        
    } 
    
    if(litaC_std__json__JsonNode_isObject(litaC_this->json)) {
        {
            return litaC_std__array__Array_get_cb_JsonEntry_ce_(&((litaC_this->json->value.objValue->values)), litaC_this->index - 1);
            
            
            
        }
        
    } 
    
    return (litaC_std__json__JsonEntry) {
        .key = NULL,
        .value = litaC_this->json
    };
    
    
}

litaC_bool litaC_std__json__JsonNode_equals(litaC_std__json__JsonNode* litaC_node,litaC_std__json__JsonNode* litaC_other) {
    if(litaC_node == litaC_other) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    if(!(litaC_node) && litaC_other) {
        return litaC_false;
        
        
    } 
    
    if(litaC_node && !(litaC_other)) {
        return litaC_false;
        
        
    } 
    
    if(litaC_node->type != litaC_other->type) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_node->type) {
        case litaC_std__json__JsonType_ARRAY: {
            {
                if(litaC_std__array__Array_size_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue) != litaC_std__array__Array_size_cb__ptr_JsonNode_ce_(litaC_other->value.arrayValue)) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue);litaC_i += 1) {
                    {
                        litaC_std__json__JsonNode* litaC_thisElement = litaC_std__array__Array_get_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue, litaC_i);
                        litaC_std__json__JsonNode* litaC_otherElement = litaC_std__array__Array_get_cb__ptr_JsonNode_ce_(litaC_other->value.arrayValue, litaC_i);
                        if(!(litaC_std__json__JsonNode_equals(litaC_thisElement, litaC_otherElement))) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_std__json__JsonType_OBJECT: {
            {
                litaC_i32 litaC_thisCount = 0;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_JsonEntry_ce_(&((litaC_node->value.objValue->values)));litaC_i += 1) {
                    {
                        litaC_std__json__JsonEntry litaC_entry = litaC_std__array__Array_get_cb_JsonEntry_ce_(&((litaC_node->value.objValue->values)), litaC_i);
                        const litaC_char* litaC_key = litaC_entry.key;
                        litaC_std__json__JsonNode* litaC_thisValue = litaC_entry.value;
                        if(litaC_thisValue != NULL && litaC_thisValue->type != litaC_std__json__JsonType_NULL) {
                            {
                                litaC_thisCount += 1;
                                
                                
                            }
                            
                        } 
                        
                        litaC_std__json__JsonNode* litaC_otherValue = litaC_std__json__JsonNode_get(litaC_other, litaC_key);
                        if(!(litaC_std__json__JsonNode_equals(litaC_thisValue, litaC_otherValue))) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                litaC_i32 litaC_otherCount = 0;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_JsonEntry_ce_(&((litaC_other->value.objValue->values)));litaC_i += 1) {
                    {
                        litaC_std__json__JsonEntry litaC_entry = litaC_std__array__Array_get_cb_JsonEntry_ce_(&((litaC_other->value.objValue->values)), litaC_i);
                        litaC_std__json__JsonNode* litaC_otherValue = litaC_entry.value;
                        if(litaC_otherValue != NULL && litaC_otherValue->type != litaC_std__json__JsonType_NULL) {
                            {
                                litaC_otherCount += 1;
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                return litaC_otherCount == litaC_thisCount;
                
                
                
            }
            
            
        }
        case litaC_std__json__JsonType_STRING: {
            {
                return strcmp(litaC_node->value.strValue, litaC_other->value.strValue) == 0;
                
                
                
            }
            
            
        }
        case litaC_std__json__JsonType_NULL: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_std__json__JsonType_BOOLEAN: {
            {
                return litaC_node->value.boolValue == litaC_other->value.boolValue;
                
                
                
            }
            
            
        }
        case litaC_std__json__JsonType_INT_NUMBER: {
            {
                return litaC_node->value.intValue == litaC_other->value.intValue;
                
                
                
            }
            
            
        }
        case litaC_std__json__JsonType_FLOAT_NUMBER: {
            {
                return litaC_node->value.doubleValue == litaC_other->value.doubleValue;
                
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    
}

const litaC_char* litaC_std__json__JsonNode_print(litaC_std__json__JsonNode* litaC_node,litaC_std__string_buffer__StringBuffer* litaC_buf) {
    litaC_std__json__PrintJson(litaC_node, litaC_buf);
    return litaC_std__string_buffer__StringBuffer_cStr(litaC_buf);
    
    
}

litaC_void litaC_std__json__JsonNode_free(litaC_std__json__JsonNode* litaC_node) {
    if(!(litaC_node)) {
        {
            return;
            
            
            
        }
        
    } 
    
    const litaC_std__mem__Allocator* litaC_alloc = litaC_node->alloc;
    if(!(litaC_alloc)) {
        {
            return;
            
            
            
        }
        
    } 
    
    switch(litaC_node->type) {
        case litaC_std__json__JsonType_ARRAY: {
            {
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue);litaC_i += 1) {
                    {
                        litaC_std__json__JsonNode* litaC_n = litaC_std__array__Array_get_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue, litaC_i);
                        if(litaC_n) {
                            {
                                litaC_std__json__JsonNode_free(litaC_n);
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                litaC_std__array__Array_free_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue);
                litaC_std__mem__Allocator_free(litaC_alloc, (litaC_void*)litaC_node->value.arrayValue);
                break;
                
                
            }
            
            
        }
        case litaC_std__json__JsonType_OBJECT: {
            {
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_JsonEntry_ce_(&((litaC_node->value.objValue->values)));litaC_i += 1) {
                    {
                        litaC_std__json__JsonEntry litaC_entry = litaC_std__array__Array_get_cb_JsonEntry_ce_(&((litaC_node->value.objValue->values)), litaC_i);
                        const litaC_char* litaC_key = litaC_entry.key;
                        litaC_std__json__JsonNode* litaC_node = litaC_entry.value;
                        litaC_std__mem__Allocator_free(litaC_alloc, (litaC_void*)litaC_key);
                        if(litaC_node) {
                            {
                                litaC_std__json__JsonNode_free(litaC_node);
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                litaC_std__map__Map_free_cb__ptr_const_char_c_i32_ce_(&((litaC_node->value.objValue->indexes)));
                litaC_std__array__Array_free_cb_JsonEntry_ce_(&((litaC_node->value.objValue->values)));
                litaC_std__mem__Allocator_free(litaC_alloc, (litaC_void*)litaC_node->value.objValue);
                break;
                
                
            }
            
            
        }
        case litaC_std__json__JsonType_STRING: {
            {
                litaC_std__mem__Allocator_free(litaC_alloc, (litaC_void*)litaC_node->value.strValue);
                break;
                
                
            }
            
            
        }
        default: {
            
            
        }
    }
    litaC_std__mem__Allocator_free(litaC_alloc, (litaC_void*)litaC_node);
    
}

litaC_std__json__JsonParser litaC_std__json__JsonParserInit(const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__json__JsonParser litaC_parser =  {
        
    };
    litaC_std__json__JsonParser_init(&((litaC_parser)), litaC_alloc);
    return litaC_parser;
    
    
}

litaC_void litaC_std__json__JsonParser_init(litaC_std__json__JsonParser* litaC_p,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_p->alloc = litaC_alloc;
    litaC_p->status = litaC_std__json__JsonParserStatus_OK;
    memset(litaC_p->errorMsg, 0, litaC_std__json__MAX_MESSAGE_SIZE);
    litaC_p->stream = NULL;
    litaC_p->lineStart = NULL;
    litaC_p->token.pos.name = "<string>";
    litaC_p->token.pos.line = 1;
    litaC_std__string_buffer__StringBuffer_init(&((litaC_p->buffer)), 16, litaC_alloc);
    
}

litaC_void litaC_std__json__JsonParser_free(litaC_std__json__JsonParser* litaC_p) {
    litaC_std__string_buffer__StringBuffer_free(&((litaC_p->buffer)));
    litaC_p->stream = NULL;
    litaC_p->lineStart = NULL;
    
}

litaC_std__json__JsonNode* litaC_std__json__JsonParser_parseJson(litaC_std__json__JsonParser* litaC_p,const litaC_char* litaC_buffer) {
    litaC_p->stream = litaC_buffer;
    litaC_p->lineStart = litaC_p->stream;
    litaC_std__string_buffer__StringBuffer_clear(&((litaC_p->buffer)));
    litaC_std__json__JsonParser_nextToken(litaC_p);
    litaC_std__json__JsonNode* litaC_node = litaC_std__json__JsonParser_parseJsonNode(litaC_p);
    if(litaC_std__json__JsonParser_hasError(litaC_p)) {
        {
            if(litaC_node) {
                {
                    litaC_std__json__JsonNode_free(litaC_node);
                    
                    
                }
                
            } 
            
            return NULL;
            
            
            
        }
        
    } 
    
    return litaC_node;
    
    
}

litaC_bool litaC_std__json__JsonParser_hasError(litaC_std__json__JsonParser* litaC_p) {
    return litaC_p->status == litaC_std__json__JsonParserStatus_ERROR;
    
    
}

litaC_void litaC_std__json__PrintJson(litaC_std__json__JsonNode* litaC_node,litaC_std__string_buffer__StringBuffer* litaC_buf) {
    if(!(litaC_node)) {
        {
            return;
            
            
            
        }
        
    } 
    
    switch(litaC_node->type) {
        case litaC_std__json__JsonType_NULL: {
            {
                litaC_std__string_buffer__StringBuffer_appendStrn(litaC_buf, "null", 4);
                break;
                
                
            }
            
            
        }
        case litaC_std__json__JsonType_BOOLEAN: {
            {
                ((litaC_node->value.boolValue)) ? litaC_std__string_buffer__StringBuffer_appendStrn(litaC_buf, "true", 4) : litaC_std__string_buffer__StringBuffer_appendStrn(litaC_buf, "false", 5);
                break;
                
                
            }
            
            
        }
        case litaC_std__json__JsonType_INT_NUMBER: {
            {
                litaC_std__string_buffer__StringBuffer_append(litaC_buf, "%lld", litaC_node->value.intValue);
                break;
                
                
            }
            
            
        }
        case litaC_std__json__JsonType_FLOAT_NUMBER: {
            {
                litaC_std__string_buffer__StringBuffer_append(litaC_buf, "%f", litaC_node->value.doubleValue);
                break;
                
                
            }
            
            
        }
        case litaC_std__json__JsonType_STRING: {
            {
                litaC_std__string_buffer__StringBuffer_append(litaC_buf, "\"%s\"", litaC_node->value.strValue);
                break;
                
                
            }
            
            
        }
        case litaC_std__json__JsonType_OBJECT: {
            {
                litaC_std__string_buffer__StringBuffer_appendStrn(litaC_buf, "{", 1);
                litaC_std__json__JsonObject* litaC_obj = litaC_node->value.objValue;
                litaC_bool litaC_isFirst = litaC_true;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_JsonEntry_ce_(&((litaC_obj->values)));litaC_i += 1) {
                    {
                        litaC_std__json__JsonEntry litaC_entry = litaC_std__array__Array_get_cb_JsonEntry_ce_(&((litaC_obj->values)), litaC_i);
                        if(!(litaC_isFirst)) {
                            litaC_std__string_buffer__StringBuffer_appendStrn(litaC_buf, ",", 1);
                            
                        } 
                        
                        litaC_std__string_buffer__StringBuffer_append(litaC_buf, "\"%s\":", litaC_entry.key);
                        litaC_std__json__PrintJson(litaC_entry.value, litaC_buf);
                        litaC_isFirst = litaC_false;
                        
                        
                    }
                }
                litaC_std__string_buffer__StringBuffer_appendStrn(litaC_buf, "}", 1);
                break;
                
                
            }
            
            
        }
        case litaC_std__json__JsonType_ARRAY: {
            {
                litaC_std__string_buffer__StringBuffer_appendStrn(litaC_buf, "[", 1);
                litaC_std__array__Array_cb__ptr_JsonNode_ce_* litaC_array = litaC_node->value.arrayValue;
                litaC_bool litaC_isFirst = litaC_true;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_JsonNode_ce_(litaC_array);litaC_i += 1) {
                    {
                        if(!(litaC_isFirst)) {
                            litaC_std__string_buffer__StringBuffer_appendStrn(litaC_buf, ",", 1);
                            
                        } 
                        
                        litaC_std__json__PrintJson(litaC_std__array__Array_get_cb__ptr_JsonNode_ce_(litaC_array, litaC_i), litaC_buf);
                        litaC_isFirst = litaC_false;
                        
                        
                    }
                }
                litaC_std__string_buffer__StringBuffer_appendStrn(litaC_buf, "]", 1);
                break;
                
                
            }
            
            
        }
    }
    
}

litaC_std__json__JsonNode* litaC_std__json__JsonParser_parseJsonNode(litaC_std__json__JsonParser* litaC_p) {
    if(litaC_std__json__JsonParser_hasError(litaC_p)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    switch(litaC_p->token.kind) {
        case litaC_std__json__TokenKind_EOF: 
        case litaC_std__json__TokenKind_ERROR: {
            return NULL;
            
            
            
        }
        case litaC_std__json__TokenKind_TRUE: {
            litaC_std__json__JsonParser_nextToken(litaC_p);
            return litaC_std__json__JSON_TRUE;
            
            
            
        }
        case litaC_std__json__TokenKind_FALSE: {
            litaC_std__json__JsonParser_nextToken(litaC_p);
            return litaC_std__json__JSON_FALSE;
            
            
            
        }
        case litaC_std__json__TokenKind_NULL: {
            litaC_std__json__JsonParser_nextToken(litaC_p);
            return litaC_std__json__JSON_NULL;
            
            
            
        }
        case litaC_std__json__TokenKind_INT_NUMBER: {
            litaC_std__json__JsonParser_nextToken(litaC_p);
            return litaC_std__json__JsonParser_parseJsonIntNumber(litaC_p);
            
            
            
        }
        case litaC_std__json__TokenKind_REAL_NUMBER: {
            litaC_std__json__JsonParser_nextToken(litaC_p);
            return litaC_std__json__JsonParser_parseJsonRealNumber(litaC_p);
            
            
            
        }
        case litaC_std__json__TokenKind_STRING: {
            litaC_std__json__JsonParser_nextToken(litaC_p);
            return litaC_std__json__JsonParser_parseJsonStr(litaC_p);
            
            
            
        }
        case litaC_std__json__TokenKind_LEFT_BRACE: {
            litaC_std__json__JsonParser_nextToken(litaC_p);
            return litaC_std__json__JsonParser_parseJsonObject(litaC_p);
            
            
            
        }
        case litaC_std__json__TokenKind_LEFT_BRACKET: {
            litaC_std__json__JsonParser_nextToken(litaC_p);
            return litaC_std__json__JsonParser_parseJsonArray(litaC_p);
            
            
            
        }
        default: {
            
            
        }
    }
    return NULL;
    
    
}

litaC_std__json__JsonNode* litaC_std__json__JsonParser_parseJsonIntNumber(litaC_std__json__JsonParser* litaC_p) {
    return litaC_std__json__CreateJsonIntNumber(litaC_p->token.intNumValue, litaC_p->alloc);
    
    
}

litaC_std__json__JsonNode* litaC_std__json__JsonParser_parseJsonRealNumber(litaC_std__json__JsonParser* litaC_p) {
    return litaC_std__json__CreateJsonFloatNumber(litaC_p->token.realNumValue, litaC_p->alloc);
    
    
}

litaC_std__json__JsonNode* litaC_std__json__JsonParser_parseJsonStr(litaC_std__json__JsonParser* litaC_p) {
    return litaC_std__json__CreateJsonStringNoDup(litaC_p->token.strValue, litaC_p->alloc);
    
    
}

litaC_std__json__JsonNode* litaC_std__json__JsonParser_parseJsonArray(litaC_std__json__JsonParser* litaC_p) {
    litaC_std__json__JsonNode* litaC_node = litaC_std__json__CreateJsonArray(litaC_p->alloc);
    do {
        {
            if(litaC_std__json__JsonParser_check(litaC_p, litaC_std__json__TokenKind_RIGHT_BRACKET)) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_std__json__JsonNode* litaC_element = litaC_std__json__JsonParser_parseJsonNode(litaC_p);
            litaC_std__array__Array_add_cb__ptr_JsonNode_ce_(litaC_node->value.arrayValue, litaC_element);
            
            
        }
    }
    while(litaC_std__json__JsonParser_match(litaC_p, litaC_std__json__TokenKind_COMMA));
    litaC_std__json__JsonParser_expect(litaC_p, litaC_std__json__TokenKind_RIGHT_BRACKET);
    return litaC_node;
    
    
}

litaC_std__json__JsonNode* litaC_std__json__JsonParser_parseJsonObject(litaC_std__json__JsonParser* litaC_p) {
    litaC_std__json__JsonNode* litaC_node = litaC_std__json__CreateJsonObject(litaC_p->alloc);
    do {
        {
            if(litaC_std__json__JsonParser_check(litaC_p, litaC_std__json__TokenKind_RIGHT_BRACE)) {
                {
                    break;
                    
                    
                }
                
            } 
            
            const litaC_char* litaC_key = litaC_p->token.strValue;
            if(!(litaC_std__json__JsonParser_expect(litaC_p, litaC_std__json__TokenKind_STRING))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            if(!(litaC_std__json__JsonParser_expect(litaC_p, litaC_std__json__TokenKind_COLON))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_std__json__JsonNode* litaC_value = litaC_std__json__JsonParser_parseJsonNode(litaC_p);
            litaC_std__json__JsonNode_putNoDup(litaC_node, litaC_key, litaC_value);
            
            
        }
    }
    while(litaC_std__json__JsonParser_match(litaC_p, litaC_std__json__TokenKind_COMMA));
    litaC_std__json__JsonParser_expect(litaC_p, litaC_std__json__TokenKind_RIGHT_BRACE);
    err:;
    
    return litaC_node;
    
    
}

const litaC_char* litaC_std__json__TokenName(litaC_std__json__TokenKind litaC_t) {
    return litaC_std__json__tokenKindNames[litaC_t];
    
    
}

litaC_void litaC_std__json__JsonParser_error(litaC_std__json__JsonParser* litaC_p,const litaC_char* litaC_format,...) {
    va_list litaC_args = {0};
    va_start(litaC_args, litaC_format);
    vsnprintf(litaC_p->errorMsg, litaC_std__json__MAX_MESSAGE_SIZE, litaC_format, litaC_args);
    va_end(litaC_args);
    litaC_p->status = litaC_std__json__JsonParserStatus_ERROR;
    litaC_p->token.kind = litaC_std__json__TokenKind_ERROR;
    
}

litaC_void litaC_std__json__JsonParser_scanInt(litaC_std__json__JsonParser* litaC_p) {
    litaC_i32 litaC_base = 10;
    const litaC_char* litaC_start_digits = litaC_p->stream;
    if(*(litaC_p->stream) == '0') {
        {
            litaC_p->stream += 1;
            if(tolower(*(litaC_p->stream)) == 'x') {
                {
                    litaC_p->stream += 1;
                    litaC_base = 16;
                    litaC_start_digits = litaC_p->stream;
                    
                    
                }
                
            } else {
                if(tolower(*(litaC_p->stream)) == 'b') {
                    {
                        litaC_p->stream += 1;
                        litaC_base = 2;
                        litaC_start_digits = litaC_p->stream;
                        
                        
                    }
                    
                } else {
                    if(isdigit(*(litaC_p->stream))) {
                        {
                            litaC_base = 8;
                            litaC_start_digits = litaC_p->stream;
                            
                            
                        }
                        
                    } 
                    
                } 
                
            } 
            
            
            
        }
        
    } 
    
    litaC_i64 litaC_val = 0;
    for(;;) {
        {
            if(*(litaC_p->stream) == '_') {
                {
                    litaC_p->stream += 1;
                    continue;
                    
                    
                }
                
            } 
            
            litaC_i32 litaC_digit = litaC_std__json__charToDigit[(litaC_i32)(*(litaC_p->stream))];
            if(litaC_digit == 0 && *(litaC_p->stream) != '0') {
                {
                    break;
                    
                    
                }
                
            } 
            
            if(litaC_digit >= litaC_base) {
                {
                    litaC_std__json__JsonParser_error(litaC_p, "Digit '%c' out of range for base %d", *(litaC_p->stream), litaC_base);
                    litaC_digit = 0;
                    
                    
                }
                
            } 
            
            if(litaC_val > (ULLONG_MAX - litaC_digit) / litaC_base) {
                {
                    litaC_std__json__JsonParser_error(litaC_p, "Integer literal overflow");
                    while(isdigit(*(litaC_p->stream))) {
                        {
                            litaC_p->stream += 1;
                            
                            
                        }
                    }
                    litaC_val = 0;
                    break;
                    
                    
                }
                
            } 
            
            litaC_val = litaC_val * litaC_base + litaC_digit;
            litaC_p->stream += 1;
            
            
        }
    }
    if(litaC_p->stream == litaC_start_digits) {
        {
            litaC_std__json__JsonParser_error(litaC_p, "Expected base %d digit, got '%c'", litaC_base, *(litaC_p->stream));
            
            
        }
        
    } 
    
    if(litaC_std__json__JsonParser_hasError(litaC_p)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_p->token.kind = litaC_std__json__TokenKind_INT_NUMBER;
    litaC_p->token.intNumValue = litaC_val;
    
}

litaC_void litaC_std__json__JsonParser_scanFloat(litaC_std__json__JsonParser* litaC_p) {
    const litaC_char* litaC_start = litaC_p->stream;
    while(isdigit(*(litaC_p->stream))) {
        {
            litaC_p->stream += 1;
            
            
        }
    }
    if(*(litaC_p->stream) == '.') {
        {
            litaC_p->stream += 1;
            
            
        }
        
    } 
    
    while(isdigit(*(litaC_p->stream))) {
        {
            litaC_p->stream += 1;
            
            
        }
    }
    if(tolower(*(litaC_p->stream)) == 'e') {
        {
            litaC_p->stream += 1;
            if(*(litaC_p->stream) == '+' || *(litaC_p->stream) == '-') {
                {
                    litaC_p->stream += 1;
                    
                    
                }
                
            } 
            
            if(!(isdigit(*(litaC_p->stream)))) {
                {
                    litaC_std__json__JsonParser_error(litaC_p, "Expected digit after float literal exponent, found '%c'.", *(litaC_p->stream));
                    
                    
                }
                
            } 
            
            while(isdigit(*(litaC_p->stream))) {
                {
                    litaC_p->stream += 1;
                    
                    
                }
            }
            
            
        }
        
    } 
    
    litaC_f64 litaC_val = strtod(litaC_start, NULL);
    if(litaC_val == HUGE_VAL) {
        {
            litaC_std__json__JsonParser_error(litaC_p, "Float literal overflow");
            
            
        }
        
    } 
    
    if(litaC_std__json__JsonParser_hasError(litaC_p)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_p->token.kind = litaC_std__json__TokenKind_REAL_NUMBER;
    litaC_p->token.realNumValue = litaC_val;
    
}

litaC_void litaC_std__json__JsonParser_scanStr(litaC_std__json__JsonParser* litaC_p) {
    assert(*(litaC_p->stream) == '"');
    litaC_p->stream += 1;
    litaC_std__string_buffer__StringBuffer_clear(&((litaC_p->buffer)));
    while(*(litaC_p->stream) && *(litaC_p->stream) != '"') {
        {
            litaC_u8 litaC_c = (litaC_u8)(*(litaC_p->stream));
            if(litaC_c >= 0x80) {
                {
                    litaC_i32 litaC_result = 0;
                    litaC_i32 litaC_len = litaC_std__unicode__utf8__Utf8Decode((const litaC_u8*)litaC_p->stream, -(1), &(litaC_result));
                    if(litaC_len < 0) {
                        {
                            litaC_std__json__JsonParser_error(litaC_p, "Invalid codepoint");
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_p->buffer)), litaC_p->stream, (litaC_i32)litaC_len);
                            litaC_p->stream += litaC_len;
                            
                            
                        }
                    } 
                    
                    
                    
                }
                
            } else {
                {
                    litaC_char litaC_val = *(litaC_p->stream);
                    if(litaC_val == '\n') {
                        {
                            litaC_std__json__JsonParser_error(litaC_p, "String literal cannot contain newline");
                            break;
                            
                            
                        }
                        
                    } else {
                        if(litaC_val == '\\') {
                            {
                                litaC_p->stream += 1;
                                if(*(litaC_p->stream) == 'x') {
                                    {
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        litaC_val = litaC_std__json__escapeToChar[(litaC_i32)(*(litaC_p->stream))];
                                        if(litaC_val == 0 && *(litaC_p->stream) != '0') {
                                            {
                                                litaC_std__json__JsonParser_error(litaC_p, "Invalid string literal escape '\\%c'", *(litaC_p->stream));
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        litaC_p->stream += 1;
                                        
                                        
                                    }
                                } 
                                
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_p->stream += 1;
                                
                                
                            }
                        } 
                        
                    } 
                    
                    litaC_std__string_buffer__StringBuffer_append(&((litaC_p->buffer)), "%c", litaC_val);
                    
                    
                }
            } 
            
            
            
        }
    }
    if(*(litaC_p->stream)) {
        {
            litaC_p->stream += 1;
            
            
        }
        
    } else {
        {
            litaC_std__json__JsonParser_error(litaC_p, "Unexpected end of file within string literal");
            
            
        }
    } 
    
    if(litaC_std__json__JsonParser_hasError(litaC_p)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_p->token.kind = litaC_std__json__TokenKind_STRING;
    litaC_p->token.strValue = (const litaC_char*)litaC_std__mem__memduplicate((const litaC_void*)litaC_std__string_buffer__StringBuffer_cStr(&((litaC_p->buffer))), litaC_std__string_buffer__StringBuffer_size(&((litaC_p->buffer))) + 1, litaC_p->alloc);
    
}

litaC_void litaC_std__json__JsonParser_scanMultiStr(litaC_std__json__JsonParser* litaC_p) {
    assert(*(litaC_p->stream) == '`');
    litaC_p->stream += 1;
    litaC_std__string_buffer__StringBuffer_clear(&((litaC_p->buffer)));
    while(*(litaC_p->stream) && *(litaC_p->stream) != '`') {
        {
            litaC_u8 litaC_c = (litaC_u8)(*(litaC_p->stream));
            if(litaC_c >= 0x80) {
                {
                    litaC_i32 litaC_result = 0;
                    litaC_i32 litaC_len = litaC_std__unicode__utf8__Utf8Decode((const litaC_u8*)litaC_p->stream, -(1), &(litaC_result));
                    if(litaC_len < 0) {
                        {
                            litaC_std__json__JsonParser_error(litaC_p, "Invalid codepoint");
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_p->buffer)), litaC_p->stream, (litaC_i32)litaC_len);
                            litaC_p->stream += litaC_len;
                            
                            
                        }
                    } 
                    
                    
                    
                }
                
            } else {
                {
                    litaC_char litaC_val = *(litaC_p->stream);
                    if(litaC_val == '\\') {
                        {
                            litaC_p->stream += 1;
                            if(*(litaC_p->stream) == '`') {
                                {
                                    litaC_val = '`';
                                    litaC_p->stream += 1;
                                    
                                    
                                }
                                
                            } else {
                                {
                                    litaC_std__string_buffer__StringBuffer_append(&((litaC_p->buffer)), "%c", litaC_val);
                                    litaC_val = *(litaC_p->stream);
                                    litaC_p->stream += 1;
                                    
                                    
                                }
                            } 
                            
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_p->stream += 1;
                            
                            
                        }
                    } 
                    
                    if(litaC_val == '\r') {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__string_buffer__StringBuffer_append(&((litaC_p->buffer)), "%c", litaC_val);
                    
                    
                }
            } 
            
            
            
        }
    }
    if(*(litaC_p->stream)) {
        {
            litaC_p->stream += 1;
            
            
        }
        
    } else {
        {
            litaC_std__json__JsonParser_error(litaC_p, "Unexpected end of file within string literal");
            
            
        }
    } 
    
    if(litaC_std__json__JsonParser_hasError(litaC_p)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_p->token.kind = litaC_std__json__TokenKind_STRING;
    litaC_p->token.strValue = (const litaC_char*)litaC_std__mem__memduplicate((const litaC_void*)litaC_std__string_buffer__StringBuffer_cStr(&((litaC_p->buffer))), litaC_std__string_buffer__StringBuffer_size(&((litaC_p->buffer))) + 1, litaC_p->alloc);
    
}

litaC_void litaC_std__json__JsonParser_skipComments(litaC_std__json__JsonParser* litaC_l) {
    if(*(litaC_l->stream) == '/') {
        {
            if(litaC_l->stream[1] == '/') {
                {
                    litaC_l->stream += 1;
                    do {
                        {
                            litaC_l->stream += 1;
                            if(*(litaC_l->stream) == '\n') {
                                {
                                    break;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                    }
                    while(litaC_l->stream);
                    
                    
                }
                
            } else {
                if(litaC_l->stream[1] == '*') {
                    {
                        litaC_l->stream += 1;
                        do {
                            {
                                litaC_l->stream += 1;
                                if((litaC_l->stream[0] == '*' && litaC_l->stream[1] == '/')) {
                                    {
                                        litaC_l->stream += 2;
                                        break;
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                        }
                        while(litaC_l->stream);
                        
                        
                    }
                    
                } 
                
            } 
            
            
            
        }
        
    } 
    
    
}

litaC_void litaC_std__json__JsonParser_nextToken(litaC_std__json__JsonParser* litaC_p) {
    repeat:;
    
    if(litaC_std__json__JsonParser_hasError(litaC_p)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_std__json__JsonParser_skipComments(litaC_p);
    litaC_p->token.start = litaC_p->stream;
    switch(*(litaC_p->stream)) {
        case ' ': 
        case '\n': 
        case '\r': 
        case '\t': {
            {
                while(isspace(*(litaC_p->stream))) {
                    {
                        if(*(litaC_p->stream) == '\n') {
                            {
                                litaC_p->lineStart = litaC_p->stream;
                                litaC_p->token.pos.line += 1;
                                
                                
                            }
                            
                        } 
                        
                        litaC_p->stream += 1;
                        
                        
                    }
                }
                goto repeat;
                
                
                
            }
            
            
        }
        case '"': {
            {
                litaC_std__json__JsonParser_scanStr(litaC_p);
                break;
                
                
            }
            
            
        }
        case '`': {
            {
                litaC_std__json__JsonParser_scanMultiStr(litaC_p);
                break;
                
                
            }
            
            
        }
        case '.': {
            if(isdigit(litaC_p->stream[1])) {
                {
                    litaC_std__json__JsonParser_scanFloat(litaC_p);
                    
                    
                }
                
            } 
            
            break;
            
            
        }
        case '0': 
        case '1': 
        case '2': 
        case '3': 
        case '4': 
        case '5': 
        case '6': 
        case '7': 
        case '8': 
        case '9': {
            {
                while(isdigit(*(litaC_p->stream))) {
                    {
                        litaC_p->stream += 1;
                        
                        
                    }
                }
                litaC_char litaC_c = *(litaC_p->stream);
                litaC_p->stream = litaC_p->token.start;
                if(litaC_c == '.' || tolower(litaC_c) == 'e') {
                    {
                        litaC_std__json__JsonParser_scanFloat(litaC_p);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_std__json__JsonParser_scanInt(litaC_p);
                        
                        
                    }
                } 
                
                break;
                
                
            }
            
            
        }
        case 'n': {
            {
                if(litaC_p->stream[1] == 'u' && litaC_p->stream[2] == 'l' && litaC_p->stream[3] == 'l') {
                    {
                        litaC_p->stream += 4;
                        litaC_p->token.kind = litaC_std__json__TokenKind_NULL;
                        break;
                        
                        
                    }
                    
                } 
                
                litaC_std__json__JsonParser_error(litaC_p, "invalid identifier, did you mean 'null'?");
                break;
                
                
            }
            
            
        }
        case 't': {
            {
                if(litaC_p->stream[1] == 'r' && litaC_p->stream[2] == 'u' && litaC_p->stream[3] == 'e') {
                    {
                        litaC_p->stream += 4;
                        litaC_p->token.kind = litaC_std__json__TokenKind_TRUE;
                        break;
                        
                        
                    }
                    
                } 
                
                litaC_std__json__JsonParser_error(litaC_p, "invalid identifier, did you mean 'true'?");
                break;
                
                
            }
            
            
        }
        case 'f': {
            {
                if(litaC_p->stream[1] == 'a' && litaC_p->stream[2] == 'l' && litaC_p->stream[3] == 's' && litaC_p->stream[4] == 'e') {
                    {
                        litaC_p->stream += 5;
                        litaC_p->token.kind = litaC_std__json__TokenKind_FALSE;
                        break;
                        
                        
                    }
                    
                } 
                
                litaC_std__json__JsonParser_error(litaC_p, "invalid identifier, did you mean 'false'?");
                break;
                
                
            }
            
            
        }
        case '\0': {
            litaC_p->token.kind = litaC_std__json__TokenKind_EOF;
            litaC_p->stream += 1;
            break;
            
            
        }
        case '{': {
            litaC_p->token.kind = litaC_std__json__TokenKind_LEFT_BRACE;
            litaC_p->stream += 1;
            break;
            
            
        }
        case '}': {
            litaC_p->token.kind = litaC_std__json__TokenKind_RIGHT_BRACE;
            litaC_p->stream += 1;
            break;
            
            
        }
        case '[': {
            litaC_p->token.kind = litaC_std__json__TokenKind_LEFT_BRACKET;
            litaC_p->stream += 1;
            break;
            
            
        }
        case ']': {
            litaC_p->token.kind = litaC_std__json__TokenKind_RIGHT_BRACKET;
            litaC_p->stream += 1;
            break;
            
            
        }
        case ',': {
            litaC_p->token.kind = litaC_std__json__TokenKind_COMMA;
            litaC_p->stream += 1;
            break;
            
            
        }
        case ':': {
            litaC_p->token.kind = litaC_std__json__TokenKind_COLON;
            litaC_p->stream += 1;
            break;
            
            
        }
        default: {
            {
                litaC_std__json__JsonParser_error(litaC_p, "Invalid '%c' ('%u') token", *(litaC_p->stream), *(litaC_p->stream));
                litaC_p->stream += 1;
                litaC_p->token.kind = litaC_std__json__TokenKind_ERROR;
                break;
                
                
            }
            
            
        }
    }
    litaC_p->token.end = litaC_p->stream;
    
}

litaC_bool litaC_std__json__JsonParser_check(litaC_std__json__JsonParser* litaC_p,litaC_std__json__TokenKind litaC_kind) {
    return litaC_p->token.kind == litaC_kind;
    
    
}

litaC_bool litaC_std__json__JsonParser_match(litaC_std__json__JsonParser* litaC_p,litaC_std__json__TokenKind litaC_kind) {
    if(!(litaC_std__json__JsonParser_check(litaC_p, litaC_kind))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_std__json__JsonParser_nextToken(litaC_p);
    return litaC_true;
    
    
}

litaC_bool litaC_std__json__JsonParser_expect(litaC_std__json__JsonParser* litaC_p,litaC_std__json__TokenKind litaC_kind) {
    if(!(litaC_std__json__JsonParser_check(litaC_p, litaC_kind))) {
        {
            if(litaC_std__json__JsonParser_hasError(litaC_p)) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_std__json__JsonParser_error(litaC_p, "Expected token %s, got %s", litaC_std__json__TokenName(litaC_kind), litaC_std__json__TokenName(litaC_p->token.kind));
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_std__json__JsonParser_nextToken(litaC_p);
    return litaC_true;
    
    
}

litaC_parser__Parser litaC_parser__ParserInit(const litaC_char* litaC_filename,const litaC_char* litaC_text,litaC_i64 litaC_length,litaC_module__Module* litaC_module,litaC_lita__Lita* litaC_lita) {
    litaC_parser__Parser litaC_parser =  {
        .allocator = litaC_module->allocator,
        .typeAllocator = &(litaC_module->typeSpecAllocator),
        .module = litaC_module,
        .result = &(litaC_lita->result),
        .lita = litaC_lita,
        .strings = &(litaC_lita->strings),
        .filename = litaC_filename,
        .current = 0,
        .breakLevel = 0,
        .loopLevel = 0,
        .switchLevel = 0,
        .funcLevel = 0,
        .aggregateLevel = 0,
        .tryLevel = 0,
        .tryErrorCounter = 0,
        .preprocessorLevel = 0,
        .panicMode = litaC_false
    };
    const litaC_std__mem__Allocator* litaC_allocator = litaC_module->allocator;
    litaC_lex__Lexer litaC_lex = litaC_lex__LexerInit(litaC_filename, litaC_text, litaC_length, litaC_allocator);
    litaC_std__array__Array_init_cb_Token_ce_(&((litaC_parser.tokens)), 1024, litaC_allocator);
    while(!(litaC_lex__Lexer_eof(&((litaC_lex))))) {
        {
            litaC_lex__Token litaC_token = litaC_lex__Lexer_nextToken(&((litaC_lex)));
            if(litaC_token.type == litaC_lex__TokenType_ERROR) {
                {
                    litaC_phase_result__PhaseResult_addError(litaC_parser.result, litaC_token.pos, "Error token: %s", litaC_lex.errorMsg);
                    
                    
                }
                
            } 
            
            litaC_std__array__Array_add_cb_Token_ce_(&((litaC_parser.tokens)), litaC_token);
            
            
        }
    }
    litaC_parser.totalLines = litaC_lex.lineNumber;
    if(litaC_std__array__Array_empty_cb_Token_ce_(&((litaC_parser.tokens)))) {
        {
            litaC_std__array__Array_add_cb_Token_ce_(&((litaC_parser.tokens)), (litaC_lex__Token) {
                .type = litaC_lex__TokenType_END_OF_FILE
            });
            
            
        }
        
    } 
    
    return litaC_parser;
    
    
}

litaC_ast__ModuleStmt* litaC_parser__Parser_parseModule(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_std__array__Array_cb__ptr_ImportDecl_ce_ litaC_imports =  {
        
    };
    litaC_std__array__Array_init_cb__ptr_ImportDecl_ce_(&((litaC_imports)), 16, litaC_p->allocator);
    litaC_std__array__Array_cb__ptr_NoteStmt_ce_ litaC_notes =  {
        
    };
    litaC_std__array__Array_init_cb__ptr_NoteStmt_ce_(&((litaC_notes)), 2, litaC_p->allocator);
    litaC_std__array__Array_cb__ptr_Decl_ce_ litaC_declarations =  {
        
    };
    litaC_std__array__Array_init_cb__ptr_Decl_ce_(&((litaC_declarations)), 16, litaC_p->allocator);
    litaC_ast__ModuleStmt* litaC_moduleStmt = (litaC_ast__ModuleStmt*)litaC_ast_new__NewModuleStmt(litaC_pos, litaC_pos, litaC_imports, litaC_notes, litaC_declarations, litaC_p->allocator);
    if(litaC_parser__Parser_atEnd(litaC_p)) {
        {
            return litaC_moduleStmt;
            
            
            
        }
        
    } 
    
    while(!(litaC_parser__Parser_atEnd(litaC_p))) {
        {
            litaC_i32 litaC_errorCount = litaC_parser__Parser_numOfErrors(litaC_p);
            litaC_parser__Parser_parseModuleDeclaration(litaC_p, litaC_moduleStmt);
            if(litaC_parser__Parser_numOfErrors(litaC_p) > litaC_errorCount) {
                {
                    litaC_parser__Parser_adjust(litaC_p, litaC_parser__DECL_ADJUST_TOKENS, litaC_parser__DECL_ADJUST_TOKENS_COUNT);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_moduleStmt->stmt.node.endPos = litaC_parser__Parser_prevPos(litaC_p);
    return litaC_moduleStmt;
    
    
}

litaC_void litaC_parser__Parser_parseModuleDeclaration(litaC_parser__Parser* litaC_p,litaC_ast__ModuleStmt* litaC_moduleStmt) {
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_IMPORT)) {
        {
            litaC_ast__ImportDecl* litaC_importDecl = litaC_parser__Parser_importDeclaration(litaC_p);
            if(litaC_importDecl) {
                {
                    litaC_std__array__Array_add_cb__ptr_ImportDecl_ce_(&((litaC_moduleStmt->imports)), litaC_importDecl);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } else {
        if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_HASH)) {
            {
                litaC_ast__Stmt* litaC_compStmt = litaC_parser__Parser_compStatement(litaC_p, litaC_false);
                assert(litaC_compStmt);
                if(!(litaC_compStmt) || litaC_compStmt->node.kind != litaC_ast__StmtKind_COMP_STMT) {
                    {
                        return;
                        
                        
                        
                    }
                    
                } 
                
                litaC_preprocessor__Preprocessor_evaluateForModule(&((litaC_p->lita->preprocessor)), litaC_p->module, litaC_moduleStmt, (litaC_ast__CompStmt*)litaC_compStmt);
                
                
            }
            
        } else {
            {
                litaC_std__array__Array_cb__ptr_NoteStmt_ce_ litaC_notes =  {
                    
                };
                if(!(litaC_parser__Parser_notes(litaC_p, &(litaC_notes)))) {
                    {
                        return;
                        
                        
                        
                    }
                    
                } 
                
                litaC_i32 litaC_visibility = litaC_ast__Visibility_PRIVATE;
                if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_INTERNAL)) {
                    {
                        litaC_visibility = litaC_ast__Visibility_INTERNAL;
                        
                        
                    }
                    
                } else {
                    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_PUBLIC)) {
                        {
                            litaC_visibility = litaC_ast__Visibility_PUBLIC;
                            
                            
                        }
                        
                    } 
                    
                } 
                
                if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_VAR)) {
                    {
                        litaC_ast__Decl* litaC_decl = litaC_parser__Parser_varDeclaration(litaC_p);
                        litaC_std__array__Array_add_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), litaC_decl);
                        
                        
                    }
                    
                } else {
                    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_CONST)) {
                        {
                            litaC_ast__Decl* litaC_decl = litaC_parser__Parser_constDeclaration(litaC_p);
                            litaC_std__array__Array_add_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), litaC_decl);
                            
                            
                        }
                        
                    } else {
                        if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_FUNC)) {
                            {
                                litaC_ast__Decl* litaC_decl = litaC_parser__Parser_funcDeclaration(litaC_p);
                                litaC_std__array__Array_add_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), litaC_decl);
                                
                                
                            }
                            
                        } else {
                            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_STRUCT)) {
                                {
                                    litaC_ast__Decl* litaC_decl = litaC_parser__Parser_structDeclaration(litaC_p);
                                    litaC_std__array__Array_add_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), litaC_decl);
                                    
                                    
                                }
                                
                            } else {
                                if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_UNION)) {
                                    {
                                        litaC_ast__Decl* litaC_decl = litaC_parser__Parser_unionDeclaration(litaC_p);
                                        litaC_std__array__Array_add_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), litaC_decl);
                                        
                                        
                                    }
                                    
                                } else {
                                    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_TRAIT)) {
                                        {
                                            litaC_ast__Decl* litaC_decl = litaC_parser__Parser_traitDeclaration(litaC_p);
                                            litaC_std__array__Array_add_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), litaC_decl);
                                            
                                            
                                        }
                                        
                                    } else {
                                        if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_ENUM)) {
                                            {
                                                litaC_ast__Decl* litaC_decl = litaC_parser__Parser_enumDeclaration(litaC_p);
                                                litaC_std__array__Array_add_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), litaC_decl);
                                                
                                                
                                            }
                                            
                                        } else {
                                            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_TYPEDEF)) {
                                                {
                                                    litaC_ast__Decl* litaC_decl = litaC_parser__Parser_typedefDeclaration(litaC_p);
                                                    litaC_std__array__Array_add_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), litaC_decl);
                                                    
                                                    
                                                }
                                                
                                            } else {
                                                if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_NOTE)) {
                                                    {
                                                        litaC_ast__Decl* litaC_decl = litaC_parser__Parser_noteDeclaration(litaC_p);
                                                        litaC_std__array__Array_add_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), litaC_decl);
                                                        
                                                        
                                                    }
                                                    
                                                } else {
                                                    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_SEMICOLON)) {
                                                        {
                                                            if(!(litaC_std__array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_notes))))) {
                                                                {
                                                                    litaC_std__array__Array_addAll_cb__ptr_NoteStmt_ce_(&((litaC_moduleStmt->notes)), &((litaC_notes)));
                                                                    
                                                                    
                                                                }
                                                                
                                                            } 
                                                            
                                                            return;
                                                            
                                                            
                                                            
                                                        }
                                                        
                                                    } else {
                                                        {
                                                            litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_error_codes__ErrorCode_UNEXPECTED_TOKEN);
                                                            return;
                                                            
                                                            
                                                            
                                                        }
                                                    } 
                                                    
                                                } 
                                                
                                            } 
                                            
                                        } 
                                        
                                    } 
                                    
                                } 
                                
                            } 
                            
                        } 
                        
                    } 
                    
                } 
                
                litaC_ast__Decl* litaC_decl = litaC_std__array__Array_last_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)));
                litaC_decl->attributes.notes = litaC_notes;
                litaC_decl->attributes.visibility = litaC_visibility;
                litaC_decl->attributes.isGlobal = litaC_true;
                
                
            }
        } 
        
    } 
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_parseCompileTimeBody(litaC_parser__Parser* litaC_p) {
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_IMPORT)) {
        {
            litaC_ast__ImportDecl* litaC_importDecl = litaC_parser__Parser_importDeclaration(litaC_p);
            if(!(litaC_importDecl)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            return (litaC_ast__Stmt*)litaC_importDecl;
            
            
            
        }
        
    } else {
        {
            litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
            litaC_std__array__Array_cb__ptr_NoteStmt_ce_ litaC_notes =  {
                
            };
            if(!(litaC_parser__Parser_notes(litaC_p, &(litaC_notes)))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_i32 litaC_visibility = litaC_ast__Visibility_PRIVATE;
            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_INTERNAL)) {
                {
                    litaC_visibility = litaC_ast__Visibility_INTERNAL;
                    
                    
                }
                
            } else {
                if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_PUBLIC)) {
                    {
                        litaC_visibility = litaC_ast__Visibility_PUBLIC;
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_ast__Decl* litaC_decl = NULL;
            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_VAR)) {
                {
                    litaC_decl = litaC_parser__Parser_varDeclaration(litaC_p);
                    
                    
                }
                
            } else {
                if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_CONST)) {
                    {
                        litaC_decl = litaC_parser__Parser_constDeclaration(litaC_p);
                        
                        
                    }
                    
                } else {
                    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_FUNC)) {
                        {
                            litaC_decl = litaC_parser__Parser_funcDeclaration(litaC_p);
                            
                            
                        }
                        
                    } else {
                        if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_STRUCT)) {
                            {
                                litaC_decl = litaC_parser__Parser_structDeclaration(litaC_p);
                                
                                
                            }
                            
                        } else {
                            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_UNION)) {
                                {
                                    litaC_decl = litaC_parser__Parser_unionDeclaration(litaC_p);
                                    
                                    
                                }
                                
                            } else {
                                if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_TRAIT)) {
                                    {
                                        litaC_decl = litaC_parser__Parser_traitDeclaration(litaC_p);
                                        
                                        
                                    }
                                    
                                } else {
                                    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_ENUM)) {
                                        {
                                            litaC_decl = litaC_parser__Parser_enumDeclaration(litaC_p);
                                            
                                            
                                        }
                                        
                                    } else {
                                        if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_TYPEDEF)) {
                                            {
                                                litaC_decl = litaC_parser__Parser_typedefDeclaration(litaC_p);
                                                
                                                
                                            }
                                            
                                        } else {
                                            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_NOTE)) {
                                                {
                                                    litaC_decl = litaC_parser__Parser_noteDeclaration(litaC_p);
                                                    
                                                    
                                                }
                                                
                                            } else {
                                                if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_SEMICOLON)) {
                                                    {
                                                        if(!(litaC_std__array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_notes))))) {
                                                            {
                                                                return (litaC_ast__Stmt*)litaC_ast_new__NewNotesDecl(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_notes, litaC_p->allocator);
                                                                
                                                                
                                                                
                                                            }
                                                            
                                                        } 
                                                        
                                                        return NULL;
                                                        
                                                        
                                                        
                                                    }
                                                    
                                                } else {
                                                    {
                                                        return litaC_parser__Parser_statement(litaC_p);
                                                        
                                                        
                                                        
                                                    }
                                                } 
                                                
                                            } 
                                            
                                        } 
                                        
                                    } 
                                    
                                } 
                                
                            } 
                            
                        } 
                        
                    } 
                    
                } 
                
            } 
            
            litaC_decl->attributes.notes = litaC_notes;
            litaC_decl->attributes.visibility = litaC_visibility;
            litaC_decl->attributes.isGlobal = litaC_true;
            return (litaC_ast__Stmt*)litaC_decl;
            
            err:;
            
            return (litaC_ast__Stmt*)litaC_ast_new__NewPoisonDecl(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
            
            
            
        }
    } 
    
    
}

litaC_ast__ImportDecl* litaC_parser__Parser_importDeclaration(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_bool litaC_isUsing = litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_USING);
    litaC_lex__Token* litaC_moduleNameStr = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_STRING, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_moduleNameStr)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Identifier litaC_moduleName =  {
        .str = litaC_intern__Strings_internStringView(litaC_p->strings, &((litaC_moduleNameStr->value.str))),
        .token = *(litaC_moduleNameStr)
    };
    litaC_ast__Identifier litaC_alias =  {
        .str = litaC_intern__EMPTY_STR,
        .token =  {
            .type = litaC_lex__TokenType_VOID
        }
    };
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_AS)) {
        {
            litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
            if(!(litaC_identifier)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_alias.str = litaC_intern__Strings_internStringView(litaC_p->strings, &((litaC_identifier->value.str)));
            litaC_alias.token = *(litaC_identifier);
            
            
        }
        
    } 
    
    return (litaC_ast__ImportDecl*)litaC_ast_new__NewImportDecl(litaC_pos, litaC_parser__Parser_prevPos(litaC_p), litaC_moduleName, litaC_alias, litaC_isUsing, litaC_p->allocator);
    
    err:;
    
    return NULL;
    
    
}

litaC_bool litaC_parser__Parser_notes(litaC_parser__Parser* litaC_p,litaC_std__array__Array_cb__ptr_NoteStmt_ce_* litaC_notes) {
    if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_AT))) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    litaC_std__array__Array_init_cb__ptr_NoteStmt_ce_(litaC_notes, 4, litaC_p->allocator);
    while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_AT)) {
        {
            litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
            litaC_ast__TypeSpec* litaC_type = litaC_parser__Parser_qualifiedIdentifierType(litaC_p, litaC_true);
            if(!(litaC_type)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_std__array__Array_cb_CallArg_ce_ litaC_args =  {
                
            };
            litaC_std__array__Array_init_cb_CallArg_ce_(&((litaC_args)), 0, litaC_p->allocator);
            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LEFT_PAREN)) {
                {
                    if(!(litaC_parser__Parser_arguments(litaC_p, &((litaC_args))))) {
                        {
                            goto err;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            litaC_ast__NoteStmt* litaC_note = (litaC_ast__NoteStmt*)litaC_ast_new__NewNoteStmt(litaC_pos, litaC_parser__Parser_prevPos(litaC_p), litaC_type, litaC_args, litaC_p->allocator);
            litaC_std__array__Array_add_cb__ptr_NoteStmt_ce_(litaC_notes, litaC_note);
            
            
        }
    }
    return litaC_true;
    
    err:;
    
    return litaC_false;
    
    
}

litaC_ast__Decl* litaC_parser__Parser_varDeclaration(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_identifier)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Identifier litaC_name =  {
        .str = litaC_intern__Strings_internStringView(litaC_p->strings, &((litaC_identifier->value.str))),
        .token = *(litaC_identifier)
    };
    litaC_ast__TypeSpec* litaC_type = NULL;
    litaC_ast__Expr* litaC_expr = NULL;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COLON)) {
        {
            litaC_type = litaC_parser__Parser_type(litaC_p, litaC_false);
            if(!(litaC_type)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_EQUALS)) {
                {
                    litaC_expr = litaC_parser__Parser_expression(litaC_p);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } else {
        {
            if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_EQUALS, litaC_error_codes__ErrorCode_MISSING_EQUALS))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_expr = litaC_parser__Parser_expression(litaC_p);
            
            
        }
    } 
    
    return litaC_ast_new__NewVarDecl(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_name, litaC_type, litaC_expr, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonDecl(litaC_p, litaC_pos);
    
    
}

litaC_ast__Decl* litaC_parser__Parser_constDeclaration(litaC_parser__Parser* litaC_p) {
    litaC_ast__Decl* litaC_decl = litaC_parser__Parser_varDeclaration(litaC_p);
    if(litaC_decl->stmt.node.kind == litaC_ast__StmtKind_VAR_DECL) {
        {
            litaC_decl->stmt.node.kind = litaC_ast__StmtKind_CONST_DECL;
            
            
        }
        
    } 
    
    return litaC_decl;
    
    
}

litaC_ast__Decl* litaC_parser__Parser_funcDeclaration(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_p->funcLevel += 1;
    litaC_ast__ParameterDecl* litaC_objectParam = NULL;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LEFT_PAREN)) {
        {
            litaC_objectParam = litaC_parser__Parser_paramDeclaration(litaC_p);
            if(!(litaC_objectParam)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_identifier)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Identifier litaC_name =  {
        .str = litaC_intern__Strings_internStringView(litaC_p->strings, &((litaC_identifier->value.str))),
        .token = *(litaC_identifier)
    };
    litaC_std__array__Array_cb_GenericParam_ce_ litaC_genericParams =  {
        
    };
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LESS_THAN)) {
        {
            if(!(litaC_parser__Parser_genericParameters(litaC_p, &(litaC_genericParams)))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_ast__ParametersStmt* litaC_parameters = litaC_parser__Parser_parametersStatement(litaC_p);
    if(!(litaC_parameters)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(litaC_objectParam != NULL) {
        {
            if(litaC_std__array__Array_empty_cb__ptr_ParameterDecl_ce_(&((litaC_parameters->params)))) {
                {
                    litaC_std__array__Array_init_cb__ptr_ParameterDecl_ce_(&((litaC_parameters->params)), 1, litaC_p->allocator);
                    
                    
                }
                
            } 
            
            litaC_std__array__Array_insertAt_cb__ptr_ParameterDecl_ce_(&((litaC_parameters->params)), 0, litaC_objectParam);
            
            
        }
        
    } 
    
    litaC_ast__TypeSpec* litaC_returnType = NULL;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COLON)) {
        {
            litaC_returnType = litaC_parser__Parser_type(litaC_p, litaC_false);
            if(!(litaC_returnType)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } else {
        {
            litaC_returnType = litaC_ast_new__NewVoidTypeSpec(litaC_parser__Parser_pos(litaC_p), litaC_p->typeAllocator);
            
            
        }
    } 
    
    litaC_i32 litaC_flags = 0;
    if(litaC_parameters->isVararg) {
        {
            litaC_flags |= litaC_ast__FuncFlags_HAS_VARARGS;
            
            
        }
        
    } 
    
    if(litaC_objectParam != NULL) {
        {
            litaC_flags |= litaC_ast__FuncFlags_IS_METHOD;
            
            
        }
        
    } 
    
    litaC_ast__Stmt* litaC_body = NULL;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_SEMICOLON)) {
        {
            litaC_body = litaC_ast_new__NewEmptyStmt(litaC_parser__Parser_prevPos(litaC_p), litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
            
            
        }
        
    } else {
        {
            litaC_body = litaC_parser__Parser_statement(litaC_p);
            if(litaC_body->node.kind == litaC_ast__StmtKind_BLOCK_STMT) {
                {
                    litaC_body->node.kind = litaC_ast__StmtKind_FUNC_BODY_STMT;
                    
                    
                }
                
            } 
            
            
            
        }
    } 
    
    litaC_p->funcLevel -= 1;
    return litaC_ast_new__NewFuncDecl(litaC_pos, litaC_parser__Parser_prevPos(litaC_p), litaC_name, litaC_genericParams, litaC_parameters, litaC_body, litaC_returnType, litaC_flags, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonDecl(litaC_p, litaC_pos);
    
    
}

litaC_ast__Decl* litaC_parser__Parser_structDeclaration(litaC_parser__Parser* litaC_p) {
    return litaC_parser__Parser_aggregateDeclaration(litaC_p, litaC_ast__StmtKind_STRUCT_DECL);
    
    
}

litaC_ast__Decl* litaC_parser__Parser_unionDeclaration(litaC_parser__Parser* litaC_p) {
    return litaC_parser__Parser_aggregateDeclaration(litaC_p, litaC_ast__StmtKind_UNION_DECL);
    
    
}

litaC_ast__Decl* litaC_parser__Parser_traitDeclaration(litaC_parser__Parser* litaC_p) {
    return litaC_parser__Parser_aggregateDeclaration(litaC_p, litaC_ast__StmtKind_TRAIT_DECL);
    
    
}

litaC_ast__Decl* litaC_parser__Parser_aggregateDeclaration(litaC_parser__Parser* litaC_p,litaC_ast__StmtKind litaC_kind) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_i32 litaC_flags = 0;
    if(litaC_p->aggregateLevel > 0) {
        {
            litaC_flags |= litaC_ast__AggregateFlags_IS_EMBEDDED;
            
            
        }
        
    } 
    
    litaC_ast__Identifier litaC_name =  {
        .str = litaC_intern__EMPTY_STR,
        .token =  {
            .type = litaC_lex__TokenType_VOID
        }
    };
    if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_IDENTIFIER)) {
        {
            litaC_lex__Token litaC_id = litaC_parser__Parser_identifier(litaC_p);
            litaC_name.str = litaC_intern__Strings_internStringView(litaC_p->strings, &((litaC_id.value.str)));
            litaC_name.token = litaC_id;
            
            
        }
        
    } else {
        {
            litaC_flags |= litaC_ast__AggregateFlags_IS_ANONYMOUS;
            
            
        }
    } 
    
    litaC_std__array__Array_cb_GenericParam_ce_ litaC_genericParams =  {
        
    };
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LESS_THAN)) {
        {
            if(!(litaC_parser__Parser_genericParameters(litaC_p, &(litaC_genericParams)))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_std__array__Array_cb_FieldStmt_ce_ litaC_fields =  {
        
    };
    litaC_p->aggregateLevel += 1;
    if(!(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_SEMICOLON))) {
        {
            if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_BRACE, litaC_error_codes__ErrorCode_MISSING_LEFT_BRACE))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_std__array__Array_init_cb_FieldStmt_ce_(&((litaC_fields)), 8, litaC_p->allocator);
            do {
                {
                    if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_BRACE)) {
                        {
                            break;
                            
                            
                        }
                        
                    } 
                    
                    litaC_ast__FieldStmt litaC_field = litaC_parser__Parser_fieldStatement(litaC_p, litaC_kind);
                    if(litaC_field.kind == litaC_ast__StmtKind_POISON_EXPR) {
                        {
                            goto err;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__array__Array_add_cb_FieldStmt_ce_(&((litaC_fields)), litaC_field);
                    litaC_parser__Parser_eatSemicolon(litaC_p);
                    
                    
                }
            }
            while(!(litaC_parser__Parser_atEnd(litaC_p)));
            if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_BRACE, litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACE))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_p->aggregateLevel -= 1;
    return litaC_ast_new__NewAggregateDecl(litaC_pos, litaC_parser__Parser_prevPos(litaC_p), litaC_kind, litaC_name, litaC_genericParams, litaC_fields, litaC_flags, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonDecl(litaC_p, litaC_pos);
    
    
}

litaC_ast__Decl* litaC_parser__Parser_enumDeclaration(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_identifier)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Identifier litaC_name =  {
        .str = litaC_intern__Strings_internStringView(litaC_p->strings, &((litaC_identifier->value.str))),
        .token = *(litaC_identifier)
    };
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_BRACE, litaC_error_codes__ErrorCode_MISSING_LEFT_BRACE))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_ litaC_fields =  {
        
    };
    litaC_std__array__Array_init_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_fields)), 16, litaC_p->allocator);
    do {
        {
            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_BRACE)) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_ast__EnumFieldEntryDecl* litaC_field = litaC_parser__Parser_enumFieldEntryDecl(litaC_p);
            if(!(litaC_field)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_std__array__Array_add_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_fields)), litaC_field);
            
            
        }
    }
    while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COMMA));
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_BRACE, litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACE))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_ast_new__NewEnumDecl(litaC_pos, litaC_parser__Parser_prevPos(litaC_p), litaC_name, litaC_fields, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonDecl(litaC_p, litaC_pos);
    
    
}

litaC_ast__Decl* litaC_parser__Parser_typedefDeclaration(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_ast__TypeSpec* litaC_aliasedType = litaC_parser__Parser_type(litaC_p, litaC_false);
    if(!(litaC_aliasedType)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_AS);
    litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_identifier)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Identifier litaC_name =  {
        .str = litaC_intern__Strings_internStringView(litaC_p->strings, &((litaC_identifier->value.str))),
        .token = *(litaC_identifier)
    };
    litaC_std__array__Array_cb_GenericParam_ce_ litaC_genericParams =  {
        
    };
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LESS_THAN)) {
        {
            if(!(litaC_parser__Parser_genericParameters(litaC_p, &(litaC_genericParams)))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    return litaC_ast_new__NewTypedefDecl(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_name, litaC_genericParams, litaC_aliasedType, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonDecl(litaC_p, litaC_pos);
    
    
}

litaC_ast__Decl* litaC_parser__Parser_noteDeclaration(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_identifier)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Identifier litaC_name =  {
        .str = litaC_intern__Strings_internStringView(litaC_p->strings, &((litaC_identifier->value.str))),
        .token = *(litaC_identifier)
    };
    litaC_std__array__Array_cb_FieldStmt_ce_ litaC_fields =  {
        
    };
    if(!(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_SEMICOLON))) {
        {
            if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_BRACE, litaC_error_codes__ErrorCode_MISSING_LEFT_BRACE))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_std__array__Array_init_cb_FieldStmt_ce_(&((litaC_fields)), 8, litaC_p->allocator);
            do {
                {
                    if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_BRACE)) {
                        {
                            break;
                            
                            
                        }
                        
                    } 
                    
                    litaC_ast__FieldStmt litaC_field = litaC_parser__Parser_noteFieldStatement(litaC_p);
                    if(litaC_field.kind == litaC_ast__StmtKind_POISON_EXPR) {
                        {
                            goto err;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__array__Array_add_cb_FieldStmt_ce_(&((litaC_fields)), litaC_field);
                    litaC_parser__Parser_eatSemicolon(litaC_p);
                    
                    
                }
            }
            while(!(litaC_parser__Parser_atEnd(litaC_p)));
            if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_BRACE, litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACE))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    return litaC_ast_new__NewNoteDecl(litaC_pos, litaC_parser__Parser_prevPos(litaC_p), litaC_name, litaC_fields, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonDecl(litaC_p, litaC_pos);
    
    
}

litaC_ast__ParameterDecl* litaC_parser__Parser_paramDeclaration(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_identifier)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Identifier litaC_name =  {
        .str = litaC_intern__Strings_internStringView(litaC_p->strings, &((litaC_identifier->value.str))),
        .token = *(litaC_identifier)
    };
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COLON, litaC_error_codes__ErrorCode_MISSING_COLON))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_bool litaC_isUsing = litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_USING);
    litaC_ast__TypeSpec* litaC_type = litaC_parser__Parser_type(litaC_p, litaC_false);
    if(!(litaC_type)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Expr* litaC_defaultExpr = NULL;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_EQUALS)) {
        {
            litaC_defaultExpr = litaC_parser__Parser_constExpression(litaC_p);
            
            
        }
        
    } 
    
    return (litaC_ast__ParameterDecl*)litaC_ast_new__NewParameterDecl(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_name, litaC_type, litaC_defaultExpr, litaC_isUsing, litaC_p->allocator);
    
    err:;
    
    return NULL;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_expression(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_i32 litaC_errorCount = litaC_parser__Parser_numOfErrors(litaC_p);
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_assignment(litaC_p);
    if(litaC_parser__Parser_numOfErrors(litaC_p) > litaC_errorCount) {
        {
            litaC_parser__Parser_adjust(litaC_p, NULL, 0);
            if(litaC_expr) {
                {
                    if(litaC_expr->stmt.node.kind == litaC_ast__StmtKind_POISON_EXPR) {
                        {
                            return litaC_expr;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__mem__Allocator_free(litaC_p->allocator, litaC_expr);
                    
                    
                }
                
            } 
            
            return litaC_ast_new__NewPoisonExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
            
            
            
        }
        
    } 
    
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_constExpression(litaC_parser__Parser* litaC_p) {
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_expression(litaC_p);
    litaC_parser__Parser_checkConstExpr(litaC_p, litaC_expr);
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_group(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_expression(litaC_p);
    litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN);
    return litaC_ast_new__NewGroupExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_p->allocator);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_arrayInit(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_ast__TypeSpec* litaC_type = litaC_parser__Parser_type(litaC_p, litaC_false);
    if(!(litaC_type)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(litaC_type->kind != litaC_ast__TypeSpecKind_ARRAY) {
        {
            litaC_parser__Parser_errorAtPos(litaC_p, litaC_type->pos, litaC_error_codes__ErrorCode_MISSING_LEFT_BRACE);
            goto err;
            
            
            
        }
        
    } 
    
    litaC_std__array__Array_cb__ptr_Expr_ce_ litaC_values =  {
        
    };
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LEFT_BRACE)) {
        {
            if(!(litaC_parser__Parser_arrayArguments(litaC_p, &(litaC_values)))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    return litaC_ast_new__NewArrayInitExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_type, litaC_values, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonExpr(litaC_p, litaC_pos);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_aggregateInit(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_std__array__Array_cb__ptr_InitArgExpr_ce_ litaC_arguments =  {
        
    };
    litaC_parser__Parser_structArguments(litaC_p, &(litaC_arguments));
    return litaC_ast_new__NewInitExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), NULL, litaC_arguments, litaC_p->allocator);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_sizeOf(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_bool litaC_isType = litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COLON);
    litaC_ast__Expr* litaC_expr = NULL;
    litaC_ast__TypeSpec* litaC_type = NULL;
    litaC_bool litaC_isBaseType = litaC_false;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COLON_COLON)) {
        {
            litaC_isBaseType = litaC_true;
            litaC_isType = litaC_true;
            
            
        }
        
    } 
    
    litaC_i32 litaC_backtrack = litaC_p->current;
    if(litaC_isType) {
        {
            litaC_type = litaC_parser__Parser_type(litaC_p, litaC_true);
            if(!(litaC_type)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_DOT)) {
                {
                    litaC_p->current = litaC_backtrack;
                    litaC_expr = litaC_parser__Parser_unary(litaC_p);
                    if(litaC_type) {
                        {
                            litaC_std__mem__Allocator_free(litaC_p->allocator, litaC_type);
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } else {
                {
                    litaC_expr = litaC_ast_new__NewTypeIdentifierExpr(litaC_type->pos, litaC_parser__Parser_pos(litaC_p), litaC_type, litaC_isBaseType, litaC_p->allocator);
                    
                    
                }
            } 
            
            
            
        }
        
    } else {
        {
            litaC_expr = litaC_parser__Parser_unary(litaC_p);
            
            
        }
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_ast_new__NewSizeOfExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonExpr(litaC_p, litaC_pos);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_typeOf(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_bool litaC_isType = litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COLON);
    litaC_ast__Expr* litaC_expr = NULL;
    litaC_ast__TypeSpec* litaC_type = NULL;
    litaC_bool litaC_isBaseType = litaC_false;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COLON_COLON)) {
        {
            litaC_isBaseType = litaC_true;
            litaC_isType = litaC_true;
            
            
        }
        
    } 
    
    litaC_i32 litaC_backtrack = litaC_p->current;
    if(litaC_isType) {
        {
            litaC_type = litaC_parser__Parser_type(litaC_p, litaC_true);
            if(!(litaC_type)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_DOT)) {
                {
                    litaC_p->current = litaC_backtrack;
                    litaC_expr = litaC_parser__Parser_unary(litaC_p);
                    if(litaC_type) {
                        {
                            litaC_std__mem__Allocator_free(litaC_p->allocator, litaC_type);
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } else {
                {
                    litaC_expr = litaC_ast_new__NewTypeIdentifierExpr(litaC_type->pos, litaC_parser__Parser_pos(litaC_p), litaC_type, litaC_isBaseType, litaC_p->allocator);
                    
                    
                }
            } 
            
            
            
        }
        
    } else {
        {
            litaC_expr = litaC_parser__Parser_unary(litaC_p);
            
            
        }
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_ast_new__NewTypeOfExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_type, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonExpr(litaC_p, litaC_pos);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_offsetOf(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__TypeSpec* litaC_type = litaC_parser__Parser_type(litaC_p, litaC_true);
    if(!(litaC_type)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COMMA, litaC_error_codes__ErrorCode_MISSING_COMMA))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_lex__Token* litaC_fieldName = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_fieldName)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Identifier litaC_name =  {
        .str = litaC_intern__Strings_internStringView(litaC_p->strings, &((litaC_fieldName->value.str))),
        .token = *(litaC_fieldName)
    };
    return litaC_ast_new__NewOffsetOfExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_type, litaC_name, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonExpr(litaC_p, litaC_pos);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_assignment(litaC_parser__Parser* litaC_p) {
    static 
    litaC_lex__TokenType litaC_checks[12] =  {
        litaC_lex__TokenType_EQUALS,
        litaC_lex__TokenType_PLUS_EQ,
        litaC_lex__TokenType_MINUS_EQ,
        litaC_lex__TokenType_DIV_EQ,
        litaC_lex__TokenType_MUL_EQ,
        litaC_lex__TokenType_MOD_EQ,
        litaC_lex__TokenType_LSHIFT_EQ,
        litaC_lex__TokenType_RSHIFT_EQ,
        litaC_lex__TokenType_BNOT_EQ,
        litaC_lex__TokenType_XOR_EQ,
        litaC_lex__TokenType_BAND_EQ,
        litaC_lex__TokenType_BOR_EQ
    };
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_ternary(litaC_p);
    if(!(litaC_expr)) {
        return NULL;
        
        
    } 
    
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_parser__Parser_matches(litaC_p, litaC_checks, 12)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_ternary(litaC_p);
            if(litaC_expr->stmt.node.kind == litaC_ast__StmtKind_GET_EXPR) {
                {
                    litaC_ast__GetExpr* litaC_getExpr = (litaC_ast__GetExpr*)litaC_expr;
                    litaC_expr = litaC_ast_new__NewSetExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_getExpr->object, litaC_getExpr->field, litaC_operator, litaC_right, litaC_p->allocator);
                    
                    
                }
                
            } else {
                if(litaC_expr->stmt.node.kind == litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR) {
                    {
                        litaC_ast__SubscriptGetExpr* litaC_getExpr = (litaC_ast__SubscriptGetExpr*)litaC_expr;
                        litaC_expr = litaC_ast_new__NewSubscriptSetExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_getExpr->object, litaC_getExpr->index, litaC_operator, litaC_right, litaC_p->allocator);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
                        
                        
                    }
                } 
                
            } 
            
            litaC_pos = litaC_parser__Parser_pos(litaC_p);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_ternary(litaC_parser__Parser* litaC_p) {
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_or(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_QUESTION_MARK)) {
        {
            litaC_ast__Expr* litaC_then = litaC_parser__Parser_expression(litaC_p);
            if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COLON, litaC_error_codes__ErrorCode_MISSING_COLON))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_ast__Expr* litaC_other = litaC_parser__Parser_expression(litaC_p);
            litaC_expr = litaC_ast_new__NewTernaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_then, litaC_other, litaC_p->allocator);
            
            
        }
        
    } 
    
    return litaC_expr;
    
    err:;
    
    return litaC_parser__Parser_poisonExpr(litaC_p, litaC_pos);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_or(litaC_parser__Parser* litaC_p) {
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_and(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_OR)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_and(litaC_p);
            litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_and(litaC_parser__Parser* litaC_p) {
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_bitOr(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_AND)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_bitOr(litaC_p);
            litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_bitOr(litaC_parser__Parser* litaC_p) {
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_bitXor(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_BOR)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_bitXor(litaC_p);
            litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_bitXor(litaC_parser__Parser* litaC_p) {
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_bitAnd(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_XOR)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_bitAnd(litaC_p);
            litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_bitAnd(litaC_parser__Parser* litaC_p) {
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_equality(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_BAND)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_equality(litaC_p);
            litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_equality(litaC_parser__Parser* litaC_p) {
    static 
    litaC_lex__TokenType litaC_checks[2] =  {
        litaC_lex__TokenType_NOT_EQUALS,
        litaC_lex__TokenType_EQUALS_EQUALS
    };
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_comparison(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_parser__Parser_matches(litaC_p, litaC_checks, 2)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_comparison(litaC_p);
            litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_comparison(litaC_parser__Parser* litaC_p) {
    static 
    litaC_lex__TokenType litaC_checks[4] =  {
        litaC_lex__TokenType_GREATER_THAN,
        litaC_lex__TokenType_GREATER_EQUALS,
        litaC_lex__TokenType_LESS_THAN,
        litaC_lex__TokenType_LESS_EQUALS
    };
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_bitShift(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_parser__Parser_matches(litaC_p, litaC_checks, 4)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_bitShift(litaC_p);
            litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_bitShift(litaC_parser__Parser* litaC_p) {
    static 
    litaC_lex__TokenType litaC_checks[2] =  {
        litaC_lex__TokenType_LSHIFT,
        litaC_lex__TokenType_RSHIFT
    };
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_term(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_ast__Expr* litaC_bitExpr = litaC_parser__Parser_tryBitShiftRight(litaC_p, litaC_expr);
    if(litaC_bitExpr) {
        {
            return litaC_bitExpr;
            
            
            
        }
        
    } 
    
    while(litaC_parser__Parser_matches(litaC_p, litaC_checks, 2)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_term(litaC_p);
            litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_term(litaC_parser__Parser* litaC_p) {
    static 
    litaC_lex__TokenType litaC_checks[2] =  {
        litaC_lex__TokenType_MINUS,
        litaC_lex__TokenType_PLUS
    };
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_factor(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_parser__Parser_matches(litaC_p, litaC_checks, 2)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_factor(litaC_p);
            litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_factor(litaC_parser__Parser* litaC_p) {
    static 
    litaC_lex__TokenType litaC_checks[3] =  {
        litaC_lex__TokenType_SLASH,
        litaC_lex__TokenType_STAR,
        litaC_lex__TokenType_MOD
    };
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_unary(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_parser__Parser_matches(litaC_p, litaC_checks, 3)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_unary(litaC_p);
            litaC_expr = litaC_ast_new__NewBinaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_operator, litaC_right, litaC_p->allocator);
            
            
        }
    }
    return litaC_expr;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_unary(litaC_parser__Parser* litaC_p) {
    static 
    litaC_lex__TokenType litaC_checks[6] =  {
        litaC_lex__TokenType_NOT,
        litaC_lex__TokenType_MINUS,
        litaC_lex__TokenType_PLUS,
        litaC_lex__TokenType_STAR,
        litaC_lex__TokenType_BAND,
        litaC_lex__TokenType_BNOT
    };
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    if(litaC_parser__Parser_matches(litaC_p, litaC_checks, 6)) {
        {
            litaC_lex__TokenType litaC_operator = litaC_parser__Parser_previous(litaC_p)->type;
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_unary(litaC_p);
            return litaC_ast_new__NewUnaryExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_operator, litaC_right, litaC_p->allocator);
            
            
            
        }
        
    } 
    
    return litaC_parser__Parser_functionCall(litaC_p);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_functionCall(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_ast__Expr* litaC_expr = litaC_parser__Parser_primary(litaC_p);
    litaC_expr->stmt.node.endPos = litaC_parser__Parser_pos(litaC_p);
    while(litaC_true) {
        {
            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LEFT_PAREN)) {
                {
                    litaC_expr = litaC_parser__Parser_finishFunctionCall(litaC_p, litaC_expr);
                    litaC_expr->stmt.node.endPos = litaC_parser__Parser_pos(litaC_p);
                    
                    
                }
                
            } else {
                if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_LEFT_BRACE)) {
                    {
                        if(!(litaC_ast__Expr_isIdentifier(litaC_expr))) {
                            {
                                return litaC_expr;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_parser__Parser_advance(litaC_p);
                        litaC_ast__IdentifierExpr* litaC_idExpr = (litaC_ast__IdentifierExpr*)litaC_expr;
                        litaC_std__array__Array_cb__ptr_InitArgExpr_ce_ litaC_arguments =  {
                            
                        };
                        if(!(litaC_parser__Parser_structArguments(litaC_p, &(litaC_arguments)))) {
                            {
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_expr = litaC_ast_new__NewInitExpr(litaC_expr->stmt.node.startPos, litaC_parser__Parser_pos(litaC_p), litaC_idExpr->type, litaC_arguments, litaC_p->allocator);
                        
                        
                    }
                    
                } else {
                    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LEFT_BRACKET)) {
                        {
                            litaC_ast__Expr* litaC_index = litaC_parser__Parser_expression(litaC_p);
                            if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_BRACKET, litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACKET))) {
                                {
                                    goto err;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_expr = litaC_ast_new__NewSubscriptGetExpr(litaC_expr->stmt.node.startPos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_index, litaC_p->allocator);
                            
                            
                        }
                        
                    } else {
                        if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_DOT)) {
                            {
                                litaC_ast__TypeSpec* litaC_identifier = litaC_parser__Parser_identifierType(litaC_p, litaC_true);
                                if(!(litaC_identifier)) {
                                    {
                                        goto err;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_expr = litaC_ast_new__NewGetExpr(litaC_expr->stmt.node.startPos, litaC_parser__Parser_pos(litaC_p), litaC_expr, (litaC_ast__IdentifierExpr*)litaC_ast_new__NewIdentifierExpr(litaC_identifier->pos, litaC_parser__Parser_pos(litaC_p), litaC_identifier, litaC_p->allocator), litaC_p->allocator);
                                
                                
                            }
                            
                        } else {
                            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_AS)) {
                                {
                                    litaC_expr = litaC_parser__Parser_cast(litaC_p, litaC_expr);
                                    
                                    
                                }
                                
                            } else {
                                {
                                    break;
                                    
                                    
                                }
                            } 
                            
                        } 
                        
                    } 
                    
                } 
                
            } 
            
            
            
        }
    }
    return litaC_expr;
    
    err:;
    
    return litaC_parser__Parser_poisonExpr(litaC_p, litaC_pos);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_primary(litaC_parser__Parser* litaC_p) {
    litaC_lex__Token* litaC_token = litaC_parser__Parser_peek(litaC_p);
    litaC_lex__SrcPos litaC_pos = litaC_token->pos;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_TRUE)) {
        {
            return litaC_ast_new__NewBooleanExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_true, litaC_p->allocator);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_FALSE)) {
        {
            return litaC_ast_new__NewBooleanExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_false, litaC_p->allocator);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_NULL)) {
        {
            return litaC_ast_new__NewNullExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_INT_NUMBER) || litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_FLOAT_NUMBER)) {
        {
            return litaC_ast_new__NewNumberExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), *((litaC_token)), litaC_p->allocator);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_STRING)) {
        {
            return litaC_ast_new__NewStringExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), *((litaC_token)), litaC_p->allocator);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_CHAR)) {
        {
            return litaC_ast_new__NewCharExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), *((litaC_token)), litaC_p->allocator);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LEFT_PAREN)) {
        {
            return litaC_parser__Parser_group(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_LEFT_BRACKET)) {
        {
            return litaC_parser__Parser_arrayInit(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LEFT_BRACE)) {
        {
            return litaC_parser__Parser_aggregateInit(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_SIZEOF)) {
        {
            return litaC_parser__Parser_sizeOf(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_TYPEOF)) {
        {
            return litaC_parser__Parser_typeOf(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_OFFSETOF)) {
        {
            return litaC_parser__Parser_offsetOf(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_IDENTIFIER)) {
        {
            litaC_ast__TypeSpec* litaC_name = litaC_parser__Parser_qualifiedIdentifierType(litaC_p, litaC_true);
            if(!(litaC_name)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            return litaC_ast_new__NewIdentifierExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_name, litaC_p->allocator);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_ERROR)) {
        {
            return litaC_parser__Parser_poisonExpr(litaC_p, litaC_pos);
            
            
            
        }
        
    } 
    
    err:;
    
    litaC_parser__Parser_errorAtToken(litaC_p, litaC_token, litaC_error_codes__ErrorCode_UNEXPECTED_TOKEN);
    return litaC_parser__Parser_poisonExpr(litaC_p, litaC_pos);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_finishFunctionCall(litaC_parser__Parser* litaC_p,litaC_ast__Expr* litaC_expr) {
    litaC_lex__SrcPos litaC_pos = litaC_expr->stmt.node.startPos;
    litaC_std__array__Array_cb_CallArg_ce_ litaC_arguments =  {
        
    };
    if(!(litaC_parser__Parser_arguments(litaC_p, &(litaC_arguments)))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_std__array__Array_cb__ptr_TypeSpec_ce_ litaC_genericArgs =  {
        
    };
    if(litaC_ast__Expr_isIdentifier(litaC_expr)) {
        {
            litaC_ast__IdentifierExpr* litaC_idExpr = (litaC_ast__IdentifierExpr*)litaC_expr;
            litaC_expr->stmt.node.kind = litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR;
            litaC_genericArgs = litaC_idExpr->type->genericArgs;
            
            
        }
        
    } else {
        if(litaC_expr->stmt.node.kind == litaC_ast__StmtKind_GET_EXPR) {
            {
                litaC_ast__GetExpr* litaC_getExpr = (litaC_ast__GetExpr*)litaC_expr;
                litaC_ast__IdentifierExpr* litaC_idExpr = litaC_getExpr->field;
                litaC_idExpr->expr.stmt.node.kind = litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR;
                litaC_genericArgs = litaC_idExpr->type->genericArgs;
                
                
            }
            
        } 
        
    } 
    
    return litaC_ast_new__NewFuncCallExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_arguments, litaC_genericArgs, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonExpr(litaC_p, litaC_pos);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_cast(litaC_parser__Parser* litaC_p,litaC_ast__Expr* litaC_expr) {
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__TypeSpec* litaC_castTo = litaC_parser__Parser_type(litaC_p, litaC_false);
    if(!(litaC_castTo)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_ast_new__NewCastExpr(litaC_expr->stmt.node.startPos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_castTo, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonExpr(litaC_p, litaC_expr->stmt.node.startPos);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_statement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_i32 litaC_errorCount = litaC_parser__Parser_numOfErrors(litaC_p);
    litaC_ast__Stmt* litaC_stmt = litaC_parser__Parser_tryStatement(litaC_p);
    if(litaC_parser__Parser_numOfErrors(litaC_p) > litaC_errorCount) {
        {
            litaC_parser__Parser_adjust(litaC_p, NULL, 0);
            if(litaC_stmt) {
                {
                    if(litaC_stmt->node.kind == litaC_ast__StmtKind_POISON_EXPR) {
                        {
                            return litaC_stmt;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__mem__Allocator_free(litaC_p->allocator, litaC_stmt);
                    
                    
                }
                
            } 
            
            return (litaC_ast__Stmt*)litaC_ast_new__NewPoisonExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
            
            
            
        }
        
    } 
    
    return litaC_stmt;
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_tryStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    if(litaC_parser__Parser_atEnd(litaC_p)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_AT)) {
        {
            litaC_std__array__Array_cb__ptr_NoteStmt_ce_ litaC_notes =  {
                
            };
            if(!(litaC_parser__Parser_notes(litaC_p, &(litaC_notes)))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_ast__Decl* litaC_decl = NULL;
            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_VAR)) {
                {
                    litaC_decl = litaC_parser__Parser_varDeclaration(litaC_p);
                    
                    
                }
                
            } else {
                if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_CONST)) {
                    {
                        litaC_decl = litaC_parser__Parser_constDeclaration(litaC_p);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_error_codes__ErrorCode_INVALID_NOTE_DECL);
                        goto err;
                        
                        
                        
                    }
                } 
                
            } 
            
            litaC_decl->attributes.notes = litaC_notes;
            litaC_decl->stmt.node.startPos = litaC_pos;
            return (litaC_ast__Stmt*)litaC_decl;
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_HASH)) {
        {
            return litaC_parser__Parser_compStatement(litaC_p, litaC_false);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LEFT_BRACE)) {
        {
            return litaC_parser__Parser_blockStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_VAR)) {
        {
            return (litaC_ast__Stmt*)litaC_parser__Parser_varDeclaration(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_CONST)) {
        {
            return (litaC_ast__Stmt*)litaC_parser__Parser_constDeclaration(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_IF)) {
        {
            return litaC_parser__Parser_ifStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_WHILE)) {
        {
            return litaC_parser__Parser_whileStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_DO)) {
        {
            return litaC_parser__Parser_doWhileStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_FOR)) {
        {
            return litaC_parser__Parser_forStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_SWITCH)) {
        {
            return litaC_parser__Parser_switchStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_BREAK)) {
        {
            return litaC_parser__Parser_breakStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_CONTINUE)) {
        {
            return litaC_parser__Parser_continueStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_RETURN)) {
        {
            return litaC_parser__Parser_returnStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_DEFER)) {
        {
            return litaC_parser__Parser_deferStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_GOTO)) {
        {
            return litaC_parser__Parser_gotoStatement(litaC_p);
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_IDENTIFIER)) {
        {
            litaC_ast__Stmt* litaC_stmt = litaC_parser__Parser_tryLabelStatement(litaC_p);
            if(litaC_stmt) {
                {
                    return litaC_stmt;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    return (litaC_ast__Stmt*)litaC_parser__Parser_expression(litaC_p);
    
    err:;
    
    return litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_compStatement(litaC_parser__Parser* litaC_p,litaC_bool litaC_isStaticIf) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_p->preprocessorLevel += 1;
    
    litaC_intern__InternedString litaC_type = litaC_intern__EMPTY_STR;
    litaC_std__string_view__StringView litaC_scriptExpr =  {
        
    };
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_IF)) {
        {
            litaC_type = litaC_intern__IF;
            
            
        }
        
    } else {
        if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_ELSE)) {
            {
                litaC_type = litaC_intern__ELSE;
                
                
            }
            
        } else {
            {
                litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
                if(!(litaC_identifier)) {
                    {
                        goto err;
                        
                        
                        
                    }
                    
                } 
                
                litaC_type = litaC_ast_copy__NewTokenNameIntern(*(litaC_identifier), &((litaC_p->lita->strings)));
                
                
            }
        } 
        
    } 
    
    if(litaC_intern__InternedString_equals(&((litaC_type)), &((litaC_intern__STATIC_IF)))) {
        {
            litaC_isStaticIf = litaC_true;
            
            
        }
        
    } 
    
    litaC_bool litaC_isIf = litaC_intern__InternedString_equals(&((litaC_type)), &((litaC_intern__IF))) || litaC_intern__InternedString_equals(&((litaC_type)), &((litaC_intern__STATIC_IF)));
    if(litaC_p->preprocessorLevel > 1) {
        {
            if(litaC_isIf) {
                {
                    litaC_phase_result__PhaseResult_addError(litaC_p->result, litaC_pos, "'#static_if' and '#if' are only allowed as the first statement in the preprocessor chain");
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(litaC_intern__InternedString_equals(&((litaC_type)), &((litaC_intern__IF))) || litaC_intern__InternedString_equals(&((litaC_type)), &((litaC_intern__ELSEIF))) || litaC_intern__InternedString_equals(&((litaC_type)), &((litaC_intern__STATIC_IF)))) {
        {
            litaC_i32 litaC_currentLine = litaC_pos.lineNumber;
            litaC_std__string_buffer__StringBuffer litaC_script = litaC_std__string_buffer__StringBufferInit(128, litaC_p->allocator);
            const litaC_char* litaC_stream = litaC_pos.end;
            while(*(litaC_stream)) {
                {
                    litaC_char litaC_c = *(litaC_stream);
                    if(litaC_c == '\n') {
                        {
                            break;
                            
                            
                        }
                        
                    } 
                    
                    if(litaC_c == '\\') {
                        {
                            if(litaC_stream[1] == '\r' && litaC_stream[2] == '\n') {
                                {
                                    litaC_stream += 3;
                                    litaC_currentLine += 1;
                                    continue;
                                    
                                    
                                }
                                
                            } else {
                                if(litaC_stream[1] == '\n') {
                                    {
                                        litaC_stream += 2;
                                        litaC_currentLine += 1;
                                        continue;
                                        
                                        
                                    }
                                    
                                } 
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    if(litaC_c == '\r') {
                        {
                            litaC_stream += 1;
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__string_buffer__StringBuffer_appendChar(&((litaC_script)), litaC_c);
                    litaC_stream += 1;
                    
                    
                }
            }
            while(!(litaC_parser__Parser_atEnd(litaC_p))) {
                {
                    litaC_lex__Token* litaC_token = litaC_parser__Parser_peek(litaC_p);
                    litaC_i32 litaC_nextLine = litaC_token->pos.lineNumber;
                    if(litaC_nextLine > litaC_currentLine) {
                        {
                            break;
                            
                            
                        }
                        
                    } 
                    
                    litaC_parser__Parser_advance(litaC_p);
                    
                    
                }
            }
            litaC_std__string_buffer__StringBuffer_trim(&((litaC_script)));
            litaC_scriptExpr.buffer = litaC_std__string_buffer__StringBuffer_cStr(&((litaC_script)));
            litaC_scriptExpr.length = litaC_script.length;
            if(litaC_script.length == 0 && litaC_isIf) {
                {
                    litaC_phase_result__PhaseResult_addError(litaC_p->result, litaC_pos, "'#static_if' and '#if' must include a conditional expression");
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_body = litaC_std__array__ArrayInit_cb__ptr_Stmt_ce_(32, litaC_p->allocator);
            while(!(litaC_parser__Parser_atEnd(litaC_p))) {
                {
                    if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_HASH)) {
                        {
                            break;
                            
                            
                        }
                        
                    } 
                    
                    litaC_ast__Stmt* litaC_stmt = litaC_parser__Parser_parseCompileTimeBody(litaC_p);
                    if(litaC_stmt) {
                        {
                            litaC_std__array__Array_add_cb__ptr_Stmt_ce_(&((litaC_body)), litaC_stmt);
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_HASH, litaC_error_codes__ErrorCode_MISSING_COMP_STMT_END))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_ast__Stmt* litaC_end = litaC_parser__Parser_compStatement(litaC_p, litaC_isStaticIf);
            if(litaC_end && litaC_end->node.kind != litaC_ast__StmtKind_COMP_STMT) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            {
                litaC_ast__Stmt* ___result = litaC_ast_new__NewCompStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_type, litaC_scriptExpr, litaC_body, (litaC_ast__CompStmt*)litaC_end, litaC_false, litaC_isStaticIf, litaC_p->allocator);
                litaC_p->preprocessorLevel -= 1;
                return ___result;
                
            }
            
            
            
        }
        
    } else {
        if(litaC_intern__InternedString_equals(&((litaC_type)), &((litaC_intern__PRECHECK))) || litaC_intern__InternedString_equals(&((litaC_type)), &((litaC_intern__POSTCHECK))) || litaC_intern__InternedString_equals(&((litaC_type)), &((litaC_intern__POSTPARSE)))) {
            {
                litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
                litaC_bool litaC_isScriptLoad = litaC_false;
                litaC_i32 litaC_rewind = litaC_p->current;
                if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_STRING)) {
                    {
                        litaC_lex__Token* litaC_filename = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_STRING, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
                        if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_HASH) && litaC_filename) {
                            {
                                litaC_isScriptLoad = litaC_true;
                                litaC_scriptExpr.buffer = litaC_filename->value.str.buffer;
                                litaC_scriptExpr.length = litaC_filename->value.str.length;
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_p->current = litaC_rewind;
                                
                                
                            }
                        } 
                        
                        
                        
                    }
                    
                } else {
                    {
                        while(!(litaC_parser__Parser_atEnd(litaC_p))) {
                            {
                                if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_HASH)) {
                                    {
                                        break;
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_parser__Parser_advance(litaC_p);
                                
                                
                            }
                        }
                        litaC_scriptExpr.buffer = litaC_pos.start;
                        litaC_scriptExpr.length = (litaC_i32)(litaC_parser__Parser_pos(litaC_p).start - litaC_pos.start);
                        
                        
                    }
                } 
                
                if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_HASH, litaC_error_codes__ErrorCode_MISSING_COMP_STMT_END))) {
                    {
                        goto err;
                        
                        
                        
                    }
                    
                } 
                
                litaC_ast__Stmt* litaC_end = litaC_parser__Parser_compStatement(litaC_p, litaC_false);
                if(litaC_end && litaC_end->node.kind != litaC_ast__StmtKind_COMP_STMT) {
                    {
                        goto err;
                        
                        
                        
                    }
                    
                } 
                
                litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_body =  {
                    
                };
                {
                    litaC_ast__Stmt* ___result = litaC_ast_new__NewCompStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_type, litaC_scriptExpr, litaC_body, (litaC_ast__CompStmt*)litaC_end, litaC_isScriptLoad, litaC_false, litaC_p->allocator);
                    litaC_p->preprocessorLevel -= 1;
                    return ___result;
                    
                }
                
                
                
            }
            
        } else {
            if(litaC_intern__InternedString_equals(&((litaC_type)), &((litaC_intern__ELSE)))) {
                {
                    litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_body = litaC_std__array__ArrayInit_cb__ptr_Stmt_ce_(32, litaC_p->allocator);
                    while(!(litaC_parser__Parser_atEnd(litaC_p))) {
                        {
                            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_HASH)) {
                                {
                                    break;
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_ast__Stmt* litaC_stmt = litaC_parser__Parser_parseCompileTimeBody(litaC_p);
                            if(litaC_stmt) {
                                {
                                    litaC_std__array__Array_add_cb__ptr_Stmt_ce_(&((litaC_body)), litaC_stmt);
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                    }
                    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_HASH, litaC_error_codes__ErrorCode_MISSING_COMP_STMT_END))) {
                        {
                            goto err;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_ast__Stmt* litaC_end = litaC_parser__Parser_compStatement(litaC_p, litaC_isStaticIf);
                    if(litaC_end && litaC_end->node.kind != litaC_ast__StmtKind_COMP_STMT) {
                        {
                            goto err;
                            
                            
                            
                        }
                        
                    } 
                    
                    {
                        litaC_ast__Stmt* ___result = litaC_ast_new__NewCompStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_type, litaC_scriptExpr, litaC_body, (litaC_ast__CompStmt*)litaC_end, litaC_false, litaC_isStaticIf, litaC_p->allocator);
                        litaC_p->preprocessorLevel -= 1;
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } else {
                if(litaC_intern__InternedString_equals(&((litaC_type)), &((litaC_intern__ELSE_ERROR)))) {
                    {
                        litaC_lex__Token* litaC_message = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_STRING, litaC_error_codes__ErrorCode_MISSING_ERROR_MESSAGE);
                        if(!(litaC_message)) {
                            {
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_HASH, litaC_error_codes__ErrorCode_MISSING_COMP_STMT_END))) {
                            {
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_ast__Stmt* litaC_end = litaC_parser__Parser_compStatement(litaC_p, litaC_isStaticIf);
                        if(litaC_end && litaC_end->node.kind != litaC_ast__StmtKind_COMP_STMT) {
                            {
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        {
                            litaC_ast__Stmt* ___result = litaC_ast_new__NewCompStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_type, litaC_message->value.str, (litaC_std__array__Array_cb__ptr_Stmt_ce_) {
                                
                            }, NULL, litaC_false, litaC_isStaticIf, litaC_p->allocator);
                            litaC_p->preprocessorLevel -= 1;
                            return ___result;
                            
                        }
                        
                        
                        
                    }
                    
                } else {
                    if(litaC_intern__InternedString_equals(&((litaC_type)), &((litaC_intern__END)))) {
                        {
                            {
                                litaC_ast__Stmt* ___result = litaC_ast_new__NewCompStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_type, (litaC_std__string_view__StringView) {
                                    
                                }, (litaC_std__array__Array_cb__ptr_Stmt_ce_) {
                                    
                                }, NULL, litaC_false, litaC_isStaticIf, litaC_p->allocator);
                                litaC_p->preprocessorLevel -= 1;
                                return ___result;
                                
                            }
                            
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_error_codes__ErrorCode_INVALID_COMP_STMT);
                            goto err;
                            
                            
                            
                        }
                    } 
                    
                } 
                
            } 
            
        } 
        
    } 
    
    err:;
    
    {
        litaC_ast__Stmt* ___result = (litaC_ast__Stmt*)litaC_ast_new__NewPoisonExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
        litaC_p->preprocessorLevel -= 1;
        return ___result;
        
    }
    
    litaC_p->preprocessorLevel -= 1;
    
}

litaC_ast__Stmt* litaC_parser__Parser_blockStatement(litaC_parser__Parser* litaC_p) {
    if(litaC_p->breakLevel > 0) {
        {
            litaC_p->breakLevel -= 1;
            
            
        }
        
    } 
    
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_stmts =  {
        
    };
    litaC_std__array__Array_init_cb__ptr_Stmt_ce_(&((litaC_stmts)), 16, litaC_p->allocator);
    do {
        {
            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_BRACE)) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_ast__Stmt* litaC_stmt = litaC_parser__Parser_statement(litaC_p);
            litaC_std__array__Array_add_cb__ptr_Stmt_ce_(&((litaC_stmts)), litaC_stmt);
            litaC_parser__Parser_eatSemicolon(litaC_p);
            
            
        }
    }
    while(!(litaC_parser__Parser_atEnd(litaC_p)));
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_BRACE, litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACE))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_ast_new__NewBlockStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_stmts, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_ifStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Expr* litaC_cond = litaC_parser__Parser_expression(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Stmt* litaC_then = litaC_parser__Parser_statement(litaC_p);
    litaC_ast__Stmt* litaC_elseStmt = NULL;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_ELSE)) {
        {
            litaC_elseStmt = litaC_parser__Parser_statement(litaC_p);
            
            
        }
        
    } 
    
    return litaC_ast_new__NewIfStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_cond, litaC_then, litaC_elseStmt, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_whileStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_p->loopLevel += 1;
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Expr* litaC_cond = litaC_parser__Parser_expression(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Stmt* litaC_body = litaC_parser__Parser_statement(litaC_p);
    litaC_p->loopLevel -= 1;
    return litaC_ast_new__NewWhileStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_cond, litaC_body, litaC_p->allocator);
    
    err:;
    
    litaC_p->loopLevel -= 1;
    return litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_doWhileStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_p->loopLevel += 1;
    litaC_ast__Stmt* litaC_body = litaC_parser__Parser_statement(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_WHILE, litaC_error_codes__ErrorCode_MISSING_WHILE))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Expr* litaC_cond = litaC_parser__Parser_expression(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_p->loopLevel -= 1;
    return litaC_ast_new__NewDoWhileStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_cond, litaC_body, litaC_p->allocator);
    
    err:;
    
    litaC_p->loopLevel -= 1;
    return litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_forStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Stmt* litaC_init = (!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_SEMICOLON))) ? litaC_parser__Parser_statement(litaC_p) : NULL;
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_SEMICOLON, litaC_error_codes__ErrorCode_MISSING_SEMICOLON))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Expr* litaC_cond = (!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_SEMICOLON))) ? litaC_parser__Parser_expression(litaC_p) : NULL;
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_SEMICOLON, litaC_error_codes__ErrorCode_MISSING_SEMICOLON))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Stmt* litaC_post = (!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_PAREN))) ? litaC_parser__Parser_statement(litaC_p) : NULL;
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_p->loopLevel += 1;
    litaC_ast__Stmt* litaC_body = litaC_parser__Parser_statement(litaC_p);
    litaC_p->loopLevel -= 1;
    return litaC_ast_new__NewForStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_init, litaC_cond, litaC_post, litaC_body, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_switchCaseStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_ast__Expr* litaC_cond = litaC_parser__Parser_constExpression(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COLON, litaC_error_codes__ErrorCode_MISSING_COLON))) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_lex__SrcPos litaC_bodyPos = litaC_parser__Parser_pos(litaC_p);
    litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_stmts =  {
        
    };
    litaC_std__array__Array_init_cb__ptr_Stmt_ce_(&((litaC_stmts)), 8, litaC_p->allocator);
    while(!(litaC_parser__Parser_atEnd(litaC_p))) {
        {
            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_BRACE) || litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_CASE) || litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_DEFAULT)) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_ast__Stmt* litaC_stmt = litaC_parser__Parser_statement(litaC_p);
            litaC_parser__Parser_eatSemicolon(litaC_p);
            litaC_std__array__Array_add_cb__ptr_Stmt_ce_(&((litaC_stmts)), litaC_stmt);
            
            
        }
    }
    litaC_ast__Stmt* litaC_body = NULL;
    if(litaC_std__array__Array_empty_cb__ptr_Stmt_ce_(&((litaC_stmts)))) {
        {
            litaC_body = litaC_ast_new__NewEmptyStmt(litaC_bodyPos, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
            
            
        }
        
    } else {
        {
            litaC_body = litaC_ast_new__NewBlockStmt(litaC_bodyPos, litaC_parser__Parser_pos(litaC_p), litaC_stmts, litaC_p->allocator);
            
            
        }
    } 
    
    return litaC_ast_new__NewSwitchCaseStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_cond, litaC_body, litaC_p->allocator);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_switchDefaultStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_i32 litaC_breakCount = litaC_p->breakLevel;
    litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_stmts =  {
        
    };
    litaC_std__array__Array_init_cb__ptr_Stmt_ce_(&((litaC_stmts)), 8, litaC_p->allocator);
    while(!(litaC_parser__Parser_atEnd(litaC_p))) {
        {
            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_BRACE) || litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_CASE)) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_ast__Stmt* litaC_stmt = litaC_parser__Parser_statement(litaC_p);
            litaC_parser__Parser_eatSemicolon(litaC_p);
            litaC_std__array__Array_add_cb__ptr_Stmt_ce_(&((litaC_stmts)), litaC_stmt);
            if(litaC_breakCount != litaC_p->breakLevel) {
                {
                    litaC_p->breakLevel -= 1;
                    break;
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_ast_new__NewBlockStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_stmts, litaC_p->allocator);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_switchStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_p->switchLevel += 1;
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Expr* litaC_cond = litaC_parser__Parser_expression(litaC_p);
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_bool litaC_startBrace = litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LEFT_BRACE);
    litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_ litaC_cases =  {
        
    };
    litaC_std__array__Array_init_cb__ptr_SwitchCaseStmt_ce_(&((litaC_cases)), 8, litaC_p->allocator);
    litaC_ast__Stmt* litaC_defaultStmt = NULL;
    while(!(litaC_parser__Parser_atEnd(litaC_p))) {
        {
            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_CASE)) {
                {
                    litaC_ast__SwitchCaseStmt* litaC_caseStmt = (litaC_ast__SwitchCaseStmt*)litaC_parser__Parser_switchCaseStatement(litaC_p);
                    if(!(litaC_caseStmt)) {
                        {
                            goto err;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__array__Array_add_cb__ptr_SwitchCaseStmt_ce_(&((litaC_cases)), litaC_caseStmt);
                    litaC_parser__Parser_eatSemicolon(litaC_p);
                    
                    
                }
                
            } else {
                if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_DEFAULT)) {
                    {
                        if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COLON, litaC_error_codes__ErrorCode_MISSING_COLON))) {
                            {
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_defaultStmt = litaC_parser__Parser_switchDefaultStatement(litaC_p);
                        litaC_parser__Parser_eatSemicolon(litaC_p);
                        
                        
                    }
                    
                } else {
                    {
                        break;
                        
                        
                    }
                } 
                
            } 
            
            
            
        }
    }
    if(litaC_startBrace) {
        {
            litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_BRACE, litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACE);
            
            
        }
        
    } 
    
    {
        litaC_ast__Stmt* ___result = litaC_ast_new__NewSwitchStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_cond, litaC_cases, litaC_defaultStmt, litaC_p->allocator);
        litaC_p->switchLevel -= 1;
        return ___result;
        
    }
    
    err:;
    
    {
        litaC_ast__Stmt* ___result = litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
        litaC_p->switchLevel -= 1;
        return ___result;
        
    }
    
    litaC_p->switchLevel -= 1;
    
}

litaC_ast__Stmt* litaC_parser__Parser_breakStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    if(litaC_p->loopLevel < 1 && litaC_p->switchLevel < 1) {
        {
            litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_previous(litaC_p), litaC_error_codes__ErrorCode_INVALID_BREAK);
            goto err;
            
            
            
        }
        
    } 
    
    if(litaC_p->switchLevel > 0 && litaC_p->loopLevel < 1) {
        {
            litaC_p->breakLevel += 1;
            
            
        }
        
    } 
    
    return litaC_ast_new__NewBreakStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_continueStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    if(litaC_p->loopLevel < 1) {
        {
            litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_previous(litaC_p), litaC_error_codes__ErrorCode_INVALID_CONTINUE);
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_ast_new__NewContinueStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_returnStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_ast__Expr* litaC_expr = NULL;
    if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_SEMICOLON))) {
        {
            litaC_expr = litaC_parser__Parser_expression(litaC_p);
            
            
        }
        
    } 
    
    return litaC_ast_new__NewReturnStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_p->allocator);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_deferStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_ast__Stmt* litaC_defered = litaC_parser__Parser_statement(litaC_p);
    return litaC_ast_new__NewDeferStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_defered, litaC_p->allocator);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_gotoStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_lex__Token* litaC_label = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_label)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Identifier litaC_name =  {
        .str = litaC_intern__Strings_internStringView(litaC_p->strings, &((litaC_label->value.str))),
        .token = *(litaC_label)
    };
    return litaC_ast_new__NewGotoStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_name, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_tryLabelStatement(litaC_parser__Parser* litaC_p) {
    litaC_i32 litaC_backtrack = litaC_p->current;
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_lex__Token* litaC_label = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COLON))) {
        {
            litaC_p->current = litaC_backtrack;
            return NULL;
            
            
            
        }
        
    } 
    
    if(litaC_p->funcLevel < 1) {
        {
            litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_error_codes__ErrorCode_INVALID_LABEL_STMT);
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Identifier litaC_name =  {
        .str = litaC_intern__Strings_internStringView(litaC_p->strings, &((litaC_label->value.str))),
        .token = *(litaC_label)
    };
    return litaC_ast_new__NewLabelStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_name, litaC_p->allocator);
    
    err:;
    
    return litaC_parser__Parser_poisonStatement(litaC_p, litaC_pos);
    
    
}

litaC_ast__TypeSpec* litaC_parser__Parser_type(litaC_parser__Parser* litaC_p,litaC_bool litaC_disambiguate) {
    litaC_lex__Token* litaC_token = litaC_parser__Parser_peek(litaC_p);
    switch(litaC_token->type) {
        case litaC_lex__TokenType_BOOL: 
        case litaC_lex__TokenType_CHAR: 
        case litaC_lex__TokenType_I8: 
        case litaC_lex__TokenType_U8: 
        case litaC_lex__TokenType_I16: 
        case litaC_lex__TokenType_U16: 
        case litaC_lex__TokenType_I32: 
        case litaC_lex__TokenType_U32: 
        case litaC_lex__TokenType_I64: 
        case litaC_lex__TokenType_U64: 
        case litaC_lex__TokenType_F32: 
        case litaC_lex__TokenType_F64: 
        case litaC_lex__TokenType_USIZE: 
        case litaC_lex__TokenType_VOID: {
            {
                litaC_parser__Parser_advance(litaC_p);
                litaC_ast__TypeSpec* litaC_spec = litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_NAME, litaC_token->pos, litaC_p->typeAllocator);
                litaC_spec->name = litaC_ast_copy__NewTokenNameIntern(*((litaC_token)), &((litaC_p->lita->strings)));
                return (litaC_ast__TypeSpec*)litaC_spec;
                
                
                
            }
            
            
        }
        case litaC_lex__TokenType_STAR: {
            {
                litaC_parser__Parser_advance(litaC_p);
                litaC_ast__TypeSpec* litaC_base = litaC_parser__Parser_type(litaC_p, litaC_disambiguate);
                if(!(litaC_base)) {
                    return NULL;
                    
                    
                } 
                
                litaC_ast__TypeSpec* litaC_spec = litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_PTR, litaC_token->pos, litaC_p->typeAllocator);
                litaC_spec->base = litaC_base;
                return (litaC_ast__TypeSpec*)litaC_spec;
                
                
                
            }
            
            
        }
        case litaC_lex__TokenType_CONST: {
            {
                litaC_parser__Parser_advance(litaC_p);
                litaC_ast__TypeSpec* litaC_base = litaC_parser__Parser_type(litaC_p, litaC_disambiguate);
                if(!(litaC_base)) {
                    return NULL;
                    
                    
                } 
                
                litaC_ast__TypeSpec* litaC_spec = litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_CONST, litaC_token->pos, litaC_p->typeAllocator);
                litaC_spec->base = litaC_base;
                return (litaC_ast__TypeSpec*)litaC_spec;
                
                
                
            }
            
            
        }
        case litaC_lex__TokenType_IDENTIFIER: {
            {
                return (litaC_ast__TypeSpec*)litaC_parser__Parser_qualifiedIdentifierType(litaC_p, litaC_disambiguate);
                
                
                
            }
            
            
        }
        case litaC_lex__TokenType_LEFT_BRACKET: {
            {
                litaC_ast__TypeSpec* litaC_spec = litaC_parser__Parser_arrayType(litaC_p);
                litaC_parser__Parser_advance(litaC_p);
                if(!(litaC_spec)) {
                    return NULL;
                    
                    
                } 
                
                litaC_spec->base = litaC_parser__Parser_type(litaC_p, litaC_disambiguate);
                return (litaC_ast__TypeSpec*)litaC_spec;
                
                
                
            }
            
            
        }
        case litaC_lex__TokenType_FUNC: {
            {
                litaC_parser__Parser_advance(litaC_p);
                return (litaC_ast__TypeSpec*)litaC_parser__Parser_funcPtrType(litaC_p);
                
                
                
            }
            
            
        }
        default: {
            {
                litaC_parser__Parser_errorAtToken(litaC_p, litaC_token, litaC_error_codes__ErrorCode_UNEXPECTED_TOKEN);
                break;
                
                
            }
            
            
        }
    }
    return NULL;
    
    
}

litaC_ast__TypeSpec* litaC_parser__Parser_identifierType(litaC_parser__Parser* litaC_p,litaC_bool litaC_disambiguate) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_lex__Token litaC_name = litaC_parser__Parser_identifier(litaC_p);
    if(litaC_name.type != litaC_lex__TokenType_IDENTIFIER) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_char litaC_buffer[256] = {0};
    litaC_std__string__String litaC_sb = litaC_std__string__StringInit(litaC_buffer, litaC_symbols__MAX_SYMBOL_NAME, 0);
    litaC_std__string__String_appendStrn(&((litaC_sb)), litaC_name.value.str.buffer, litaC_name.value.str.length);
    litaC_ast__TypeSpec* litaC_spec = litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_NAME, litaC_pos, litaC_p->typeAllocator);
    litaC_spec->name = litaC_intern__Strings_internCopy(&((litaC_p->lita->strings)), litaC_std__string__String_cStr(litaC_sb), litaC_sb.length);
    if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_LESS_THAN)) {
        {
            litaC_spec->genericArgs = litaC_parser__Parser_tryGenericArguments(litaC_p, litaC_disambiguate);
            
            
        }
        
    } 
    
    return litaC_spec;
    
    err:;
    
    return NULL;
    
    
}

litaC_ast__TypeSpec* litaC_parser__Parser_qualifiedIdentifierType(litaC_parser__Parser* litaC_p,litaC_bool litaC_disambiguate) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_lex__Token litaC_name = litaC_parser__Parser_identifier(litaC_p);
    if(litaC_name.type != litaC_lex__TokenType_IDENTIFIER) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_char litaC_buffer[256] = {0};
    litaC_std__string__String litaC_sb = litaC_std__string__StringInit(litaC_buffer, litaC_symbols__MAX_SYMBOL_NAME, 0);
    litaC_std__string__String_appendStrn(&((litaC_sb)), litaC_name.value.str.buffer, litaC_name.value.str.length);
    while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COLON_COLON)) {
        {
            litaC_lex__Token litaC_identifier = litaC_parser__Parser_identifier(litaC_p);
            if(litaC_identifier.type != litaC_lex__TokenType_IDENTIFIER) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_std__string__String_appendStrn(&((litaC_sb)), "::", 2);
            litaC_std__string__String_appendStrn(&((litaC_sb)), litaC_identifier.value.str.buffer, litaC_identifier.value.str.length);
            
            
        }
    }
    litaC_ast__TypeSpec* litaC_spec = litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_NAME, litaC_pos, litaC_p->typeAllocator);
    litaC_spec->name = litaC_intern__Strings_internCopy(&((litaC_p->lita->strings)), litaC_std__string__String_cStr(litaC_sb), litaC_sb.length);
    if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_LESS_THAN)) {
        {
            litaC_spec->genericArgs = litaC_parser__Parser_tryGenericArguments(litaC_p, litaC_disambiguate);
            
            
        }
        
    } 
    
    return litaC_spec;
    
    err:;
    
    return NULL;
    
    
}

litaC_ast__TypeSpec* litaC_parser__Parser_arrayType(litaC_parser__Parser* litaC_p) {
    litaC_ast__TypeSpec* litaC_spec = litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_ARRAY, litaC_parser__Parser_pos(litaC_p), litaC_p->typeAllocator);
    litaC_parser__Parser_advance(litaC_p);
    if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_BRACKET))) {
        {
            litaC_ast__Expr* litaC_expr = litaC_parser__Parser_expression(litaC_p);
            if(!(litaC_ast__Expr_isConstNumberExpr(litaC_expr))) {
                {
                    litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_error_codes__ErrorCode_INVALID_ARRAY_DIMENSION_EXPR);
                    goto err;
                    
                    
                    
                }
                
            } else {
                {
                    litaC_spec->numElements = litaC_expr;
                    
                    
                }
            } 
            
            
            
        }
        
    } 
    
    return litaC_spec;
    
    err:;
    
    return NULL;
    
    
}

litaC_ast__TypeSpec* litaC_parser__Parser_funcPtrType(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_prevPos(litaC_p);
    litaC_ast__TypeSpec* litaC_spec = litaC_ast_new__NewTypeSpec(litaC_ast__TypeSpecKind_FUNC_PTR, litaC_pos, litaC_p->typeAllocator);
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LESS_THAN)) {
        {
            if(!(litaC_parser__Parser_genericParameters(litaC_p, &(litaC_spec->genericParams)))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_PAREN))) {
        {
            do {
                {
                    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_VAR_ARGS)) {
                        {
                            litaC_spec->hasVarargs = litaC_true;
                            if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_PAREN))) {
                                {
                                    litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_error_codes__ErrorCode_INVALID_VARARG_POSITION);
                                    goto err;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_ast__TypeSpec* litaC_arg = litaC_parser__Parser_type(litaC_p, litaC_false);
                            if(!(litaC_arg)) {
                                {
                                    goto err;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_std__array__Array_add_cb__ptr_TypeSpec_ce_(&((litaC_spec->args)), litaC_arg);
                            
                            
                        }
                    } 
                    
                    
                    
                }
            }
            while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COMMA));
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COLON, litaC_error_codes__ErrorCode_MISSING_COLON))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_spec->ret = litaC_parser__Parser_type(litaC_p, litaC_false);
    if(!(litaC_spec->ret)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_spec;
    
    err:;
    
    return NULL;
    
    
}

litaC_ast__ParametersStmt* litaC_parser__Parser_parametersStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_std__array__Array_cb__ptr_ParameterDecl_ce_ litaC_params =  {
        
    };
    litaC_bool litaC_isVarargs = litaC_false;
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_LEFT_PAREN, litaC_error_codes__ErrorCode_MISSING_LEFT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_PAREN))) {
        {
            litaC_std__array__Array_init_cb__ptr_ParameterDecl_ce_(&((litaC_params)), 8, litaC_p->allocator);
            do {
                {
                    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_VAR_ARGS)) {
                        {
                            litaC_isVarargs = litaC_true;
                            if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_PAREN))) {
                                {
                                    litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_error_codes__ErrorCode_INVALID_VARARG_POSITION);
                                    goto err;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_ast__ParameterDecl* litaC_param = litaC_parser__Parser_paramDeclaration(litaC_p);
                            if(!(litaC_param)) {
                                {
                                    goto err;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_std__array__Array_add_cb__ptr_ParameterDecl_ce_(&((litaC_params)), litaC_param);
                            
                            
                        }
                    } 
                    
                    
                    
                }
            }
            while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COMMA));
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return (litaC_ast__ParametersStmt*)litaC_ast_new__NewParametersStmt(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_params, litaC_isVarargs, litaC_p->allocator);
    
    err:;
    
    return NULL;
    
    
}

litaC_bool litaC_parser__Parser_structArguments(litaC_parser__Parser* litaC_p,litaC_std__array__Array_cb__ptr_InitArgExpr_ce_* litaC_arguments) {
    litaC_std__array__Array_init_cb__ptr_InitArgExpr_ce_(litaC_arguments, 16, litaC_p->allocator);
    litaC_i32 litaC_argPosition = 0;
    do {
        {
            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_BRACE)) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
            litaC_ast__Identifier litaC_fieldName =  {
                .str = litaC_intern__EMPTY_STR,
                .token =  {
                    .type = litaC_lex__TokenType_VOID
                }
            };
            if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_DOT)) {
                {
                    litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
                    if(!(litaC_identifier)) {
                        {
                            goto err;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_fieldName.str = litaC_intern__Strings_internStringView(litaC_p->strings, &((litaC_identifier->value.str)));
                    litaC_fieldName.token = *(litaC_identifier);
                    if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_COLON)) {
                        {
                            litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COLON, litaC_error_codes__ErrorCode_MISSING_COLON);
                            
                            
                        }
                        
                    } else {
                        if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_EQUALS)) {
                            {
                                litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_EQUALS, litaC_error_codes__ErrorCode_MISSING_EQUALS);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_error_codes__ErrorCode_MISSING_COLON);
                                goto err;
                                
                                
                                
                            }
                        } 
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            litaC_ast__Expr* litaC_value = litaC_parser__Parser_expression(litaC_p);
            litaC_ast__InitArgExpr* litaC_arg = (litaC_ast__InitArgExpr*)litaC_ast_new__NewInitArgExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_fieldName, litaC_argPosition, litaC_value, litaC_p->allocator);
            litaC_std__array__Array_add_cb__ptr_InitArgExpr_ce_(litaC_arguments, litaC_arg);
            litaC_argPosition += 1;
            
            
        }
    }
    while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COMMA));
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_BRACE, litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACE))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    err:;
    
    return litaC_false;
    
    
}

litaC_bool litaC_parser__Parser_arguments(litaC_parser__Parser* litaC_p,litaC_std__array__Array_cb_CallArg_ce_* litaC_arguments) {
    if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_PAREN))) {
        {
            litaC_std__array__Array_init_cb_CallArg_ce_(litaC_arguments, 8, litaC_p->allocator);
            do {
                {
                    litaC_ast__CallArg litaC_arg =  {
                        .isDefault = litaC_false
                    };
                    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_DOT)) {
                        {
                            litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
                            if(!(litaC_identifier)) {
                                {
                                    goto err;
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_arg.argName.str = litaC_intern__Strings_internStringView(litaC_p->strings, &((litaC_identifier->value.str)));
                            litaC_arg.argName.token = *(litaC_identifier);
                            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_COLON)) {
                                {
                                    litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COLON, litaC_error_codes__ErrorCode_MISSING_COLON);
                                    
                                    
                                }
                                
                            } else {
                                if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_EQUALS)) {
                                    {
                                        litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_EQUALS, litaC_error_codes__ErrorCode_MISSING_EQUALS);
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_error_codes__ErrorCode_MISSING_COLON);
                                        goto err;
                                        
                                        
                                        
                                    }
                                } 
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_arg.argExpr = litaC_parser__Parser_expression(litaC_p);
                    if(litaC_arg.argExpr->stmt.node.kind == litaC_ast__StmtKind_POISON_EXPR) {
                        {
                            goto err;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__array__Array_add_cb_CallArg_ce_(litaC_arguments, litaC_arg);
                    
                    
                }
            }
            while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COMMA));
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_PAREN, litaC_error_codes__ErrorCode_MISSING_RIGHT_PAREN))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    err:;
    
    return litaC_false;
    
    
}

litaC_bool litaC_parser__Parser_genericParameters(litaC_parser__Parser* litaC_p,litaC_std__array__Array_cb_GenericParam_ce_* litaC_arguments) {
    if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_GREATER_THAN))) {
        {
            litaC_std__array__Array_init_cb_GenericParam_ce_(litaC_arguments, 2, litaC_p->allocator);
            do {
                {
                    litaC_lex__Token* litaC_typeName = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
                    if(!(litaC_typeName)) {
                        {
                            goto err;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_ast__Identifier litaC_name =  {
                        .str = litaC_intern__Strings_internStringView(litaC_p->strings, &((litaC_typeName->value.str))),
                        .token = *(litaC_typeName)
                    };
                    litaC_std__array__Array_add_cb_GenericParam_ce_(litaC_arguments, (litaC_ast__GenericParam) {
                        .name = litaC_name
                    });
                    
                    
                }
            }
            while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COMMA));
            
            
        }
        
    } 
    
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_GREATER_THAN, litaC_error_codes__ErrorCode_MISSING_GENERIC_END))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    err:;
    
    return litaC_false;
    
    
}

litaC_std__array__Array_cb__ptr_TypeSpec_ce_ litaC_parser__Parser_genericArguments(litaC_parser__Parser* litaC_p) {
    litaC_std__array__Array_cb__ptr_TypeSpec_ce_ litaC_arguments =  {
        
    };
    if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_GREATER_THAN))) {
        {
            litaC_std__array__Array_init_cb__ptr_TypeSpec_ce_(&((litaC_arguments)), 2, litaC_p->allocator);
            do {
                {
                    litaC_ast__TypeSpec* litaC_type = litaC_parser__Parser_type(litaC_p, litaC_false);
                    if(!(litaC_type)) {
                        {
                            return litaC_arguments;
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__array__Array_add_cb__ptr_TypeSpec_ce_(&((litaC_arguments)), litaC_type);
                    
                    
                }
            }
            while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COMMA));
            
            
        }
        
    } 
    
    litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_GREATER_THAN, litaC_error_codes__ErrorCode_MISSING_GENERIC_END);
    return litaC_arguments;
    
    
}

litaC_std__array__Array_cb__ptr_TypeSpec_ce_ litaC_parser__Parser_tryGenericArguments(litaC_parser__Parser* litaC_p,litaC_bool litaC_disambiguate) {
    litaC_p->tryLevel += 1;
    
    litaC_i32 litaC_backtrack = litaC_p->current;
    litaC_u64 litaC_numOfErrors = litaC_p->tryErrorCounter;
    litaC_parser__Parser_advance(litaC_p);
    litaC_std__array__Array_cb__ptr_TypeSpec_ce_ litaC_arguments = litaC_parser__Parser_genericArguments(litaC_p);
    litaC_bool litaC_isFailed = litaC_false;
    if(litaC_p->tryErrorCounter == litaC_numOfErrors) {
        {
            if(litaC_disambiguate) {
                {
                    litaC_lex__Token* litaC_token = litaC_parser__Parser_peek(litaC_p);
                    switch(litaC_token->type) {
                        case litaC_lex__TokenType_LEFT_PAREN: 
                        case litaC_lex__TokenType_RIGHT_PAREN: 
                        case litaC_lex__TokenType_RIGHT_BRACKET: 
                        case litaC_lex__TokenType_LEFT_BRACE: 
                        case litaC_lex__TokenType_RIGHT_BRACE: 
                        case litaC_lex__TokenType_COLON: 
                        case litaC_lex__TokenType_SEMICOLON: 
                        case litaC_lex__TokenType_COMMA: 
                        case litaC_lex__TokenType_DOT: 
                        case litaC_lex__TokenType_QUESTION_MARK: 
                        case litaC_lex__TokenType_EQUALS_EQUALS: 
                        case litaC_lex__TokenType_NOT_EQUALS: 
                        case litaC_lex__TokenType_OR: 
                        case litaC_lex__TokenType_XOR: 
                        case litaC_lex__TokenType_STAR: {
                            {
                                litaC_std__array__Array_cb__ptr_TypeSpec_ce_ ___result = litaC_arguments;
                                litaC_p->tryLevel -= 1;
                                return ___result;
                                
                            }
                            
                            
                            
                        }
                        default: {
                            {
                                litaC_isFailed = litaC_true;
                                break;
                                
                                
                            }
                            
                            
                        }
                    }
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(litaC_p->tryErrorCounter > litaC_numOfErrors || litaC_isFailed) {
        {
            litaC_parser__Parser_rewindTo(litaC_p, litaC_backtrack, litaC_numOfErrors);
            litaC_isFailed = litaC_true;
            
            
        }
        
    } 
    
    if(litaC_isFailed) {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_arguments)));litaC_i += 1) {
                {
                    litaC_ast__TypeSpec* litaC_type = litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_arguments)), litaC_i);
                    litaC_std__mem__Allocator_free(litaC_p->allocator, litaC_type);
                    
                    
                }
            }
            litaC_std__array__Array_free_cb__ptr_TypeSpec_ce_(&((litaC_arguments)));
            litaC_std__array__Array_clear_cb__ptr_TypeSpec_ce_(&((litaC_arguments)));
            
            
        }
        
    } 
    
    {
        litaC_std__array__Array_cb__ptr_TypeSpec_ce_ ___result = litaC_arguments;
        litaC_p->tryLevel -= 1;
        return ___result;
        
    }
    
    litaC_p->tryLevel -= 1;
    
}

litaC_bool litaC_parser__Parser_arrayArguments(litaC_parser__Parser* litaC_p,litaC_std__array__Array_cb__ptr_Expr_ce_* litaC_arguments) {
    litaC_std__array__Array_init_cb__ptr_Expr_ce_(litaC_arguments, 16, litaC_p->allocator);
    do {
        {
            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_RIGHT_BRACE)) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_ast__Expr* litaC_expr = NULL;
            if(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_LEFT_BRACKET)) {
                {
                    litaC_expr = litaC_parser__Parser_tryArrayDesignationExpr(litaC_p);
                    
                    
                }
                
            } 
            
            if(!(litaC_expr)) {
                {
                    litaC_expr = litaC_parser__Parser_expression(litaC_p);
                    
                    
                }
                
            } 
            
            litaC_std__array__Array_add_cb__ptr_Expr_ce_(litaC_arguments, litaC_expr);
            
            
        }
    }
    while(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_COMMA));
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_BRACE, litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACE))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    err:;
    
    return litaC_false;
    
    
}

litaC_ast__Expr* litaC_parser__Parser_tryArrayDesignationExpr(litaC_parser__Parser* litaC_p) {
    litaC_p->tryLevel += 1;
    
    litaC_i32 litaC_backtrack = litaC_p->current;
    litaC_u64 litaC_numOfErrors = litaC_p->tryErrorCounter;
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_ast__Expr* litaC_designatorExpr = NULL;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_LEFT_BRACKET)) {
        {
            litaC_ast__Expr* litaC_index = litaC_parser__Parser_expression(litaC_p);
            litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_RIGHT_BRACKET, litaC_error_codes__ErrorCode_MISSING_RIGHT_BRACKET);
            litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_EQUALS, litaC_error_codes__ErrorCode_MISSING_EQUALS);
            litaC_ast__Expr* litaC_value = litaC_parser__Parser_expression(litaC_p);
            if(litaC_p->tryErrorCounter == litaC_numOfErrors) {
                {
                    litaC_designatorExpr = litaC_ast_new__NewArrayDesignationExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_index, litaC_value, litaC_p->allocator);
                    
                    
                }
                
            } else {
                {
                    litaC_std__mem__Allocator_free(litaC_p->allocator, litaC_index);
                    litaC_std__mem__Allocator_free(litaC_p->allocator, litaC_value);
                    
                    
                }
            } 
            
            
            
        }
        
    } 
    
    if(litaC_p->tryErrorCounter > litaC_numOfErrors) {
        {
            litaC_parser__Parser_rewindTo(litaC_p, litaC_backtrack, litaC_numOfErrors);
            
            
        }
        
    } 
    
    {
        litaC_ast__Expr* ___result = litaC_designatorExpr;
        litaC_p->tryLevel -= 1;
        return ___result;
        
    }
    
    litaC_p->tryLevel -= 1;
    
}

litaC_ast__FieldStmt litaC_parser__Parser_fieldStatement(litaC_parser__Parser* litaC_p,litaC_ast__StmtKind litaC_aggKind) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_std__array__Array_cb__ptr_NoteStmt_ce_ litaC_notes =  {
        
    };
    if(!(litaC_parser__Parser_notes(litaC_p, &(litaC_notes)))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_bool litaC_isTrait = litaC_aggKind == litaC_ast__StmtKind_TRAIT_DECL;
    if(litaC_isTrait) {
        {
            litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
            if(!(litaC_identifier)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_ast__Identifier litaC_fieldName =  {
                .str = litaC_intern__Strings_internStringView(litaC_p->strings, &((litaC_identifier->value.str))),
                .token = *(litaC_identifier)
            };
            if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COLON, litaC_error_codes__ErrorCode_MISSING_COLON))) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_ast__Attributes litaC_attributes =  {
                .visibility = litaC_ast__Visibility_PRIVATE
            };
            litaC_attributes.notes = litaC_notes;
            litaC_ast__TypeSpec* litaC_type = litaC_parser__Parser_type(litaC_p, litaC_false);
            if(!(litaC_type)) {
                {
                    goto err;
                    
                    
                    
                }
                
            } 
            
            if(litaC_type->kind != litaC_ast__TypeSpecKind_FUNC_PTR) {
                {
                    litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_previous(litaC_p), litaC_error_codes__ErrorCode_INVALID_TRAIT_MEMBER);
                    goto err;
                    
                    
                    
                }
                
            } 
            
            litaC_ast__Stmt* litaC_traitField = litaC_ast_new__NewTraitFieldDecl(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_fieldName, litaC_type, litaC_attributes, litaC_p->allocator);
            return (litaC_ast__FieldStmt) {
                .kind = litaC_ast__StmtKind_TRAIT_FIELD_DECL,
                .traitField = (litaC_ast__TraitFieldDecl*)litaC_traitField
            };
            
            
            
        }
        
    } else {
        {
            litaC_bool litaC_isStruct = litaC_aggKind == litaC_ast__StmtKind_STRUCT_DECL;
            switch(litaC_parser__Parser_peek(litaC_p)->type) {
                case litaC_lex__TokenType_IDENTIFIER: {
                    {
                        litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
                        if(!(litaC_identifier)) {
                            {
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_ast__Identifier litaC_fieldName =  {
                            .str = litaC_intern__Strings_internStringView(litaC_p->strings, &((litaC_identifier->value.str))),
                            .token = *(litaC_identifier)
                        };
                        if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COLON, litaC_error_codes__ErrorCode_MISSING_COLON))) {
                            {
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_ast__Attributes litaC_attributes =  {
                            .visibility = litaC_ast__Visibility_PRIVATE
                        };
                        litaC_attributes.isUsing = litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_USING);
                        litaC_attributes.notes = litaC_notes;
                        litaC_ast__Expr* litaC_defaultExpr = NULL;
                        litaC_ast__TypeSpec* litaC_type = litaC_parser__Parser_type(litaC_p, litaC_false);
                        if(!(litaC_type)) {
                            {
                                goto err;
                                
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_EQUALS)) {
                            {
                                if(!(litaC_isStruct)) {
                                    {
                                        litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_previous(litaC_p), litaC_error_codes__ErrorCode_INVALID_DEFAULT_ASSIGNMENT);
                                        goto err;
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_defaultExpr = litaC_parser__Parser_constExpression(litaC_p);
                                
                                
                            }
                            
                        } 
                        
                        litaC_ast__Stmt* litaC_varField = litaC_ast_new__NewVarFieldDecl(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_fieldName, litaC_type, litaC_attributes, litaC_defaultExpr, litaC_p->allocator);
                        return (litaC_ast__FieldStmt) {
                            .kind = litaC_ast__StmtKind_VAR_FIELD_DECL,
                            .varField = (litaC_ast__VarFieldDecl*)litaC_varField
                        };
                        
                        
                        
                    }
                    
                    
                }
                case litaC_lex__TokenType_STRUCT: {
                    {
                        litaC_parser__Parser_advance(litaC_p);
                        litaC_ast__Decl* litaC_structField = litaC_parser__Parser_structDeclaration(litaC_p);
                        litaC_structField->stmt.node.startPos = litaC_pos;
                        litaC_structField->attributes.notes = litaC_notes;
                        return (litaC_ast__FieldStmt) {
                            .kind = litaC_ast__StmtKind_STRUCT_FIELD_DECL,
                            .aggregateField = (litaC_ast__AggregateDecl*)litaC_structField
                        };
                        
                        
                        
                    }
                    
                    
                }
                case litaC_lex__TokenType_UNION: {
                    {
                        litaC_parser__Parser_advance(litaC_p);
                        litaC_ast__Decl* litaC_unionField = litaC_parser__Parser_unionDeclaration(litaC_p);
                        litaC_unionField->stmt.node.startPos = litaC_pos;
                        litaC_unionField->attributes.notes = litaC_notes;
                        return (litaC_ast__FieldStmt) {
                            .kind = litaC_ast__StmtKind_UNION_FIELD_DECL,
                            .aggregateField = (litaC_ast__AggregateDecl*)litaC_unionField
                        };
                        
                        
                        
                    }
                    
                    
                }
                case litaC_lex__TokenType_ENUM: {
                    {
                        litaC_parser__Parser_advance(litaC_p);
                        litaC_ast__Decl* litaC_enumField = litaC_parser__Parser_enumDeclaration(litaC_p);
                        litaC_enumField->stmt.node.startPos = litaC_pos;
                        litaC_enumField->attributes.notes = litaC_notes;
                        return (litaC_ast__FieldStmt) {
                            .kind = litaC_ast__StmtKind_ENUM_FIELD_DECL,
                            .enumField = (litaC_ast__EnumDecl*)litaC_enumField
                        };
                        
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        litaC_parser__Parser_errorAtToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_error_codes__ErrorCode_INVALID_FIELD);
                        litaC_parser__Parser_advance(litaC_p);
                        goto err;
                        
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    } 
    
    err:;
    
    return (litaC_ast__FieldStmt) {
        .kind = litaC_ast__StmtKind_POISON_EXPR
    };
    
    
}

litaC_ast__FieldStmt litaC_parser__Parser_noteFieldStatement(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_identifier)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Identifier litaC_fieldName =  {
        .str = litaC_intern__Strings_internStringView(litaC_p->strings, &((litaC_identifier->value.str))),
        .token = *(litaC_identifier)
    };
    if(!(litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_COLON, litaC_error_codes__ErrorCode_MISSING_COLON))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Attributes litaC_attributes =  {
        .visibility = litaC_ast__Visibility_PRIVATE
    };
    litaC_ast__Expr* litaC_defaultExpr = NULL;
    litaC_ast__TypeSpec* litaC_type = litaC_parser__Parser_type(litaC_p, litaC_false);
    if(!(litaC_type)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_EQUALS)) {
        {
            litaC_defaultExpr = litaC_parser__Parser_constExpression(litaC_p);
            
            
        }
        
    } 
    
    litaC_ast__Stmt* litaC_varField = litaC_ast_new__NewVarFieldDecl(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_fieldName, litaC_type, litaC_attributes, litaC_defaultExpr, litaC_p->allocator);
    return (litaC_ast__FieldStmt) {
        .kind = litaC_ast__StmtKind_VAR_FIELD_DECL,
        .varField = (litaC_ast__VarFieldDecl*)litaC_varField
    };
    
    err:;
    
    return (litaC_ast__FieldStmt) {
        .kind = litaC_ast__StmtKind_POISON_EXPR
    };
    
    
}

litaC_ast__EnumFieldEntryDecl* litaC_parser__Parser_enumFieldEntryDecl(litaC_parser__Parser* litaC_p) {
    litaC_lex__SrcPos litaC_pos = litaC_parser__Parser_pos(litaC_p);
    litaC_std__array__Array_cb__ptr_NoteStmt_ce_ litaC_notes =  {
        
    };
    if(!(litaC_parser__Parser_notes(litaC_p, &(litaC_notes)))) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(!(litaC_identifier)) {
        {
            goto err;
            
            
            
        }
        
    } 
    
    litaC_ast__Identifier litaC_fieldName =  {
        .str = litaC_intern__Strings_internStringView(litaC_p->strings, &((litaC_identifier->value.str))),
        .token = *(litaC_identifier)
    };
    litaC_ast__Expr* litaC_value = NULL;
    if(litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_EQUALS)) {
        {
            litaC_value = litaC_parser__Parser_constExpression(litaC_p);
            
            
        }
        
    } 
    
    litaC_ast__Attributes litaC_attributes =  {
        .notes = litaC_notes,
        .visibility = litaC_ast__Visibility_PRIVATE
    };
    return (litaC_ast__EnumFieldEntryDecl*)litaC_ast_new__NewEnumFieldEntryDecl(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_fieldName, litaC_value, litaC_attributes, litaC_p->allocator);
    
    err:;
    
    return NULL;
    
    
}

litaC_void litaC_parser__Parser_rewindTo(litaC_parser__Parser* litaC_p,litaC_i32 litaC_backtrack,litaC_u64 litaC_numOfErrors) {
    assert(litaC_p->tryErrorCounter >= litaC_numOfErrors);
    {
        litaC_p->current = litaC_backtrack;
        litaC_p->tryErrorCounter = litaC_numOfErrors;
        
        
    }
    
}

litaC_ast__Expr* litaC_parser__Parser_tryBitShiftRight(litaC_parser__Parser* litaC_p,litaC_ast__Expr* litaC_expr) {
    if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_GREATER_THAN))) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_lex__Token* litaC_prevToken = litaC_parser__Parser_advancep(litaC_p);
    if(!(litaC_parser__Parser_check(litaC_p, litaC_lex__TokenType_GREATER_THAN))) {
        {
            litaC_parser__Parser_rewind(litaC_p);
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_lex__Token* litaC_nextToken = litaC_parser__Parser_advancep(litaC_p);
    if((litaC_nextToken->pos.position - litaC_prevToken->pos.position) == 1) {
        {
            litaC_ast__Expr* litaC_right = litaC_parser__Parser_term(litaC_p);
            return litaC_ast_new__NewBinaryExpr(litaC_expr->stmt.node.startPos, litaC_parser__Parser_pos(litaC_p), litaC_expr, litaC_lex__TokenType_RSHIFT, litaC_right, litaC_p->allocator);
            
            
            
        }
        
    } 
    
    litaC_parser__Parser_rewind(litaC_p);
    litaC_parser__Parser_rewind(litaC_p);
    return NULL;
    
    
}

litaC_void litaC_parser__Parser_eatSemicolon(litaC_parser__Parser* litaC_p) {
    litaC_parser__Parser_match(litaC_p, litaC_lex__TokenType_SEMICOLON);
    
}

litaC_lex__Token litaC_parser__Parser_identifier(litaC_parser__Parser* litaC_p) {
    litaC_lex__Token litaC_name =  {
        .type = litaC_lex__TokenType_ERROR
    };
    litaC_lex__Token* litaC_identifier = litaC_parser__Parser_consume(litaC_p, litaC_lex__TokenType_IDENTIFIER, litaC_error_codes__ErrorCode_MISSING_IDENTIFIER);
    if(litaC_identifier) {
        {
            litaC_name = *(litaC_identifier);
            
            
        }
        
    } 
    
    return litaC_name;
    
    
}

litaC_bool litaC_parser__Parser_checkConstExpr(litaC_parser__Parser* litaC_p,litaC_ast__Expr* litaC_expr) {
    if(!(litaC_expr)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_expr->stmt.node.kind) {
        case litaC_ast__StmtKind_NUMBER_EXPR: 
        case litaC_ast__StmtKind_BOOLEAN_EXPR: 
        case litaC_ast__StmtKind_STRING_EXPR: 
        case litaC_ast__StmtKind_CHAR_EXPR: 
        case litaC_ast__StmtKind_NULL_EXPR: 
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_GET_EXPR: {
            {
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_INIT_EXPR: {
            {
                litaC_ast__ArrayInitExpr* litaC_arrayInitExpr = (litaC_ast__ArrayInitExpr*)litaC_expr;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Expr_ce_(&((litaC_arrayInitExpr->values)));litaC_i += 1) {
                    {
                        litaC_ast__Expr* litaC_arg = litaC_std__array__Array_get_cb__ptr_Expr_ce_(&((litaC_arrayInitExpr->values)), litaC_i);
                        if(!(litaC_parser__Parser_checkConstExpr(litaC_p, litaC_arg))) {
                            {
                                return litaC_false;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                return litaC_true;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GROUP_EXPR: {
            {
                litaC_ast__GroupExpr* litaC_groupExpr = (litaC_ast__GroupExpr*)litaC_expr;
                return litaC_parser__Parser_checkConstExpr(litaC_p, litaC_groupExpr->groupedExpr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BINARY_EXPR: {
            {
                litaC_ast__BinaryExpr* litaC_binExpr = (litaC_ast__BinaryExpr*)litaC_expr;
                return litaC_parser__Parser_checkConstExpr(litaC_p, litaC_binExpr->left) && litaC_parser__Parser_checkConstExpr(litaC_p, litaC_binExpr->right);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNARY_EXPR: {
            {
                litaC_ast__UnaryExpr* litaC_unaryExpr = (litaC_ast__UnaryExpr*)litaC_expr;
                return litaC_parser__Parser_checkConstExpr(litaC_p, litaC_unaryExpr->unaryExpr);
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_OF_EXPR: 
        case litaC_ast__StmtKind_SIZE_OF_EXPR: {
            return litaC_true;
            
            
            
        }
        default: {
            {
                litaC_parser__Parser_errorAtPos(litaC_p, litaC_expr->stmt.node.startPos, litaC_error_codes__ErrorCode_INVALID_CONST_EXPR);
                
                
            }
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_ast__Stmt* litaC_parser__Parser_poisonStatement(litaC_parser__Parser* litaC_p,litaC_lex__SrcPos litaC_pos) {
    return (litaC_ast__Stmt*)litaC_ast_new__NewPoisonExpr(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
    
    
}

litaC_ast__Expr* litaC_parser__Parser_poisonExpr(litaC_parser__Parser* litaC_p,litaC_lex__SrcPos litaC_pos) {
    return litaC_ast_new__NewPoisonExpr(litaC_parser__Parser_prevPos(litaC_p), litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
    
    
}

litaC_ast__Decl* litaC_parser__Parser_poisonDecl(litaC_parser__Parser* litaC_p,litaC_lex__SrcPos litaC_pos) {
    return litaC_ast_new__NewPoisonDecl(litaC_pos, litaC_parser__Parser_pos(litaC_p), litaC_p->allocator);
    
    
}

LITAC_INLINE 
litaC_lex__SrcPos litaC_parser__Parser_pos(litaC_parser__Parser* litaC_p) {
    return litaC_p->tokens.elements[litaC_p->current].pos;
    
    
}

litaC_lex__SrcPos litaC_parser__Parser_prevPos(litaC_parser__Parser* litaC_p) {
    return litaC_parser__Parser_previous(litaC_p)->pos;
    
    
}

LITAC_INLINE 
litaC_lex__Token* litaC_parser__Parser_peek(litaC_parser__Parser* litaC_p) {
    assert(litaC_p->current >= 0 && litaC_p->current <= litaC_std__array__Array_size_cb_Token_ce_(&((litaC_p->tokens))));
    if(litaC_p->current >= litaC_std__array__Array_size_cb_Token_ce_(&((litaC_p->tokens)))) {
        {
            return &(litaC_p->tokens.elements[litaC_std__array__Array_size_cb_Token_ce_(&((litaC_p->tokens))) - 1]);
            
            
            
        }
        
    } 
    
    return &(litaC_p->tokens.elements[litaC_p->current]);
    
    
}

litaC_void litaC_parser__Parser_rewind(litaC_parser__Parser* litaC_p) {
    litaC_p->current -= 1;
    if(litaC_p->current < 0) {
        {
            litaC_p->current = 0;
            
            
        }
        
    } 
    
    
}

litaC_lex__Token* litaC_parser__Parser_previous(litaC_parser__Parser* litaC_p) {
    litaC_i32 litaC_index = litaC_p->current - 1;
    assert(litaC_index < litaC_std__array__Array_size_cb_Token_ce_(&((litaC_p->tokens))) && litaC_index >= 0);
    return &(litaC_p->tokens.elements[litaC_index]);
    
    
}

litaC_bool litaC_parser__Parser_atEnd(litaC_parser__Parser* litaC_p) {
    if(litaC_p->current < litaC_std__array__Array_size_cb_Token_ce_(&((litaC_p->tokens))) - 1) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    assert(!(litaC_std__array__Array_empty_cb_Token_ce_(&((litaC_p->tokens)))));
    return litaC_p->current >= litaC_std__array__Array_size_cb_Token_ce_(&((litaC_p->tokens))) || litaC_parser__Parser_peek(litaC_p)->type == litaC_lex__TokenType_END_OF_FILE;
    
    
}

litaC_void litaC_parser__Parser_advance(litaC_parser__Parser* litaC_p) {
    if(!(litaC_parser__Parser_atEnd(litaC_p))) {
        {
            litaC_p->current += 1;
            
            
        }
        
    } 
    
    
}

litaC_lex__Token* litaC_parser__Parser_advancep(litaC_parser__Parser* litaC_p) {
    if(!(litaC_parser__Parser_atEnd(litaC_p))) {
        {
            litaC_p->current += 1;
            
            
        }
        
    } 
    
    return litaC_parser__Parser_previous(litaC_p);
    
    
}

LITAC_INLINE 
litaC_bool litaC_parser__Parser_check(litaC_parser__Parser* litaC_p,litaC_lex__TokenType litaC_type) {
    litaC_lex__Token* litaC_token = litaC_parser__Parser_peek(litaC_p);
    assert(litaC_token != NULL);
    return litaC_token->type == litaC_type;
    
    
}

litaC_bool litaC_parser__Parser_match(litaC_parser__Parser* litaC_p,litaC_lex__TokenType litaC_type) {
    if(litaC_parser__Parser_check(litaC_p, litaC_type)) {
        {
            litaC_parser__Parser_advance(litaC_p);
            return litaC_true;
            
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_bool litaC_parser__Parser_matches(litaC_parser__Parser* litaC_p,litaC_lex__TokenType* litaC_types,litaC_i32 litaC_len) {
    litaC_lex__TokenType litaC_tokenType = litaC_parser__Parser_peek(litaC_p)->type;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_len;litaC_i += 1) {
        {
            litaC_lex__TokenType litaC_type = litaC_types[litaC_i];
            if(litaC_tokenType == litaC_type) {
                {
                    litaC_parser__Parser_advance(litaC_p);
                    return litaC_true;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_lex__Token* litaC_parser__Parser_consume(litaC_parser__Parser* litaC_p,litaC_lex__TokenType litaC_type,litaC_error_codes__ErrorCode litaC_errorCode) {
    if(litaC_parser__Parser_check(litaC_p, litaC_type)) {
        {
            return litaC_parser__Parser_advancep(litaC_p);
            
            
            
        }
        
    } 
    
    litaC_parser__Parser_errorUnexpectedToken(litaC_p, litaC_parser__Parser_peek(litaC_p), litaC_errorCode);
    return NULL;
    
    
}

litaC_void litaC_parser__Parser_adjust(litaC_parser__Parser* litaC_p,litaC_lex__TokenType* litaC_types,litaC_i32 litaC_len) {
    litaC_p->panicMode = litaC_false;
    if(!(litaC_types) || litaC_len < 1) {
        {
            litaC_parser__Parser_advance(litaC_p);
            return;
            
            
            
        }
        
    } 
    
    while(!(litaC_parser__Parser_atEnd(litaC_p))) {
        {
            litaC_lex__TokenType litaC_type = litaC_parser__Parser_peek(litaC_p)->type;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_len;litaC_i += 1) {
                {
                    if(litaC_types[litaC_i] == litaC_type) {
                        {
                            return;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            litaC_parser__Parser_advance(litaC_p);
            
            
        }
    }
    
}

litaC_void litaC_parser__Parser_errorAtToken(litaC_parser__Parser* litaC_p,litaC_lex__Token* litaC_token,litaC_error_codes__ErrorCode litaC_errorCode) {
    if(!(litaC_token)) {
        {
            litaC_parser__Parser_errorAtPos(litaC_p, litaC_parser__Parser_pos(litaC_p), litaC_errorCode);
            
            
        }
        
    } else {
        {
            litaC_parser__Parser_errorAtPos(litaC_p, litaC_token->pos, litaC_errorCode);
            
            
        }
    } 
    
    
}

litaC_void litaC_parser__Parser_errorAtPos(litaC_parser__Parser* litaC_p,litaC_lex__SrcPos litaC_pos,litaC_error_codes__ErrorCode litaC_errorCode) {
    
    if(litaC_p->tryLevel > 0) {
        {
            litaC_p->tryErrorCounter += 1;
            litaC_parser__Parser_advance(litaC_p);
            return;
            
            
            
        }
        
    } 
    
    if(litaC_p->panicMode) {
        {
            litaC_parser__Parser_advance(litaC_p);
            return;
            
            
            
        }
        
    } 
    
    litaC_p->panicMode = litaC_true;
    litaC_phase_result__PhaseResult_addError(litaC_p->result, litaC_pos, "%s", litaC_error_codes__errorCodeText[litaC_errorCode]);
    litaC_parser__Parser_advance(litaC_p);
    
}

litaC_void litaC_parser__Parser_errorUnexpectedToken(litaC_parser__Parser* litaC_p,litaC_lex__Token* litaC_token,litaC_error_codes__ErrorCode litaC_errorCode) {
    if(litaC_token) {
        {
            
            if(litaC_p->tryLevel > 0) {
                {
                    litaC_p->tryErrorCounter += 1;
                    litaC_parser__Parser_advance(litaC_p);
                    return;
                    
                    
                    
                }
                
            } 
            
            if(litaC_p->panicMode) {
                {
                    litaC_parser__Parser_advance(litaC_p);
                    return;
                    
                    
                    
                }
                
            } 
            
            litaC_p->panicMode = litaC_true;
            litaC_phase_result__PhaseResult_addError(litaC_p->result, litaC_parser__Parser_pos(litaC_p), "Unexpected token: '%s' - %s", litaC_lex__tokenText[litaC_token->type], litaC_error_codes__errorCodeText[litaC_errorCode]);
            litaC_parser__Parser_advance(litaC_p);
            
            
        }
        
    } else {
        {
            litaC_parser__Parser_errorAtPos(litaC_p, litaC_parser__Parser_pos(litaC_p), litaC_errorCode);
            
            
        }
    } 
    
    
}

litaC_i32 litaC_parser__Parser_numOfErrors(litaC_parser__Parser* litaC_p) {
    return litaC_std__array__Array_size_cb_PhaseError_ce_(&((litaC_p->result->errors)));
    
    
}

litaC_void litaC_lsp__workspace__Workspace_init(litaC_lsp__workspace__Workspace* litaC_this,litaC_lsp__lsp__LspServer* litaC_lsp,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_this->allocator = litaC_alloc;
    litaC_this->lsp = litaC_lsp;
    litaC_this->openedDocuments = litaC_std__map__StrMap_cb__ptr_Document_ce_(NULL, 64, litaC_this->allocator);
    
}

litaC_void litaC_lsp__workspace__Workspace_setup(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_rootPath,const litaC_char* litaC_rootUri) {
    litaC_this->rootPath = litaC_rootPath;
    litaC_lita__Lita* litaC_lita = litaC_this->lsp->lita;
    litaC_char litaC_filepath[_MAX_PATH] =  {
        0
    };
    litaC_std__string__String litaC_pathStr = litaC_std__string__StringInit(litaC_filepath, _MAX_PATH, 0);
    litaC_std__string__String_format(&((litaC_pathStr)), "%s/src/main.lita", litaC_rootPath);
    litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Checking for main at: '%s'...", litaC_std__string__String_cStr(litaC_pathStr));
    if(!(litaC_std__system__FileExists(litaC_std__string__String_cStrConst(litaC_pathStr)))) {
        {
            litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "unable to find main.lita from '%s'\n", litaC_rootPath);
            return;
            
            
            
        }
        
    } 
    
    litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "found!\n");
    litaC_std__system__GetAbsolutePath("", litaC_std__string__String_cStr(litaC_pathStr), litaC_lita->options->inputFile);
    litaC_std__system__FilePath(litaC_lita->options->inputFile, litaC_lita->options->srcPath);
    const litaC_char* litaC_lib = litaC_std__system__GetEnv("LITAC_HOME");
    if(!(litaC_lib)) {
        litaC_lib = "";
        
    } 
    
    litaC_std__system__GetAbsolutePath("", litaC_lib, litaC_lita->options->litaPath);
    litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Lita.inputFile = '%s'\nLita.srcPath = '%s'\nLita.libPath = '%s'\nLita.litaPath = '%s'\n", litaC_lita->options->inputFile, litaC_lita->options->srcPath, litaC_lita->options->libPath, litaC_lita->options->litaPath);
    litaC_lita->options->checkerOnly = litaC_true;
    litaC_lsp__workspace__Workspace_runDiagnostics(litaC_this, NULL, litaC_true);
    
}

litaC_bool litaC_lsp__workspace__Workspace_isDocumentOpen(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_uri) {
    if(!(litaC_uri)) {
        return litaC_false;
        
        
    } 
    
    return litaC_std__map__Map_contains_cb__ptr_const_char_c__ptr_Document_ce_(&((litaC_this->openedDocuments)), litaC_uri);
    
    
}

litaC_void litaC_lsp__workspace__Workspace_openDocument(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_uri,const litaC_char* litaC_text) {
    if(!(litaC_uri)) {
        return;
        
        
    } 
    
    litaC_char* litaC_moduleUri = litaC_std__string__StringClone(litaC_uri, -(1), litaC_this->allocator);
    litaC_lsp__document__Document* litaC_doc = litaC_std__mem__new_cb_Document_ce_(litaC_this->allocator);
    litaC_std__array__Array_init_cb_u32_ce_(&((litaC_doc->lineMap)), 256, litaC_this->allocator);
    litaC_doc->text = litaC_std__string_buffer__StringBufferInit(strlen(litaC_text), litaC_this->allocator);
    litaC_lsp__document__Document_setText(litaC_doc, litaC_text);
    litaC_std__system__UriToFilePath(litaC_uri, litaC_doc->filename);
    litaC_std__map__Map_put_cb__ptr_const_char_c__ptr_Document_ce_(&((litaC_this->openedDocuments)), litaC_moduleUri, litaC_doc);
    
}

litaC_void litaC_lsp__workspace__Workspace_closeDocument(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_uri) {
    if(!(litaC_uri)) {
        return;
        
        
    } 
    
    litaC_lsp__document__Document* litaC_doc = litaC_std__map__Map_remove_cb__ptr_const_char_c__ptr_Document_ce_(&((litaC_this->openedDocuments)), litaC_uri);
    if(!(litaC_doc)) {
        {
            
            
        }
        
    } 
    
    
}

litaC_void litaC_lsp__workspace__Workspace_saveDocument(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_uri) {
    if(!(litaC_uri)) {
        return;
        
        
    } 
    
    
}

litaC_void litaC_lsp__workspace__Workspace_changeDocument(litaC_lsp__workspace__Workspace* litaC_this,litaC_lsp__protocol__TextDocumentDidChange* litaC_change) {
    if(!(litaC_change)) {
        return;
        
        
    } 
    
    litaC_lsp__document__Document* litaC_doc = litaC_std__map__Map_get_cb__ptr_const_char_c__ptr_Document_ce_(&((litaC_this->openedDocuments)), litaC_change->textDocument.uri);
    if(!(litaC_doc)) {
        {
            return;
            
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_TextDocumentChangeEvent_ce_(&((litaC_change->contentChanges)));litaC_i += 1) {
        {
            litaC_lsp__protocol__TextDocumentChangeEvent* litaC_event = litaC_std__array__Array_getPtr_cb_TextDocumentChangeEvent_ce_(&((litaC_change->contentChanges)), litaC_i);
            if(litaC_event->hasRange) {
                {
                    litaC_lsp__document__Document_insert(litaC_doc, litaC_event->range, litaC_event->text);
                    
                    
                }
                
            } else {
                {
                    litaC_lsp__document__Document_setText(litaC_doc, litaC_event->text);
                    
                    
                }
            } 
            
            
            
        }
    }
    litaC_lsp__workspace__Workspace_runDiagnostics(litaC_this, litaC_change->textDocument.uri, litaC_false);
    
}

litaC_std__json__JsonNode* litaC_lsp__workspace__Workspace_documentSymbols(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_uri,const litaC_std__mem__Allocator* litaC_alloc) {
    if(!(litaC_uri)) {
        return NULL;
        
        
    } 
    
    litaC_lsp__document__Document* litaC_doc = litaC_std__map__Map_get_cb__ptr_const_char_c__ptr_Document_ce_(&((litaC_this->openedDocuments)), litaC_uri);
    if(!(litaC_doc)) {
        return NULL;
        
        
    } 
    
    litaC_module__Module* litaC_module = litaC_lita__Lita_getModule(litaC_this->lsp->lita, litaC_doc->filename);
    if(!(litaC_module)) {
        return NULL;
        
        
    } 
    
    litaC_std__json__JsonNode* litaC_results = litaC_std__json__CreateJsonArray(litaC_alloc);
    litaC_symbols__Scope* litaC_syms = &(litaC_module->symbols);
    litaC_lsp__workspace__Workspace_addDocumentSymbols(litaC_this, litaC_results, litaC_module, *((&(litaC_syms->symbolNotes))), litaC_doc->filename, litaC_alloc);
    litaC_lsp__workspace__Workspace_addDocumentSymbols(litaC_this, litaC_results, litaC_module, *((&(litaC_syms->symbolTypes))), litaC_doc->filename, litaC_alloc);
    litaC_lsp__workspace__Workspace_addDocumentSymbols(litaC_this, litaC_results, litaC_module, *((&(litaC_syms->symbolFuncs))), litaC_doc->filename, litaC_alloc);
    return litaC_results;
    
    
}

litaC_void litaC_lsp__workspace__Workspace_addDocumentSymbols(litaC_lsp__workspace__Workspace* litaC_this,litaC_std__json__JsonNode* litaC_results,litaC_module__Module* litaC_module,litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_ litaC_symbols,const litaC_char* litaC_docFilename,const litaC_std__mem__Allocator* litaC_alloc) {
    for(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_ litaC_it = litaC_std__map__Map_iter_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_symbols)));litaC_std__map__MapIterator_hasNext_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_std__map__MapIterator_next_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it))).value;
            if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_MARKED_RESET) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_FROM_GENERIC_TEMPLATE) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_HIDDEN) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(!(litaC_module__Module_equals(litaC_sym->declared, litaC_module))) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_std__json__JsonNode* litaC_info = litaC_lsp__protocol__SymbolToSymbolInformation(litaC_sym, litaC_this->rootPath, litaC_alloc);
            if(litaC_info) {
                {
                    litaC_std__json__JsonNode_add(litaC_results, litaC_info);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

litaC_std__json__JsonNode* litaC_lsp__workspace__Workspace_references(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_uri,litaC_std__json__JsonNode* litaC_position,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "looking up references...\n");
    if(!(litaC_uri) || !(litaC_position)) {
        return litaC_std__json__JSON_NULL;
        
        
    } 
    
    litaC_lsp__util__SourceLocation litaC_location = litaC_lsp__workspace__Workspace_getNodeAtSourcePos(litaC_this, litaC_uri, litaC_position);
    if(litaC_location.kind == litaC_lsp__util__SourceLocationKind_NONE) {
        {
            return litaC_std__json__JSON_NULL;
            
            
            
        }
        
    } 
    
    if(litaC_location.kind == litaC_lsp__util__SourceLocationKind_AST) {
        {
            litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Found ast node: %s\n", litaC_ast__StmtKindAsStr(litaC_location.node->kind));
            switch(litaC_location.node->kind) {
                case litaC_ast__StmtKind_NATIVE_DECL: 
                case litaC_ast__StmtKind_TYPEDEF_DECL: 
                case litaC_ast__StmtKind_UNION_DECL: 
                case litaC_ast__StmtKind_STRUCT_DECL: 
                case litaC_ast__StmtKind_TRAIT_DECL: 
                case litaC_ast__StmtKind_ENUM_DECL: 
                case litaC_ast__StmtKind_FUNC_DECL: {
                    {
                        litaC_ast__Decl* litaC_decl = (litaC_ast__Decl*)litaC_location.node;
                        if(litaC_decl->sym && litaC_decl->sym->type) {
                            {
                                litaC_i64 litaC_typeid = litaC_decl->sym->type->typeid;
                                return litaC_lsp__workspace__Workspace_findTypeReferences(litaC_this, litaC_typeid, litaC_alloc);
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        litaC_ast__TraitFieldDecl* litaC_varField = (litaC_ast__TraitFieldDecl*)litaC_location.node;
                        litaC_ast__Node* litaC_parentNode = litaC_varField->decl.stmt.node.parent;
                        while(litaC_parentNode && (litaC_parentNode->kind == litaC_ast__StmtKind_UNION_DECL || litaC_parentNode->kind == litaC_ast__StmtKind_STRUCT_DECL)) {
                            {
                                litaC_ast__AggregateDecl* litaC_decl = (litaC_ast__AggregateDecl*)litaC_parentNode;
                                if(litaC_decl->flags & litaC_ast__AggregateFlags_IS_ANONYMOUS) {
                                    {
                                        litaC_parentNode = litaC_decl->decl.declaration.stmt.node.parent;
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        litaC_types__TypeInfo* litaC_parentType = litaC_decl->decl.declaration.sym->type;
                                        if(litaC_parentType) {
                                            {
                                                litaC_types__TypeInfo* litaC_aggInfo = litaC_parentType;
                                                litaC_types__FieldPositionResult litaC_fieldResult = litaC_types__TypeInfo_getFieldPosition(litaC_aggInfo, litaC_varField->decl.name.str);
                                                litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Getting field position: %d\n", litaC_fieldResult.position);
                                                if(litaC_fieldResult.aggInfo) {
                                                    {
                                                        return litaC_lsp__workspace__Workspace_findFieldReferences(litaC_this, litaC_fieldResult.aggInfo->typeid, litaC_fieldResult.position, litaC_alloc);
                                                        
                                                        
                                                        
                                                    }
                                                    
                                                } 
                                                
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        break;
                                        
                                        
                                    }
                                } 
                                
                                
                                
                            }
                        }
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = (litaC_ast__VarFieldDecl*)litaC_location.node;
                        litaC_ast__Node* litaC_parentNode = litaC_varField->decl.stmt.node.parent;
                        while(litaC_parentNode && (litaC_parentNode->kind == litaC_ast__StmtKind_UNION_DECL || litaC_parentNode->kind == litaC_ast__StmtKind_STRUCT_DECL)) {
                            {
                                litaC_ast__AggregateDecl* litaC_decl = (litaC_ast__AggregateDecl*)litaC_parentNode;
                                if(litaC_decl->flags & litaC_ast__AggregateFlags_IS_ANONYMOUS) {
                                    {
                                        litaC_parentNode = litaC_decl->decl.declaration.stmt.node.parent;
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        litaC_types__TypeInfo* litaC_parentType = litaC_decl->decl.declaration.sym->type;
                                        if(litaC_parentType) {
                                            {
                                                litaC_types__TypeInfo* litaC_aggInfo = litaC_parentType;
                                                litaC_types__FieldPositionResult litaC_fieldResult = litaC_types__TypeInfo_getFieldPosition(litaC_aggInfo, litaC_varField->decl.name.str);
                                                litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Getting field position: %d\n", litaC_fieldResult.position);
                                                if(litaC_fieldResult.aggInfo) {
                                                    {
                                                        return litaC_lsp__workspace__Workspace_findFieldReferences(litaC_this, litaC_fieldResult.aggInfo->typeid, litaC_fieldResult.position, litaC_alloc);
                                                        
                                                        
                                                        
                                                    }
                                                    
                                                } 
                                                
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        break;
                                        
                                        
                                    }
                                } 
                                
                                
                                
                            }
                        }
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_CONST_DECL: 
                case litaC_ast__StmtKind_VAR_DECL: 
                case litaC_ast__StmtKind_PARAM_DECL: {
                    {
                        litaC_ast__Decl* litaC_decl = (litaC_ast__Decl*)litaC_location.node;
                        litaC_std__array__Array_cb_SrcPos_ce_ litaC_result = litaC_lsp__references__ReferenceDatabase_getSymbolReferences(&((litaC_this->lsp->lita->references)), litaC_decl->sym);
                        return litaC_lsp__protocol__SrcPosToLocations(litaC_this->rootPath, &(litaC_result), litaC_alloc);
                        
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_INIT_ARG_EXPR: {
                    {
                        litaC_ast__InitArgExpr* litaC_arg = (litaC_ast__InitArgExpr*)litaC_location.node;
                        litaC_ast__Node* litaC_parentNode = litaC_arg->expr.stmt.node.parent;
                        if(litaC_parentNode && (litaC_parentNode->kind == litaC_ast__StmtKind_INIT_EXPR)) {
                            {
                                litaC_ast__InitExpr* litaC_init = (litaC_ast__InitExpr*)litaC_parentNode;
                                litaC_types__TypeInfo* litaC_parentType = litaC_init->expr.operand.typeInfo;
                                if(litaC_types__IsAggregate(litaC_parentType)) {
                                    {
                                        litaC_types__TypeInfo* litaC_aggInfo = litaC_parentType;
                                        litaC_types__FieldPositionResult litaC_fieldResult = litaC_types__TypeInfo_getFieldPosition(litaC_aggInfo, litaC_arg->fieldName.str);
                                        if(litaC_fieldResult.aggInfo) {
                                            {
                                                litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Getting field position: %llu %d\n", litaC_fieldResult.aggInfo->typeid, litaC_fieldResult.position);
                                                return litaC_lsp__workspace__Workspace_findFieldReferences(litaC_this, litaC_fieldResult.aggInfo->typeid, litaC_fieldResult.position, litaC_alloc);
                                                
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: {
                    {
                        litaC_ast__IdentifierExpr* litaC_expr = (litaC_ast__IdentifierExpr*)litaC_location.node;
                        if(litaC_expr->sym && litaC_expr->sym->type) {
                            {
                                return litaC_lsp__workspace__Workspace_findTypeReferences(litaC_this, litaC_expr->sym->type->typeid, litaC_alloc);
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_IDENTIFIER_EXPR: {
                    {
                        litaC_ast__IdentifierExpr* litaC_expr = (litaC_ast__IdentifierExpr*)litaC_location.node;
                        litaC_std__array__Array_cb_SrcPos_ce_ litaC_result = litaC_lsp__references__ReferenceDatabase_getSymbolReferences(&((litaC_this->lsp->lita->references)), litaC_expr->sym);
                        return litaC_lsp__protocol__SrcPosToLocations(litaC_this->rootPath, &(litaC_result), litaC_alloc);
                        
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_GET_EXPR: {
                    {
                        litaC_ast__GetExpr* litaC_expr = (litaC_ast__GetExpr*)litaC_location.node;
                        litaC_types__TypeInfo* litaC_base = litaC_types__TypeInfo_getBaseType(litaC_expr->object->operand.typeInfo);
                        if(litaC_types__IsAggregate(litaC_base)) {
                            {
                                litaC_types__TypeInfo* litaC_aggInfo = litaC_base;
                                litaC_types__FieldPositionResult litaC_fieldResult = litaC_types__TypeInfo_getFieldPosition(litaC_aggInfo, litaC_expr->field->type->name);
                                litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Getting field position: %d\n", litaC_fieldResult.position);
                                if(litaC_fieldResult.aggInfo) {
                                    {
                                        return litaC_lsp__workspace__Workspace_findFieldReferences(litaC_this, litaC_fieldResult.aggInfo->typeid, litaC_fieldResult.position, litaC_alloc);
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } else {
                            if(litaC_base->kind == litaC_types__TypeKind_ENUM) {
                                {
                                    litaC_types__TypeInfo* litaC_enumInfo = litaC_base;
                                    litaC_i32 litaC_index = litaC_types__TypeInfo_getEnumFieldIndex(litaC_enumInfo, litaC_expr->field->type->name);
                                    litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Getting enum position: %d\n", litaC_index);
                                    return litaC_lsp__workspace__Workspace_findFieldReferences(litaC_this, litaC_enumInfo->typeid, litaC_index, litaC_alloc);
                                    
                                    
                                    
                                }
                                
                            } 
                            
                        } 
                        
                        if(!(litaC_expr->field->expr.operand.typeInfo)) {
                            {
                                break;
                                
                                
                            }
                            
                        } 
                        
                        litaC_i64 litaC_fieldType = litaC_expr->field->expr.operand.typeInfo->typeid;
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_this->lsp->lita->programSymbols.symbolFuncs)));litaC_i += 1) {
                            {
                                litaC_symbols__Symbol* litaC_fn = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_this->lsp->lita->programSymbols.symbolFuncs)), litaC_i);
                                if(!((litaC_fn->flags & litaC_symbols__SymbolFlags_IS_METHOD))) {
                                    {
                                        continue;
                                        
                                        
                                    }
                                    
                                } 
                                
                                if(litaC_fn->type->typeid == litaC_fieldType) {
                                    {
                                        return litaC_lsp__workspace__Workspace_findTypeReferences(litaC_this, litaC_fn->type->typeid, litaC_alloc);
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                        }
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_SET_EXPR: {
                    {
                        litaC_ast__SetExpr* litaC_expr = (litaC_ast__SetExpr*)litaC_location.node;
                        litaC_types__TypeInfo* litaC_base = litaC_types__TypeInfo_getBaseType(litaC_expr->object->operand.typeInfo);
                        if(litaC_types__IsAggregate(litaC_base)) {
                            {
                                litaC_types__TypeInfo* litaC_aggInfo = litaC_base;
                                litaC_types__FieldPositionResult litaC_fieldResult = litaC_types__TypeInfo_getFieldPosition(litaC_aggInfo, litaC_expr->field->type->name);
                                if(litaC_fieldResult.aggInfo) {
                                    {
                                        return litaC_lsp__workspace__Workspace_findFieldReferences(litaC_this, litaC_fieldResult.aggInfo->typeid, litaC_fieldResult.position, litaC_alloc);
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } else {
                            if(litaC_base->kind == litaC_types__TypeKind_ENUM) {
                                {
                                    litaC_types__TypeInfo* litaC_enumInfo = litaC_base;
                                    litaC_i32 litaC_index = litaC_types__TypeInfo_getEnumFieldIndex(litaC_enumInfo, litaC_expr->field->type->name);
                                    litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Getting enum position: %d\n", litaC_index);
                                    return litaC_lsp__workspace__Workspace_findFieldReferences(litaC_this, litaC_enumInfo->typeid, litaC_index, litaC_alloc);
                                    
                                    
                                    
                                }
                                
                            } 
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
        
    } else {
        if(litaC_location.kind == litaC_lsp__util__SourceLocationKind_TYPE) {
            {
                litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Found type: %s\n", litaC_ast__TypeSpecKindAsStr(litaC_location.type->kind));
                if(!(litaC_location.type->typeInfo)) {
                    {
                        return litaC_std__json__JSON_NULL;
                        
                        
                        
                    }
                    
                } 
                
                litaC_i64 litaC_typeid = litaC_location.type->typeInfo->typeid;
                litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "~typeid: %llu\n", litaC_typeid);
                return litaC_lsp__workspace__Workspace_findTypeReferences(litaC_this, litaC_typeid, litaC_alloc);
                
                
                
            }
            
        } 
        
    } 
    
    return litaC_std__json__JSON_NULL;
    
    
}

litaC_std__json__JsonNode* litaC_lsp__workspace__Workspace_findTypeReferences(litaC_lsp__workspace__Workspace* litaC_this,litaC_i64 litaC_typeid,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__array__Array_cb_SrcPos_ce_ litaC_results = litaC_std__array__ArrayInit_cb_SrcPos_ce_(64, litaC_alloc);
    litaC_lsp__references__ReferenceDatabase_getTypeReferences(&((litaC_this->lsp->lita->references)), litaC_typeid, &(litaC_results));
    return litaC_lsp__protocol__SrcPosToLocations(litaC_this->rootPath, &(litaC_results), litaC_alloc);
    
    
}

litaC_std__json__JsonNode* litaC_lsp__workspace__Workspace_findFieldReferences(litaC_lsp__workspace__Workspace* litaC_this,litaC_i64 litaC_typeid,litaC_i32 litaC_offset,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__array__Array_cb_SrcPos_ce_ litaC_results = litaC_std__array__ArrayInit_cb_SrcPos_ce_(64, litaC_alloc);
    litaC_lsp__references__ReferenceDatabase_getFieldReferences(&((litaC_this->lsp->lita->references)), litaC_typeid, litaC_offset, &(litaC_results));
    return litaC_lsp__protocol__SrcPosToLocations(litaC_this->rootPath, &(litaC_results), litaC_alloc);
    
    
}

litaC_lsp__util__SourceLocation litaC_lsp__workspace__Workspace_getNodeAtSourcePos(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_uri,litaC_std__json__JsonNode* litaC_position) {
    assert(litaC_uri != NULL);
    assert(litaC_position != NULL);
    litaC_lsp__document__Document* litaC_doc = litaC_std__map__Map_get_cb__ptr_const_char_c__ptr_Document_ce_(&((litaC_this->openedDocuments)), litaC_uri);
    litaC_lsp__protocol__Position litaC_pos =  {
        .line = litaC_std__json__JsonNode_getInt(litaC_position, "line", 0),
        .character = litaC_std__json__JsonNode_getInt(litaC_position, "character", 0)
    };
    litaC_lsp__util__SourceLookup litaC_lookup =  {
        .lsp = litaC_this->lsp,
        .lookupPos = litaC_pos,
        .result =  {
            .kind = litaC_lsp__util__SourceLocationKind_NONE,
            .module = NULL,
            .location =  {
                .uri = litaC_uri
            }
        }
    };
    litaC_module__Module* litaC_module = litaC_lita__Lita_getModule(litaC_this->lsp->lita, litaC_doc->filename);
    if(!(litaC_module)) {
        {
            litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "No module found for: '%s'\n", litaC_doc->filename);
            return (litaC_lsp__util__SourceLocation) {
                .kind = litaC_lsp__util__SourceLocationKind_NONE
            };
            
            
            
        }
        
    } 
    
    litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Module for: '%s'\n", litaC_doc->filename);
    litaC_lsp__util__SourceLocation litaC_location = litaC_lsp__util__SourceLookup_findAstNodeByPosition(&((litaC_lookup)), litaC_module->ast, litaC_pos);
    litaC_location.module = litaC_module;
    return litaC_location;
    
    
}

litaC_std__json__JsonNode* litaC_lsp__workspace__Workspace_goToDefinition(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_uri,litaC_std__json__JsonNode* litaC_position,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "looking up definition...\n");
    if(!(litaC_uri) || !(litaC_position)) {
        return litaC_std__json__JSON_NULL;
        
        
    } 
    
    litaC_lsp__util__SourceLocation litaC_location = litaC_lsp__workspace__Workspace_getNodeAtSourcePos(litaC_this, litaC_uri, litaC_position);
    if(litaC_location.kind == litaC_lsp__util__SourceLocationKind_NONE) {
        {
            litaC_lsp__protocol__Position litaC_pos =  {
                .line = litaC_std__json__JsonNode_getInt(litaC_position, "line", 0),
                .character = litaC_std__json__JsonNode_getInt(litaC_position, "character", 0)
            };
            litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "No ast node found at '%s:%d:%d'\n", litaC_uri, litaC_pos.line, litaC_pos.character);
            return litaC_std__json__JSON_NULL;
            
            
            
        }
        
    } 
    
    if(litaC_location.kind == litaC_lsp__util__SourceLocationKind_AST) {
        {
            litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Found ast node: %s\n", litaC_ast__StmtKindAsStr(litaC_location.node->kind));
            switch(litaC_location.node->kind) {
                case litaC_ast__StmtKind_IMPORT_DECL: {
                    {
                        litaC_ast__ImportDecl* litaC_importDecl = (litaC_ast__ImportDecl*)litaC_location.node;
                        if(!(litaC_importDecl->moduleId)) {
                            {
                                litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "ImportDecl.moduleId is null!\n");
                                return litaC_std__json__JSON_NULL;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_lex__SrcPos litaC_pos =  {
                            .filename = litaC_importDecl->moduleId->filename,
                            .lineStart = NULL,
                            .start = NULL,
                            .end = NULL,
                            .lineNumber = 1,
                            .position = 0
                        };
                        return litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_pos, litaC_pos, litaC_this->rootPath, litaC_alloc);
                        
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_NATIVE_DECL: 
                case litaC_ast__StmtKind_TYPEDEF_DECL: 
                case litaC_ast__StmtKind_UNION_DECL: 
                case litaC_ast__StmtKind_STRUCT_DECL: 
                case litaC_ast__StmtKind_TRAIT_DECL: 
                case litaC_ast__StmtKind_ENUM_DECL: 
                case litaC_ast__StmtKind_FUNC_DECL: {
                    {
                        litaC_ast__Decl* litaC_decl = (litaC_ast__Decl*)litaC_location.node;
                        return litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_decl->stmt.node.startPos, litaC_decl->stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                        
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        litaC_ast__TraitFieldDecl* litaC_varField = (litaC_ast__TraitFieldDecl*)litaC_location.node;
                        litaC_ast__Node* litaC_parentNode = litaC_varField->decl.stmt.node.parent;
                        while(litaC_parentNode && (litaC_parentNode->kind == litaC_ast__StmtKind_UNION_DECL || litaC_parentNode->kind == litaC_ast__StmtKind_STRUCT_DECL)) {
                            {
                                litaC_ast__AggregateDecl* litaC_decl = (litaC_ast__AggregateDecl*)litaC_parentNode;
                                {
                                    litaC_types__TypeInfo* litaC_parentType = litaC_decl->decl.declaration.sym->type;
                                    if(litaC_parentType) {
                                        {
                                            litaC_types__TypeInfo* litaC_aggInfo = litaC_parentType;
                                            litaC_types__FieldPositionResult litaC_fieldResult = litaC_types__TypeInfo_getFieldPosition(litaC_aggInfo, litaC_varField->decl.name.str);
                                            litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Getting field position: %d\n", litaC_fieldResult.position);
                                            if(litaC_fieldResult.aggInfo && litaC_fieldResult.aggInfo->sym) {
                                                {
                                                    litaC_ast__Decl* litaC_decl = litaC_fieldResult.aggInfo->sym->decl;
                                                    return litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_decl->stmt.node.startPos, litaC_decl->stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                    
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                        }
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_ast__VarFieldDecl* litaC_varField = (litaC_ast__VarFieldDecl*)litaC_location.node;
                        litaC_ast__Node* litaC_parentNode = litaC_varField->decl.stmt.node.parent;
                        while(litaC_parentNode && (litaC_parentNode->kind == litaC_ast__StmtKind_UNION_DECL || litaC_parentNode->kind == litaC_ast__StmtKind_STRUCT_DECL)) {
                            {
                                litaC_ast__AggregateDecl* litaC_decl = (litaC_ast__AggregateDecl*)litaC_parentNode;
                                {
                                    litaC_types__TypeInfo* litaC_parentType = litaC_decl->decl.declaration.sym->type;
                                    if(litaC_parentType) {
                                        {
                                            litaC_types__TypeInfo* litaC_aggInfo = litaC_parentType;
                                            litaC_types__FieldPositionResult litaC_fieldResult = litaC_types__TypeInfo_getFieldPosition(litaC_aggInfo, litaC_varField->decl.name.str);
                                            litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Getting field position: %d\n", litaC_fieldResult.position);
                                            if(litaC_fieldResult.aggInfo && litaC_fieldResult.aggInfo->sym) {
                                                {
                                                    litaC_ast__Decl* litaC_decl = litaC_fieldResult.aggInfo->sym->decl;
                                                    return litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_decl->stmt.node.startPos, litaC_decl->stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                    
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                        }
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_CONST_DECL: 
                case litaC_ast__StmtKind_VAR_DECL: 
                case litaC_ast__StmtKind_PARAM_DECL: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_INIT_ARG_EXPR: {
                    {
                        litaC_ast__InitArgExpr* litaC_arg = (litaC_ast__InitArgExpr*)litaC_location.node;
                        litaC_ast__Node* litaC_parentNode = litaC_arg->expr.stmt.node.parent;
                        if(litaC_parentNode && (litaC_parentNode->kind == litaC_ast__StmtKind_INIT_EXPR)) {
                            {
                                litaC_ast__InitExpr* litaC_init = (litaC_ast__InitExpr*)litaC_parentNode;
                                litaC_types__TypeInfo* litaC_parentType = litaC_init->expr.operand.typeInfo;
                                if(litaC_types__IsAggregate(litaC_parentType)) {
                                    {
                                        litaC_types__TypeInfo* litaC_aggInfo = litaC_parentType;
                                        litaC_ast__FieldStmt litaC_field = litaC_types__TypeInfo_getField(litaC_aggInfo, litaC_arg->fieldName.str);
                                        if(litaC_field.kind != litaC_ast__StmtKind_POISON_EXPR) {
                                            {
                                                switch(litaC_field.kind) {
                                                    case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                                        {
                                                            litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                                                            return litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_varField->decl.stmt.node.startPos, litaC_varField->decl.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                            
                                                            
                                                            
                                                        }
                                                        
                                                        
                                                    }
                                                    case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                                        {
                                                            litaC_ast__EnumDecl* litaC_enumField = litaC_field.enumField;
                                                            return litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_enumField->decl.stmt.node.startPos, litaC_enumField->decl.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                            
                                                            
                                                            
                                                        }
                                                        
                                                        
                                                    }
                                                    case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                                                    case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                                                        {
                                                            litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                                                            return litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_aggField->decl.declaration.stmt.node.startPos, litaC_aggField->decl.declaration.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                            
                                                            
                                                            
                                                        }
                                                        
                                                        
                                                    }
                                                    default: {
                                                        {
                                                            
                                                            
                                                        }
                                                        
                                                        
                                                    }
                                                }
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: 
                case litaC_ast__StmtKind_IDENTIFIER_EXPR: {
                    {
                        litaC_ast__IdentifierExpr* litaC_expr = (litaC_ast__IdentifierExpr*)litaC_location.node;
                        if(litaC_expr->sym && litaC_expr->sym->decl) {
                            {
                                litaC_ast__Decl* litaC_decl = litaC_expr->sym->decl;
                                return litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_decl->stmt.node.startPos, litaC_decl->stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_GET_EXPR: {
                    {
                        litaC_ast__GetExpr* litaC_expr = (litaC_ast__GetExpr*)litaC_location.node;
                        litaC_types__TypeInfo* litaC_base = litaC_types__TypeInfo_getBaseType(litaC_expr->object->operand.typeInfo);
                        if(!(litaC_base)) {
                            {
                                break;
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_types__IsAggregate(litaC_base)) {
                            {
                                litaC_types__TypeInfo* litaC_aggInfo = litaC_base;
                                litaC_ast__FieldStmt litaC_field = litaC_types__TypeInfo_getField(litaC_aggInfo, litaC_expr->field->type->name);
                                if(litaC_field.kind != litaC_ast__StmtKind_POISON_EXPR) {
                                    {
                                        switch(litaC_field.kind) {
                                            case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                                {
                                                    litaC_ast__TraitFieldDecl* litaC_varField = litaC_field.traitField;
                                                    return litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_varField->decl.stmt.node.startPos, litaC_varField->decl.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                    
                                                    
                                                    
                                                }
                                                
                                                
                                            }
                                            case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                                {
                                                    litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                                                    return litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_varField->decl.stmt.node.startPos, litaC_varField->decl.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                    
                                                    
                                                    
                                                }
                                                
                                                
                                            }
                                            case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                                {
                                                    litaC_ast__EnumDecl* litaC_enumField = litaC_field.enumField;
                                                    return litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_enumField->decl.stmt.node.startPos, litaC_enumField->decl.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                    
                                                    
                                                    
                                                }
                                                
                                                
                                            }
                                            case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                                            case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                                                {
                                                    litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                                                    return litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_aggField->decl.declaration.stmt.node.startPos, litaC_aggField->decl.declaration.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                    
                                                    
                                                    
                                                }
                                                
                                                
                                            }
                                            default: {
                                                {
                                                    
                                                    
                                                }
                                                
                                                
                                            }
                                        }
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } else {
                            if(litaC_base->kind == litaC_types__TypeKind_ENUM) {
                                {
                                    litaC_types__TypeInfo* litaC_enumInfo = litaC_base;
                                    litaC_i32 litaC_index = litaC_types__TypeInfo_getEnumFieldIndex(litaC_enumInfo, litaC_expr->field->type->name);
                                    if(litaC_index >= 0) {
                                        {
                                            litaC_ast__EnumFieldEntryDecl* litaC_entryDecl = litaC_std__array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_enumInfo->enumDecl->fields)), litaC_index);
                                            return litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_entryDecl->decl.stmt.node.startPos, litaC_entryDecl->decl.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    
                                    
                                }
                                
                            } 
                            
                        } 
                        
                        if(!(litaC_expr->field->expr.operand.typeInfo)) {
                            {
                                break;
                                
                                
                            }
                            
                        } 
                        
                        litaC_i64 litaC_fieldType = litaC_expr->field->expr.operand.typeInfo->typeid;
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_this->lsp->lita->programSymbols.symbolFuncs)));litaC_i += 1) {
                            {
                                litaC_symbols__Symbol* litaC_fn = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_this->lsp->lita->programSymbols.symbolFuncs)), litaC_i);
                                if(!((litaC_fn->flags & litaC_symbols__SymbolFlags_IS_METHOD))) {
                                    {
                                        continue;
                                        
                                        
                                    }
                                    
                                } 
                                
                                if(litaC_fn->type->typeid == litaC_fieldType) {
                                    {
                                        litaC_ast__Decl* litaC_decl = litaC_fn->decl;
                                        return litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_decl->stmt.node.startPos, litaC_decl->stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                        }
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_SET_EXPR: {
                    {
                        litaC_ast__SetExpr* litaC_expr = (litaC_ast__SetExpr*)litaC_location.node;
                        litaC_types__TypeInfo* litaC_base = litaC_types__TypeInfo_getBaseType(litaC_expr->object->operand.typeInfo);
                        if(litaC_types__IsAggregate(litaC_base)) {
                            {
                                litaC_types__TypeInfo* litaC_aggInfo = litaC_base;
                                litaC_ast__FieldStmt litaC_field = litaC_types__TypeInfo_getField(litaC_aggInfo, litaC_expr->field->type->name);
                                if(litaC_field.kind != litaC_ast__StmtKind_POISON_EXPR) {
                                    {
                                        switch(litaC_field.kind) {
                                            case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                                {
                                                    litaC_ast__TraitFieldDecl* litaC_varField = litaC_field.traitField;
                                                    return litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_varField->decl.stmt.node.startPos, litaC_varField->decl.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                    
                                                    
                                                    
                                                }
                                                
                                                
                                            }
                                            case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                                {
                                                    litaC_ast__VarFieldDecl* litaC_varField = litaC_field.varField;
                                                    return litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_varField->decl.stmt.node.startPos, litaC_varField->decl.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                    
                                                    
                                                    
                                                }
                                                
                                                
                                            }
                                            case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                                {
                                                    litaC_ast__EnumDecl* litaC_enumField = litaC_field.enumField;
                                                    return litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_enumField->decl.stmt.node.startPos, litaC_enumField->decl.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                    
                                                    
                                                    
                                                }
                                                
                                                
                                            }
                                            case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                                            case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                                                {
                                                    litaC_ast__AggregateDecl* litaC_aggField = litaC_field.aggregateField;
                                                    return litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_aggField->decl.declaration.stmt.node.startPos, litaC_aggField->decl.declaration.stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                                                    
                                                    
                                                    
                                                }
                                                
                                                
                                            }
                                            default: {
                                                {
                                                    
                                                    
                                                }
                                                
                                                
                                            }
                                        }
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
        
    } else {
        if(litaC_location.kind == litaC_lsp__util__SourceLocationKind_TYPE) {
            {
                litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Found type: %s\n", litaC_ast__TypeSpecKindAsStr(litaC_location.type->kind));
                litaC_symbols__Symbol* litaC_sym = NULL;
                if(litaC_location.type->kind == litaC_ast__TypeSpecKind_NAME && litaC_location.module) {
                    {
                        litaC_ast__TypeSpec* litaC_name = litaC_location.type;
                        litaC_sym = litaC_module__Module_getType(litaC_location.module, litaC_name->name);
                        
                        
                    }
                    
                } 
                
                if(!(litaC_sym)) {
                    {
                        if(!(litaC_location.type->typeInfo) || !(litaC_location.type->typeInfo->sym)) {
                            {
                                return litaC_std__json__JSON_NULL;
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_sym = litaC_location.type->typeInfo->sym;
                        
                        
                    }
                    
                } 
                
                litaC_ast__Decl* litaC_decl = litaC_sym->decl;
                return litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_decl->stmt.node.startPos, litaC_decl->stmt.node.endPos, litaC_this->rootPath, litaC_alloc);
                
                
                
            }
            
        } 
        
    } 
    
    return litaC_std__json__JSON_NULL;
    
    
}

litaC_std__json__JsonNode* litaC_lsp__workspace__Workspace_autoComplete(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_uri,litaC_std__json__JsonNode* litaC_position,litaC_std__json__JsonNode* litaC_context,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "auto-completion...\n");
    if(!(litaC_uri) || !(litaC_position)) {
        return litaC_std__json__JSON_NULL;
        
        
    } 
    
    litaC_lsp__document__Document* litaC_doc = litaC_std__map__Map_get_cb__ptr_const_char_c__ptr_Document_ce_(&((litaC_this->openedDocuments)), litaC_uri);
    if(!(litaC_doc)) {
        {
            return litaC_std__json__JSON_NULL;
            
            
            
        }
        
    } 
    
    litaC_module__Module* litaC_module = litaC_lita__Lita_getModule(litaC_this->lsp->lita, litaC_doc->filename);
    if(!(litaC_module)) {
        {
            return litaC_std__json__JSON_NULL;
            
            
            
        }
        
    } 
    
    litaC_bool litaC_isMethodLookUp = litaC_false;
    if(litaC_context) {
        {
            const litaC_char* litaC_trigger = litaC_std__json__JsonNode_getStr(litaC_context, "triggerCharacter", NULL);
            if(litaC_trigger && strncmp(".", litaC_trigger, 1)) {
                {
                    litaC_isMethodLookUp = litaC_true;
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_lineNumber = litaC_std__json__JsonNode_getInt(litaC_position, "line", 0);
    litaC_i32 litaC_character = litaC_std__json__JsonNode_getInt(litaC_position, "character", 0);
    litaC_u32 litaC_lineStart = litaC_lsp__document__Document_getLineStart(litaC_doc, litaC_lineNumber);
    litaC_u32 litaC_offset = litaC_lineStart + (litaC_character - 1);
    if(litaC_offset >= litaC_doc->text.length) {
        {
            return litaC_std__json__JSON_NULL;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_endPos = litaC_offset;
    while(litaC_offset > 0) {
        {
            litaC_char litaC_c = litaC_doc->text.buffer[litaC_offset];
            if(litaC_c == '.') {
                {
                    litaC_isMethodLookUp = litaC_true;
                    break;
                    
                    
                }
                
            } 
            
            if(litaC_std__ascii__char_isWhitespace(litaC_c)) {
                {
                    break;
                    
                    
                }
                
            } 
            
            if(!(litaC_std__ascii__char_isAlphanumeric(litaC_c)) && litaC_c != '_') {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_offset -= 1;
            
            
        }
    }
    
#define litaC_MAX_RESULTS (1024 * 2)
    litaC_std__json__JsonNode* litaC_results = litaC_std__json__CreateJsonArray(litaC_alloc);
    if(litaC_endPos > litaC_offset) {
        {
            litaC_std__string_view__StringView litaC_prefix = litaC_std__string_view__StringViewInit(litaC_doc->text.buffer + litaC_offset + 1, (litaC_i32)(litaC_endPos - litaC_offset));
            litaC_i32 litaC_i = 0;
            for(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_ litaC_it = litaC_std__map__Map_iter_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_module->symbols.symbolFuncs)));litaC_std__map__MapIterator_hasNext_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it))) && litaC_i < litaC_MAX_RESULTS;litaC_i += 1) {
                {
                    litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_ litaC_entry = litaC_std__map__MapIterator_next_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));
                    litaC_symbols__Symbol* litaC_symbol = litaC_entry.value;
                    litaC_i32 litaC_isMethod = litaC_symbol->flags & litaC_symbols__SymbolFlags_IS_METHOD;
                    if(litaC_isMethodLookUp && !(litaC_isMethod)) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__string_view__StringView litaC_name = litaC_symbol->name.view;
                    if(litaC_isMethod && litaC_symbol->decl) {
                        {
                            litaC_name = litaC_std__string_view__StringViewInit(litaC_symbol->decl->name.str.buffer, litaC_symbol->decl->name.str.length);
                            
                            
                        }
                        
                    } 
                    
                    if(litaC_std__string_view__StringView_startsWith(litaC_name, litaC_prefix.buffer, litaC_prefix.length, 0)) {
                        {
                            litaC_std__json__JsonNode* litaC_item = litaC_lsp__protocol__SymbolToCompletionItem(litaC_symbol, litaC_alloc);
                            litaC_std__json__JsonNode_add(litaC_results, litaC_item);
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            litaC_i32 litaC_i = 0;
            for(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_ litaC_it = litaC_std__map__Map_iter_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_module->symbols.symbolFuncs)));litaC_std__map__MapIterator_hasNext_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it))) && litaC_i < litaC_MAX_RESULTS;litaC_i += 1) {
                {
                    litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_ litaC_entry = litaC_std__map__MapIterator_next_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_it)));
                    litaC_symbols__Symbol* litaC_symbol = litaC_entry.value;
                    if(litaC_isMethodLookUp && !((litaC_symbol->flags & litaC_symbols__SymbolFlags_IS_METHOD))) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__json__JsonNode* litaC_item = litaC_lsp__protocol__SymbolToCompletionItem(litaC_symbol, litaC_alloc);
                    litaC_std__json__JsonNode_add(litaC_results, litaC_item);
                    
                    
                }
            }
            
            
        }
    } 
    
    return litaC_results;
    
    #undef litaC_MAX_RESULTS
    
}

litaC_phase_result__PhaseResult* litaC_lsp__workspace__Workspace_runDiagnostics(litaC_lsp__workspace__Workspace* litaC_this,const litaC_char* litaC_docUri,litaC_bool litaC_isFullBuild) {
    litaC_f64 litaC_startTime = litaC_std__system__SystemTimeMSec();
    litaC_lita__Lita* litaC_lita = litaC_this->lsp->lita;
    if(litaC_isFullBuild) {
        {
            litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Running diagnostics for full rebuild\n");
            
            
        }
        
    } 
    
    if(litaC_docUri && !(litaC_isFullBuild)) {
        {
            litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Running %s diagnostics for: '%s'...\n", (litaC_isFullBuild) ? "full" : "incremental", litaC_docUri);
            litaC_std__system__UriToFilePath(litaC_docUri, litaC_lita->options->inputFile);
            litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Source file: '%s', source path: '%s'...\n", litaC_lita->options->inputFile, litaC_lita->options->srcPath);
            
            
        }
        
    } 
    
    if(litaC_isFullBuild) {
        {
            litaC_lita__Lita_reset(litaC_lita);
            litaC_module__Module* litaC_root = litaC_lita__Lita_parse(litaC_lita);
            if(!(litaC_root)) {
                {
                    litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Failed to parse\n");
                    litaC_lita->result.isReadable = litaC_false;
                    goto report;
                    
                    
                    
                }
                
            } 
            
            litaC_bool litaC_checked = litaC_lita__Lita_typeCheck(litaC_lita, litaC_root, litaC_checker__TypeCheckerFlags_DISABLE_TRAIT_WRAPPERS);
            if(!(litaC_checked)) {
                {
                    litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Failed to type check\n");
                    litaC_lita->result.isReadable = litaC_false;
                    goto report;
                    
                    
                    
                }
                
            } 
            
            litaC_lita->result.isReadable = litaC_true;
            
            
        }
        
    } else {
        {
            litaC_lsp__document__Document* litaC_doc = litaC_std__map__Map_get_cb__ptr_const_char_c__ptr_Document_ce_(&((litaC_this->openedDocuments)), litaC_docUri);
            if(!(litaC_doc)) {
                {
                    litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Failed to find open document: '%s'\n", litaC_docUri);
                    goto report;
                    
                    
                    
                }
                
            } 
            
            litaC_module__Module* litaC_module = litaC_lita__Lita_getModule(litaC_lita, litaC_doc->filename);
            if(!(litaC_module)) {
                {
                    litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "module: '%s' from URI: '%s' module has not been generated yet\n", litaC_doc->filename, litaC_docUri);
                    litaC_std__string_view__StringView litaC_packageName = litaC_lita__GetPackageName(litaC_lita->options->srcPath, litaC_doc->filename);
                    litaC_module = litaC_module__NewModule(litaC_lita, litaC_packageName, litaC_doc->filename);
                    litaC_lita__Lita_addModule(litaC_lita, litaC_module);
                    
                    
                }
                
            } 
            
            litaC_lita__Lita_incrementalBuild(litaC_lita, litaC_module);
            
            
        }
    } 
    
    litaC_f64 litaC_totalTime = litaC_std__system__SystemTimeMSec() - litaC_startTime;
    litaC_lsp__lsp__LspServer_log(litaC_this->lsp, "Successfully compiled in %.3f msec\n", litaC_totalTime);
    report:;
    
    return &(litaC_lita->result);
    
    
}

litaC_void litaC_lsp__lsp__LspServer_init(litaC_lsp__lsp__LspServer* litaC_this,litaC_lita__Lita* litaC_lita) {
    litaC_this->lita = litaC_lita;
    litaC_this->isRunning = litaC_false;
    litaC_this->isInitialized = litaC_false;
    litaC_this->logFile = fopen("litac_lsp.log", "w");
    if(!(litaC_this->logFile)) {
        {
            printf("Couldn't open log file!\n");
            
            
        }
        
    } 
    
    litaC_usize litaC_size = 1024 * 1024 * 100;
    litaC_std__mem__linear_allocator__LinearAllocator_init(&((litaC_this->requestAllocator)), litaC_std__mem__Allocator_alloc(litaC_std__mem__defaultAllocator, litaC_size), litaC_size, LITAC_DEFAULT_ALIGNMENT, litaC_std__mem__linear_allocator__DEFAULT_EXPAND_INFO);
    litaC_std__mem__linear_allocator__LinearAllocator_init(&((litaC_this->applicationAllocator)), litaC_std__mem__Allocator_alloc(litaC_std__mem__defaultAllocator, litaC_size), litaC_size, LITAC_DEFAULT_ALIGNMENT, litaC_std__mem__linear_allocator__DEFAULT_EXPAND_INFO);
    litaC_this->message = litaC_std__string_buffer__StringBufferInit(litaC_lsp__lsp__IN_BUFFER_SIZE, litaC_std__mem__defaultAllocator);
    litaC_this->output = litaC_std__string_buffer__StringBufferInit(litaC_lsp__lsp__IN_BUFFER_SIZE, litaC_std__mem__defaultAllocator);
    litaC_this->outbound = litaC_std__string_buffer__StringBufferInit(litaC_lsp__lsp__IN_BUFFER_SIZE, litaC_std__mem__defaultAllocator);
    litaC_lsp__workspace__Workspace_init(&((litaC_this->workspace)), litaC_this, litaC_lsp__lsp__LspServer_appAlloc(litaC_this));
    litaC_this->lita->workspace = &(litaC_this->workspace);
    
}

const litaC_std__mem__Allocator* litaC_lsp__lsp__LspServer_requestAlloc(litaC_lsp__lsp__LspServer* litaC_this) {
    return (const litaC_std__mem__Allocator*)(&(litaC_this->requestAllocator));
    
    
}

const litaC_std__mem__Allocator* litaC_lsp__lsp__LspServer_appAlloc(litaC_lsp__lsp__LspServer* litaC_this) {
    return (const litaC_std__mem__Allocator*)(&(litaC_this->applicationAllocator));
    
    
}

litaC_void litaC_lsp__lsp__LspServer_free(litaC_lsp__lsp__LspServer* litaC_this) {
    if(litaC_this->applicationAllocator.mem) {
        {
            litaC_std__mem__Allocator_free(litaC_std__mem__defaultAllocator, litaC_this->applicationAllocator.mem);
            
            
        }
        
    } 
    
    if(litaC_this->requestAllocator.mem) {
        {
            litaC_std__mem__Allocator_free(litaC_std__mem__defaultAllocator, litaC_this->requestAllocator.mem);
            
            
        }
        
    } 
    
    litaC_std__string_buffer__StringBuffer_free(&((litaC_this->message)));
    litaC_std__string_buffer__StringBuffer_free(&((litaC_this->output)));
    if(litaC_this->logFile) {
        {
            fclose(litaC_this->logFile);
            
            
        }
        
    } 
    
    
}

litaC_void litaC_lsp__lsp__LspServer_start(litaC_lsp__lsp__LspServer* litaC_this) {
    litaC_lsp__lsp__LspServer_log(litaC_this, "starting Lita Language Server v%s\n", litaC_lsp__lsp__VERSION);
    
    litaC_this->isRunning = litaC_true;
    while(litaC_true) {
        {
            litaC_lsp__lsp__LspServer_readMessage(litaC_this);
            
            
        }
    }
    litaC_lsp__lsp__LspServer_log(litaC_this, "terminating Lita Language Server\n");
    
}

litaC_void litaC_lsp__lsp__LspServer_log(litaC_lsp__lsp__LspServer* litaC_this,const litaC_char* litaC_format,...) {
    va_list litaC_args = {0};
    va_start(litaC_args, litaC_format);
    vfprintf(litaC_this->logFile, litaC_format, litaC_args);
    va_end(litaC_args);
    fflush(litaC_this->logFile);
    
}

litaC_void litaC_lsp__lsp__LspServer_readMessage(litaC_lsp__lsp__LspServer* litaC_this) {
    litaC_std__string_buffer__StringBuffer_clear(&((litaC_this->message)));
    litaC_lsp__lsp__LspServer_log(litaC_this, "Waiting for message..\n");
    litaC_i32 litaC_size = litaC_lsp__lsp__LspServer_readHeader(litaC_this);
    if(litaC_size < 0) {
        {
            litaC_lsp__lsp__LspServer_writeErrorResponse(litaC_this, 0, litaC_lsp__protocol__ErrorCodes_ParseError, "error reading 'Content-Length'");
            return;
            
            
            
        }
        
    } 
    
    litaC_f64 litaC_startTime = litaC_std__system__SystemTimeMSec();
    
    
    litaC_lsp__lsp__LspServer_log(litaC_this, "Received message size: %d\n", litaC_size);
    litaC_std__string_buffer__StringBuffer_reserve(&((litaC_this->message)), litaC_size);
    litaC_i64 litaC_bytesRead = fread(litaC_this->message.buffer, 1, litaC_size, stdin);
    litaC_lsp__lsp__LspServer_log(litaC_this, "Received %d bytes from fread\n", litaC_bytesRead);
    if(litaC_bytesRead != litaC_size) {
        {
            litaC_lsp__lsp__LspServer_log(litaC_this, "message received size of %d did not match Content-Length: %d\n", litaC_bytesRead, litaC_size);
            litaC_size = (litaC_i32)litaC_bytesRead;
            
            
        }
        
    } 
    
    litaC_this->message.length = litaC_size;
    litaC_lsp__lsp__LspServer_log(litaC_this, "Received message: '%.*s'\n", litaC_size, litaC_this->message.buffer);
    litaC_std__json__JsonParser litaC_parser = litaC_std__json__JsonParserInit(litaC_lsp__lsp__LspServer_requestAlloc(litaC_this));
    
    litaC_std__json__JsonNode* litaC_json = litaC_std__json__JsonParser_parseJson(&((litaC_parser)), litaC_std__string_buffer__StringBuffer_cStr(&((litaC_this->message))));
    if(litaC_std__json__JsonParser_hasError(&((litaC_parser)))) {
        {
            litaC_lsp__lsp__LspServer_log(litaC_this, "json parsing error: %s\n", litaC_parser.errorMsg);
            litaC_std__json__JsonParser_free(&((litaC_parser)));
            litaC_this->requestAllocator.currentOffset = 0;
            litaC_lsp__lsp__LspServer_log(litaC_this, ">>> Request Handling Time: %.4fms\n\n", litaC_std__system__SystemTimeMSec() - litaC_startTime);
            return;
            
            
            
        }
        
    } 
    
    litaC_lsp__lsp__LspServer_handleMessage(litaC_this, litaC_json);
    litaC_std__json__JsonParser_free(&((litaC_parser)));
    litaC_this->requestAllocator.currentOffset = 0;
    litaC_lsp__lsp__LspServer_log(litaC_this, ">>> Request Handling Time: %.4fms\n\n", litaC_std__system__SystemTimeMSec() - litaC_startTime);
    
}

litaC_i32 litaC_lsp__lsp__LspServer_readHeader(litaC_lsp__lsp__LspServer* litaC_this) {
    
#define litaC_MAX_HEADER_SIZE (256)
    litaC_char litaC_header[256] =  {
        0
    };
    litaC_i32 litaC_sizeIndex = 0;
    litaC_i32 litaC_index = 0;
    litaC_lsp__lsp__LspServer_log(litaC_this, "Reading header:\n'");
    while(litaC_index < litaC_MAX_HEADER_SIZE) {
        {
            litaC_i32 litaC_r = getchar();
            if(litaC_r == EOF) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_char litaC_c = (litaC_char)litaC_r;
            litaC_lsp__lsp__LspServer_log(litaC_this, "%c", litaC_c);
            if(litaC_c == ' ') {
                {
                    litaC_sizeIndex = litaC_index + 1;
                    
                    
                }
                
            } 
            
            if(litaC_c == '\n' || litaC_c == '\r') {
                {
                    litaC_header[litaC_index] = '\0';
                    break;
                    
                    
                }
                
            } else {
                {
                    litaC_header[litaC_index] = litaC_c;
                    
                    
                }
            } 
            
            litaC_index += 1;
            
            
        }
    }
    litaC_lsp__lsp__LspServer_log(litaC_this, "'\nRead header: '%s'\n", litaC_header);
    if(strncmp(litaC_header, "Content-Length: ", litaC_sizeIndex) != 0) {
        {
            litaC_lsp__lsp__LspServer_log(litaC_this, "Invalid header: '%s'\n", litaC_header);
            return -(1);
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_size = atoi(&(litaC_header[litaC_sizeIndex]));
    
    #if defined(_WIN32) || defined(_WIN64)
    litaC_i32 litaC_endingsSize = 1;
    
    #else
    litaC_i32 litaC_endingsSize = 3;
    
    #endif
    
    return litaC_size + litaC_endingsSize;
    
    #undef litaC_MAX_HEADER_SIZE
    
}

litaC_void litaC_lsp__lsp__LspServer_handleMessage(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg) {
    const litaC_char* litaC_method = litaC_std__json__JsonNode_getStr(litaC_msg, "method", NULL);
    if(!(litaC_method)) {
        {
            litaC_lsp__lsp__LspServer_writeErrorResponse(litaC_this, 0, litaC_lsp__protocol__ErrorCodes_MethodNotFound, "no method defined");
            return;
            
            
            
        }
        
    } 
    
    if(!(litaC_this->isRunning)) {
        {
            if(strcmp(litaC_method, "exit") == 0) {
                {
                    exit(0);
                    
                    
                }
                
            } else {
                {
                    litaC_lsp__lsp__LspServer_writeErrorResponse(litaC_this, 0, litaC_lsp__protocol__ErrorCodes_InvalidRequest, "not yet properly initialized");
                    return;
                    
                    
                    
                }
            } 
            
            
            
        }
        
    } 
    
    litaC_std__json__JsonNode* litaC_params = litaC_std__json__JsonNode_getObject(litaC_msg, "params");
    if(strcmp(litaC_method, "initialize") == 0) {
        {
            litaC_lsp__lsp__LspServer_handleInitializeMessage(litaC_this, litaC_msg, litaC_params);
            
            
        }
        
    } else {
        if(strcmp(litaC_method, "initialized") == 0) {
            {
                litaC_this->isInitialized = litaC_true;
                
                
            }
            
        } else {
            if(!(litaC_this->isInitialized)) {
                {
                    litaC_lsp__lsp__LspServer_writeErrorResponse(litaC_this, 0, litaC_lsp__protocol__ErrorCodes_ServerNotInitialized, "not yet properly initialized");
                    
                    
                }
                
            } else {
                if(strcmp(litaC_method, "textDocument/didOpen") == 0) {
                    {
                        litaC_lsp__lsp__LspServer_handleTextDocumentOpenMessage(litaC_this, litaC_msg, litaC_params);
                        
                        
                    }
                    
                } else {
                    if(strcmp(litaC_method, "textDocument/didClose") == 0) {
                        {
                            litaC_lsp__lsp__LspServer_handleTextDocumentCloseMessage(litaC_this, litaC_msg, litaC_params);
                            
                            
                        }
                        
                    } else {
                        if(strcmp(litaC_method, "textDocument/didSave") == 0) {
                            {
                                litaC_lsp__lsp__LspServer_handleTextDocumentSaveMessage(litaC_this, litaC_msg, litaC_params);
                                
                                
                            }
                            
                        } else {
                            if(strcmp(litaC_method, "textDocument/documentSymbol") == 0) {
                                {
                                    litaC_lsp__lsp__LspServer_handleTextDocumentSymbolMessage(litaC_this, litaC_msg, litaC_params);
                                    
                                    
                                }
                                
                            } else {
                                if(strcmp(litaC_method, "textDocument/didChange") == 0) {
                                    {
                                        litaC_lsp__lsp__LspServer_handleTextDocumentChangeMessage(litaC_this, litaC_msg, litaC_params);
                                        
                                        
                                    }
                                    
                                } else {
                                    if(strcmp(litaC_method, "textDocument/references") == 0) {
                                        {
                                            litaC_lsp__lsp__LspServer_handleTextDocumentReferencesMessage(litaC_this, litaC_msg, litaC_params);
                                            
                                            
                                        }
                                        
                                    } else {
                                        if(strcmp(litaC_method, "textDocument/definition") == 0) {
                                            {
                                                litaC_lsp__lsp__LspServer_handleTextDocumentDefinitionMessage(litaC_this, litaC_msg, litaC_params);
                                                
                                                
                                            }
                                            
                                        } else {
                                            if(strcmp(litaC_method, "textDocument/completion") == 0) {
                                                {
                                                    litaC_lsp__lsp__LspServer_handleTextDocumentCompletionMessage(litaC_this, litaC_msg, litaC_params);
                                                    
                                                    
                                                }
                                                
                                            } else {
                                                if(strcmp(litaC_method, "$/cancelRequest") == 0) {
                                                    {
                                                        
                                                        
                                                    }
                                                    
                                                } else {
                                                    if(strcmp(litaC_method, "shutdown") == 0) {
                                                        {
                                                            litaC_this->isRunning = litaC_false;
                                                            
                                                            
                                                        }
                                                        
                                                    } else {
                                                        {
                                                            litaC_lsp__lsp__LspServer_writeErrorResponse(litaC_this, 0, litaC_lsp__protocol__ErrorCodes_MethodNotFound, "unsupported method: '%s'", litaC_method);
                                                            
                                                            
                                                        }
                                                    } 
                                                    
                                                } 
                                                
                                            } 
                                            
                                        } 
                                        
                                    } 
                                    
                                } 
                                
                            } 
                            
                        } 
                        
                    } 
                    
                } 
                
            } 
            
        } 
        
    } 
    
    
}

litaC_void litaC_lsp__lsp__LspServer_handleInitializeMessage(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg,litaC_std__json__JsonNode* litaC_params) {
    const litaC_char* litaC_rootPath = litaC_std__json__JsonNode_getStr(litaC_params, "rootPath", "");
    const litaC_char* litaC_rootUri = litaC_std__json__JsonNode_getStr(litaC_params, "rootUri", "");
    litaC_lsp__lsp__LspServer_log(litaC_this, "Root Path = '%s'\n", litaC_rootPath);
    litaC_char litaC_path[_MAX_PATH] =  {
        0
    };
    litaC_std__system__UriToFilePath(litaC_rootUri, litaC_path);
    litaC_lsp__lsp__LspServer_log(litaC_this, "Root Uri = '%s' as path: '%s'\n", litaC_rootUri, litaC_path);
    litaC_lsp__workspace__Workspace_setup(&((litaC_this->workspace)), litaC_path, litaC_rootUri);
    const char* litaC_capabilities = "\n    {\n        \"capabilities\": {\n            \"textDocumentSync\": 2,\n            \"definitionProvider\": true,\n            \"documentSymbolProvider\": true,\n            \"workspaceSymbolProvider\": true,\n            \"referencesProvider\": true,\n            \"completionProvider\": {\n                \"resolveProvider\": true,\n                \"triggerCharacters\": [\n                    \".\"\n                ]\n            }\n        }\n    }";
    litaC_std__json__JsonNode* litaC_resp = litaC_lsp__lsp__LspServer_createResponse(litaC_this, litaC_std__json__JsonNode_getInt(litaC_msg, "id", 0));
    litaC_std__json__JsonParser litaC_parser = litaC_std__json__JsonParserInit(litaC_lsp__lsp__LspServer_requestAlloc(litaC_this));
    litaC_std__json__JsonNode_put(litaC_resp, "result", litaC_std__json__JsonParser_parseJson(&((litaC_parser)), litaC_capabilities));
    litaC_std__json__JsonNode_put(litaC_resp, "error", litaC_std__json__JSON_NULL);
    litaC_lsp__lsp__LspServer_writeResponse(litaC_this, litaC_resp);
    
}

litaC_void litaC_lsp__lsp__LspServer_handleTextDocumentOpenMessage(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg,litaC_std__json__JsonNode* litaC_params) {
    litaC_std__json__JsonNode* litaC_textDoc = litaC_std__json__JsonNode_getObject(litaC_params, "textDocument");
    if(!(litaC_textDoc)) {
        {
            return;
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_uri = litaC_std__json__JsonNode_getStr(litaC_textDoc, "uri", NULL);
    litaC_lsp__workspace__Workspace_openDocument(&((litaC_this->workspace)), litaC_uri, litaC_std__json__JsonNode_getStr(litaC_textDoc, "text", NULL));
    litaC_lsp__lsp__LspServer_writeDiagnostic(litaC_this, litaC_uri, litaC_false);
    
}

litaC_void litaC_lsp__lsp__LspServer_handleTextDocumentCloseMessage(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg,litaC_std__json__JsonNode* litaC_params) {
    litaC_std__json__JsonNode* litaC_textDoc = litaC_std__json__JsonNode_getObject(litaC_params, "textDocument");
    if(!(litaC_textDoc)) {
        {
            return;
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_uri = litaC_std__json__JsonNode_getStr(litaC_textDoc, "uri", NULL);
    litaC_lsp__workspace__Workspace_closeDocument(&((litaC_this->workspace)), litaC_uri);
    
}

litaC_void litaC_lsp__lsp__LspServer_handleTextDocumentSymbolMessage(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg,litaC_std__json__JsonNode* litaC_params) {
    litaC_std__json__JsonNode* litaC_textDoc = litaC_std__json__JsonNode_getObject(litaC_params, "textDocument");
    if(!(litaC_textDoc)) {
        {
            return;
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_uri = litaC_std__json__JsonNode_getStr(litaC_textDoc, "uri", NULL);
    litaC_std__json__JsonNode* litaC_results = litaC_lsp__workspace__Workspace_documentSymbols(&((litaC_this->workspace)), litaC_uri, litaC_lsp__lsp__LspServer_requestAlloc(litaC_this));
    litaC_std__json__JsonNode* litaC_resp = litaC_lsp__lsp__LspServer_createResponse(litaC_this, litaC_std__json__JsonNode_getInt(litaC_msg, "id", 0));
    litaC_std__json__JsonNode_put(litaC_resp, "result", litaC_results);
    litaC_std__json__JsonNode_put(litaC_resp, "error", litaC_std__json__JSON_NULL);
    litaC_lsp__lsp__LspServer_writeResponse(litaC_this, litaC_resp);
    
}

litaC_void litaC_lsp__lsp__LspServer_handleTextDocumentSaveMessage(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg,litaC_std__json__JsonNode* litaC_params) {
    litaC_std__json__JsonNode* litaC_textDoc = litaC_std__json__JsonNode_getObject(litaC_params, "textDocument");
    if(!(litaC_textDoc)) {
        {
            return;
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_uri = litaC_std__json__JsonNode_getStr(litaC_textDoc, "uri", NULL);
    litaC_lsp__workspace__Workspace_saveDocument(&((litaC_this->workspace)), litaC_uri);
    litaC_lsp__lsp__LspServer_writeDiagnostic(litaC_this, litaC_uri, litaC_false);
    
}

litaC_void litaC_lsp__lsp__LspServer_handleTextDocumentChangeMessage(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg,litaC_std__json__JsonNode* litaC_params) {
    litaC_lsp__protocol__TextDocumentDidChange* litaC_changeEvent = litaC_lsp__protocol__JsonNodeToTextDocumentChangeEvent(litaC_params, litaC_lsp__lsp__LspServer_requestAlloc(litaC_this));
    if(litaC_changeEvent) {
        {
            litaC_lsp__workspace__Workspace_changeDocument(&((litaC_this->workspace)), litaC_changeEvent);
            litaC_lsp__lsp__LspServer_writeDiagnostic(litaC_this, litaC_changeEvent->textDocument.uri, litaC_false);
            
            
        }
        
    } 
    
    
}

litaC_void litaC_lsp__lsp__LspServer_handleTextDocumentReferencesMessage(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg,litaC_std__json__JsonNode* litaC_params) {
    litaC_std__json__JsonNode* litaC_textDoc = litaC_std__json__JsonNode_getObject(litaC_params, "textDocument");
    if(!(litaC_textDoc)) {
        {
            return;
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_uri = litaC_std__json__JsonNode_getStr(litaC_textDoc, "uri", NULL);
    litaC_std__json__JsonNode* litaC_pos = litaC_std__json__JsonNode_getObject(litaC_params, "position");
    litaC_std__json__JsonNode* litaC_results = litaC_lsp__workspace__Workspace_references(&((litaC_this->workspace)), litaC_uri, litaC_pos, litaC_lsp__lsp__LspServer_requestAlloc(litaC_this));
    litaC_std__json__JsonNode* litaC_resp = litaC_lsp__lsp__LspServer_createResponse(litaC_this, litaC_std__json__JsonNode_getInt(litaC_msg, "id", 0));
    litaC_std__json__JsonNode_put(litaC_resp, "result", litaC_results);
    litaC_std__json__JsonNode_put(litaC_resp, "error", litaC_std__json__JSON_NULL);
    litaC_lsp__lsp__LspServer_writeResponse(litaC_this, litaC_resp);
    
}

litaC_void litaC_lsp__lsp__LspServer_handleTextDocumentDefinitionMessage(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg,litaC_std__json__JsonNode* litaC_params) {
    litaC_std__json__JsonNode* litaC_textDoc = litaC_std__json__JsonNode_getObject(litaC_params, "textDocument");
    if(!(litaC_textDoc)) {
        {
            return;
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_uri = litaC_std__json__JsonNode_getStr(litaC_textDoc, "uri", NULL);
    litaC_std__json__JsonNode* litaC_pos = litaC_std__json__JsonNode_getObject(litaC_params, "position");
    litaC_std__json__JsonNode* litaC_results = litaC_lsp__workspace__Workspace_goToDefinition(&((litaC_this->workspace)), litaC_uri, litaC_pos, litaC_lsp__lsp__LspServer_requestAlloc(litaC_this));
    litaC_std__json__JsonNode* litaC_resp = litaC_lsp__lsp__LspServer_createResponse(litaC_this, litaC_std__json__JsonNode_getInt(litaC_msg, "id", 0));
    litaC_std__json__JsonNode_put(litaC_resp, "result", litaC_results);
    litaC_std__json__JsonNode_put(litaC_resp, "error", litaC_std__json__JSON_NULL);
    litaC_lsp__lsp__LspServer_writeResponse(litaC_this, litaC_resp);
    
}

litaC_void litaC_lsp__lsp__LspServer_handleTextDocumentCompletionMessage(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg,litaC_std__json__JsonNode* litaC_params) {
    litaC_std__json__JsonNode* litaC_textDoc = litaC_std__json__JsonNode_getObject(litaC_params, "textDocument");
    if(!(litaC_textDoc)) {
        {
            return;
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_uri = litaC_std__json__JsonNode_getStr(litaC_textDoc, "uri", NULL);
    litaC_std__json__JsonNode* litaC_pos = litaC_std__json__JsonNode_getObject(litaC_params, "position");
    litaC_std__json__JsonNode* litaC_context = litaC_std__json__JsonNode_getObject(litaC_params, "context");
    litaC_std__json__JsonNode* litaC_results = litaC_lsp__workspace__Workspace_autoComplete(&((litaC_this->workspace)), litaC_uri, litaC_pos, litaC_context, litaC_lsp__lsp__LspServer_requestAlloc(litaC_this));
    litaC_std__json__JsonNode* litaC_resp = litaC_lsp__lsp__LspServer_createResponse(litaC_this, litaC_std__json__JsonNode_getInt(litaC_msg, "id", 0));
    litaC_std__json__JsonNode_put(litaC_resp, "result", litaC_results);
    litaC_std__json__JsonNode_put(litaC_resp, "error", litaC_std__json__JSON_NULL);
    litaC_lsp__lsp__LspServer_writeResponse(litaC_this, litaC_resp);
    
}

litaC_void litaC_lsp__lsp__LspServer_writeDiagnostic(litaC_lsp__lsp__LspServer* litaC_this,const litaC_char* litaC_docUri,litaC_bool litaC_fullBuild) {
    litaC_phase_result__PhaseResult* litaC_result = litaC_lsp__workspace__Workspace_runDiagnostics(&((litaC_this->workspace)), litaC_docUri, litaC_fullBuild);
    litaC_std__json__JsonNode* litaC_params = litaC_std__json__CreateJsonObject(litaC_lsp__lsp__LspServer_requestAlloc(litaC_this));
    litaC_std__json__JsonNode_putStr(litaC_params, "uri", litaC_docUri, -(1));
    litaC_std__json__JsonNode* litaC_diagnostics = litaC_std__json__CreateJsonArray(litaC_lsp__lsp__LspServer_requestAlloc(litaC_this));
    litaC_std__json__JsonNode_put(litaC_params, "diagnostics", litaC_diagnostics);
    litaC_std__json__JsonNode* litaC_resp = litaC_std__json__CreateJsonObject(litaC_lsp__lsp__LspServer_requestAlloc(litaC_this));
    litaC_std__json__JsonNode_putStr(litaC_resp, "method", "textDocument/publishDiagnostics", -(1));
    litaC_std__json__JsonNode_put(litaC_resp, "params", litaC_params);
    litaC_char litaC_output[_MAX_PATH] =  {
        0
    };
    litaC_char* litaC_openedDocFilename = litaC_std__system__UriToFilePath(litaC_docUri, litaC_output);
    if(!(litaC_std__array__Array_empty_cb_PhaseError_ce_(&((litaC_result->errors))))) {
        {
            litaC_char litaC_outputPath[_MAX_PATH] =  {
                0
            };
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_PhaseError_ce_(&((litaC_result->errors)));litaC_i += 1) {
                {
                    litaC_phase_result__PhaseError litaC_error = litaC_std__array__Array_get_cb_PhaseError_ce_(&((litaC_result->errors)), litaC_i);
                    if(!(litaC_error.pos.filename)) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    litaC_char* litaC_modulePathOfError = litaC_std__system__GetAbsolutePath(litaC_this->workspace.rootPath, litaC_error.pos.filename, litaC_outputPath);
                    if(strcmp(litaC_modulePathOfError, litaC_openedDocFilename) != 0) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__json__JsonNode* litaC_diagnostic = litaC_std__json__CreateJsonObject(litaC_lsp__lsp__LspServer_requestAlloc(litaC_this));
                    litaC_std__json__JsonNode_putStr(litaC_diagnostic, "message", litaC_error.message, -(1));
                    litaC_std__json__JsonNode_putIntNumber(litaC_diagnostic, "severity", 1);
                    litaC_char* litaC_sourceLine = litaC_std__string__StringClone(litaC_error.pos.start, (litaC_i32)(litaC_error.pos.end - litaC_error.pos.start), litaC_lsp__lsp__LspServer_requestAlloc(litaC_this));
                    litaC_std__json__JsonNode_putStr(litaC_diagnostic, "source", litaC_sourceLine, -(1));
                    litaC_std__json__JsonNode_put(litaC_diagnostic, "range", litaC_lsp__protocol__SrcPosToRange(litaC_error.pos, litaC_lsp__lsp__LspServer_requestAlloc(litaC_this)));
                    litaC_std__json__JsonNode_add(litaC_diagnostics, litaC_diagnostic);
                    
                    
                }
            }
            
            
        }
        
    } 
    
    litaC_lsp__lsp__LspServer_writeResponse(litaC_this, litaC_resp);
    
}

litaC_void litaC_lsp__lsp__LspServer_writeErrorResponse(litaC_lsp__lsp__LspServer* litaC_this,litaC_i64 litaC_id,litaC_i32 litaC_code,const litaC_char* litaC_format,...) {
    va_list litaC_args = {0};
    va_start(litaC_args, litaC_format);
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(512, litaC_lsp__lsp__LspServer_requestAlloc(litaC_this));
    litaC_std__string_buffer__StringBuffer_appendArgs(&((litaC_sb)), litaC_format, litaC_args);
    va_end(litaC_args);
    litaC_std__json__JsonNode* litaC_error = litaC_std__json__CreateJsonObject(litaC_lsp__lsp__LspServer_requestAlloc(litaC_this));
    litaC_std__json__JsonNode_putStr(litaC_error, "message", litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb))), -(1));
    litaC_std__json__JsonNode_putIntNumber(litaC_error, "code", litaC_code);
    litaC_std__json__JsonNode* litaC_resp = litaC_lsp__lsp__LspServer_createResponse(litaC_this, litaC_id);
    litaC_std__json__JsonNode_put(litaC_resp, "error", litaC_error);
    litaC_lsp__lsp__LspServer_writeResponse(litaC_this, litaC_resp);
    
}

litaC_void litaC_lsp__lsp__LspServer_writeResponse(litaC_lsp__lsp__LspServer* litaC_this,litaC_std__json__JsonNode* litaC_msg) {
    litaC_std__string_buffer__StringBuffer_clear(&((litaC_this->output)));
    litaC_std__string_buffer__StringBuffer_clear(&((litaC_this->outbound)));
    const litaC_char* litaC_jsonStr = litaC_std__json__JsonNode_print(litaC_msg, &((litaC_this->output)));
    litaC_i32 litaC_length = litaC_this->output.length;
    if(litaC_length < 1) {
        {
            return;
            
            
            
        }
        
    } 
    
    
    #if defined(_WIN32) || defined(_WIN64)
    litaC_std__string_buffer__StringBuffer_append(&((litaC_this->outbound)), "Content-Length: %d\n\n%.*s", litaC_length, litaC_length, litaC_this->output.buffer);
    
    #else
    litaC_std__string_buffer__StringBuffer_append(&((litaC_this->outbound)), "Content-Length: %d\r\n\r\n%.*s", litaC_length, litaC_length, litaC_this->output.buffer);
    
    #endif
    
    litaC_lsp__lsp__LspServer_log(litaC_this, "Sending: Len: %d %.*s\n", litaC_this->outbound.length, litaC_this->outbound.length, litaC_this->outbound.buffer);
    fwrite((const litaC_void*)litaC_std__string_buffer__StringBuffer_cStr(&((litaC_this->outbound))), sizeof(litaC_char), litaC_this->outbound.length, stdout);
    fflush(stdout);
    
}

litaC_std__json__JsonNode* litaC_lsp__lsp__LspServer_createResponse(litaC_lsp__lsp__LspServer* litaC_this,litaC_i64 litaC_id) {
    litaC_std__json__JsonNode* litaC_response = litaC_std__json__CreateJsonObject(litaC_lsp__lsp__LspServer_requestAlloc(litaC_this));
    litaC_std__json__JsonNode_putStr(litaC_response, "jsonrpc", "2.0", -(1));
    if(litaC_id > -(1)) {
        {
            litaC_std__json__JsonNode_putIntNumber(litaC_response, "id", litaC_id);
            
            
        }
        
    } 
    
    return litaC_response;
    
    
}

litaC_lsp__protocol__SymbolInfoKind litaC_lsp__protocol__SymbolKindFromSymbol(litaC_symbols__Symbol* litaC_sym) {
    if(!(litaC_sym)) {
        return litaC_lsp__protocol__SymbolInfoKind_Null;
        
        
    } 
    
    switch(litaC_sym->kind) {
        case litaC_symbols__SymbolKind_FUNC: {
            {
                return litaC_lsp__protocol__SymbolInfoKind_Function;
                
                
                
            }
            
            
        }
        case litaC_symbols__SymbolKind_VAR: {
            {
                if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_CONSTANT) {
                    {
                        return litaC_lsp__protocol__SymbolInfoKind_Constant;
                        
                        
                        
                    }
                    
                } 
                
                return litaC_lsp__protocol__SymbolInfoKind_Variable;
                
                
                
            }
            
            
        }
        case litaC_symbols__SymbolKind_TYPE: {
            {
                litaC_types__TypeInfo* litaC_type = litaC_sym->type;
                if(!(litaC_type)) {
                    return litaC_lsp__protocol__SymbolInfoKind_Null;
                    
                    
                } 
                
                switch(litaC_type->kind) {
                    case litaC_types__TypeKind_ARRAY: {
                        {
                            return litaC_lsp__protocol__SymbolInfoKind_Array;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_BOOL: {
                        {
                            return litaC_lsp__protocol__SymbolInfoKind_Boolean;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_CHAR: {
                        {
                            return litaC_lsp__protocol__SymbolInfoKind_Number;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_ENUM: {
                        {
                            return litaC_lsp__protocol__SymbolInfoKind_Enum;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_FUNC: {
                        {
                            return litaC_lsp__protocol__SymbolInfoKind_Function;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_FUNC_PTR: {
                        {
                            return litaC_lsp__protocol__SymbolInfoKind_Object;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_GENERIC_PARAM: {
                        {
                            return litaC_lsp__protocol__SymbolInfoKind_TypeParameter;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_NULL: {
                        {
                            return litaC_lsp__protocol__SymbolInfoKind_Null;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_PTR: {
                        {
                            return litaC_lsp__protocol__SymbolInfoKind_Object;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_STR: {
                        {
                            return litaC_lsp__protocol__SymbolInfoKind_String;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_STRUCT: {
                        {
                            return litaC_lsp__protocol__SymbolInfoKind_Struct;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_UNION: {
                        {
                            return litaC_lsp__protocol__SymbolInfoKind_Struct;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_TRAIT: {
                        {
                            return litaC_lsp__protocol__SymbolInfoKind_Interface;
                            
                            
                            
                        }
                        
                        
                    }
                    case litaC_types__TypeKind_VOID: {
                        {
                            return litaC_lsp__protocol__SymbolInfoKind_Null;
                            
                            
                            
                        }
                        
                        
                    }
                    default: {
                        {
                            return litaC_lsp__protocol__SymbolInfoKind_Number;
                            
                            
                            
                        }
                        
                        
                    }
                }
                
                
            }
            
            
        }
        default: {
            {
                return litaC_lsp__protocol__SymbolInfoKind_Variable;
                
                
                
            }
            
            
        }
    }
    
}

litaC_std__json__JsonNode* litaC_lsp__protocol__SymbolToSymbolInformation(litaC_symbols__Symbol* litaC_sym,const litaC_char* litaC_rootPath,const litaC_std__mem__Allocator* litaC_alloc) {
    if(!(litaC_sym)) {
        return NULL;
        
        
    } 
    
    litaC_std__json__JsonNode* litaC_result = litaC_std__json__CreateJsonObject(litaC_alloc);
    litaC_std__json__JsonNode_putStr(litaC_result, "name", litaC_sym->name.buffer, litaC_sym->name.length);
    litaC_std__json__JsonNode_putBool(litaC_result, "deprecated", (litaC_sym->flags & litaC_symbols__SymbolFlags_IS_TYPE) && litaC_ast__Decl_hasNote(litaC_sym->decl, "deprecated"));
    litaC_i32 litaC_kind = (litaC_i32)litaC_lsp__protocol__SymbolKindFromSymbol(litaC_sym);
    litaC_std__json__JsonNode_putIntNumber(litaC_result, "kind", (litaC_i64)litaC_kind);
    if(litaC_sym->type) {
        {
            litaC_std__json__JsonNode_putIntNumber(litaC_result, "typeid", (litaC_i64)litaC_sym->type->typeid);
            
            
        }
        
    } 
    
    if(litaC_sym->decl) {
        {
            litaC_std__json__JsonNode* litaC_location = litaC_lsp__protocol__SrcPosToLocation(litaC_sym->decl->stmt.node.startPos, litaC_rootPath, litaC_alloc);
            if(litaC_location) {
                {
                    litaC_std__json__JsonNode_put(litaC_result, "location", litaC_location);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    return litaC_result;
    
    
}

litaC_std__json__JsonNode* litaC_lsp__protocol__SrcPosToLocation(litaC_lex__SrcPos litaC_pos,const litaC_char* litaC_rootPath,const litaC_std__mem__Allocator* litaC_alloc) {
    if(!(litaC_pos.filename)) {
        return NULL;
        
        
    } 
    
    litaC_char litaC_absPath[_MAX_PATH] =  {
        0
    };
    litaC_std__system__GetAbsolutePath(litaC_rootPath, litaC_pos.filename, litaC_absPath);
    litaC_char litaC_uri[_MAX_PATH] =  {
        0
    };
    litaC_std__system__FilePathToUri(litaC_absPath, litaC_uri);
    litaC_std__json__JsonNode* litaC_result = litaC_std__json__CreateJsonObject(litaC_alloc);
    litaC_std__json__JsonNode_putStr(litaC_result, "uri", litaC_uri, -(1));
    litaC_std__json__JsonNode_put(litaC_result, "range", litaC_lsp__protocol__SrcPosToRange(litaC_pos, litaC_alloc));
    return litaC_result;
    
    
}

litaC_std__json__JsonNode* litaC_lsp__protocol__SrcPosWithEndToLocation(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_char* litaC_rootPath,const litaC_std__mem__Allocator* litaC_alloc) {
    if(!(litaC_startPos.filename)) {
        return NULL;
        
        
    } 
    
    litaC_char litaC_absPath[_MAX_PATH] =  {
        0
    };
    litaC_std__system__GetAbsolutePath(litaC_rootPath, litaC_startPos.filename, litaC_absPath);
    litaC_char litaC_uri[_MAX_PATH] =  {
        0
    };
    litaC_std__system__FilePathToUri(litaC_absPath, litaC_uri);
    litaC_std__json__JsonNode* litaC_result = litaC_std__json__CreateJsonObject(litaC_alloc);
    litaC_std__json__JsonNode_putStr(litaC_result, "uri", litaC_uri, -(1));
    litaC_std__json__JsonNode_put(litaC_result, "range", litaC_lsp__protocol__SrcPosWithEndToRange(litaC_startPos, litaC_endPos, litaC_alloc));
    return litaC_result;
    
    
}

litaC_std__json__JsonNode* litaC_lsp__protocol__SrcPosToRange(litaC_lex__SrcPos litaC_pos,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_i64 litaC_lineNumber = (litaC_i64)MAX(litaC_pos.lineNumber - 1, 0);
    litaC_std__json__JsonNode* litaC_start = litaC_std__json__CreateJsonObject(litaC_alloc);
    litaC_std__json__JsonNode_putIntNumber(litaC_start, "line", litaC_lineNumber);
    litaC_i64 litaC_offset = MAX(0L, (litaC_i64)(litaC_pos.start - litaC_pos.lineStart));
    litaC_std__json__JsonNode_putIntNumber(litaC_start, "character", litaC_offset);
    litaC_std__json__JsonNode* litaC_end = litaC_std__json__CreateJsonObject(litaC_alloc);
    litaC_std__json__JsonNode_putIntNumber(litaC_end, "line", litaC_lineNumber);
    litaC_i64 litaC_length = MAX(1L, (litaC_i64)(litaC_pos.end - litaC_pos.start));
    litaC_std__json__JsonNode_putIntNumber(litaC_end, "character", litaC_offset + litaC_length);
    litaC_std__json__JsonNode* litaC_range = litaC_std__json__CreateJsonObject(litaC_alloc);
    litaC_std__json__JsonNode_put(litaC_range, "start", litaC_start);
    litaC_std__json__JsonNode_put(litaC_range, "end", litaC_end);
    return litaC_range;
    
    
}

litaC_std__json__JsonNode* litaC_lsp__protocol__SrcPosWithEndToRange(litaC_lex__SrcPos litaC_startPos,litaC_lex__SrcPos litaC_endPos,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_i64 litaC_startLineNumber = (litaC_i64)MAX(litaC_startPos.lineNumber - 1, 0);
    litaC_std__json__JsonNode* litaC_start = litaC_std__json__CreateJsonObject(litaC_alloc);
    litaC_std__json__JsonNode_putIntNumber(litaC_start, "line", litaC_startLineNumber);
    litaC_i64 litaC_startOffset = MAX(0L, (litaC_i64)(litaC_startPos.start - litaC_startPos.lineStart));
    litaC_std__json__JsonNode_putIntNumber(litaC_start, "character", litaC_startOffset);
    litaC_i64 litaC_endLineNumber = (litaC_i64)MAX(litaC_endPos.lineNumber - 1, 0);
    litaC_std__json__JsonNode* litaC_end = litaC_std__json__CreateJsonObject(litaC_alloc);
    litaC_std__json__JsonNode_putIntNumber(litaC_end, "line", litaC_endLineNumber);
    litaC_i64 litaC_endOffset = MAX(1L, (litaC_i64)(litaC_endPos.start - litaC_endPos.lineStart));
    litaC_std__json__JsonNode_putIntNumber(litaC_end, "character", litaC_endOffset);
    litaC_std__json__JsonNode* litaC_range = litaC_std__json__CreateJsonObject(litaC_alloc);
    litaC_std__json__JsonNode_put(litaC_range, "start", litaC_start);
    litaC_std__json__JsonNode_put(litaC_range, "end", litaC_end);
    return litaC_range;
    
    
}

litaC_std__json__JsonNode* litaC_lsp__protocol__SrcPosToLocations(const litaC_char* litaC_rootPath,litaC_std__array__Array_cb_SrcPos_ce_* litaC_results,const litaC_std__mem__Allocator* litaC_alloc) {
    if(litaC_std__array__Array_empty_cb_SrcPos_ce_(litaC_results)) {
        {
            return litaC_std__json__JSON_NULL;
            
            
            
        }
        
    } 
    
    litaC_std__json__JsonNode* litaC_locations = litaC_std__json__CreateJsonArray(litaC_alloc);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_SrcPos_ce_(litaC_results);litaC_i += 1) {
        {
            litaC_lex__SrcPos* litaC_pos = litaC_std__array__Array_getPtr_cb_SrcPos_ce_(litaC_results, litaC_i);
            litaC_std__json__JsonNode_add(litaC_locations, litaC_lsp__protocol__SrcPosToLocation(*((litaC_pos)), litaC_rootPath, litaC_alloc));
            
            
        }
    }
    return litaC_locations;
    
    
}

litaC_std__json__JsonNode* litaC_lsp__protocol__SymbolToCompletionItem(litaC_symbols__Symbol* litaC_symbol,const litaC_std__mem__Allocator* litaC_alloc) {
    if(!(litaC_symbol)) {
        {
            return litaC_std__json__JSON_NULL;
            
            
            
        }
        
    } 
    
    litaC_std__json__JsonNode* litaC_item = litaC_std__json__CreateJsonObject(litaC_alloc);
    litaC_std__json__JsonNode_putStr(litaC_item, "label", litaC_symbol->name.buffer, litaC_symbol->name.length);
    if(litaC_symbol->flags & litaC_symbols__SymbolFlags_IS_METHOD) {
        {
            if(litaC_symbol->decl) {
                {
                    litaC_std__json__JsonNode_putStr(litaC_item, "insertText", litaC_symbol->decl->name.str.buffer, litaC_symbol->decl->name.str.length);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    return litaC_item;
    
    
}

litaC_lsp__protocol__TextDocumentDidChange* litaC_lsp__protocol__JsonNodeToTextDocumentChangeEvent(litaC_std__json__JsonNode* litaC_params,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__json__JsonNode* litaC_textDoc = litaC_std__json__JsonNode_getObject(litaC_params, "textDocument");
    if(!(litaC_textDoc)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_lsp__protocol__TextDocumentDidChange* litaC_result = litaC_std__mem__new_cb_TextDocumentDidChange_ce_(litaC_alloc);
    litaC_result->textDocument.uri = litaC_std__json__JsonNode_getStr(litaC_textDoc, "uri", NULL);
    litaC_result->textDocument.version = litaC_std__json__JsonNode_getInt(litaC_textDoc, "version", 1);
    litaC_std__json__JsonNode* litaC_contentArray = litaC_std__json__JsonNode_getArray(litaC_params, "contentChanges");
    if(!(litaC_contentArray)) {
        {
            return litaC_result;
            
            
            
        }
        
    } 
    
    litaC_std__array__Array_init_cb_TextDocumentChangeEvent_ce_(&((litaC_result->contentChanges)), litaC_std__json__JsonNode_size(litaC_contentArray), litaC_alloc);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__json__JsonNode_size(litaC_contentArray);litaC_i += 1) {
        {
            litaC_std__json__JsonNode* litaC_content = litaC_std__json__JsonNode_at(litaC_contentArray, litaC_i);
            litaC_lsp__protocol__TextDocumentChangeEvent litaC_change =  {
                
            };
            litaC_change.hasRange = litaC_false;
            litaC_change.text = litaC_std__json__JsonNode_getStr(litaC_content, "text", NULL);
            litaC_change.rangeLength = litaC_std__json__JsonNode_getInt(litaC_content, "rangeLength", 0);
            litaC_std__json__JsonNode* litaC_range = litaC_std__json__JsonNode_getObject(litaC_content, "range");
            if(litaC_range) {
                {
                    litaC_lsp__protocol__Range* litaC_r = &(litaC_change.range);
                    litaC_change.hasRange = litaC_true;
                    litaC_std__json__JsonNode* litaC_start = litaC_std__json__JsonNode_getObject(litaC_range, "start");
                    if(litaC_start) {
                        {
                            litaC_r->start.line = litaC_std__json__JsonNode_getInt(litaC_start, "line", 0);
                            litaC_r->start.character = litaC_std__json__JsonNode_getInt(litaC_start, "character", 0);
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__json__JsonNode* litaC_end = litaC_std__json__JsonNode_getObject(litaC_range, "end");
                    if(litaC_end) {
                        {
                            litaC_r->end.line = litaC_std__json__JsonNode_getInt(litaC_end, "line", 0);
                            litaC_r->end.character = litaC_std__json__JsonNode_getInt(litaC_end, "character", 0);
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            litaC_std__array__Array_add_cb_TextDocumentChangeEvent_ce_(&((litaC_result->contentChanges)), litaC_change);
            
            
        }
    }
    return litaC_result;
    
    
}

litaC_void litaC_lsp__util__PosToRange(litaC_lex__SrcPos litaC_srcPos,litaC_lsp__protocol__Range* litaC_range) {
    litaC_i32 litaC_lineNumber = MAX(0, litaC_srcPos.lineNumber - 1);
    litaC_i32 litaC_offset = MAX(0, (litaC_i32)(litaC_srcPos.start - litaC_srcPos.lineStart));
    litaC_range->start.character = litaC_offset;
    litaC_range->start.line = litaC_lineNumber;
    litaC_offset = MAX(1, (litaC_i32)(litaC_srcPos.end - litaC_srcPos.start));
    litaC_range->end.character = litaC_offset;
    litaC_range->end.line = litaC_lineNumber;
    
}

litaC_bool litaC_lsp__util__IsSrcPosAtPosition(litaC_lex__SrcPos* litaC_srcPos,litaC_lsp__protocol__Position litaC_pos) {
    if(!(litaC_srcPos)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(!(litaC_srcPos->start)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_fromIndex = litaC_srcPos->position;
    litaC_i32 litaC_toIndex = litaC_fromIndex + (litaC_i32)(litaC_srcPos->end - litaC_srcPos->start);
    if((litaC_pos.line + 1) == litaC_srcPos->lineNumber) {
        {
            if(litaC_pos.character >= litaC_fromIndex && litaC_pos.character <= litaC_toIndex) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_lsp__util__SourceLocation litaC_lsp__util__SourceLookup_findAstNodeByPosition(litaC_lsp__util__SourceLookup* litaC_this,litaC_ast__ModuleStmt* litaC_moduleAst,litaC_lsp__protocol__Position litaC_pos) {
    if(!(litaC_moduleAst)) {
        {
            return (litaC_lsp__util__SourceLocation) {
                
            };
            
            
            
        }
        
    } 
    
    litaC_lsp__util__SourceLookup_visitStmt(litaC_this, &((litaC_moduleAst->stmt)));
    return litaC_this->result;
    
    
}

litaC_bool litaC_lsp__util__SourceLookup_isNodeAtPos(litaC_lsp__util__SourceLookup* litaC_this,litaC_ast__Node* litaC_node) {
    if(!(litaC_node)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_lex__SrcPos litaC_srcPos = litaC_node->startPos;
    if(litaC_lsp__util__SourceLookup_isSrcAtPos(litaC_this, &((litaC_srcPos)))) {
        {
            litaC_this->result.kind = litaC_lsp__util__SourceLocationKind_AST;
            litaC_this->result.node = litaC_node;
            litaC_lsp__util__PosToRange(litaC_srcPos, &(litaC_this->result.location.range));
            return litaC_true;
            
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_bool litaC_lsp__util__SourceLookup_isSrcAtPos(litaC_lsp__util__SourceLookup* litaC_this,litaC_lex__SrcPos* litaC_srcPos) {
    if(!(litaC_srcPos)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_lsp__util__IsSrcPosAtPosition(litaC_srcPos, litaC_this->lookupPos)) {
        {
            litaC_lsp__util__PosToRange(*((litaC_srcPos)), &(litaC_this->result.location.range));
            return litaC_true;
            
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_bool litaC_lsp__util__SourceLookup_isTokenAtPos(litaC_lsp__util__SourceLookup* litaC_this,litaC_lex__Token litaC_token) {
    if(litaC_lsp__util__IsSrcPosAtPosition(&((litaC_token.pos)), litaC_this->lookupPos)) {
        {
            litaC_lsp__util__PosToRange(litaC_token.pos, &(litaC_this->result.location.range));
            return litaC_true;
            
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_bool litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_lsp__util__SourceLookup* litaC_this,litaC_ast__TypeSpec* litaC_type) {
    if(!(litaC_type)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    switch(litaC_type->kind) {
        case litaC_ast__TypeSpecKind_ARRAY: {
            {
                litaC_ast__TypeSpec* litaC_arraySpec = litaC_type;
                if(litaC_arraySpec->numElements) {
                    {
                        if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_arraySpec->numElements)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_arraySpec->base)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_PTR: {
            {
                if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_type->base)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_CONST: {
            {
                if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_type->base)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_NAME: {
            {
                litaC_ast__TypeSpec* litaC_name = litaC_type;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)));litaC_i += 1) {
                    {
                        litaC_ast__TypeSpec* litaC_param = litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)), litaC_i);
                        if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_param)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_FUNC_PTR: {
            {
                litaC_ast__TypeSpec* litaC_funcPtr = litaC_type;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_funcPtr->genericParams)));litaC_i += 1) {
                    {
                        litaC_ast__GenericParam* litaC_param = litaC_std__array__Array_getPtr_cb_GenericParam_ce_(&((litaC_funcPtr->genericParams)), litaC_i);
                        if(litaC_lsp__util__SourceLookup_isTokenAtPos(litaC_this, litaC_param->name.token)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_funcPtr->args)));litaC_i += 1) {
                    {
                        litaC_ast__TypeSpec* litaC_param = litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_funcPtr->args)), litaC_i);
                        if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_param)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_funcPtr->base)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_funcPtr->ret)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_NONE: 
        default: {
            {
                
                
            }
            
            
        }
    }
    if(litaC_lsp__util__SourceLookup_isSrcAtPos(litaC_this, &((litaC_type->pos)))) {
        {
            litaC_this->result.kind = litaC_lsp__util__SourceLocationKind_TYPE;
            litaC_this->result.type = litaC_type;
            return litaC_true;
            
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_bool litaC_lsp__util__SourceLookup_isDeclAtPos(litaC_lsp__util__SourceLookup* litaC_this,litaC_ast__Decl* litaC_decl) {
    if(!(litaC_decl)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_lsp__util__SourceLookup_isTokenAtPos(litaC_this, litaC_decl->name.token)) {
        {
            litaC_this->result.kind = litaC_lsp__util__SourceLocationKind_AST;
            litaC_this->result.node = &(litaC_decl->stmt.node);
            litaC_lsp__util__PosToRange(litaC_decl->name.token.pos, &(litaC_this->result.location.range));
            return litaC_true;
            
            
            
        }
        
    } 
    
    return litaC_lsp__util__SourceLookup_isNodeAtPos(litaC_this, &((litaC_decl->stmt.node)));
    
    
}

litaC_bool litaC_lsp__util__SourceLookup_visitDecl(litaC_lsp__util__SourceLookup* litaC_this,litaC_ast__Decl* litaC_node) {
    if(!(litaC_node)) {
        return litaC_false;
        
        
    } 
    
    switch(litaC_node->stmt.node.kind) {
        case litaC_ast__StmtKind_IMPORT_DECL: {
            {
                litaC_ast__ImportDecl* litaC_decl = (litaC_ast__ImportDecl*)litaC_node;
                if(litaC_decl->alias.token.type == litaC_lex__TokenType_IDENTIFIER) {
                    {
                        if(litaC_lsp__util__SourceLookup_isTokenAtPos(litaC_this, litaC_decl->alias.token)) {
                            {
                                litaC_this->result.kind = litaC_lsp__util__SourceLocationKind_AST;
                                litaC_this->result.node = &(litaC_decl->decl.stmt.node);
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONST_DECL: 
        case litaC_ast__StmtKind_VAR_DECL: {
            {
                litaC_ast__VarDecl* litaC_decl = (litaC_ast__VarDecl*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_decl->expr)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_decl->typeSpec)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_decl = (litaC_ast__AggregateDecl*)litaC_node;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_decl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__FieldStmt* litaC_field = litaC_std__array__Array_getPtr_cb_FieldStmt_ce_(&((litaC_decl->fields)), litaC_i);
                        switch(litaC_field->kind) {
                            case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                {
                                    if(litaC_lsp__util__SourceLookup_visitDecl(litaC_this, &((litaC_field->traitField->decl)))) {
                                        {
                                            return litaC_true;
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                {
                                    if(litaC_lsp__util__SourceLookup_visitDecl(litaC_this, &((litaC_field->varField->decl)))) {
                                        {
                                            return litaC_true;
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                {
                                    if(litaC_lsp__util__SourceLookup_visitDecl(litaC_this, &((litaC_field->enumField->decl)))) {
                                        {
                                            return litaC_true;
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_STRUCT_FIELD_DECL: 
                            case litaC_ast__StmtKind_UNION_FIELD_DECL: {
                                {
                                    if(litaC_lsp__util__SourceLookup_visitDecl(litaC_this, &((litaC_field->aggregateField->decl.declaration)))) {
                                        {
                                            return litaC_true;
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            default: {
                                assert(litaC_false);
                                
                                
                            }
                        }
                        
                        
                    }
                }
                if(litaC_lsp__util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl.declaration)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: {
            {
                litaC_ast__EnumDecl* litaC_decl = (litaC_ast__EnumDecl*)litaC_node;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_decl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__EnumFieldEntryDecl* litaC_field = litaC_std__array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_decl->fields)), litaC_i);
                        if(litaC_lsp__util__SourceLookup_visitDecl(litaC_this, &((litaC_field->decl)))) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                if(litaC_lsp__util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                litaC_ast__FuncDecl* litaC_decl = (litaC_ast__FuncDecl*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitStmt(litaC_this, &((litaC_decl->params->stmt)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_visitStmt(litaC_this, litaC_decl->body)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_decl->returnType)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl.declaration)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                litaC_ast__TypedefDecl* litaC_decl = (litaC_ast__TypedefDecl*)litaC_node;
                if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_decl->type)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl.declaration)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAM_DECL: {
            {
                litaC_ast__ParameterDecl* litaC_decl = (litaC_ast__ParameterDecl*)litaC_node;
                if(litaC_decl->defaultExpr) {
                    {
                        if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_decl->defaultExpr)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_decl->type)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NATIVE_DECL: {
            {
                litaC_ast__NativeDecl* litaC_decl = (litaC_ast__NativeDecl*)litaC_node;
                if(litaC_lsp__util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NOTES_DECL: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_FIELD_ENTRY_DECL: {
            {
                litaC_ast__EnumFieldEntryDecl* litaC_decl = (litaC_ast__EnumFieldEntryDecl*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_decl->value)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
            {
                litaC_ast__TraitFieldDecl* litaC_decl = (litaC_ast__TraitFieldDecl*)litaC_node;
                if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_decl->type)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_VAR_FIELD_DECL: {
            {
                litaC_ast__VarFieldDecl* litaC_decl = (litaC_ast__VarFieldDecl*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_decl->defaultExpr)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_decl->type)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_isDeclAtPos(litaC_this, &((litaC_decl->decl)))) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_FIELD_DECL: 
        case litaC_ast__StmtKind_STRUCT_FIELD_DECL: 
        case litaC_ast__StmtKind_UNION_FIELD_DECL: {
            {
                assert(litaC_false);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_DECL: {
            {
                break;
                
                
            }
            
            
        }
        default: {
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_bool litaC_lsp__util__SourceLookup_visitStmt(litaC_lsp__util__SourceLookup* litaC_this,litaC_ast__Stmt* litaC_node) {
    if(!(litaC_node)) {
        return litaC_false;
        
        
    } 
    
    if(litaC_ast__IsExpr(&((litaC_node->node)))) {
        {
            return litaC_lsp__util__SourceLookup_visitExpr(litaC_this, (litaC_ast__Expr*)litaC_node);
            
            
            
        }
        
    } 
    
    if(litaC_ast__IsDecl(&((litaC_node->node)))) {
        {
            return litaC_lsp__util__SourceLookup_visitDecl(litaC_this, (litaC_ast__Decl*)litaC_node);
            
            
            
        }
        
    } 
    
    switch(litaC_node->node.kind) {
        case litaC_ast__StmtKind_BLOCK_STMT: {
            {
                litaC_ast__BlockStmt* litaC_stmt = (litaC_ast__BlockStmt*)litaC_node;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)));litaC_i += 1) {
                    {
                        litaC_ast__Stmt* litaC_s = litaC_std__array__Array_get_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)), litaC_i);
                        if(litaC_lsp__util__SourceLookup_visitStmt(litaC_this, litaC_s)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DEFER_STMT: {
            {
                litaC_ast__DeferStmt* litaC_stmt = (litaC_ast__DeferStmt*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitStmt(litaC_this, litaC_stmt->deferedStmt)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DO_WHILE_STMT: {
            {
                litaC_ast__DoWhileStmt* litaC_stmt = (litaC_ast__DoWhileStmt*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_stmt->cond)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_visitStmt(litaC_this, litaC_stmt->body)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FOR_STMT: {
            {
                litaC_ast__ForStmt* litaC_stmt = (litaC_ast__ForStmt*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitStmt(litaC_this, litaC_stmt->init)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_stmt->cond)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_visitStmt(litaC_this, litaC_stmt->post)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_visitStmt(litaC_this, litaC_stmt->body)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_BODY_STMT: {
            {
                litaC_ast__FuncBodyStmt* litaC_stmt = (litaC_ast__FuncBodyStmt*)litaC_node;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)));litaC_i += 1) {
                    {
                        litaC_ast__Stmt* litaC_s = litaC_std__array__Array_get_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)), litaC_i);
                        if(litaC_lsp__util__SourceLookup_visitStmt(litaC_this, litaC_s)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IF_STMT: {
            {
                litaC_ast__IfStmt* litaC_stmt = (litaC_ast__IfStmt*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_stmt->cond)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_visitStmt(litaC_this, litaC_stmt->then)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_visitStmt(litaC_this, litaC_stmt->elseStmt)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_MODULE_STMT: {
            {
                litaC_ast__ModuleStmt* litaC_stmt = (litaC_ast__ModuleStmt*)litaC_node;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_ImportDecl_ce_(&((litaC_stmt->imports)));litaC_i += 1) {
                    {
                        litaC_ast__ImportDecl* litaC_imp = litaC_std__array__Array_get_cb__ptr_ImportDecl_ce_(&((litaC_stmt->imports)), litaC_i);
                        if(litaC_lsp__util__SourceLookup_visitDecl(litaC_this, &((litaC_imp->decl)))) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_stmt->notes)));litaC_i += 1) {
                    {
                        litaC_ast__NoteStmt* litaC_n = litaC_std__array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_stmt->notes)), litaC_i);
                        if(litaC_lsp__util__SourceLookup_visitStmt(litaC_this, &((litaC_n->stmt)))) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Decl_ce_(&((litaC_stmt->declarations)));litaC_i += 1) {
                    {
                        litaC_ast__Decl* litaC_d = litaC_std__array__Array_get_cb__ptr_Decl_ce_(&((litaC_stmt->declarations)), litaC_i);
                        if(litaC_lsp__util__SourceLookup_visitDecl(litaC_this, litaC_d)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAMETERS_STMT: {
            {
                litaC_ast__ParametersStmt* litaC_stmt = (litaC_ast__ParametersStmt*)litaC_node;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_stmt->params)));litaC_i += 1) {
                    {
                        litaC_ast__ParameterDecl* litaC_p = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_stmt->params)), litaC_i);
                        if(litaC_lsp__util__SourceLookup_visitDecl(litaC_this, &((litaC_p->decl)))) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_RETURN_STMT: {
            {
                litaC_ast__ReturnStmt* litaC_stmt = (litaC_ast__ReturnStmt*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_stmt->expr)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SWITCH_CASE_STMT: {
            {
                litaC_ast__SwitchCaseStmt* litaC_stmt = (litaC_ast__SwitchCaseStmt*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_stmt->cond)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_visitStmt(litaC_this, litaC_stmt->body)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SWITCH_STMT: {
            {
                litaC_ast__SwitchStmt* litaC_stmt = (litaC_ast__SwitchStmt*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_stmt->cond)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_SwitchCaseStmt_ce_(&((litaC_stmt->cases)));litaC_i += 1) {
                    {
                        litaC_ast__SwitchCaseStmt* litaC_s = litaC_std__array__Array_get_cb__ptr_SwitchCaseStmt_ce_(&((litaC_stmt->cases)), litaC_i);
                        if(litaC_lsp__util__SourceLookup_visitStmt(litaC_this, &((litaC_s->stmt)))) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                if(litaC_lsp__util__SourceLookup_visitStmt(litaC_this, litaC_stmt->defaultStmt)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_WHILE_STMT: {
            {
                litaC_ast__WhileStmt* litaC_stmt = (litaC_ast__WhileStmt*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_stmt->cond)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_visitStmt(litaC_this, litaC_stmt->body)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BREAK_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONTINUE_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_EMPTY_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GOTO_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_COMP_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_LABEL_STMT: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NOTE_STMT: {
            {
                break;
                
                
            }
            
            
        }
        default: {
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_bool litaC_lsp__util__SourceLookup_visitExpr(litaC_lsp__util__SourceLookup* litaC_this,litaC_ast__Expr* litaC_node) {
    if(!(litaC_node)) {
        return litaC_false;
        
        
    } 
    
    switch(litaC_node->stmt.node.kind) {
        case litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR: {
            {
                litaC_ast__ArrayDesignationExpr* litaC_expr = (litaC_ast__ArrayDesignationExpr*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->value)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->index)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_INIT_EXPR: {
            {
                litaC_ast__ArrayInitExpr* litaC_expr = (litaC_ast__ArrayInitExpr*)litaC_node;
                if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_expr->type)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Expr_ce_(&((litaC_expr->values)));litaC_i += 1) {
                    {
                        litaC_ast__Expr* litaC_e = litaC_std__array__Array_get_cb__ptr_Expr_ce_(&((litaC_expr->values)), litaC_i);
                        if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_e)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BINARY_EXPR: {
            {
                litaC_ast__BinaryExpr* litaC_expr = (litaC_ast__BinaryExpr*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->left)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->right)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CAST_EXPR: {
            {
                litaC_ast__CastExpr* litaC_expr = (litaC_ast__CastExpr*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->exprToCast)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_expr->castTo)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_CALL_EXPR: {
            {
                litaC_ast__FuncCallExpr* litaC_expr = (litaC_ast__FuncCallExpr*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->object)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_CallArg_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
                    {
                        litaC_ast__Expr* litaC_arg = litaC_std__array__Array_get_cb_CallArg_ce_(&((litaC_expr->arguments)), litaC_i).argExpr;
                        if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_arg)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: {
            {
                litaC_ast__IdentifierExpr* litaC_expr = (litaC_ast__IdentifierExpr*)litaC_node;
                if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_expr->type)) {
                    {
                        litaC_this->result.kind = litaC_lsp__util__SourceLocationKind_AST;
                        litaC_this->result.node = &(litaC_expr->expr.stmt.node);
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR: {
            {
                litaC_ast__TypeIdentifierExpr* litaC_expr = (litaC_ast__TypeIdentifierExpr*)litaC_node;
                if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_expr->type)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GET_EXPR: {
            {
                litaC_ast__GetExpr* litaC_expr = (litaC_ast__GetExpr*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->object)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, &((litaC_expr->field->expr)))) {
                    {
                        litaC_this->result.kind = litaC_lsp__util__SourceLocationKind_AST;
                        litaC_this->result.node = &(litaC_node->stmt.node);
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GROUP_EXPR: {
            {
                litaC_ast__GroupExpr* litaC_expr = (litaC_ast__GroupExpr*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->groupedExpr)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_INIT_EXPR: {
            {
                litaC_ast__InitExpr* litaC_expr = (litaC_ast__InitExpr*)litaC_node;
                if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_expr->type)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)));litaC_i += 1) {
                    {
                        litaC_ast__TypeSpec* litaC_arg = litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_expr->genericArgs)), litaC_i);
                        if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_arg)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
                    {
                        litaC_ast__InitArgExpr* litaC_arg = litaC_std__array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)), litaC_i);
                        if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, &((litaC_arg->expr)))) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_INIT_ARG_EXPR: {
            {
                litaC_ast__InitArgExpr* litaC_expr = (litaC_ast__InitArgExpr*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->value)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_expr->fieldName.token.type == litaC_lex__TokenType_IDENTIFIER) {
                    {
                        if(litaC_lsp__util__SourceLookup_isTokenAtPos(litaC_this, litaC_expr->fieldName.token)) {
                            {
                                litaC_this->result.kind = litaC_lsp__util__SourceLocationKind_AST;
                                litaC_this->result.node = &(litaC_node->stmt.node);
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_OFFSET_OF_EXPR: {
            {
                litaC_ast__OffsetOfExpr* litaC_expr = (litaC_ast__OffsetOfExpr*)litaC_node;
                if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_expr->type)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_expr->field.token.type == litaC_lex__TokenType_IDENTIFIER) {
                    {
                        if(litaC_lsp__util__SourceLookup_isTokenAtPos(litaC_this, litaC_expr->field.token)) {
                            {
                                return litaC_true;
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SET_EXPR: {
            {
                litaC_ast__SetExpr* litaC_expr = (litaC_ast__SetExpr*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->object)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, &((litaC_expr->field->expr)))) {
                    {
                        litaC_this->result.kind = litaC_lsp__util__SourceLocationKind_AST;
                        litaC_this->result.node = &(litaC_node->stmt.node);
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->value)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SIZE_OF_EXPR: {
            {
                litaC_ast__SizeOfExpr* litaC_expr = (litaC_ast__SizeOfExpr*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->sizeOfExpr)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR: {
            {
                litaC_ast__SubscriptGetExpr* litaC_expr = (litaC_ast__SubscriptGetExpr*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->object)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->index)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_SET_EXPR: {
            {
                litaC_ast__SubscriptSetExpr* litaC_expr = (litaC_ast__SubscriptSetExpr*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->object)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->index)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->value)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TERNARY_EXPR: {
            {
                litaC_ast__TernaryExpr* litaC_expr = (litaC_ast__TernaryExpr*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->cond)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->then)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->other)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_OF_EXPR: {
            {
                litaC_ast__TypeOfExpr* litaC_expr = (litaC_ast__TypeOfExpr*)litaC_node;
                if(litaC_lsp__util__SourceLookup_isTypeAtPos(litaC_this, litaC_expr->type)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->typeOfExpr)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNARY_EXPR: {
            {
                litaC_ast__UnaryExpr* litaC_expr = (litaC_ast__UnaryExpr*)litaC_node;
                if(litaC_lsp__util__SourceLookup_visitExpr(litaC_this, litaC_expr->unaryExpr)) {
                    {
                        return litaC_true;
                        
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NULL_EXPR: 
        case litaC_ast__StmtKind_NUMBER_EXPR: 
        case litaC_ast__StmtKind_STRING_EXPR: 
        case litaC_ast__StmtKind_CHAR_EXPR: 
        case litaC_ast__StmtKind_BOOLEAN_EXPR: 
        case litaC_ast__StmtKind_POISON_EXPR: {
            {
                break;
                
                
            }
            
            
        }
        default: {
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_void litaC_lsp__document__Document_refreshLineMap(litaC_lsp__document__Document* litaC_this) {
    litaC_std__array__Array_clear_cb_u32_ce_(&((litaC_this->lineMap)));
    litaC_std__array__Array_add_cb_u32_ce_(&((litaC_this->lineMap)), 0);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_this->text.length;litaC_i += 1) {
        {
            litaC_char litaC_c = litaC_this->text.buffer[litaC_i];
            if(litaC_c == '\n') {
                {
                    litaC_std__array__Array_add_cb_u32_ce_(&((litaC_this->lineMap)), litaC_i + 1);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

LITAC_INLINE 
litaC_u32 litaC_lsp__document__Document_getLineStart(litaC_lsp__document__Document* litaC_this,litaC_i32 litaC_lineNumber) {
    return litaC_std__array__Array_get_cb_u32_ce_(&((litaC_this->lineMap)), litaC_lineNumber);
    
    
}

litaC_void litaC_lsp__document__Document_insert(litaC_lsp__document__Document* litaC_this,litaC_lsp__protocol__Range litaC_range,const litaC_char* litaC_text) {
    litaC_i32 litaC_fromIndex = (litaC_i32)(litaC_lsp__document__Document_getLineStart(litaC_this, litaC_range.start.line) + litaC_range.start.character);
    litaC_i32 litaC_toIndex = (litaC_i32)(litaC_lsp__document__Document_getLineStart(litaC_this, litaC_range.end.line) + litaC_range.end.character);
    litaC_std__string_buffer__StringBuffer_replace(&((litaC_this->text)), litaC_fromIndex, litaC_toIndex, litaC_text);
    litaC_lsp__document__Document_refreshLineMap(litaC_this);
    
}

litaC_void litaC_lsp__document__Document_setText(litaC_lsp__document__Document* litaC_this,const litaC_char* litaC_text) {
    litaC_std__string_buffer__StringBuffer_clear(&((litaC_this->text)));
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_this->text)), litaC_text);
    litaC_lsp__document__Document_refreshLineMap(litaC_this);
    
}

litaC_void litaC_instrument__Instrument(litaC_lita__Lita* litaC_lita,litaC_checker__TypeChecker* litaC_checker) {
    litaC_char litaC_filename[_MAX_PATH] =  {
        0
    };
    litaC_std__string_view__StringView litaC_moduleName = litaC_std__string_view__StringViewInit("profile", -(1));
    if(!(litaC_lita__FindModulePath(litaC_lita, litaC_moduleName, litaC_filename))) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_lita->result)), (litaC_lex__SrcPos) {
                
            }, "could not find module 'profile' on the system path.");
            return;
            
            
            
        }
        
    } 
    
    litaC_module__Module* litaC_module = litaC_lita__Lita_getModule(litaC_lita, litaC_filename);
    if(!(litaC_module)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(2048 * 2, litaC_lita->allocator);
    litaC_bool litaC_profileAll = litaC_true;
    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "@generated public enum ProfileTag {\n");
    litaC_i32 litaC_numOfProfiled = 0;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)), litaC_i);
            if(litaC_sym->declared == litaC_module) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_sym->flags & (litaC_symbols__SymbolFlags_IS_FOREIGN | litaC_symbols__SymbolFlags_IS_MAIN | litaC_symbols__SymbolFlags_IS_TEST)) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_ast__Decl_hasNote(litaC_sym->decl, "no_profile")) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_profileAll || litaC_ast__Decl_hasNote(litaC_sym->decl, "profile")) {
                {
                    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "    %.*s__%.*s,\n", litaC_sym->declared->id.name.length, litaC_sym->declared->id.name.buffer, litaC_sym->name.length, litaC_sym->name.buffer);
                    litaC_numOfProfiled += 1;
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "    MAX_PROFILE_TAGS\n");
    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "\n}\n");
    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "@generated const profileEntries = [%d]ProfileEntry {\n", litaC_numOfProfiled);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)), litaC_i);
            if(litaC_sym->declared == litaC_module) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_sym->flags & (litaC_symbols__SymbolFlags_IS_FOREIGN | litaC_symbols__SymbolFlags_IS_MAIN | litaC_symbols__SymbolFlags_IS_TEST)) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_ast__Decl_hasNote(litaC_sym->decl, "no_profile")) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_profileAll || litaC_ast__Decl_hasNote(litaC_sym->decl, "profile")) {
                {
                    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "\n                ProfileEntry {\n                    .functionName = \"%.*s::%.*s\",\n                    .count = 0_u64,\n                    .startTime = 0_f64,\n                    .totalTime = 0_f64,\n                },\n            ", litaC_sym->declared->id.name.length, litaC_sym->declared->id.name.buffer, litaC_sym->name.length, litaC_sym->name.buffer);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "\n}\n");
    litaC_parser__Parser litaC_parser = litaC_parser__ParserInit(litaC_module->id.filename, litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_sb.length, litaC_module, litaC_lita);
    litaC_ast__ModuleStmt* litaC_stmts = litaC_parser__Parser_parseModule(&((litaC_parser)));
    if(litaC_stmts) {
        {
            litaC_checker__TypeChecker_enterModule(litaC_checker, litaC_module);
            
            {
                litaC_ast__Decl* litaC_tagDecl = litaC_std__array__Array_get_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)), 0);
                assert(litaC_tagDecl->stmt.node.kind == litaC_ast__StmtKind_ENUM_DECL);
                litaC_symbols__Symbol* litaC_existingDecl = litaC_module__Module_getType(litaC_module, litaC_intern__PROFILE_TAG);
                assert(litaC_existingDecl != NULL);
                litaC_tagDecl->sym = litaC_existingDecl;
                litaC_existingDecl->decl = litaC_tagDecl;
                
                
            }
            {
                litaC_ast__Decl* litaC_entriesDecl = litaC_std__array__Array_get_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)), 1);
                assert(litaC_entriesDecl->stmt.node.kind == litaC_ast__StmtKind_CONST_DECL);
                litaC_symbols__Symbol* litaC_existingDecl = litaC_module__Module_getType(litaC_module, litaC_intern__PROFILE_ENTRIES);
                assert(litaC_existingDecl != NULL);
                litaC_entriesDecl->sym = litaC_existingDecl;
                litaC_existingDecl->decl = litaC_entriesDecl;
                
                
            }
            litaC_checker__TypeChecker_leaveModule(litaC_checker);
            
            
        }
        
    } 
    
    litaC_sb = litaC_std__string_buffer__StringBufferInit(2048, litaC_lita->allocator);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_checker->symbolFuncs)), litaC_i);
            if(litaC_sym->declared == litaC_module) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_sym->flags & (litaC_symbols__SymbolFlags_IS_FOREIGN | litaC_symbols__SymbolFlags_IS_MAIN | litaC_symbols__SymbolFlags_IS_TEST)) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_ast__Decl_hasNote(litaC_sym->decl, "no_profile")) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_profileAll || litaC_ast__Decl_hasNote(litaC_sym->decl, "profile")) {
                {
                    const litaC_char* litaC_alias = litaC_ast_copy__AstAddImport(litaC_lita, litaC_checker, litaC_sym->declared, litaC_module);
                    if(litaC_alias) {
                        {
                            litaC_std__string_buffer__StringBuffer_clear(&((litaC_sb)));
                            litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "defer %s::StopWatch(%s::ProfileTag.%.*s__%.*s)\n", litaC_alias, litaC_alias, litaC_sym->declared->id.name.length, litaC_sym->declared->id.name.buffer, litaC_sym->name.length, litaC_sym->name.buffer);
                            litaC_ast_copy__AstInsertText(&((litaC_sym->decl->stmt.node)), litaC_std__string__StringClone(litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_sb.length, litaC_module->allocator), 0, litaC_module, litaC_lita);
                            litaC_std__string_buffer__StringBuffer_clear(&((litaC_sb)));
                            litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "%s::StartWatch(%s::ProfileTag.%.*s__%.*s)\n", litaC_alias, litaC_alias, litaC_sym->declared->id.name.length, litaC_sym->declared->id.name.buffer, litaC_sym->name.length, litaC_sym->name.buffer);
                            litaC_ast_copy__AstInsertText(&((litaC_sym->decl->stmt.node)), litaC_std__string__StringClone(litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_sb.length, litaC_module->allocator), 0, litaC_module, litaC_lita);
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_std__string_buffer__StringBuffer_clear(&((litaC_sb)));
                            litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "defer StopWatch(ProfileTag.%.*s__%.*s)\n", litaC_sym->declared->id.name.length, litaC_sym->declared->id.name.buffer, litaC_sym->name.length, litaC_sym->name.buffer);
                            litaC_ast_copy__AstInsertText(&((litaC_sym->decl->stmt.node)), litaC_std__string__StringClone(litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_sb.length, litaC_module->allocator), 0, litaC_module, litaC_lita);
                            litaC_std__string_buffer__StringBuffer_clear(&((litaC_sb)));
                            litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "StartWatch(ProfileTag.%.*s__%.*s)\n", litaC_sym->declared->id.name.length, litaC_sym->declared->id.name.buffer, litaC_sym->name.length, litaC_sym->name.buffer);
                            litaC_ast_copy__AstInsertText(&((litaC_sym->decl->stmt.node)), litaC_std__string__StringClone(litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_sb.length, litaC_module->allocator), 0, litaC_module, litaC_lita);
                            
                            
                        }
                    } 
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

litaC_std__array__Array_cb__ptr_Decl_ce_ litaC_traits__CreateTraitWrappers(litaC_checker__TypeChecker* litaC_checker) {
    const litaC_std__mem__Allocator* litaC_allocator = litaC_checker->current->allocator;
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(2048, litaC_allocator);
    litaC_std__string_buffer__StringBuffer litaC_traitBuffer = litaC_std__string_buffer__StringBufferInit(litaC_symbols__MAX_SYMBOL_NAME, litaC_allocator);
    litaC_std__string_buffer__StringBuffer litaC_traitFieldBuffer = litaC_std__string_buffer__StringBufferInit(litaC_symbols__MAX_SYMBOL_NAME, litaC_allocator);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_checker->symbolTraits)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_traitSym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_checker->symbolTraits)), litaC_i);
            assert(litaC_traitSym);
            assert(litaC_traitSym->decl && litaC_traitSym->decl->stmt.node.kind == litaC_ast__StmtKind_TRAIT_DECL);
            litaC_ast__AggregateDecl* litaC_traitDecl = (litaC_ast__AggregateDecl*)litaC_traitSym->decl;
            litaC_std__string_view__StringView litaC_traitName = litaC_traits__GetTraitName(litaC_traitSym, &((litaC_traitBuffer)));
            litaC_traits__GenerateVTable(litaC_traitSym, litaC_traitDecl, litaC_traitName, &((litaC_sb)));
            if(!(litaC_std__map__Map_contains_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_checker->interfaceImpls)), litaC_traitSym->type->typeid))) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_std__array__Array_cb_i64_ce_* litaC_impls = litaC_std__map__Map_getPtr_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_checker->interfaceImpls)), litaC_traitSym->type->typeid);
            litaC_traits__GenerateWrapperFunctions(litaC_checker, litaC_traitSym, litaC_traitDecl, litaC_traitName, &((litaC_sb)), &((litaC_traitFieldBuffer)), litaC_impls);
            litaC_traits__GenerateVTableEntries(litaC_checker, litaC_traitDecl, litaC_traitName, &((litaC_sb)), &((litaC_traitFieldBuffer)), litaC_impls);
            
            
        }
    }
    litaC_parser__Parser litaC_parser = litaC_parser__ParserInit("generated", litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_sb.length, litaC_checker->current, litaC_checker->lita);
    litaC_ast__ModuleStmt* litaC_stmts = litaC_parser__Parser_parseModule(&((litaC_parser)));
    return litaC_stmts->declarations;
    
    
}

litaC_void litaC_traits__GenerateVTable(litaC_symbols__Symbol* litaC_traitSym,litaC_ast__AggregateDecl* litaC_traitDecl,litaC_std__string_view__StringView litaC_traitName,litaC_std__string_buffer__StringBuffer* litaC_sb) {
    litaC_std__string_buffer__StringBuffer_append(litaC_sb, "@hidden struct %.*s__VirtualTable", litaC_traitName.length, litaC_traitName.buffer);
    litaC_std__string_buffer__StringBuffer_append(litaC_sb, " {\n");
    for(litaC_i32 litaC_j = 0;litaC_j < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_traitDecl->fields)));litaC_j += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_traitDecl->fields)), litaC_j);
            assert(litaC_field.kind == litaC_ast__StmtKind_TRAIT_FIELD_DECL);
            assert(litaC_field.typeInfo != NULL && litaC_field.typeInfo->kind == litaC_types__TypeKind_FUNC_PTR);
            litaC_types__TypeInfo* litaC_fn = litaC_field.typeInfo;
            litaC_ast__TraitFieldDecl* litaC_traitField = litaC_field.traitField;
            litaC_std__string_buffer__StringBuffer_append(litaC_sb, "    %.*s: func", litaC_traitField->decl.name.str.length, litaC_traitField->decl.name.str.buffer);
            litaC_traits__PrintGenerics(&((litaC_fn->genericParams)), litaC_sb);
            litaC_std__string_buffer__StringBuffer_append(litaC_sb, "(*void");
            for(litaC_i32 litaC_p = 0;litaC_p < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_fn->paramDecls)));litaC_p += 1) {
                {
                    litaC_types__TypeInfo* litaC_param = litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_fn->paramDecls)), litaC_p);
                    litaC_std__string_buffer__StringBuffer_append(litaC_sb, ", ");
                    litaC_types__TypeInfo_toString(litaC_param, litaC_sb, litaC_true);
                    
                    
                }
            }
            litaC_std__string_buffer__StringBuffer_append(litaC_sb, ") : ");
            litaC_types__TypeInfo_toString(litaC_fn->returnType, litaC_sb, litaC_true);
            litaC_std__string_buffer__StringBuffer_append(litaC_sb, ";\n");
            
            
        }
    }
    litaC_std__string_buffer__StringBuffer_append(litaC_sb, "}\n");
    
}

litaC_void litaC_traits__GenerateWrapperFunctions(litaC_checker__TypeChecker* litaC_checker,litaC_symbols__Symbol* litaC_traitSym,litaC_ast__AggregateDecl* litaC_traitDecl,litaC_std__string_view__StringView litaC_traitName,litaC_std__string_buffer__StringBuffer* litaC_sb,litaC_std__string_buffer__StringBuffer* litaC_traitFieldBuffer,litaC_std__array__Array_cb_i64_ce_* litaC_impls) {
    litaC_std__string_buffer__StringBuffer_append(litaC_sb, "// Trait: '%.*s' has %d impls\n", litaC_traitDecl->decl.declaration.name.str.length, litaC_traitDecl->decl.declaration.name.str.buffer, litaC_std__array__Array_size_cb_i64_ce_(litaC_impls));
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_i64_ce_(litaC_impls);litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_implSym = litaC_traits__FindSymbolByTypeid(litaC_checker->symbolTypes, litaC_std__array__Array_get_cb_i64_ce_(litaC_impls, litaC_i));
            if(!(litaC_implSym)) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_std__string_view__StringView litaC_implEscapedName = litaC_traits__GetTraitName(litaC_implSym, litaC_traitFieldBuffer);
            litaC_intern__InternedString litaC_implName = litaC_implSym->name;
            if(litaC_implSym->flags & litaC_symbols__SymbolFlags_IS_FROM_GENERIC_TEMPLATE) {
                {
                    litaC_i64 litaC_genericTypeid = litaC_implSym->type->genericTypeid;
                    litaC_symbols__Symbol* litaC_genSym = litaC_traits__FindSymbolByTypeid(litaC_checker->symbolTypes, litaC_genericTypeid);
                    litaC_implName = litaC_genSym->name;
                    
                    
                }
                
            } 
            
            for(litaC_i32 litaC_j = 0;litaC_j < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_traitDecl->fields)));litaC_j += 1) {
                {
                    litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_traitDecl->fields)), litaC_j);
                    assert(litaC_field.kind == litaC_ast__StmtKind_TRAIT_FIELD_DECL);
                    assert(litaC_field.typeInfo && litaC_field.typeInfo->kind == litaC_types__TypeKind_FUNC_PTR);
                    litaC_types__TypeInfo* litaC_fn = litaC_field.typeInfo;
                    litaC_std__string_buffer__StringBuffer_append(litaC_sb, "@hidden func __%.*s_%.*s_wrapper", litaC_implEscapedName.length, litaC_implEscapedName.buffer, litaC_field.traitField->decl.name.str.length, litaC_field.traitField->decl.name.str.buffer);
                    litaC_std__string_buffer__StringBuffer_append(litaC_sb, "(this: *void");
                    for(litaC_i32 litaC_p = 0;litaC_p < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_fn->paramDecls)));litaC_p += 1) {
                        {
                            litaC_types__TypeInfo* litaC_param = litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_fn->paramDecls)), litaC_p);
                            litaC_std__string_buffer__StringBuffer_append(litaC_sb, ", _%d: ", litaC_p);
                            litaC_types__TypeInfo_toString(litaC_param, litaC_sb, litaC_true);
                            
                            
                        }
                    }
                    if(litaC_fn->hasVarargs) {
                        {
                            litaC_std__string_buffer__StringBuffer_append(litaC_sb, ", ...");
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__string_buffer__StringBuffer_append(litaC_sb, ") : ");
                    litaC_types__TypeInfo_toString(litaC_fn->returnType, litaC_sb, litaC_true);
                    litaC_std__string_buffer__StringBuffer_append(litaC_sb, " {\n");
                    {
                        if(litaC_module__Module_isBuiltin(litaC_implSym->declared)) {
                            {
                                litaC_std__string_buffer__StringBuffer_append(litaC_sb, "    var __this = this as (*%.*s", litaC_implName.length, litaC_implName.buffer);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_intern__InternedString litaC_moduleName = litaC_implSym->declared->id.name;
                                litaC_std__string_buffer__StringBuffer_append(litaC_sb, "    var __this = this as (*%.*s::%.*s", litaC_moduleName.length, litaC_moduleName.buffer, litaC_implName.length, litaC_implName.buffer);
                                
                                
                            }
                        } 
                        
                        litaC_traits__PrintGenericArgs(&((litaC_implSym->genericArgs)), litaC_sb);
                        litaC_std__string_buffer__StringBuffer_append(litaC_sb, ")\n");
                        if(litaC_fn->returnType->kind != litaC_types__TypeKind_VOID) {
                            {
                                litaC_std__string_buffer__StringBuffer_append(litaC_sb, "    return ");
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_std__string_buffer__StringBuffer_append(litaC_sb, "    ");
                                
                                
                            }
                        } 
                        
                        litaC_std__string_buffer__StringBuffer_append(litaC_sb, "__this.%.*s", litaC_field.traitField->decl.name.str.length, litaC_field.traitField->decl.name.str.buffer);
                        litaC_std__string_buffer__StringBuffer_append(litaC_sb, "(");
                        for(litaC_i32 litaC_p = 0;litaC_p < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_fn->paramDecls)));litaC_p += 1) {
                            {
                                litaC_types__TypeInfo* litaC_param = litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_fn->paramDecls)), litaC_p);
                                if(litaC_p > 0) {
                                    {
                                        litaC_std__string_buffer__StringBuffer_append(litaC_sb, ", ");
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_std__string_buffer__StringBuffer_append(litaC_sb, "_%d", litaC_p);
                                
                                
                            }
                        }
                        litaC_std__string_buffer__StringBuffer_append(litaC_sb, ")");
                        
                        
                    }
                    litaC_std__string_buffer__StringBuffer_append(litaC_sb, "\n}\n");
                    
                    
                }
            }
            
            
        }
    }
    
}

litaC_void litaC_traits__GenerateVTableEntries(litaC_checker__TypeChecker* litaC_checker,litaC_ast__AggregateDecl* litaC_traitDecl,litaC_std__string_view__StringView litaC_traitName,litaC_std__string_buffer__StringBuffer* litaC_sb,litaC_std__string_buffer__StringBuffer* litaC_traitFieldBuffer,litaC_std__array__Array_cb_i64_ce_* litaC_impls) {
    litaC_std__string_buffer__StringBuffer_append(litaC_sb, "@hidden const %.*s__vtables = []*%.*s__VirtualTable {\n", litaC_traitName.length, litaC_traitName.buffer, litaC_traitName.length, litaC_traitName.buffer);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_i64_ce_(litaC_impls);litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_implSym = litaC_traits__FindSymbolByTypeid(litaC_checker->symbolTypes, litaC_std__array__Array_get_cb_i64_ce_(litaC_impls, litaC_i));
            if(!(litaC_implSym)) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_std__string_view__StringView litaC_implEscapedName = litaC_traits__GetTraitName(litaC_implSym, litaC_traitFieldBuffer);
            litaC_std__string_buffer__StringBuffer_append(litaC_sb, "    [%d] = &%.*s__VirtualTable {\n", litaC_i, litaC_traitName.length, litaC_traitName.buffer);
            {
                for(litaC_i32 litaC_j = 0;litaC_j < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_traitDecl->fields)));litaC_j += 1) {
                    {
                        litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_traitDecl->fields)), litaC_j);
                        assert(litaC_field.kind == litaC_ast__StmtKind_TRAIT_FIELD_DECL);
                        litaC_std__string_buffer__StringBuffer_append(litaC_sb, "        .%.*s = __%.*s_%.*s_wrapper", litaC_field.traitField->decl.name.str.length, litaC_field.traitField->decl.name.str.buffer, litaC_implEscapedName.length, litaC_implEscapedName.buffer, litaC_field.traitField->decl.name.str.length, litaC_field.traitField->decl.name.str.buffer);
                        litaC_std__string_buffer__StringBuffer_append(litaC_sb, ",\n");
                        
                        
                    }
                }
                
                
            }
            litaC_std__string_buffer__StringBuffer_append(litaC_sb, "    },\n");
            
            
        }
    }
    litaC_std__string_buffer__StringBuffer_append(litaC_sb, "}\n");
    
}

litaC_void litaC_traits__PrintGenerics(litaC_std__array__Array_cb_GenericParam_ce_* litaC_genericParams,litaC_std__string_buffer__StringBuffer* litaC_sb) {
    for(litaC_i32 litaC_x = 0;litaC_x < litaC_std__array__Array_size_cb_GenericParam_ce_(litaC_genericParams);litaC_x += 1) {
        {
            if(litaC_x == 0) {
                {
                    litaC_std__string_buffer__StringBuffer_append(litaC_sb, "<");
                    
                    
                }
                
            } 
            
            if(litaC_x > 0) {
                {
                    litaC_std__string_buffer__StringBuffer_append(litaC_sb, ", ");
                    
                    
                }
                
            } 
            
            litaC_ast__Identifier litaC_name = litaC_std__array__Array_get_cb_GenericParam_ce_(litaC_genericParams, litaC_x).name;
            litaC_std__string_buffer__StringBuffer_append(litaC_sb, "%.*s", litaC_name.str.length, litaC_name.str.buffer);
            
            
        }
    }
    if(litaC_std__array__Array_size_cb_GenericParam_ce_(litaC_genericParams) > 0) {
        {
            litaC_std__string_buffer__StringBuffer_append(litaC_sb, ">");
            
            
        }
        
    } 
    
    
}

litaC_void litaC_traits__PrintGenericArgs(litaC_std__array__Array_cb__ptr_TypeInfo_ce_* litaC_genericArgs,litaC_std__string_buffer__StringBuffer* litaC_sb) {
    for(litaC_i32 litaC_x = 0;litaC_x < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(litaC_genericArgs);litaC_x += 1) {
        {
            if(litaC_x == 0) {
                {
                    litaC_std__string_buffer__StringBuffer_append(litaC_sb, "<");
                    
                    
                }
                
            } 
            
            if(litaC_x > 0) {
                {
                    litaC_std__string_buffer__StringBuffer_append(litaC_sb, ", ");
                    
                    
                }
                
            } 
            
            litaC_types__TypeInfo* litaC_type = litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(litaC_genericArgs, litaC_x);
            assert(litaC_type);
            litaC_types__TypeInfo_toString(litaC_type, litaC_sb, litaC_true);
            
            
        }
    }
    if(litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(litaC_genericArgs) > 0) {
        {
            litaC_std__string_buffer__StringBuffer_append(litaC_sb, ">");
            
            
        }
        
    } 
    
    
}

litaC_symbols__Symbol* litaC_traits__FindSymbolByTypeid(litaC_std__array__Array_cb__ptr_Symbol_ce_ litaC_symbols,litaC_i64 litaC_id) {
    if(litaC_id < litaC_types__TypeKind_MAX_TYPE_KINDS) {
        {
            return litaC_module__GetBuiltinSymbol(litaC_id);
            
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_symbols)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_symbols)), litaC_i);
            if(litaC_sym->type && litaC_sym->type->typeid == litaC_id) {
                {
                    return litaC_sym;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return NULL;
    
    
}

litaC_std__string_view__StringView litaC_traits__GetTraitName(litaC_symbols__Symbol* litaC_traitSym,litaC_std__string_buffer__StringBuffer* litaC_sb) {
    if(!((litaC_traitSym->flags & litaC_symbols__SymbolFlags_IS_FROM_GENERIC_TEMPLATE))) {
        {
            return litaC_traitSym->name.view;
            
            
            
        }
        
    } 
    
    litaC_std__string_buffer__StringBuffer_clear(litaC_sb);
    litaC_common__EscapeName(litaC_traitSym->name.buffer, litaC_traitSym->name.length, litaC_sb);
    return (litaC_std__string_view__StringView) {
        .buffer = litaC_sb->buffer,
        .length = litaC_sb->length
    };
    
    
}

litaC_void litaC_traits__Parse(litaC_std__string_buffer__StringBuffer* litaC_sb,litaC_checker__TypeChecker* litaC_checker,litaC_std__array__Array_cb__ptr_Decl_ce_* litaC_decls) {
    litaC_parser__Parser litaC_parser = litaC_parser__ParserInit("generated", litaC_std__string_buffer__StringBuffer_cStr(litaC_sb), litaC_sb->length, litaC_checker->current, litaC_checker->lita);
    litaC_ast__ModuleStmt* litaC_stmts = litaC_parser__Parser_parseModule(&((litaC_parser)));
    litaC_std__array__Array_addAll_cb__ptr_Decl_ce_(litaC_decls, &((litaC_stmts->declarations)));
    
}

litaC_void litaC_preprocessor__api__Preprocessor_registerApi(litaC_preprocessor__Preprocessor* litaC_this) {
    litaC_this->runtime.ape = ape_make_ex(litaC_preprocessor__api__litaMalloc, litaC_preprocessor__api__noOpFree, (litaC_void*)litaC_this->lita);
    ape_set_repl_mode(litaC_this->runtime.ape, litaC_true);
    ape_set_global_constant(litaC_this->runtime.ape, "OS", ape_object_make_string(litaC_this->runtime.ape, litaC_std__system__OSAsStr(litaC_std__system__GetOS())));
    ape_set_global_constant(litaC_this->runtime.ape, "ARCH", ape_object_make_string(litaC_this->runtime.ape, litaC_std__system__ArchAsStr(litaC_std__system__GetArch())));
    ape_set_global_constant(litaC_this->runtime.ape, "DEBUG", ape_object_make_bool(litaC_this->lita->options->isDebug));
    ape_set_global_constant(litaC_this->runtime.ape, "REFLECTION", ape_object_make_bool(litaC_this->lita->options->typeOption != litaC_lita__TypeInfoOption_NONE));
    ape_set_global_constant(litaC_this->runtime.ape, "TESTING", ape_object_make_bool(litaC_this->lita->options->testsOnly));
    ape_set_global_constant(litaC_this->runtime.ape, "INSTRUMENT", ape_object_make_bool(litaC_this->lita->options->instrument));
    ape_set_global_constant(litaC_this->runtime.ape, "OUTPUT_NAME", ape_object_make_string(litaC_this->runtime.ape, litaC_this->lita->options->outputFile));
    ape_set_global_constant(litaC_this->runtime.ape, "OUTPUT_PATH", ape_object_make_string(litaC_this->runtime.ape, litaC_this->lita->options->outputPath));
    ape_set_native_function(litaC_this->runtime.ape, "getTypeKind", litaC_preprocessor__api__ApeGetTypeKind, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->runtime.ape, "isPrimitive", litaC_preprocessor__api__ApeIsPrimitive, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->runtime.ape, "getSymbol", litaC_preprocessor__api__ApeGetSymbol, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->runtime.ape, "getSymbolByTypeInfo", litaC_preprocessor__api__ApeGetSymbolByTypeInfo, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->runtime.ape, "getTypeInfo", litaC_preprocessor__api__ApeGetTypeInfo, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->runtime.ape, "getSymbolsByNote", litaC_preprocessor__api__ApeGetSymbolsWithNote, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->runtime.ape, "getSymbolsToTest", litaC_preprocessor__api__ApeGetSymbolsToTest, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->runtime.ape, "addDeclaration", litaC_preprocessor__api__ApeAddDeclaration, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->runtime.ape, "replaceDeclaration", litaC_preprocessor__api__ApeReplaceDeclaration, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->runtime.ape, "addImport", litaC_preprocessor__api__ApeAddImport, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->runtime.ape, "flushDeclarations", litaC_preprocessor__api__ApeFlushDeclarations, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->runtime.ape, "assert", litaC_preprocessor__api__ApeAssert, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->runtime.ape, "getMainSymbol", litaC_preprocessor__api__ApeGetMainSymbol, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->runtime.ape, "setMainSymbol", litaC_preprocessor__api__ApeSetMainSymbol, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->runtime.ape, "getInputModuleFilename", litaC_preprocessor__api__ApeGetInputModuleFilename, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->runtime.ape, "getCurrentModuleFilename", litaC_preprocessor__api__ApeGetCurrentModuleFilename, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->runtime.ape, "astInsert", litaC_preprocessor__api__ApeAstInsert, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->runtime.ape, "emit", litaC_preprocessor__api__ApeEmit, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->runtime.ape, "emitClear", litaC_preprocessor__api__ApeEmitClear, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->runtime.ape, "emitStr", litaC_preprocessor__api__ApeEmitStr, &(litaC_this->callContext));
    ape_set_native_function(litaC_this->runtime.ape, "error", litaC_preprocessor__api__ApeError, &(litaC_this->callContext));
    
}

litaC_void litaC_preprocessor__api__Preprocessor_deregisterApi(litaC_preprocessor__Preprocessor* litaC_this) {
    
}

litaC_bool litaC_preprocessor__api__Preprocessor_execute(litaC_preprocessor__Preprocessor* litaC_this,litaC_ast__CompStmt* litaC_comp,litaC_std__string_view__StringView litaC_code) {
    ape_object_t litaC_result = ape_execute(litaC_this->runtime.ape, litaC_code.buffer, litaC_code.length);
    if(ape_has_errors(litaC_this->runtime.ape)) {
        {
            const ape_error_t* litaC_error = ape_get_error(litaC_this->runtime.ape, 0);
            litaC_lex__SrcPos litaC_pos =  {
                .filename = litaC_comp->stmt.node.startPos.filename,
                .lineStart = litaC_comp->stmt.node.startPos.lineStart,
                .start = litaC_comp->stmt.node.startPos.start,
                .end = litaC_comp->stmt.node.startPos.end,
                .lineNumber = litaC_comp->stmt.node.startPos.lineNumber,
                .position = litaC_comp->stmt.node.startPos.position
            };
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_pos, "error evaluating preprocessor expression: '%s' for line:\n%s", ape_error_get_message(litaC_error), ape_error_get_line(litaC_error));
            return litaC_false;
            
            
            
        }
        
    } 
    
    return ape_object_get_bool(litaC_result);
    
    
}

litaC_void litaC_preprocessor__api__noOpFree(litaC_void* litaC_ctx,litaC_void* litaC_mem) {
    
}

litaC_void* litaC_preprocessor__api__litaMalloc(litaC_void* litaC_ctx,litaC_usize litaC_len) {
    litaC_lita__Lita* litaC_lita = (litaC_lita__Lita*)litaC_ctx;
    return litaC_std__mem__Allocator_alloc(litaC_lita->allocator, litaC_len);
    
    
}

ape_object_t litaC_preprocessor__api__ApeGetTypeKind(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    if(!(APE_CHECK_ARGS(litaC_ape, litaC_true, litaC_argc, litaC_args, APE_OBJECT_STRING))) {
        {
            litaC_preprocessor__api__CallContext_logErrors(litaC_context);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_element = (const litaC_char*)ape_object_get_string(litaC_args[0]);
    if(!(litaC_element)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty symbol name");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_intern__InternedString litaC_elementIntern = litaC_intern__Strings_internCopy(&((litaC_context->pp->lita->strings)), litaC_element, -(1));
    litaC_symbols__Symbol* litaC_symbol = litaC_symbols__Scope_lookup(litaC_context->checker->current->currentScope, litaC_elementIntern, litaC_true);
    if(!(litaC_symbol)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "no symbol found for '%s'", litaC_element);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    return ape_object_make_string(litaC_ape, litaC_types__TypeKindAsStr(litaC_symbol->type->kind));
    
    
}

ape_object_t litaC_preprocessor__api__ApeIsPrimitive(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    if(!(APE_CHECK_ARGS(litaC_ape, litaC_true, litaC_argc, litaC_args, APE_OBJECT_STRING))) {
        {
            litaC_preprocessor__api__CallContext_logErrors(litaC_context);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_element = (const litaC_char*)ape_object_get_string(litaC_args[0]);
    if(!(litaC_element)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty symbol name");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_intern__InternedString litaC_elementIntern = litaC_intern__Strings_internCopy(&((litaC_context->pp->lita->strings)), litaC_element, -(1));
    litaC_symbols__Symbol* litaC_symbol = litaC_symbols__Scope_lookup(litaC_context->checker->current->currentScope, litaC_elementIntern, litaC_true);
    if(!(litaC_symbol)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "no symbol found for '%s'", litaC_element);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    return ape_object_make_bool(litaC_types__IsPrimitive(litaC_symbol->type));
    
    
}

ape_object_t litaC_preprocessor__api__ApeGetSymbol(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    if(!(APE_CHECK_ARGS(litaC_ape, litaC_true, litaC_argc, litaC_args, APE_OBJECT_STRING))) {
        {
            litaC_preprocessor__api__CallContext_logErrors(litaC_context);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_element = (const litaC_char*)ape_object_get_string(litaC_args[0]);
    if(!(litaC_element)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty symbol name");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_intern__InternedString litaC_elementIntern = litaC_intern__Strings_internCopy(&((litaC_context->pp->lita->strings)), litaC_element, -(1));
    litaC_symbols__Symbol* litaC_symbol = litaC_symbols__Scope_lookup(litaC_context->checker->current->currentScope, litaC_elementIntern, litaC_true);
    if(!(litaC_symbol)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "no symbol found for '%s'", litaC_element);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    return litaC_preprocessor__api__Preprocessor_declToApe(litaC_context->pp, litaC_symbol);
    
    
}

ape_object_t litaC_preprocessor__api__ApeGetSymbolByTypeInfo(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    if(!(APE_CHECK_ARGS(litaC_ape, litaC_true, litaC_argc, litaC_args, APE_OBJECT_MAP))) {
        {
            litaC_preprocessor__api__CallContext_logErrors(litaC_context);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    ape_object_t litaC_typeInfoObj = litaC_args[0];
    ape_object_t litaC_typePtr = ape_object_get_map_value(litaC_typeInfoObj, "typePtr");
    litaC_types__TypeInfo* litaC_typeInfo = (litaC_types__TypeInfo*)ape_object_get_external(litaC_typePtr);
    if(!(litaC_typeInfo)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid typeInfo pointer");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    return litaC_preprocessor__api__Preprocessor_declToApe(litaC_context->pp, litaC_typeInfo->sym);
    
    
}

ape_object_t litaC_preprocessor__api__ApeGetTypeInfo(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    if(!(APE_CHECK_ARGS(litaC_ape, litaC_true, litaC_argc, litaC_args, APE_OBJECT_STRING))) {
        {
            litaC_preprocessor__api__CallContext_logErrors(litaC_context);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_element = (const litaC_char*)ape_object_get_string(litaC_args[0]);
    if(!(litaC_element)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty symbol name");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_intern__InternedString litaC_elementIntern = litaC_intern__Strings_internCopy(&((litaC_context->pp->lita->strings)), litaC_element, -(1));
    litaC_symbols__Symbol* litaC_symbol = litaC_symbols__Scope_lookup(litaC_context->checker->current->currentScope, litaC_elementIntern, litaC_true);
    if(!(litaC_symbol)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "no symbol found for '%s'", litaC_element);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    return litaC_preprocessor__api__Preprocessor_typeInfoToApe(litaC_context->pp, litaC_symbol->type);
    
    
}

litaC_bool litaC_preprocessor__api__CallContext_logErrors(litaC_preprocessor__CallContext* litaC_this) {
    if(!(ape_has_errors(litaC_this->pp->runtime.ape))) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_lex__SrcPos litaC_pos =  {
        
    };
    for(litaC_i32 litaC_i = 0;litaC_i < ape_errors_count(litaC_this->pp->runtime.ape);litaC_i += 1) {
        {
            const ape_error_t* litaC_err = ape_get_error(litaC_this->pp->runtime.ape, litaC_i);
            litaC_char* litaC_errStr = ape_error_serialize(litaC_this->pp->runtime.ape, litaC_err);
            litaC_phase_result__PhaseResult_addError(&((litaC_this->pp->lita->result)), litaC_pos, "%s", litaC_errStr);
            
            
        }
    }
    return litaC_true;
    
    
}

litaC_void litaC_preprocessor__api__Preprocessor_addNotes(litaC_preprocessor__Preprocessor* litaC_this,ape_object_t litaC_obj,litaC_module__Module* litaC_module,litaC_ast__Attributes* litaC_attributes) {
    if(litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_attributes->notes)))) {
        {
            litaC_checker__TypeChecker_enterModule(litaC_this->callContext.checker, litaC_module);
            litaC_checker__TypeChecker_resolveNotes(litaC_this->callContext.checker, &((litaC_attributes->notes)));
            litaC_checker__TypeChecker_leaveModule(litaC_this->callContext.checker);
            ape_object_t litaC_notesArray = ape_object_make_array(litaC_this->runtime.ape);
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_attributes->notes)));litaC_i += 1) {
                {
                    litaC_ast__NoteStmt* litaC_note = litaC_std__array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_attributes->notes)), litaC_i);
                    ape_object_t litaC_noteObj = ape_object_make_map(litaC_this->runtime.ape);
                    ape_object_t litaC_name = ape_object_make_stringf(litaC_this->runtime.ape, "%.*s", litaC_note->type->name.length, litaC_note->type->name.buffer);
                    ape_object_set_map_value(litaC_noteObj, "name", litaC_name);
                    if(litaC_std__array__Array_size_cb_CallArg_ce_(&((litaC_note->arguments)))) {
                        {
                            ape_object_t litaC_argumentsArray = ape_object_make_array(litaC_this->runtime.ape);
                            for(litaC_i32 litaC_j = 0;litaC_j < litaC_std__array__Array_size_cb_CallArg_ce_(&((litaC_note->arguments)));litaC_j += 1) {
                                {
                                    litaC_ast__CallArg litaC_attr = litaC_std__array__Array_get_cb_CallArg_ce_(&((litaC_note->arguments)), litaC_j);
                                    ape_object_t litaC_attrObj = ape_object_make_map(litaC_this->runtime.ape);
                                    ape_object_t litaC_name = ape_object_make_stringf(litaC_this->runtime.ape, "%.*s", litaC_attr.argName.str.length, litaC_attr.argName.str.buffer);
                                    ape_object_set_map_value(litaC_attrObj, "name", litaC_name);
                                    ape_object_add_array_value(litaC_argumentsArray, litaC_attrObj);
                                    if(litaC_attr.argExpr != NULL && litaC_attr.argExpr->operand.typeInfo != NULL) {
                                        {
                                            if(litaC_attr.argExpr->operand.typeInfo->kind == litaC_types__TypeKind_STR) {
                                                {
                                                    ape_object_t litaC_value = ape_object_make_stringf(litaC_this->runtime.ape, "%.*s", litaC_attr.argExpr->operand.val.str.length, litaC_attr.argExpr->operand.val.str.buffer);
                                                    ape_object_set_map_value(litaC_attrObj, "value", litaC_value);
                                                    
                                                    
                                                }
                                                
                                            } else {
                                                if(litaC_types__IsNumberLike(litaC_attr.argExpr->operand.typeInfo)) {
                                                    {
                                                        if(litaC_types__IsInteger(litaC_attr.argExpr->operand.typeInfo)) {
                                                            {
                                                                ape_object_set_map_number(litaC_attrObj, "value", (litaC_f64)litaC_attr.argExpr->operand.val.intValue);
                                                                
                                                                
                                                            }
                                                            
                                                        } else {
                                                            {
                                                                ape_object_set_map_number(litaC_attrObj, "value", litaC_attr.argExpr->operand.val.floatValue);
                                                                
                                                                
                                                            }
                                                        } 
                                                        
                                                        
                                                        
                                                    }
                                                    
                                                } else {
                                                    {
                                                        
                                                        
                                                    }
                                                } 
                                                
                                            } 
                                            
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    
                                    
                                }
                            }
                            ape_object_set_map_value(litaC_noteObj, "arguments", litaC_argumentsArray);
                            
                            
                        }
                        
                    } 
                    
                    ape_object_add_array_value(litaC_notesArray, litaC_noteObj);
                    
                    
                }
            }
            ape_object_set_map_value(litaC_obj, "notes", litaC_notesArray);
            
            
        }
        
    } 
    
    
}

ape_object_t litaC_preprocessor__api__Preprocessor_typeInfoToApe(litaC_preprocessor__Preprocessor* litaC_this,litaC_types__TypeInfo* litaC_typeInfo) {
    if(!(litaC_typeInfo)) {
        {
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    ape_object_t litaC_typeObj = ape_object_make_map(litaC_this->runtime.ape);
    ape_object_set_map_value(litaC_typeObj, "name", ape_object_make_stringf(litaC_this->runtime.ape, "%.*s", litaC_typeInfo->name.length, litaC_typeInfo->name.buffer));
    ape_object_set_map_string(litaC_typeObj, "kind", litaC_types__TypeKindAsStr(litaC_typeInfo->kind));
    ape_object_set_map_bool(litaC_typeObj, "isPrimitive", litaC_types__IsPrimitive(litaC_typeInfo));
    ape_object_set_map_bool(litaC_typeObj, "isString", litaC_types__IsStringLike(litaC_typeInfo));
    ape_object_set_map_bool(litaC_typeObj, "isPointer", litaC_types__IsPtr(litaC_typeInfo));
    ape_object_set_map_value(litaC_typeObj, "typePtr", ape_object_make_external(litaC_this->runtime.ape, litaC_typeInfo));
    switch(litaC_typeInfo->kind) {
        case litaC_types__TypeKind_PTR: {
            {
                ape_object_t litaC_baseTypeObj = litaC_preprocessor__api__Preprocessor_typeInfoToApe(litaC_this, litaC_typeInfo->ptrOf);
                ape_object_set_map_value(litaC_typeObj, "base", litaC_baseTypeObj);
                break;
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                ape_object_t litaC_baseTypeObj = litaC_preprocessor__api__Preprocessor_typeInfoToApe(litaC_this, litaC_typeInfo->ptrOf);
                ape_object_set_map_value(litaC_typeObj, "base", litaC_baseTypeObj);
                break;
                
                
            }
            
            
        }
        default: {
            {
                
                
            }
            
            
        }
    }
    if(litaC_typeInfo->sym) {
        {
            ape_object_set_map_value(litaC_typeObj, "symbol", litaC_preprocessor__api__Preprocessor_declToApe(litaC_this, litaC_typeInfo->sym));
            
            
        }
        
    } 
    
    return litaC_typeObj;
    
    
}

ape_object_t litaC_preprocessor__api__Preprocessor_declToApe(litaC_preprocessor__Preprocessor* litaC_this,litaC_symbols__Symbol* litaC_sym) {
    if(!(litaC_sym)) {
        {
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    ape_object_t litaC_declObj = ape_object_make_map(litaC_this->runtime.ape);
    ape_object_set_map_value(litaC_declObj, "name", ape_object_make_stringf(litaC_this->runtime.ape, "%.*s", litaC_sym->name.length, litaC_sym->name.buffer));
    ape_object_set_map_string(litaC_declObj, "kind", litaC_ast__StmtKindAsStr(litaC_sym->decl->stmt.node.kind));
    ape_object_set_map_string(litaC_declObj, "moduleFilename", litaC_sym->declared->id.filename);
    ape_object_set_map_value(litaC_declObj, "moduleName", ape_object_make_stringf(litaC_this->runtime.ape, "%.*s", litaC_sym->declared->id.name.length, litaC_sym->declared->id.name.buffer));
    ape_object_set_map_value(litaC_declObj, "packageName", ape_object_make_stringf(litaC_this->runtime.ape, "%.*s", litaC_sym->declared->id.packageName.length, litaC_sym->declared->id.packageName.buffer));
    ape_object_set_map_value(litaC_declObj, "isPublic", ape_object_make_bool(litaC_sym->decl->attributes.visibility == litaC_ast__Visibility_PUBLIC));
    ape_object_set_map_value(litaC_declObj, "isInternal", ape_object_make_bool(litaC_sym->decl->attributes.visibility == litaC_ast__Visibility_INTERNAL));
    ape_object_set_map_value(litaC_declObj, "isPrivate", ape_object_make_bool(litaC_sym->decl->attributes.visibility == litaC_ast__Visibility_PRIVATE));
    ape_object_set_map_value(litaC_declObj, "isGlobal", ape_object_make_bool(litaC_sym->decl->attributes.isGlobal));
    ape_object_set_map_value(litaC_declObj, "declPtr", ape_object_make_external(litaC_this->runtime.ape, litaC_sym->decl));
    ape_object_set_map_value(litaC_declObj, "fullName", ape_object_make_stringf(litaC_this->runtime.ape, "%.*s::%.*s", litaC_sym->declared->id.packageName.length, litaC_sym->declared->id.packageName.buffer, litaC_sym->name.length, litaC_sym->name.buffer));
    ape_object_set_map_value(litaC_declObj, "declFullName", ape_object_make_stringf(litaC_this->runtime.ape, "%.*s::%.*s", litaC_sym->declared->id.packageName.length, litaC_sym->declared->id.packageName.buffer, litaC_sym->decl->name.str.length, litaC_sym->decl->name.str.buffer));
    if(!(litaC_std__array__Array_empty_cb__ptr_TypeInfo_ce_(&((litaC_sym->genericArgs))))) {
        {
            ape_object_t litaC_genericArgs = ape_object_make_map(litaC_this->runtime.ape);
            litaC_i32 litaC_nameSize = litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_sym->genericParams)));
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_sym->genericArgs)));litaC_i += 1) {
                {
                    litaC_types__TypeInfo* litaC_arg = litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_sym->genericArgs)), litaC_i);
                    if(litaC_i < litaC_nameSize) {
                        {
                            litaC_ast__Identifier litaC_name = litaC_std__array__Array_getPtr_cb_GenericParam_ce_(&((litaC_sym->genericParams)), litaC_i)->name;
                            ape_object_t litaC_argObj = litaC_preprocessor__api__Preprocessor_typeInfoToApe(litaC_this, litaC_arg);
                            ape_object_t litaC_key = ape_object_make_stringf(litaC_this->runtime.ape, "%.*s", litaC_name.str.length, litaC_name.str.buffer);
                            ape_object_set_map_value_with_value_key(litaC_genericArgs, litaC_key, litaC_argObj);
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            ape_object_set_map_value(litaC_declObj, "genericArgs", litaC_genericArgs);
            
            
        }
        
    } 
    
    litaC_preprocessor__api__Preprocessor_addNotes(litaC_this, litaC_declObj, litaC_sym->declared, &((litaC_sym->decl->attributes)));
    switch(litaC_sym->decl->stmt.node.kind) {
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: {
            {
                ape_object_t litaC_aggObj = ape_object_make_map(litaC_this->runtime.ape);
                if(litaC_ast__StmtKind_UNION_DECL == litaC_sym->decl->stmt.node.kind) {
                    {
                        ape_object_set_map_value(litaC_declObj, "unionDecl", litaC_aggObj);
                        
                        
                    }
                    
                } else {
                    if(litaC_ast__StmtKind_TRAIT_DECL == litaC_sym->decl->stmt.node.kind) {
                        {
                            ape_object_set_map_value(litaC_declObj, "traitDecl", litaC_aggObj);
                            
                            
                        }
                        
                    } else {
                        {
                            ape_object_set_map_value(litaC_declObj, "structDecl", litaC_aggObj);
                            
                            
                        }
                    } 
                    
                } 
                
                ape_object_t litaC_fieldsArray = ape_object_make_array(litaC_this->runtime.ape);
                litaC_ast__AggregateDecl* litaC_aggDecl = (litaC_ast__AggregateDecl*)litaC_sym->decl;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_aggDecl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__FieldStmt* litaC_field = litaC_std__array__Array_getPtr_cb_FieldStmt_ce_(&((litaC_aggDecl->fields)), litaC_i);
                        ape_object_t litaC_fieldObj = ape_object_make_map(litaC_this->runtime.ape);
                        switch(litaC_field->kind) {
                            case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                                {
                                    litaC_ast__TraitFieldDecl* litaC_varField = litaC_field->traitField;
                                    ape_object_t litaC_name = ape_object_make_stringf(litaC_this->runtime.ape, "%.*s", litaC_varField->decl.name.str.length, litaC_varField->decl.name.str.buffer);
                                    ape_object_set_map_value(litaC_fieldObj, "name", litaC_name);
                                    litaC_preprocessor__api__Preprocessor_addNotes(litaC_this, litaC_fieldObj, litaC_sym->declared, &((litaC_varField->decl.attributes)));
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                                {
                                    litaC_ast__VarFieldDecl* litaC_varField = litaC_field->varField;
                                    ape_object_t litaC_name = ape_object_make_stringf(litaC_this->runtime.ape, "%.*s", litaC_varField->decl.name.str.length, litaC_varField->decl.name.str.buffer);
                                    ape_object_set_map_value(litaC_fieldObj, "name", litaC_name);
                                    if(litaC_varField->type && litaC_varField->type->typeInfo) {
                                        {
                                            ape_object_t litaC_typeInfo = litaC_preprocessor__api__Preprocessor_typeInfoToApe(litaC_this, litaC_varField->type->typeInfo);
                                            ape_object_set_map_value(litaC_fieldObj, "typeInfo", litaC_typeInfo);
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    litaC_preprocessor__api__Preprocessor_addNotes(litaC_this, litaC_fieldObj, litaC_sym->declared, &((litaC_varField->decl.attributes)));
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                                {
                                    litaC_ast__EnumDecl* litaC_enumField = litaC_field->enumField;
                                    ape_object_t litaC_name = ape_object_make_stringf(litaC_this->runtime.ape, "%.*s", litaC_enumField->decl.name.str.length, litaC_enumField->decl.name.str.buffer);
                                    ape_object_set_map_value(litaC_fieldObj, "name", litaC_name);
                                    litaC_preprocessor__api__Preprocessor_addNotes(litaC_this, litaC_fieldObj, litaC_sym->declared, &((litaC_enumField->decl.attributes)));
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                            case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                                {
                                    litaC_ast__AggregateDecl* litaC_aggregateField = litaC_field->aggregateField;
                                    ape_object_t litaC_name = ape_object_make_stringf(litaC_this->runtime.ape, "%.*s", litaC_aggregateField->decl.declaration.name.str.length, litaC_aggregateField->decl.declaration.name.str.buffer);
                                    ape_object_set_map_value(litaC_fieldObj, "name", litaC_name);
                                    litaC_preprocessor__api__Preprocessor_addNotes(litaC_this, litaC_fieldObj, litaC_sym->declared, &((litaC_aggregateField->decl.declaration.attributes)));
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            default: {
                                break;
                                
                                
                            }
                        }
                        ape_object_add_array_value(litaC_fieldsArray, litaC_fieldObj);
                        
                        
                    }
                }
                ape_object_set_map_value(litaC_aggObj, "fields", litaC_fieldsArray);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: {
            {
                ape_object_t litaC_enumObj = ape_object_make_map(litaC_this->runtime.ape);
                ape_object_set_map_value(litaC_declObj, "enumDecl", litaC_enumObj);
                ape_object_t litaC_fieldsArray = ape_object_make_array(litaC_this->runtime.ape);
                litaC_ast__EnumDecl* litaC_enumDecl = (litaC_ast__EnumDecl*)litaC_sym->decl;
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_enumDecl->fields)));litaC_i += 1) {
                    {
                        litaC_ast__EnumFieldEntryDecl* litaC_field = litaC_std__array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_enumDecl->fields)), litaC_i);
                        ape_object_t litaC_fieldObj = ape_object_make_map(litaC_this->runtime.ape);
                        ape_object_t litaC_name = ape_object_make_stringf(litaC_this->runtime.ape, "%.*s", litaC_field->decl.name.str.length, litaC_field->decl.name.str.buffer);
                        ape_object_set_map_value(litaC_fieldObj, "name", litaC_name);
                        litaC_preprocessor__api__Preprocessor_addNotes(litaC_this, litaC_fieldObj, litaC_sym->declared, &((litaC_field->decl.attributes)));
                        ape_object_add_array_value(litaC_fieldsArray, litaC_fieldObj);
                        
                        
                    }
                }
                ape_object_set_map_value(litaC_enumObj, "fields", litaC_fieldsArray);
                break;
                
                
            }
            
            
        }
        default: {
            {
                break;
                
                
            }
            
            
        }
    }
    return litaC_declObj;
    
    
}


litaC_void litaC_preprocessor__api__CallContext_postParse(litaC_preprocessor__CallContext* litaC_this,litaC_module__Module* litaC_module,litaC_ast__ModuleStmt* litaC_moduleStmt,litaC_ast__CompStmt* litaC_comp) {
    litaC_preprocessor__Preprocessor_eval(litaC_this->pp, litaC_comp);
    litaC_std__string_view__StringView litaC_original = litaC_std__string_view__StringViewInit(litaC_this->buffer.buffer, litaC_this->buffer.length);
    if(litaC_std__string_view__StringView_empty(litaC_original)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_std__string_view__StringView litaC_emitCode = litaC_std__string_view__StringView_copy(litaC_original, litaC_this->pp->lita->allocator);
    litaC_parser__Parser litaC_parser = litaC_parser__ParserInit(litaC_moduleStmt->stmt.node.startPos.filename, litaC_emitCode.buffer, litaC_emitCode.length, litaC_module, litaC_this->pp->lita);
    litaC_ast__ModuleStmt* litaC_stmts = litaC_parser__Parser_parseModule(&((litaC_parser)));
    if(litaC_stmts) {
        {
            if(litaC_std__array__Array_size_cb__ptr_ImportDecl_ce_(&((litaC_stmts->imports)))) {
                {
                    litaC_std__array__Array_addAll_cb__ptr_ImportDecl_ce_(&((litaC_moduleStmt->imports)), &((litaC_stmts->imports)));
                    
                    
                }
                
            } 
            
            if(litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_stmts->notes)))) {
                {
                    litaC_std__array__Array_addAll_cb__ptr_NoteStmt_ce_(&((litaC_moduleStmt->notes)), &((litaC_stmts->notes)));
                    
                    
                }
                
            } 
            
            if(litaC_std__array__Array_size_cb__ptr_Decl_ce_(&((litaC_stmts->declarations)))) {
                {
                    litaC_std__array__Array_addAll_cb__ptr_Decl_ce_(&((litaC_moduleStmt->declarations)), &((litaC_stmts->declarations)));
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    
}

ape_object_t litaC_preprocessor__api__ApeEmit(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    return litaC_preprocessor__api__FormatStr(litaC_context, &(litaC_context->buffer), litaC_argc, litaC_args);
    
    
}

ape_object_t litaC_preprocessor__api__ApeEmitClear(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    litaC_std__string_buffer__StringBuffer_clear(&((litaC_context->buffer)));
    return ape_object_make_null();
    
    
}

ape_object_t litaC_preprocessor__api__ApeEmitStr(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    return ape_object_make_string(litaC_ape, litaC_std__string_buffer__StringBuffer_cStr(&((litaC_context->buffer))));
    
    
}

ape_object_t litaC_preprocessor__api__ApeError(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(1024, litaC_context->pp->lita->allocator);
    ape_object_t litaC_result = litaC_preprocessor__api__FormatStr(litaC_context, &(litaC_sb), litaC_argc, litaC_args);
    litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "%s", litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb))));
    return litaC_result;
    
    
}

ape_object_t litaC_preprocessor__api__FormatStr(litaC_preprocessor__CallContext* litaC_context,litaC_std__string_buffer__StringBuffer* litaC_buffer,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_i32 litaC_argIndex = 1;
    const litaC_char* litaC_str = (const litaC_char*)ape_object_get_string(litaC_args[0]);
    if(!(litaC_str)) {
        {
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    while(*(litaC_str)) {
        {
            litaC_char litaC_c = *(litaC_str);
            if(litaC_c == '%') {
                {
                    if(litaC_str[1] == '%') {
                        {
                            litaC_std__string_buffer__StringBuffer_append(litaC_buffer, "%s", "%");
                            litaC_str += 2;
                            continue;
                            
                            
                        }
                        
                    } else {
                        {
                            if(litaC_argIndex >= litaC_argc) {
                                {
                                    litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid argument index, there are more format parameters than supplied function arguments");
                                    return ape_object_make_null();
                                    
                                    
                                    
                                }
                                
                            } 
                            
                            if(litaC_str[1] == 's') {
                                {
                                    const litaC_char* litaC_arg = (const litaC_char*)ape_object_get_string(litaC_args[litaC_argIndex]);
                                    litaC_std__string_buffer__StringBuffer_append(litaC_buffer, "%s", litaC_arg);
                                    
                                    
                                }
                                
                            } else {
                                if(litaC_str[1] == 'f') {
                                    {
                                        litaC_f64 litaC_arg = (litaC_f64)ape_object_get_number(litaC_args[litaC_argIndex]);
                                        litaC_std__string_buffer__StringBuffer_append(litaC_buffer, "%f", litaC_arg);
                                        
                                        
                                    }
                                    
                                } else {
                                    if(litaC_str[1] == 'd') {
                                        {
                                            litaC_i64 litaC_arg = (litaC_i64)ape_object_get_number(litaC_args[litaC_argIndex]);
                                            litaC_std__string_buffer__StringBuffer_append(litaC_buffer, "%d", litaC_arg);
                                            
                                            
                                        }
                                        
                                    } else {
                                        if(litaC_str[1] == 'b') {
                                            {
                                                litaC_bool litaC_arg = (litaC_bool)ape_object_get_bool(litaC_args[litaC_argIndex]);
                                                litaC_std__string_buffer__StringBuffer_append(litaC_buffer, "%s", (litaC_arg) ? "true" : "false");
                                                
                                                
                                            }
                                            
                                        } else {
                                            {
                                                litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid format parameter: '%%%c'", litaC_str[1]);
                                                return ape_object_make_null();
                                                
                                                
                                                
                                            }
                                        } 
                                        
                                    } 
                                    
                                } 
                                
                            } 
                            
                            litaC_argIndex += 1;
                            litaC_str += 2;
                            continue;
                            
                            
                        }
                    } 
                    
                    
                    
                }
                
            } else {
                if(litaC_c == '\\') {
                    {
                        if(litaC_str[1] == '\\') {
                            {
                                litaC_std__string_buffer__StringBuffer_append(litaC_buffer, "\\");
                                litaC_str += 2;
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_std__string_buffer__StringBuffer_append(litaC_buffer, "%c", litaC_c);
            litaC_str += 1;
            
            
        }
    }
    return ape_object_make_null();
    
    
}

ape_object_t litaC_preprocessor__api__ApeGetSymbolsWithNote(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    if(!(APE_CHECK_ARGS(litaC_ape, litaC_true, litaC_argc, litaC_args, APE_OBJECT_STRING))) {
        {
            litaC_preprocessor__api__CallContext_logErrors(litaC_context);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_element = (const litaC_char*)ape_object_get_string(litaC_args[0]);
    if(!(litaC_element)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty note name");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    ape_object_t litaC_results = ape_object_make_array(litaC_ape);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_context->checker->symbolFuncs)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_context->checker->symbolFuncs)), litaC_i);
            if(litaC_ast__Decl_hasNote(litaC_sym->decl, litaC_element)) {
                {
                    ape_object_t litaC_declObj = litaC_preprocessor__api__Preprocessor_declToApe(litaC_context->pp, litaC_sym);
                    ape_object_add_array_value(litaC_results, litaC_declObj);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_context->checker->symbolTypes)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_context->checker->symbolTypes)), litaC_i);
            if(litaC_ast__Decl_hasNote(litaC_sym->decl, litaC_element)) {
                {
                    ape_object_t litaC_declObj = litaC_preprocessor__api__Preprocessor_declToApe(litaC_context->pp, litaC_sym);
                    ape_object_add_array_value(litaC_results, litaC_declObj);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_results;
    
    
}

ape_object_t litaC_preprocessor__api__ApeAddDeclaration(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    return litaC_preprocessor__api__QueueDeclaration(litaC_ape, litaC_data, litaC_argc, litaC_args, litaC_false);
    
    
}

ape_object_t litaC_preprocessor__api__ApeReplaceDeclaration(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    return litaC_preprocessor__api__QueueDeclaration(litaC_ape, litaC_data, litaC_argc, litaC_args, litaC_true);
    
    
}

ape_object_t litaC_preprocessor__api__QueueDeclaration(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args,litaC_bool litaC_replacement) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    if(!(APE_CHECK_ARGS(litaC_ape, litaC_true, litaC_argc, litaC_args, APE_OBJECT_STRING, APE_OBJECT_STRING))) {
        {
            litaC_preprocessor__api__CallContext_logErrors(litaC_context);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_moduleName = (const litaC_char*)ape_object_get_string(litaC_args[0]);
    if(!(litaC_moduleName)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty module filename");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_code = (const litaC_char*)ape_object_get_string(litaC_args[1]);
    if(!(litaC_code)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty code buffer");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_module__Module* litaC_module = litaC_lita__Lita_getModule(litaC_context->pp->lita, litaC_moduleName);
    if(!(litaC_module)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid module: '%s'", litaC_moduleName);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_ast__ModuleStmt* litaC_moduleStmt = litaC_module->ast;
    litaC_std__string_view__StringView litaC_original = litaC_std__string_view__StringViewInit(litaC_code, -(1));
    litaC_std__string_view__StringView litaC_emitCode = litaC_std__string_view__StringView_copy(litaC_original, litaC_context->pp->lita->allocator);
    litaC_parser__Parser litaC_parser = litaC_parser__ParserInit(litaC_moduleStmt->stmt.node.startPos.filename, litaC_emitCode.buffer, litaC_emitCode.length, litaC_module, litaC_context->pp->lita);
    litaC_ast__ModuleStmt* litaC_declarations = litaC_parser__Parser_parseModule(&((litaC_parser)));
    litaC_std__array__Array_add_cb_ScriptDecl_ce_(&((litaC_context->pp->declQueue)), (litaC_preprocessor__ScriptDecl) {
        .ctx =  {
            .checker = litaC_context->checker,
            .comp = litaC_context->comp,
            .resolveSymbols = litaC_context->resolveSymbols
        },
        .module = litaC_module,
        .declarations = litaC_declarations,
        .replacement = litaC_replacement
    });
    return ape_object_make_bool(litaC_true);
    
    
}

ape_object_t litaC_preprocessor__api__ApeGetInputModuleFilename(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    litaC_char* litaC_moduleFilename = litaC_context->pp->lita->options->inputFile;
    litaC_module__Module* litaC_mainModule = litaC_lita__Lita_getModule(litaC_context->pp->lita, litaC_moduleFilename);
    if(!(litaC_mainModule)) {
        {
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    return ape_object_make_string(litaC_ape, litaC_moduleFilename);
    
    
}

ape_object_t litaC_preprocessor__api__ApeGetCurrentModuleFilename(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    const litaC_char* litaC_moduleFilename = litaC_context->comp->stmt.node.startPos.filename;
    litaC_module__Module* litaC_mainModule = litaC_lita__Lita_getModule(litaC_context->pp->lita, litaC_moduleFilename);
    if(!(litaC_mainModule)) {
        {
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    return ape_object_make_string(litaC_ape, litaC_moduleFilename);
    
    
}

ape_object_t litaC_preprocessor__api__ApeFlushDeclarations(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    litaC_preprocessor__Preprocessor_drainQueue(litaC_context->pp);
    return ape_object_make_null();
    
    
}

ape_object_t litaC_preprocessor__api__ApeGetMainSymbol(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    litaC_symbols__Symbol* litaC_mainEntry = litaC_context->checker->mainEntry;
    if(!(litaC_mainEntry)) {
        {
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    return litaC_preprocessor__api__Preprocessor_declToApe(litaC_context->pp, litaC_mainEntry);
    
    
}

ape_object_t litaC_preprocessor__api__ApeAstInsert(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    if(!(APE_CHECK_ARGS(litaC_ape, litaC_true, litaC_argc, litaC_args, APE_OBJECT_EXTERNAL, APE_OBJECT_STRING, APE_OBJECT_NUMBER))) {
        {
            litaC_preprocessor__api__CallContext_logErrors(litaC_context);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_void* litaC_astPtr = ape_object_get_external(litaC_args[0]);
    if(!(litaC_astPtr)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty ast node");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_code = (const litaC_char*)ape_object_get_string(litaC_args[1]);
    if(!(litaC_code)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty code buffer");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_index = (litaC_i32)ape_object_get_number(litaC_args[2]);
    litaC_ast__Node* litaC_astNode = (litaC_ast__Node*)litaC_astPtr;
    litaC_module__Module* litaC_module = litaC_context->checker->current;
    litaC_parser__Parser litaC_parser = litaC_parser__ParserInit(litaC_astNode->startPos.filename, litaC_code, strlen(litaC_code), litaC_module, litaC_context->pp->lita);
    litaC_ast__Stmt* litaC_stmt = litaC_parser__Parser_statement(&((litaC_parser)));
    litaC_ast_copy__AstInsert(litaC_astNode, litaC_stmt, litaC_index, litaC_module, litaC_context->pp->lita);
    return ape_object_make_null();
    
    
}

ape_object_t litaC_preprocessor__api__ApeAddImport(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    if(!(APE_CHECK_ARGS(litaC_ape, litaC_true, litaC_argc, litaC_args, APE_OBJECT_STRING, APE_OBJECT_STRING))) {
        {
            litaC_preprocessor__api__CallContext_logErrors(litaC_context);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_moduleName = (const litaC_char*)ape_object_get_string(litaC_args[0]);
    if(!(litaC_moduleName)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty module filename");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_module__Module* litaC_module = litaC_lita__Lita_getModule(litaC_context->pp->lita, litaC_moduleName);
    if(!(litaC_module)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid module: '%s'", litaC_moduleName);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_moduleToImport = (const litaC_char*)ape_object_get_string(litaC_args[1]);
    if(!(litaC_moduleToImport)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty module to import name");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    if(strcmp(litaC_moduleName, litaC_moduleToImport) == 0) {
        {
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_module__Module* litaC_importModule = litaC_lita__Lita_getModule(litaC_context->pp->lita, litaC_moduleToImport);
    if(!(litaC_importModule)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid module: '%s'", litaC_moduleToImport);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_alias = litaC_ast_copy__AstAddImport(litaC_context->pp->lita, litaC_context->checker, litaC_module, litaC_importModule);
    if(!(litaC_alias)) {
        {
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    return ape_object_make_string(litaC_ape, litaC_alias);
    
    
}

ape_object_t litaC_preprocessor__api__ApeSetMainSymbol(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    if(!(APE_CHECK_ARGS(litaC_ape, litaC_true, litaC_argc, litaC_args, APE_OBJECT_STRING, APE_OBJECT_STRING))) {
        {
            litaC_preprocessor__api__CallContext_logErrors(litaC_context);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_moduleName = (const litaC_char*)ape_object_get_string(litaC_args[0]);
    if(!(litaC_moduleName)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty module filename");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_module__Module* litaC_module = litaC_lita__Lita_getModule(litaC_context->pp->lita, litaC_moduleName);
    if(!(litaC_module)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid module: '%s'", litaC_moduleName);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_symbolName = (const litaC_char*)ape_object_get_string(litaC_args[1]);
    if(!(litaC_symbolName)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "invalid empty symbol name");
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_intern__InternedString litaC_symbolNameIntern = litaC_intern__Strings_internCopy(&((litaC_context->pp->lita->strings)), litaC_symbolName, -(1));
    litaC_symbols__Symbol* litaC_sym = litaC_module__Module_getType(litaC_module, litaC_symbolNameIntern);
    if(!(litaC_sym)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "can not find symbol '%s' in module: '%s'", litaC_symbolName, litaC_moduleName);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    if(litaC_sym->kind != litaC_symbols__SymbolKind_FUNC) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "can not make symbol '%s' a main entry point because it isn't a function", litaC_symbolName);
            return ape_object_make_null();
            
            
            
        }
        
    } 
    
    litaC_context->checker->mainEntry = litaC_sym;
    return ape_object_make_bool(litaC_true);
    
    
}

ape_object_t litaC_preprocessor__api__ApeGetSymbolsToTest(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    ape_object_t litaC_results = ape_object_make_array(litaC_ape);
    if(!(litaC_context->pp->lita->options->testsOnly)) {
        {
            return litaC_results;
            
            
            
        }
        
    } 
    
    litaC_char* litaC_moduleName = litaC_context->pp->lita->options->inputFile;
    litaC_module__Module* litaC_mainModule = litaC_lita__Lita_getModule(litaC_context->pp->lita, litaC_moduleName);
    if(!(litaC_mainModule)) {
        {
            return litaC_results;
            
            
            
        }
        
    } 
    
    if(litaC_context->pp->lita->options->testsRegex) {
        {
            litaC_bool litaC_all = strcmp(litaC_context->pp->lita->options->testsRegex, ".*") == 0;
            litaC_std__regex__Regex litaC_pattern = litaC_std__regex__RegexCompile(litaC_context->pp->lita->options->testsRegex);
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_context->checker->symbolFuncs)));litaC_i += 1) {
                {
                    litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_context->checker->symbolFuncs)), litaC_i);
                    if(litaC_sym->kind == litaC_symbols__SymbolKind_FUNC && litaC_sym->flags & litaC_symbols__SymbolFlags_IS_TEST) {
                        {
                            if(!(litaC_symbols__Symbol_isVisibleTo(litaC_sym, litaC_mainModule))) {
                                {
                                    continue;
                                    
                                    
                                }
                                
                            } 
                            
                            if(litaC_all) {
                                {
                                    ape_object_t litaC_declObj = litaC_preprocessor__api__Preprocessor_declToApe(litaC_context->pp, litaC_sym);
                                    ape_object_add_array_value(litaC_results, litaC_declObj);
                                    
                                    
                                }
                                
                            } else {
                                {
                                    litaC_ast__NoteStmt* litaC_note = litaC_ast__Decl_getNote(litaC_sym->decl, "test");
                                    
#define litaC_MAX_SIZE (256)
                                    litaC_char litaC_buffer[256] = {0};
                                    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_CallArg_ce_(&((litaC_note->arguments)));litaC_i += 1) {
                                        {
                                            litaC_ast__CallArg litaC_att = litaC_std__array__Array_get_cb_CallArg_ce_(&((litaC_note->arguments)), litaC_i);
                                            litaC_i32 litaC_matchlength = 0;
                                            if(litaC_att.argExpr == NULL || litaC_att.argExpr->operand.typeInfo == NULL) {
                                                {
                                                    continue;
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                            if(litaC_att.argExpr->operand.typeInfo->kind != litaC_types__TypeKind_STR) {
                                                {
                                                    continue;
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                            litaC_std__string_view__StringView litaC_value = litaC_att.argExpr->operand.val.str;
                                            if(litaC_value.length >= litaC_MAX_SIZE) {
                                                {
                                                    continue;
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                            litaC_std__string_view__StringView_copyTo(litaC_value, litaC_buffer, litaC_value.length, litaC_true);
                                            if(litaC_std__regex__Regex_match(&((litaC_pattern)), litaC_buffer, &(litaC_matchlength)) > -(1)) {
                                                {
                                                    ape_object_t litaC_declObj = litaC_preprocessor__api__Preprocessor_declToApe(litaC_context->pp, litaC_sym);
                                                    ape_object_add_array_value(litaC_results, litaC_declObj);
                                                    break;
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                            
                                            
                                        }
                                    }
                                    #undef litaC_MAX_SIZE
                                    
                                    
                                }
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_context->checker->symbolFuncs)));litaC_i += 1) {
                {
                    litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_context->checker->symbolFuncs)), litaC_i);
                    if(litaC_sym->declared == litaC_mainModule && litaC_sym->kind == litaC_symbols__SymbolKind_FUNC && litaC_sym->flags & litaC_symbols__SymbolFlags_IS_TEST) {
                        {
                            ape_object_t litaC_declObj = litaC_preprocessor__api__Preprocessor_declToApe(litaC_context->pp, litaC_sym);
                            ape_object_add_array_value(litaC_results, litaC_declObj);
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
    } 
    
    return litaC_results;
    
    
}

ape_object_t litaC_preprocessor__api__ApeAssert(ape_t* litaC_ape,litaC_void* litaC_data,litaC_i32 litaC_argc,ape_object_t* litaC_args) {
    litaC_preprocessor__CallContext* litaC_context = (litaC_preprocessor__CallContext*)litaC_data;
    litaC_bool litaC_stmt = ape_object_get_bool(litaC_args[0]);
    if(!(litaC_stmt)) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_context->pp->lita->result)), litaC_context->comp->stmt.node.startPos, "preprocessor assertion failure");
            
            
        }
        
    } 
    
    return ape_object_make_null();
    
    
}

litaC_bool litaC_preprocessor__api__Preprocessor_loadScript(litaC_preprocessor__Preprocessor* litaC_this,litaC_ast__CompStmt* litaC_comp,litaC_std__string_view__StringView* litaC_filename,litaC_std__string_view__StringView* litaC_code) {
    litaC_char litaC_filepath[_MAX_PATH] =  {
        0
    };
    litaC_std__string__String litaC_filepathStr = litaC_std__string__StringInit(litaC_filepath, _MAX_PATH, 0);
    litaC_std__system__FilePath(litaC_comp->stmt.node.startPos.filename, litaC_filepath);
    litaC_std__string__String_adjust(&((litaC_filepathStr)));
    litaC_std__string__String_append(&((litaC_filepathStr)), "/%.*s", litaC_filename->length, litaC_filename->buffer);
    if(!(litaC_std__system__FileExists(litaC_std__string__String_cStr(litaC_filepathStr)))) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_comp->stmt.node.startPos, "unable to locate '%.*s'", litaC_filename->length, litaC_filename->buffer);
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_char* litaC_buffer = NULL;
    litaC_usize litaC_length = 0;
    litaC_std__io__FileStatus litaC_status = litaC_std__io__ReadFile(litaC_std__string__String_cStr(litaC_filepathStr), &(litaC_buffer), &(litaC_length), litaC_this->lita->allocator);
    if(litaC_status != litaC_std__io__FileStatus_Ok) {
        {
            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_comp->stmt.node.startPos, "error loading '%s'", litaC_std__string__String_cStr(litaC_filepathStr));
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_code->buffer = litaC_buffer;
    litaC_code->length = (litaC_i32)litaC_length;
    return litaC_true;
    
    
}

litaC_void litaC_cgen__CGen_init(litaC_cgen__CGen* litaC_this,litaC_lita__Lita* litaC_lita,litaC_std__io__File* litaC_output) {
    litaC_this->lita = litaC_lita;
    litaC_std__string_buffer__StringBuffer_init(&((litaC_this->buf)), 1024 * 2, litaC_lita->allocator);
    litaC_std__string_buffer__StringBuffer_init(&((litaC_this->line)), 1024 * 2, litaC_lita->allocator);
    litaC_this->aggregateLevel = 0;
    litaC_this->currentLine = 0;
    litaC_this->currentFile = NULL;
    litaC_this->currentFunc = NULL;
    litaC_this->currentScope = NULL;
    litaC_this->bufferFlush = litaC_false;
    litaC_this->deferStack = 0;
    litaC_this->format = litaC_lita->options->cFormat;
    litaC_this->output = litaC_output;
    
}

litaC_void litaC_cgen__CGen_emitProgram(litaC_cgen__CGen* litaC_this,litaC_module__Module* litaC_module) {
    assert(litaC_module != NULL);
    assert(litaC_module->ast != NULL);
    litaC_this->bufferFlush = litaC_true;
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), "#ifndef _LITAC_HEADER_H\n");
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), "#define _LITAC_HEADER_H\n");
    litaC_cgen__CGen_emitForward(litaC_this);
    litaC_cgen__CGen_emitPrimitiveConstDecls(litaC_this);
    litaC_cgen__CGen_emitModuleNotes(litaC_this);
    litaC_cgen__CGen_emitForwardDecls(litaC_this);
    litaC_cgen__CGen_emitTraitForwardDecls(litaC_this);
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), "\n#endif /* _LITAC_HEADER_H */\n");
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), "\n\n");
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), "// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), "// translated code begins\n");
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), "// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), "\n\n");
    litaC_this->bufferFlush = litaC_false;
    litaC_dependency_graph__DependencyGraph litaC_graph =  {
        
    };
    litaC_dependency_graph__DependencyGraph_init(&((litaC_graph)), litaC_this->lita);
    litaC_std__array__Array_cb__ptr_Symbol_ce_ litaC_declarations = litaC_dependency_graph__DependencyGraph_sort(&((litaC_graph)));
    litaC_bool litaC_isTesting = litaC_this->lita->options->testsOnly;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_declarations)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_declarations)), litaC_i);
            assert(litaC_sym->decl);
            if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_EMITTED) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_sym == litaC_this->lita->programSymbols.mainEntry) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(!(litaC_isTesting) && litaC_sym->flags & litaC_symbols__SymbolFlags_IS_TEST) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_sym->decl->stmt)));
            litaC_cgen__CGen_emitln(litaC_this);
            litaC_cgen__CGen_flush(litaC_this);
            
            
        }
    }
    litaC_cgen__CGen_emitTraitDecls(litaC_this);
    litaC_cgen__CGen_emitln(litaC_this);
    if(litaC_this->lita->programSymbols.mainEntry) {
        {
            litaC_cgen__CGen_emitMain(litaC_this, litaC_this->lita->programSymbols.mainEntry);
            
            
        }
        
    } 
    
    litaC_cgen__CGen_flush(litaC_this);
    
}

litaC_void litaC_cgen__CGen_emitMain(litaC_cgen__CGen* litaC_this,litaC_symbols__Symbol* litaC_sym) {
    litaC_ast__FuncDecl* litaC_decl = (litaC_ast__FuncDecl*)litaC_sym->decl;
    litaC_cgen_decl__CGen_emitFuncDeclSignature(litaC_this, litaC_decl, "main");
    litaC_this->currentFunc = litaC_sym->type;
    
    litaC_cgen__CGen_emitStrn(litaC_this, " {", 2);
    litaC_this->funcIndex = litaC_this->buf.length;
    litaC_cgen__CGen_emitStmt(litaC_this, litaC_decl->body);
    litaC_cgen__CGen_emitStrn(litaC_this, "}", 1);
    litaC_this->currentFunc = NULL;
    
}

litaC_void litaC_cgen__CGen_emitForward(litaC_cgen__CGen* litaC_this) {
    litaC_std__string_buffer__StringBuffer_append(&((litaC_this->buf)), "\n// Generated on %s\n#include <stdint.h>\n#include <stddef.h>\ntypedef int8_t    %s%s;\ntypedef int16_t   %s%s;\ntypedef int32_t   %s%s;\ntypedef int64_t   %s%s;\ntypedef uint8_t   %s%s;\ntypedef uint16_t  %s%s;\ntypedef uint32_t  %s%s;\ntypedef uint64_t  %s%s;\ntypedef float     %s%s;\ntypedef double    %s%s;\n//typedef int8_t    %s%s;\ntypedef size_t    %s%s;\n\n#if _MSC_VER\n#define LITAC_THREADLOCAL __declspec(thread)\n#define LITAC_INLINE static inline __forceinline\n#define LITAC_NOINLINE __declspec(noinline)\n#define LITAC_PACKED __pragma(pack(push, 1))\n#define LITAC_PACKED_POP __pragma(pack(pop))\n#define LITAC_EXPORT __declspec(dllexport)\n#endif\n\n#if __GNUC__\n#define LITAC_THREADLOCAL __thread\n#define LITAC_INLINE static inline __attribute__((always_inline))\n#define LITAC_NOINLINE __attribute__((noinline))\n#define LITAC_PACKED _Pragma(\"pack(push)\")\n#define LITAC_PACKED_POP _Pragma(\"pack(pop)\")\n#define LITAC_EXPORT __attribute__((visibility(\"default\")))\n#endif\n\n#if __TINYC__\n#define LITAC_THREADLOCAL\n#define LITAC_INLINE\n#define LITAC_NOINLINE\n#define LITAC_PACKED __attribute__((packed))\n#define LITAC_PACKED_POP\n#define LITAC_EXPORT __attribute__((dllexport))\n#endif\n\n", litaC_std__system__CurrentDateTime(), litaC_this->lita->options->cPrefix, "i8", litaC_this->lita->options->cPrefix, "i16", litaC_this->lita->options->cPrefix, "i32", litaC_this->lita->options->cPrefix, "i64", litaC_this->lita->options->cPrefix, "u8", litaC_this->lita->options->cPrefix, "u16", litaC_this->lita->options->cPrefix, "u32", litaC_this->lita->options->cPrefix, "u64", litaC_this->lita->options->cPrefix, "f32", litaC_this->lita->options->cPrefix, "f64", litaC_this->lita->options->cPrefix, "bool", litaC_this->lita->options->cPrefix, "usize");
    if(strlen(litaC_this->lita->options->cPrefix) > 0) {
        {
            litaC_std__string_buffer__StringBuffer_append(&((litaC_this->buf)), "typedef int8_t %s%s;\n", litaC_this->lita->options->cPrefix, "bool");
            litaC_std__string_buffer__StringBuffer_append(&((litaC_this->buf)), "#define %s%s (1)\n", litaC_this->lita->options->cPrefix, "true");
            litaC_std__string_buffer__StringBuffer_append(&((litaC_this->buf)), "#define %s%s (0)\n", litaC_this->lita->options->cPrefix, "false");
            litaC_std__string_buffer__StringBuffer_append(&((litaC_this->buf)), "#define %s%s void\n", litaC_this->lita->options->cPrefix, "void");
            litaC_std__string_buffer__StringBuffer_append(&((litaC_this->buf)), "typedef char   %s%s;\n", litaC_this->lita->options->cPrefix, "char");
            
            
        }
        
    } else {
        {
            litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), "\n// Boolean type\n#if defined(__STDC__) && __STDC_VERSION__ >= 199901L\n    #include <stdbool.h>\n#elif !defined(__cplusplus) && !defined(bool)\n    typedef enum { false, true } bool;\n#endif\n        ");
            
            
        }
    } 
    
    
}

litaC_void litaC_cgen__CGen_emitPrimitiveConstDecls(litaC_cgen__CGen* litaC_this) {
    litaC_symbols__ProgramSymbols* litaC_program = &(litaC_this->lita->programSymbols);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_program->values)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_program->values)), litaC_i);
            if(!((litaC_sym->flags & litaC_symbols__SymbolFlags_IS_CONSTANT))) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            if(!(litaC_types__IsPrimitive(litaC_sym->type))) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_cgen_decl__CGen_emitVarDecl(litaC_this, (litaC_ast__VarDecl*)litaC_sym->decl);
            litaC_cgen__CGen_emitln(litaC_this);
            
            
        }
    }
    
}

litaC_void litaC_cgen__CGen_emitModuleNotes(litaC_cgen__CGen* litaC_this) {
    for(litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_ litaC_it = litaC_std__map__Map_iter_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_this->lita->modules)));litaC_std__map__MapIterator_hasNext_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_it)));) {
        {
            litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_Module_ce_ litaC_m = litaC_std__map__MapIterator_next_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_it)));
            litaC_module__Module* litaC_module = litaC_m.value;
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_module->ast->notes)));litaC_i += 1) {
                {
                    litaC_ast__NoteStmt* litaC_note = litaC_std__array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_module->ast->notes)), litaC_i);
                    litaC_cgen__CGen_emitPreludeNote(litaC_this, litaC_note);
                    litaC_cgen__CGen_emitStrn(litaC_this, "\n", 1);
                    
                    
                }
            }
            
            
        }
    }
    
}

litaC_symbols__Symbol* litaC_cgen__CGen_findSymbolByTypeid(litaC_cgen__CGen* litaC_this,litaC_i64 litaC_id) {
    if(litaC_id < litaC_types__TypeKind_MAX_TYPE_KINDS) {
        {
            return litaC_module__GetBuiltinSymbol(litaC_id);
            
            
            
        }
        
    } 
    
    litaC_std__array__Array_cb__ptr_Symbol_ce_ litaC_symbols = litaC_this->lita->programSymbols.symbolTypes;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_symbols)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_symbols)), litaC_i);
            if(litaC_sym->type && litaC_sym->type->typeid == litaC_id) {
                {
                    return litaC_sym;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return NULL;
    
    
}

litaC_void litaC_cgen__CGen_emitTraitForwardDecls(litaC_cgen__CGen* litaC_this) {
    litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_ litaC_interfaceImpls = litaC_this->lita->programSymbols.interfaceImpls;
    litaC_cgen__CGen_emit(litaC_this, "\n\n// Generated code for interfaces\n");
    for(litaC_std__map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_ litaC_it = litaC_std__map__Map_iter_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_interfaceImpls)));litaC_std__map__MapIterator_hasNext_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_it)));) {
        {
            litaC_std__map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_ litaC_entry = litaC_std__map__MapIterator_next_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_it)));
            litaC_symbols__Symbol* litaC_traitSym = litaC_cgen__CGen_findSymbolByTypeid(litaC_this, litaC_entry.key);
            assert(litaC_traitSym);
            assert(litaC_traitSym->decl && litaC_traitSym->decl->stmt.node.kind == litaC_ast__StmtKind_TRAIT_DECL);
            litaC_ast__AggregateDecl* litaC_traitDecl = (litaC_ast__AggregateDecl*)litaC_traitSym->decl;
            const litaC_char* litaC_traitName = litaC_cgen__CGen_cTypeName(litaC_this, litaC_traitSym->type);
            litaC_cgen__CGen_emit(litaC_this, "// Generated code %s\n", litaC_traitName);
            {
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_i64_ce_(&((litaC_entry.value)));litaC_i += 1) {
                    {
                        litaC_symbols__Symbol* litaC_implSym = litaC_cgen__CGen_findSymbolByTypeid(litaC_this, litaC_std__array__Array_get_cb_i64_ce_(&((litaC_entry.value)), litaC_i));
                        assert(litaC_implSym);
                        const litaC_char* litaC_implName = litaC_cgen__CGen_cTypeName(litaC_this, litaC_implSym->type);
                        litaC_cgen__CGen_emit(litaC_this, "%s %s__to__%s(%s* x);\n", litaC_traitName, litaC_implName, litaC_traitName, litaC_implName);
                        
                        
                    }
                }
                
                
            }
            litaC_cgen__CGen_emitStrn(litaC_this, "\n", 1);
            
            
        }
    }
    
}

litaC_void litaC_cgen__CGen_emitTraitDecls(litaC_cgen__CGen* litaC_this) {
    litaC_module__Module* litaC_root = litaC_this->lita->programSymbols.root;
    assert(litaC_root != NULL);
    litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_ litaC_interfaceImpls = litaC_this->lita->programSymbols.interfaceImpls;
    for(litaC_std__map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_ litaC_it = litaC_std__map__Map_iter_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_interfaceImpls)));litaC_std__map__MapIterator_hasNext_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_it)));) {
        {
            litaC_std__map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_ litaC_entry = litaC_std__map__MapIterator_next_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_it)));
            litaC_symbols__Symbol* litaC_traitSym = litaC_cgen__CGen_findSymbolByTypeid(litaC_this, litaC_entry.key);
            assert(litaC_traitSym);
            assert(litaC_traitSym->decl && litaC_traitSym->decl->stmt.node.kind == litaC_ast__StmtKind_TRAIT_DECL);
            litaC_ast__AggregateDecl* litaC_traitDecl = (litaC_ast__AggregateDecl*)litaC_traitSym->decl;
            const litaC_char* litaC_traitName = litaC_cgen__CGen_cTypeName(litaC_this, litaC_traitSym->type);
            litaC_module__Module* litaC_module = litaC_root;
            litaC_char litaC_vtableName[256] =  {
                
            };
            litaC_std__string__String litaC_vtableNameStr = litaC_std__string__StringInit(litaC_vtableName, litaC_symbols__MAX_SYMBOL_NAME, 0);
            litaC_std__string_view__StringView litaC_escapedName = litaC_cgen__CGen_escapeNameStr(litaC_this, litaC_traitSym->name);
            litaC_std__string__String_format(&((litaC_vtableNameStr)), "%s%.*s__%.*s", litaC_this->lita->options->cPrefix, litaC_module->id.name.length, litaC_module->id.name.buffer, litaC_escapedName.length, litaC_escapedName.buffer);
            {
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_i64_ce_(&((litaC_entry.value)));litaC_i += 1) {
                    {
                        litaC_symbols__Symbol* litaC_implSym = litaC_cgen__CGen_findSymbolByTypeid(litaC_this, litaC_std__array__Array_get_cb_i64_ce_(&((litaC_entry.value)), litaC_i));
                        assert(litaC_implSym);
                        const litaC_char* litaC_implName = litaC_cgen__CGen_cTypeName(litaC_this, litaC_implSym->type);
                        litaC_cgen__CGen_emit(litaC_this, "%s %s__to__%s(%s* x) {", litaC_traitName, litaC_implName, litaC_traitName, litaC_implName);
                        litaC_cgen__CGen_emit(litaC_this, "return (%s) {", litaC_traitName);
                        litaC_cgen__CGen_emit(litaC_this, ".__vtable = %s__vtables[%d],\n", litaC_std__string__String_cStr(litaC_vtableNameStr), litaC_i);
                        litaC_cgen__CGen_emit(litaC_this, ".__this = x");
                        litaC_cgen__CGen_emitStrn(litaC_this, "}", 1);
                        litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                        litaC_cgen__CGen_emitStrn(litaC_this, "}\n", 2);
                        
                        
                    }
                }
                
                
            }
            
            
        }
    }
    
}

litaC_bool litaC_cgen__CGen_emitTraitCast(litaC_cgen__CGen* litaC_this,litaC_ast__Expr* litaC_expr) {
    if(!(litaC_expr)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    if(litaC_types__IsTraitLike(litaC_expr->expectedType)) {
        {
            if(litaC_expr->operand.typeInfo != NULL && !(litaC_types__IsTraitLike(litaC_expr->operand.typeInfo))) {
                {
                    const litaC_char* litaC_traitName = litaC_cgen__CGen_cTypeName(litaC_this, litaC_types__TypeInfo_getBaseType(litaC_expr->expectedType));
                    const litaC_char* litaC_implName = litaC_cgen__CGen_cTypeName(litaC_this, litaC_types__TypeInfo_getBaseType(litaC_expr->operand.typeInfo));
                    if(litaC_types__IsPtr(litaC_expr->expectedType)) {
                        {
                            litaC_cgen__CGen_emitStrn(litaC_this, "&", 1);
                            
                            
                        }
                        
                    } 
                    
                    litaC_cgen__CGen_emit(litaC_this, "%s__to__%s(", litaC_implName, litaC_traitName);
                    if(!(litaC_types__IsPtr(litaC_expr->operand.typeInfo))) {
                        {
                            litaC_cgen__CGen_emitStrn(litaC_this, "&", 1);
                            
                            
                        }
                        
                    } 
                    
                    litaC_cgen__CGen_emitStrn(litaC_this, "(", 1);
                    litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->stmt)));
                    litaC_cgen__CGen_emitStrn(litaC_this, "))", 2);
                    return litaC_true;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_void litaC_cgen__CGen_emitForwardDecls(litaC_cgen__CGen* litaC_this) {
    litaC_symbols__ProgramSymbols* litaC_program = &(litaC_this->lita->programSymbols);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_program->symbolTypes)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_program->symbolTypes)), litaC_i);
            litaC_cgen__CGen_emitTypeForwardDecl(litaC_this, litaC_sym);
            
            
        }
    }
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_program->symbolFuncs)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_program->symbolFuncs)), litaC_i);
            litaC_cgen__CGen_emitTypeForwardDecl(litaC_this, litaC_sym);
            
            
        }
    }
    
}

litaC_void litaC_cgen__CGen_emitTypeForwardDecl(litaC_cgen__CGen* litaC_this,litaC_symbols__Symbol* litaC_sym) {
    litaC_ast__Decl* litaC_decl = litaC_sym->decl;
    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN || litaC_sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(!(litaC_this->lita->options->testsOnly) && litaC_sym->flags & litaC_symbols__SymbolFlags_IS_TEST) {
        {
            return;
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_name = litaC_cgen__CGen_cName(litaC_this, litaC_decl->sym);
    switch(litaC_decl->stmt.node.kind) {
        case litaC_ast__StmtKind_VAR_DECL: 
        case litaC_ast__StmtKind_CONST_DECL: {
            break;
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                litaC_cgen_decl__CGen_emitFuncDeclSignature(litaC_this, (litaC_ast__FuncDecl*)litaC_decl, litaC_name);
                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ";\n", 2);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNION_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: 
        case litaC_ast__StmtKind_TRAIT_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_aggDecl = (litaC_ast__AggregateDecl*)litaC_decl;
                {
                    litaC_std__string_buffer__StringBuffer_append(&((litaC_this->buf)), "typedef %s %s %s;\n", (litaC_aggDecl->decl.declaration.stmt.node.kind == litaC_ast__StmtKind_UNION_DECL) ? "union" : "struct", litaC_name, litaC_name);
                    
                    
                }
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: {
            {
                litaC_cgen_decl__CGen_emitEnumDecl(litaC_this, (litaC_ast__EnumDecl*)litaC_decl);
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                break;
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    
}

const litaC_char* litaC_cgen__CGen_allocTemp(litaC_cgen__CGen* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_char* litaC_buffer) {
    litaC_std__string__String litaC_name = litaC_std__string__StringInit(litaC_buffer, litaC_symbols__MAX_SYMBOL_NAME, 0);
    litaC_std__string__String_format(&((litaC_name)), "__tmp%d", litaC_this->tmpVar);
    litaC_this->tmpVar += 1;
    const litaC_char* litaC_decl = litaC_cgen__CGen_cTypeDecl(litaC_this, litaC_type, litaC_std__string__String_cStr(litaC_name), litaC_false);
    litaC_std__string_buffer__StringBuffer_insert(&((litaC_this->buf)), litaC_this->funcIndex, "    %s;\n", litaC_decl);
    return litaC_std__string__String_cStr(litaC_name);
    
    
}

litaC_std__string_view__StringView litaC_cgen__CGen_escapeNameStr(litaC_cgen__CGen* litaC_this,litaC_intern__InternedString litaC_name) {
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_common__EscapeName(litaC_name.buffer, litaC_name.length, &((litaC_sb)));
    return (litaC_std__string_view__StringView) {
        .buffer = litaC_sb.buffer,
        .length = litaC_sb.length
    };
    
    
}

litaC_std__string_view__StringView litaC_cgen__CGen_escapeNameChars(litaC_cgen__CGen* litaC_this,const litaC_char* litaC_name) {
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_common__EscapeName(litaC_name, strlen(litaC_name), &((litaC_sb)));
    return (litaC_std__string_view__StringView) {
        .buffer = litaC_sb.buffer,
        .length = litaC_sb.length
    };
    
    
}

litaC_std__string_view__StringView litaC_cgen__CGen_escapeName(litaC_cgen__CGen* litaC_this,litaC_types__TypeInfo* litaC_type) {
    if(litaC_types__IsAggregate(litaC_type)) {
        {
            return litaC_cgen__CGen_escapeNameStr(litaC_this, litaC_type->name);
            
            
            
        }
        
    } 
    
    if(litaC_types__IsFuncLike(litaC_type)) {
        {
            if(litaC_type->kind == litaC_types__TypeKind_FUNC) {
                {
                    litaC_types__TypeInfo* litaC_funcInfo = litaC_type;
                    if(litaC_funcInfo->funcDecl->flags & litaC_ast__FuncFlags_IS_METHOD) {
                        {
                            litaC_char litaC_methodName[256] = {0};
                            if(!(litaC_ast__FuncDecl_getName(litaC_funcInfo->funcDecl, litaC_methodName))) {
                                {
                                    assert(litaC_false);
                                    
                                    
                                }
                                
                            } 
                            
                            return litaC_cgen__CGen_escapeNameChars(litaC_this, litaC_methodName);
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            return (litaC_std__string_view__StringView) {
                .buffer = "_",
                .length = 1
            };
            
            
            
        }
        
    } 
    
    return litaC_type->name.view;
    
    
}

litaC_std__string_view__StringView litaC_cgen__CGen_baseTypeName(litaC_cgen__CGen* litaC_this,litaC_std__string_view__StringView litaC_name) {
    litaC_i32 litaC_index = litaC_std__string_view__StringView_lastIndexOfAt(litaC_name, "::", -(1), -(1));
    if(litaC_index >= 0) {
        {
            litaC_name = litaC_std__string_view__StringView_substring(litaC_name, litaC_index + 2, -(1));
            
            
        }
        
    } 
    
    litaC_index = litaC_std__string_view__StringView_indexOf(litaC_name, "<", -(1));
    if(litaC_index >= 0) {
        {
            litaC_name = litaC_std__string_view__StringView_substring(litaC_name, 0, litaC_index);
            
            
        }
        
    } 
    
    return litaC_name;
    
    
}

litaC_void litaC_cgen__CGen_pushScope(litaC_cgen__CGen* litaC_this,litaC_cgen__CGenScope* litaC_scope) {
    litaC_scope->parent = litaC_this->currentScope;
    litaC_this->currentScope = litaC_scope;
    
}

litaC_cgen__CGenScope* litaC_cgen__CGen_popScope(litaC_cgen__CGen* litaC_this) {
    litaC_cgen__CGenScope* litaC_scope = litaC_this->currentScope;
    if(!(litaC_scope)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_this->currentScope = litaC_scope->parent;
    litaC_cgen__CGen_leaveScope(litaC_this, litaC_scope, litaC_true);
    return litaC_scope;
    
    
}

litaC_void litaC_cgen__CGen_popLoopScope(litaC_cgen__CGen* litaC_this,litaC_bool litaC_checkSwitch) {
    litaC_cgen__CGenScope* litaC_scope = litaC_this->currentScope;
    while(litaC_scope) {
        {
            if(litaC_checkSwitch && litaC_scope->isSwitch) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_cgen__CGen_leaveScope(litaC_this, litaC_scope, litaC_true);
            if(!(litaC_scope) || litaC_scope->isLoop) {
                {
                    break;
                    
                    
                }
                
            } 
            
            litaC_scope = litaC_scope->parent;
            
            
        }
    }
    
}

litaC_void litaC_cgen__CGen_leaveScope(litaC_cgen__CGen* litaC_this,litaC_cgen__CGenScope* litaC_scope,litaC_bool litaC_includeConst) {
    if(!(litaC_scope)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_this->deferStack += 1;
    for(litaC_i32 litaC_i = litaC_std__array__Array_size_cb__ptr_Stmt_ce_(&((litaC_scope->defers))) - 1;litaC_i >= 0;litaC_i -= 1) {
        {
            litaC_ast__Stmt* litaC_deferStmt = litaC_std__array__Array_get_cb__ptr_Stmt_ce_(&((litaC_scope->defers)), litaC_i);
            litaC_cgen__CGen_emitStmt(litaC_this, litaC_deferStmt);
            litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
            
            
        }
    }
    litaC_this->deferStack -= 1;
    if(litaC_includeConst) {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_const_char_ce_(&((litaC_scope->constDefs)));litaC_i += 1) {
                {
                    const litaC_char* litaC_name = litaC_std__array__Array_get_cb__ptr_const_char_ce_(&((litaC_scope->constDefs)), litaC_i);
                    litaC_cgen__CGen_emit(litaC_this, "#undef %s\n", litaC_name);
                    
                    
                }
            }
            
            
        }
        
    } 
    
    
}

litaC_bool litaC_cgen__CGen_hasPendingDefers(litaC_cgen__CGen* litaC_this) {
    litaC_cgen__CGenScope* litaC_scope = litaC_this->currentScope;
    while(litaC_scope) {
        {
            if(!(litaC_std__array__Array_empty_cb__ptr_Stmt_ce_(&((litaC_scope->defers))))) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } 
            
            litaC_scope = litaC_scope->parent;
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_void litaC_cgen__CGen_emitDefers(litaC_cgen__CGen* litaC_this) {
    if(litaC_this->deferStack > 0) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_cgen__CGenScope* litaC_scope = litaC_this->currentScope;
    while(litaC_scope) {
        {
            litaC_cgen__CGen_leaveScope(litaC_this, litaC_scope, litaC_false);
            litaC_scope = litaC_scope->parent;
            
            
        }
    }
    
}

litaC_void litaC_cgen__CGen_emitLineInfo(litaC_cgen__CGen* litaC_this,litaC_ast__Stmt* litaC_stmt) {
    if(litaC_this->lita->options->disableLineSync || litaC_this->inTextBlock || !(litaC_stmt)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_lex__SrcPos litaC_pos = litaC_stmt->node.startPos;
    if(litaC_this->currentLine != litaC_pos.lineNumber || litaC_this->currentFile != litaC_pos.filename) {
        {
            litaC_this->currentFile = litaC_pos.filename;
            litaC_this->currentLine = litaC_pos.lineNumber;
            if(litaC_this->currentFile) {
                {
                    litaC_cgen__CGen_emit(litaC_this, "\n#line %d \"", litaC_this->currentLine);
                    litaC_i32 litaC_len = strlen(litaC_this->currentFile);
                    for(litaC_i32 litaC_i = 0;litaC_i < litaC_len;litaC_i += 1) {
                        {
                            litaC_char litaC_c = litaC_this->currentFile[litaC_i];
                            const litaC_char* litaC_escaped = litaC_cgen__escapeStrings[(litaC_u32)litaC_c];
                            if(litaC_escaped) {
                                {
                                    litaC_cgen__CGen_emitStr(litaC_this, litaC_escaped);
                                    continue;
                                    
                                    
                                }
                                
                            } else {
                                {
                                    litaC_std__string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), litaC_c);
                                    
                                    
                                }
                            } 
                            
                            
                            
                        }
                    }
                    litaC_cgen__CGen_emitStrn(litaC_this, "\"\n", 2);
                    
                    
                }
                
            } else {
                {
                    litaC_cgen__CGen_emit(litaC_this, "\n#line %d \n", litaC_this->currentLine);
                    
                    
                }
            } 
            
            
            
        }
        
    } 
    
    
}

const litaC_char* litaC_cgen__CGen_cType(litaC_cgen__CGen* litaC_this,litaC_types__TypeInfo* litaC_type,litaC_bool litaC_isCast,litaC_bool litaC_decay) {
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__TypeInfo* litaC_ptrInfo = litaC_type;
                litaC_types__TypeInfo* litaC_ptrOf = litaC_ptrInfo->ptrOf;
                if(litaC_ptrOf->kind == litaC_types__TypeKind_ARRAY && !(litaC_decay)) {
                    {
                        litaC_types__TypeInfo* litaC_arrayInfo = litaC_ptrOf;
                        if(litaC_arrayInfo->isLengthDefined) {
                            {
                                litaC_types__TypeInfo* litaC_baseInfo = litaC_types__TypeInfo_getBaseType(litaC_arrayInfo);
                                const litaC_char* litaC_cType = litaC_cgen__CGen_cType(litaC_this, litaC_baseInfo, litaC_isCast, litaC_false);
                                litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "%s (*)[%zu]", litaC_cType, litaC_arrayInfo->length);
                                return litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                const litaC_char* litaC_cType = litaC_cgen__CGen_cType(litaC_this, litaC_ptrInfo->ptrOf, litaC_isCast, litaC_decay);
                litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_cType);
                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "*", 1);
                return litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__TypeInfo* litaC_constInfo = litaC_type;
                if(litaC_types__IsPtrLike(litaC_constInfo->constOf)) {
                    {
                        const litaC_char* litaC_cType = litaC_cgen__CGen_cType(litaC_this, litaC_constInfo->constOf, litaC_isCast, litaC_decay);
                        litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_cType);
                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), " const", 6);
                        return litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                        
                        
                        
                    }
                    
                } 
                
                const litaC_char* litaC_cType = litaC_cgen__CGen_cType(litaC_this, litaC_constInfo->constOf, litaC_isCast, litaC_decay);
                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "const ", 6);
                litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_cType);
                return litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__TypeInfo* litaC_arrayInfo = litaC_type;
                if(litaC_decay) {
                    {
                        litaC_types__TypeInfo litaC_ptrInfo =  {
                            .kind = litaC_types__TypeKind_PTR,
                            .ptrOf = litaC_arrayInfo->arrayOf
                        };
                        return litaC_cgen__CGen_cType(litaC_this, &((litaC_ptrInfo)), litaC_isCast, litaC_false);
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__TypeInfo* litaC_baseInfo = litaC_types__TypeInfo_getBaseType(litaC_arrayInfo);
                const litaC_char* litaC_baseName = litaC_cgen__CGen_cType(litaC_this, litaC_baseInfo, litaC_false, litaC_false);
                litaC_std__string_buffer__StringBuffer litaC_buf = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
                litaC_std__string_buffer__StringBuffer litaC_line = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
                do {
                    {
                        if(litaC_arrayInfo->length < 0) {
                            {
                                if(litaC_arrayInfo->numOfElements) {
                                    {
                                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_buf)), "[", 1);
                                        litaC_cgen__CGen litaC_cgen =  {
                                            .lita = litaC_this->lita,
                                            .buf = litaC_buf,
                                            .line = litaC_line
                                        };
                                        litaC_cgen__CGen_emitStmt(&((litaC_cgen)), &((litaC_arrayInfo->numOfElements->stmt)));
                                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_buf)), "]", 1);
                                        
                                        
                                    }
                                    
                                } else {
                                    if(!(litaC_arrayInfo->isLengthDefined)) {
                                        {
                                            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_buf)), "[]", 2);
                                            
                                            
                                        }
                                        
                                    } else {
                                        {
                                            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_buf)), "[0]", 3);
                                            
                                            
                                        }
                                    } 
                                    
                                } 
                                
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_std__string_buffer__StringBuffer_append(&((litaC_buf)), "[%zu]", litaC_arrayInfo->length);
                                
                                
                            }
                        } 
                        
                        if(litaC_arrayInfo->arrayOf && litaC_arrayInfo->arrayOf->kind == litaC_types__TypeKind_ARRAY) {
                            {
                                litaC_arrayInfo = litaC_arrayInfo->arrayOf;
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_arrayInfo = NULL;
                                
                                
                            }
                        } 
                        
                        
                        
                    }
                }
                while(litaC_arrayInfo);
                litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_baseName);
                litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_buf))));
                return litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                litaC_types__TypeInfo* litaC_funcInfo = litaC_type;
                litaC_std__string_buffer__StringBuffer litaC_params = litaC_std__string_buffer__StringBufferInit(512, litaC_this->lita->allocator);
                if(litaC_funcInfo->isTrait) {
                    {
                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_params)), "void*", 5);
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcInfo->paramDecls)));litaC_i += 1) {
                    {
                        if(litaC_i > 0 || litaC_funcInfo->isTrait) {
                            {
                                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_params)), ",", 1);
                                
                                
                            }
                            
                        } 
                        
                        litaC_types__TypeInfo* litaC_param = litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_funcInfo->paramDecls)), litaC_i);
                        litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_params)), litaC_cgen__CGen_cType(litaC_this, litaC_param, litaC_isCast, litaC_true));
                        
                        
                    }
                }
                litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "%s (*%s)(%s)", litaC_cgen__CGen_cType(litaC_this, litaC_funcInfo->returnType, litaC_isCast, litaC_decay), (litaC_isCast) ? "" : litaC_cgen__CGen_cTypeName(litaC_this, litaC_funcInfo), litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_params))));
                return litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                
                
                
            }
            
            
        }
        default: {
            {
                return litaC_cgen__CGen_cTypeName(litaC_this, litaC_type);
                
                
                
            }
            
            
        }
    }
    
}

const litaC_char* litaC_cgen__CGen_cTypeDecl(litaC_cgen__CGen* litaC_this,litaC_types__TypeInfo* litaC_type,const litaC_char* litaC_name,litaC_bool litaC_decay) {
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    switch(litaC_type->kind) {
        case litaC_types__TypeKind_PTR: {
            {
                litaC_types__TypeInfo* litaC_ptrInfo = litaC_type;
                litaC_types__TypeInfo* litaC_ptrOf = litaC_ptrInfo->ptrOf;
                if(litaC_ptrOf->kind == litaC_types__TypeKind_ARRAY && !(litaC_decay)) {
                    {
                        litaC_types__TypeInfo* litaC_arrayInfo = litaC_ptrOf;
                        if(litaC_arrayInfo->isLengthDefined) {
                            {
                                litaC_types__TypeInfo* litaC_baseInfo = litaC_types__TypeInfo_getBaseType(litaC_arrayInfo);
                                const litaC_char* litaC_cType = litaC_cgen__CGen_cType(litaC_this, litaC_baseInfo, litaC_false, litaC_false);
                                litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "%s (*%s)[%zu]", litaC_cType, litaC_name, litaC_arrayInfo->length);
                                return litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                const litaC_char* litaC_cType = litaC_cgen__CGen_cType(litaC_this, litaC_type, litaC_false, litaC_decay);
                litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_cType);
                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), " ", 1);
                litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_name);
                return litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_CONST: {
            {
                litaC_types__TypeInfo* litaC_constInfo = litaC_type;
                if(litaC_types__IsPtrLike(litaC_constInfo->constOf)) {
                    {
                        const litaC_char* litaC_cType = litaC_cgen__CGen_cType(litaC_this, litaC_constInfo->constOf, litaC_false, litaC_decay);
                        litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_cType);
                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), " const ", 7);
                        litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_name);
                        return litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                        
                        
                        
                    }
                    
                } 
                
                const litaC_char* litaC_cType = litaC_cgen__CGen_cTypeDecl(litaC_this, litaC_constInfo->constOf, litaC_name, litaC_decay);
                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "const ", 6);
                litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_cType);
                return litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            {
                litaC_types__TypeInfo* litaC_arrayInfo = litaC_type;
                if(litaC_decay) {
                    {
                        litaC_types__TypeInfo litaC_ptrInfo =  {
                            .kind = litaC_types__TypeKind_PTR,
                            .ptrOf = litaC_arrayInfo->arrayOf
                        };
                        return litaC_cgen__CGen_cTypeDecl(litaC_this, &((litaC_ptrInfo)), litaC_name, litaC_false);
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__TypeInfo* litaC_baseInfo = litaC_types__TypeInfo_getBaseType(litaC_arrayInfo);
                const litaC_char* litaC_baseName = litaC_cgen__CGen_cType(litaC_this, litaC_baseInfo, litaC_false, litaC_false);
                litaC_std__string_buffer__StringBuffer litaC_buf = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
                litaC_std__string_buffer__StringBuffer litaC_line = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
                do {
                    {
                        if(litaC_arrayInfo->length == 0) {
                            {
                                if(litaC_arrayInfo->numOfElements) {
                                    {
                                        litaC_cgen__CGen_flush(litaC_this);
                                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_buf)), "[", 1);
                                        litaC_cgen__CGen litaC_cgen =  {
                                            .lita = litaC_this->lita,
                                            .buf = litaC_buf,
                                            .line = litaC_line
                                        };
                                        litaC_cgen__CGen_emitStmt(&((litaC_cgen)), &((litaC_arrayInfo->numOfElements->stmt)));
                                        litaC_buf = litaC_cgen.buf;
                                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_buf)), "]", 1);
                                        
                                        
                                    }
                                    
                                } else {
                                    if(!(litaC_arrayInfo->isLengthDefined)) {
                                        {
                                            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_buf)), "[]", 2);
                                            
                                            
                                        }
                                        
                                    } else {
                                        {
                                            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_buf)), "[0]", 3);
                                            
                                            
                                        }
                                    } 
                                    
                                } 
                                
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_std__string_buffer__StringBuffer_append(&((litaC_buf)), "[%zu]", litaC_arrayInfo->length);
                                
                                
                            }
                        } 
                        
                        if(litaC_arrayInfo->arrayOf && litaC_arrayInfo->arrayOf->kind == litaC_types__TypeKind_ARRAY) {
                            {
                                litaC_arrayInfo = litaC_arrayInfo->arrayOf;
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_arrayInfo = NULL;
                                
                                
                            }
                        } 
                        
                        
                        
                    }
                }
                while(litaC_arrayInfo);
                if(litaC_baseInfo->kind == litaC_types__TypeKind_FUNC_PTR) {
                    {
                        litaC_std__string_buffer__StringBuffer_insert(&((litaC_buf)), 0, "%s", litaC_name);
                        return litaC_cgen__CGen_cTypeDecl(litaC_this, litaC_baseInfo, litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_buf))), litaC_decay);
                        
                        
                        
                    }
                    
                } 
                
                litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_baseName);
                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), " ", 1);
                litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_name);
                litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_std__string_buffer__StringBuffer_cStr(&((litaC_buf))));
                return litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_STR: {
            {
                litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), "const char* ");
                litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_name);
                return litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                
                
                
            }
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            {
                litaC_types__TypeInfo* litaC_funcInfo = litaC_type;
                litaC_std__string_buffer__StringBuffer litaC_params = litaC_std__string_buffer__StringBufferInit(512, litaC_this->lita->allocator);
                if(litaC_funcInfo->isTrait) {
                    {
                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_params)), "void*", 5);
                        
                        
                    }
                    
                } 
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcInfo->paramDecls)));litaC_i += 1) {
                    {
                        if(litaC_i > 0 || litaC_funcInfo->isTrait) {
                            {
                                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_params)), ",", 1);
                                
                                
                            }
                            
                        } 
                        
                        litaC_types__TypeInfo* litaC_param = litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_funcInfo->paramDecls)), litaC_i);
                        litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_params)), litaC_cgen__CGen_cType(litaC_this, litaC_param, litaC_false, litaC_true));
                        
                        
                    }
                }
                litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "%s (*%s)(%s)", litaC_cgen__CGen_cType(litaC_this, litaC_funcInfo->returnType, litaC_false, litaC_decay), litaC_name, litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_params))));
                return litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                
                
                
            }
            
            
        }
        default: {
            {
                const litaC_char* litaC_cType = litaC_cgen__CGen_cType(litaC_this, litaC_type, litaC_false, litaC_decay);
                litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_cType);
                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), " ", 1);
                litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_name);
                return litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
                
                
                
            }
            
            
        }
    }
    
}

litaC_std__string_view__StringView litaC_cgen__CGen_foreignName(litaC_cgen__CGen* litaC_this,litaC_ast__Decl* litaC_decl,litaC_std__string_view__StringView litaC_defaultName) {
    if(!(litaC_decl)) {
        {
            return litaC_defaultName;
            
            
            
        }
        
    } 
    
    litaC_ast__NoteStmt* litaC_note = litaC_ast__Decl_getNote(litaC_decl, "foreign");
    if(!(litaC_note)) {
        {
            return litaC_defaultName;
            
            
            
        }
        
    } 
    
    if(litaC_std__array__Array_empty_cb_CallArg_ce_(&((litaC_note->arguments)))) {
        {
            return litaC_defaultName;
            
            
            
        }
        
    } 
    
    litaC_ast__CallArg litaC_arg = litaC_std__array__Array_get_cb_CallArg_ce_(&((litaC_note->arguments)), 0);
    if(!(litaC_arg.argExpr)) {
        {
            return litaC_defaultName;
            
            
            
        }
        
    } 
    
    return litaC_arg.argExpr->operand.val.str;
    
    
}

const litaC_char* litaC_cgen__CGen_cName(litaC_cgen__CGen* litaC_this,litaC_symbols__Symbol* litaC_sym) {
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    litaC_std__string_view__StringView litaC_declName = litaC_sym->name.view;
    if(litaC_types__IsFuncLike(litaC_sym->type)) {
        {
            litaC_declName = litaC_cgen__CGen_escapeNameStr(litaC_this, litaC_sym->name);
            
            
        }
        
    } else {
        if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_TYPE) {
            {
                litaC_declName = litaC_cgen__CGen_escapeName(litaC_this, litaC_sym->type);
                
                
            }
            
        } 
        
    } 
    
    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_LOCAL) {
        {
            return litaC_cgen__CGen_prefix(litaC_this, litaC_declName, &((litaC_sb)));
            
            
            
        }
        
    } 
    
    if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN) {
        {
            if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_BUILTIN) {
                {
                    return litaC_cgen__CGen_prefix(litaC_this, litaC_sym->name.view, &((litaC_sb)));
                    
                    
                    
                }
                
            } 
            
            litaC_std__string_view__StringView litaC_name = litaC_cgen__CGen_foreignName(litaC_this, litaC_sym->decl, litaC_cgen__CGen_baseTypeName(litaC_this, litaC_sym->decl->name.str.view));
            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), litaC_name.buffer, litaC_name.length);
            return litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
            
            
            
        }
        
    } 
    
    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_sb)), litaC_this->lita->options->cPrefix);
    litaC_std__string_view__StringView litaC_packageName = litaC_cgen__CGen_escapeNameStr(litaC_this, litaC_sym->declared->id.packageName);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), litaC_packageName.buffer, litaC_packageName.length);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), "__", 2);
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_sb)), litaC_declName.buffer, litaC_declName.length);
    return litaC_std__string_buffer__StringBuffer_cStrConst(&((litaC_sb)));
    
    
}

const litaC_char* litaC_cgen__CGen_cTypeName(litaC_cgen__CGen* litaC_this,litaC_types__TypeInfo* litaC_type) {
    assert(litaC_type != NULL);
    if(!(litaC_type->sym)) {
        {
            litaC_std__string_view__StringView litaC_typeName = litaC_cgen__CGen_escapeName(litaC_this, litaC_type);
            litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
            return litaC_cgen__CGen_prefix(litaC_this, litaC_typeName, &((litaC_sb)));
            
            
            
        }
        
    } 
    
    return litaC_cgen__CGen_cName(litaC_this, litaC_type->sym);
    
    
}

const litaC_char* litaC_cgen__CGen_prefix(litaC_cgen__CGen* litaC_this,litaC_std__string_view__StringView litaC_name,litaC_std__string_buffer__StringBuffer* litaC_sb) {
    litaC_std__string_buffer__StringBuffer_appendStr(litaC_sb, litaC_this->lita->options->cPrefix);
    litaC_std__string_buffer__StringBuffer_appendStrn(litaC_sb, litaC_name.buffer, litaC_name.length);
    return litaC_std__string_buffer__StringBuffer_cStrConst(litaC_sb);
    
    
}

litaC_void litaC_cgen__CGen_emitTypeSpec(litaC_cgen__CGen* litaC_this,litaC_ast__TypeSpec* litaC_spec) {
    assert(litaC_spec != NULL);
    switch(litaC_spec->kind) {
        case litaC_ast__TypeSpecKind_NONE: {
            {
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_ARRAY: {
            {
                litaC_ast__TypeSpec* litaC_array = litaC_spec;
                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "[", 1);
                if(litaC_array->numElements) {
                    {
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_array->numElements->stmt)));
                        
                        
                    }
                    
                } 
                
                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "]", 1);
                litaC_cgen__CGen_emitTypeSpec(litaC_this, litaC_array->base);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_PTR: {
            {
                litaC_ast__TypeSpec* litaC_ptr = litaC_spec;
                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "*", 1);
                litaC_cgen__CGen_emitTypeSpec(litaC_this, litaC_ptr->base);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_CONST: {
            {
                litaC_ast__TypeSpec* litaC_c = litaC_spec;
                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "const ", 6);
                litaC_cgen__CGen_emitTypeSpec(litaC_this, litaC_c->base);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_NAME: {
            {
                litaC_ast__TypeSpec* litaC_name = litaC_spec;
                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), litaC_name->name.buffer, litaC_name->name.length);
                if(!(litaC_std__array__Array_empty_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs))))) {
                    {
                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "<", 1);
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ",", 1);
                                    
                                } 
                                
                                litaC_cgen__CGen_emitTypeSpec(litaC_this, litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_name->genericArgs)), litaC_i));
                                
                                
                            }
                        }
                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ">", 1);
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__TypeSpecKind_FUNC_PTR: {
            {
                litaC_ast__TypeSpec* litaC_fn = litaC_spec;
                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "func", 4);
                if(!(litaC_std__array__Array_empty_cb_GenericParam_ce_(&((litaC_fn->genericParams))))) {
                    {
                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "<", 1);
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_GenericParam_ce_(&((litaC_fn->genericParams)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ",", 1);
                                    
                                } 
                                
                                litaC_cgen__CGen_emitName(litaC_this, litaC_std__array__Array_get_cb_GenericParam_ce_(&((litaC_fn->genericParams)), litaC_i).name);
                                
                                
                            }
                        }
                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ">", 1);
                        
                        
                    }
                    
                } 
                
                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "(", 1);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(&((litaC_fn->args)));litaC_i += 1) {
                    {
                        if(litaC_i > 0) {
                            litaC_std__string_buffer__StringBuffer_append(&((litaC_this->buf)), ",");
                            
                        } 
                        
                        litaC_cgen__CGen_emitTypeSpec(litaC_this, litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(&((litaC_fn->args)), litaC_i));
                        
                        
                    }
                }
                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ") : ", 4);
                litaC_cgen__CGen_emitTypeSpec(litaC_this, litaC_fn->ret);
                return;
                
                
                
            }
            
            
        }
        default: {
            {
                litaC_common__Panic("Invalid TypeSpecKind: '%d'\n", litaC_spec->kind);
                
                
            }
            
            
        }
    }
    
}

litaC_void litaC_cgen__CGen_flush(litaC_cgen__CGen* litaC_this) {
    if(litaC_this->output) {
        {
            litaC_std__io__File_writeBytes(litaC_this->output, litaC_this->buf.buffer, litaC_this->buf.length);
            litaC_this->buf.length = 0;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_cgen__CGen_emitNameStr(litaC_cgen__CGen* litaC_this,litaC_std__string_view__StringView litaC_name) {
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), litaC_name.buffer, litaC_name.length);
    
}

litaC_void litaC_cgen__CGen_emitName(litaC_cgen__CGen* litaC_this,litaC_ast__Identifier litaC_id) {
    litaC_lex__Token litaC_tok = litaC_id.token;
    if(litaC_tok.type != litaC_lex__TokenType_ERROR) {
        {
            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), litaC_tok.value.str.buffer, litaC_tok.value.str.length);
            
            
        }
        
    } 
    
    
}

litaC_void litaC_cgen__CGen_emitln(litaC_cgen__CGen* litaC_this) {
    litaC_std__string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), '\n');
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_this->indent;litaC_i += 1) {
        {
            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "    ", 4);
            
            
        }
    }
    
}

litaC_void litaC_cgen__CGen_emit(litaC_cgen__CGen* litaC_this,const litaC_char* litaC_strFormat,...) {
    if(litaC_this->format) {
        {
            litaC_std__string_buffer__StringBuffer_clear(&((litaC_this->line)));
            va_list litaC_args = {0};
            va_start(litaC_args, litaC_strFormat);
            litaC_std__string_buffer__StringBuffer_appendArgs(&((litaC_this->line)), litaC_strFormat, litaC_args);
            va_end(litaC_args);
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_this->line.length;litaC_i += 1) {
                {
                    litaC_char litaC_c = litaC_this->line.buffer[litaC_i];
                    if(litaC_c == '\n') {
                        {
                            litaC_cgen__CGen_emitln(litaC_this);
                            
                            
                        }
                        
                    } else {
                        if(litaC_c == '{') {
                            {
                                litaC_std__string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), litaC_c);
                                litaC_this->indent += 1;
                                litaC_cgen__CGen_emitln(litaC_this);
                                
                                
                            }
                            
                        } else {
                            if(litaC_c == '}') {
                                {
                                    litaC_this->indent -= 1;
                                    litaC_cgen__CGen_emitln(litaC_this);
                                    litaC_std__string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), litaC_c);
                                    
                                    
                                }
                                
                            } else {
                                {
                                    litaC_std__string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), litaC_c);
                                    
                                    
                                }
                            } 
                            
                        } 
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            va_list litaC_args = {0};
            va_start(litaC_args, litaC_strFormat);
            litaC_std__string_buffer__StringBuffer_appendArgs(&((litaC_this->buf)), litaC_strFormat, litaC_args);
            va_end(litaC_args);
            
            
        }
    } 
    
    if(litaC_this->bufferFlush) {
        {
            if(litaC_this->buf.length > (litaC_this->buf.capacity / 2)) {
                {
                    litaC_cgen__CGen_flush(litaC_this);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    
}

litaC_void litaC_cgen__CGen_emitStr(litaC_cgen__CGen* litaC_this,const litaC_char* litaC_str) {
    litaC_i32 litaC_len = strlen(litaC_str);
    litaC_cgen__CGen_emitStrn(litaC_this, litaC_str, litaC_len);
    
}

litaC_void litaC_cgen__CGen_emitStrn(litaC_cgen__CGen* litaC_this,const litaC_char* litaC_str,litaC_i32 litaC_len) {
    if(litaC_this->format) {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_len;litaC_i += 1) {
                {
                    litaC_char litaC_c = litaC_str[litaC_i];
                    if(litaC_c == '\n') {
                        {
                            litaC_cgen__CGen_emitln(litaC_this);
                            
                            
                        }
                        
                    } else {
                        if(litaC_c == '{') {
                            {
                                litaC_std__string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), litaC_c);
                                litaC_this->indent += 1;
                                litaC_cgen__CGen_emitln(litaC_this);
                                
                                
                            }
                            
                        } else {
                            if(litaC_c == '}') {
                                {
                                    litaC_this->indent -= 1;
                                    litaC_cgen__CGen_emitln(litaC_this);
                                    litaC_std__string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), litaC_c);
                                    
                                    
                                }
                                
                            } else {
                                {
                                    litaC_std__string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), litaC_c);
                                    
                                    
                                }
                            } 
                            
                        } 
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), litaC_str, litaC_len);
            
            
        }
    } 
    
    if(litaC_this->bufferFlush) {
        {
            if(litaC_this->buf.length > (litaC_this->buf.capacity / 2)) {
                {
                    litaC_cgen__CGen_flush(litaC_this);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    
}

litaC_void litaC_cgen__CGen_emitNotes(litaC_cgen__CGen* litaC_this,litaC_ast__Attributes* litaC_attributes,litaC_bool litaC_isPrelude) {
    if(litaC_std__array__Array_empty_cb__ptr_NoteStmt_ce_(&((litaC_attributes->notes)))) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_isPrelude) {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_attributes->notes)));litaC_i += 1) {
                {
                    litaC_cgen__CGen_emitPreludeNote(litaC_this, litaC_std__array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_attributes->notes)), litaC_i));
                    litaC_cgen__CGen_emitStrn(litaC_this, "\n", 1);
                    
                    
                }
            }
            
            
        }
        
    } else {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(&((litaC_attributes->notes)));litaC_i += 1) {
                {
                    litaC_cgen__CGen_emitPostludeNote(litaC_this, litaC_std__array__Array_get_cb__ptr_NoteStmt_ce_(&((litaC_attributes->notes)), litaC_i));
                    litaC_cgen__CGen_emitStrn(litaC_this, "\n", 1);
                    
                    
                }
            }
            
            
        }
    } 
    
    
}

litaC_void litaC_cgen__CGen_emitPreludeNote(litaC_cgen__CGen* litaC_this,litaC_ast__NoteStmt* litaC_note) {
    if(litaC_intern__InternedString_equals(&((litaC_note->type->name)), &(litaC_intern__INCLUDE))) {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_CallArg_ce_(&((litaC_note->arguments)));litaC_i += 1) {
                {
                    litaC_ast__CallArg litaC_attr = litaC_std__array__Array_get_cb_CallArg_ce_(&((litaC_note->arguments)), litaC_i);
                    if(!(litaC_attr.argExpr)) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__string_view__StringView litaC_value = litaC_attr.argExpr->operand.val.str;
                    if(litaC_value.length > 0 && litaC_value.buffer[0] == '<') {
                        {
                            litaC_cgen__CGen_emit(litaC_this, "#include %.*s\n", litaC_value.length, litaC_value.buffer);
                            
                            
                        }
                        
                    } else {
                        {
                            litaC_cgen__CGen_emit(litaC_this, "#include \"%.*s\"\n", litaC_value.length, litaC_value.buffer);
                            
                            
                        }
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } else {
        if(litaC_intern__InternedString_equals(&((litaC_note->type->name)), &(litaC_intern__RAW))) {
            {
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_CallArg_ce_(&((litaC_note->arguments)));litaC_i += 1) {
                    {
                        litaC_ast__CallArg litaC_attr = litaC_std__array__Array_get_cb_CallArg_ce_(&((litaC_note->arguments)), litaC_i);
                        if(!(litaC_attr.argExpr)) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        litaC_std__string_view__StringView litaC_value = litaC_attr.argExpr->operand.val.str;
                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), litaC_value.buffer, litaC_value.length);
                        
                        
                    }
                }
                
                
            }
            
        } else {
            if(litaC_intern__InternedString_equals(&((litaC_note->type->name)), &(litaC_intern__COMPILER_OPTION))) {
                {
                    litaC_lita__CCompilerOption litaC_ccOption =  {
                        .os = Lita_OSType_OTHER,
                        .arch = Lita_ArchType_UNKNOWN,
                        .options =  {
                            
                        }
                    };
                    litaC_char litaC_temp[_MAX_PATH] = {0};
                    
#define litaC_len (14)
                    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_CallArg_ce_(&((litaC_note->arguments)));litaC_i += 1) {
                        {
                            litaC_ast__CallArg litaC_attr = litaC_std__array__Array_get_cb_CallArg_ce_(&((litaC_note->arguments)), litaC_i);
                            if(!(litaC_attr.argExpr)) {
                                {
                                    continue;
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_std__string_view__StringView litaC_value = litaC_attr.argExpr->operand.val.str;
                            {
                                litaC_i32 litaC_index = litaC_std__string_view__StringView_indexOf(litaC_value, "{relativePath}", litaC_len);
                                if(litaC_index > -(1) && litaC_note->stmt.node.startPos.filename != NULL) {
                                    {
                                        litaC_std__string_buffer__StringBuffer litaC_buffer = litaC_std__string_buffer__StringBufferInit(_MAX_PATH, litaC_this->lita->allocator);
                                        litaC_std__string_buffer__StringBuffer_append(&((litaC_buffer)), "%.*s", litaC_value.length, litaC_value.buffer);
                                        litaC_std__string_buffer__StringBuffer_replace(&((litaC_buffer)), litaC_index, litaC_index + litaC_len, litaC_std__system__FileParent(litaC_note->stmt.node.startPos.filename, litaC_temp, NULL));
                                        litaC_value = litaC_std__string_buffer__StringBuffer_asStringView(&((litaC_buffer)));
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            if(litaC_attr.argName.token.type == litaC_lex__TokenType_IDENTIFIER) {
                                {
                                    if(litaC_intern__InternedString_equalsStr(&((litaC_attr.argName.str)), "os")) {
                                        {
                                            litaC_ccOption.os = litaC_std__system__OSFromStr(litaC_value.buffer, litaC_value.length);
                                            
                                            
                                        }
                                        
                                    } else {
                                        if(litaC_intern__InternedString_equalsStr(&((litaC_attr.argName.str)), "arch")) {
                                            {
                                                litaC_ccOption.arch = litaC_std__system__ArchFromStr(litaC_value.buffer, litaC_value.length);
                                                
                                                
                                            }
                                            
                                        } else {
                                            if(litaC_intern__InternedString_equalsStr(&((litaC_attr.argName.str)), "options")) {
                                                {
                                                    litaC_ccOption.options = litaC_value;
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                        } 
                                        
                                    } 
                                    
                                    
                                    
                                }
                                
                            } else {
                                {
                                    if(litaC_i == 0) {
                                        {
                                            litaC_ccOption.os = litaC_std__system__OSFromStr(litaC_value.buffer, litaC_value.length);
                                            
                                            
                                        }
                                        
                                    } else {
                                        if(litaC_i == 1) {
                                            {
                                                litaC_ccOption.options = litaC_value;
                                                
                                                
                                            }
                                            
                                        } else {
                                            if(litaC_i == 2) {
                                                {
                                                    litaC_ccOption.arch = litaC_std__system__ArchFromStr(litaC_value.buffer, litaC_value.length);
                                                    
                                                    
                                                }
                                                
                                            } 
                                            
                                        } 
                                        
                                    } 
                                    
                                    
                                    
                                }
                            } 
                            
                            
                            
                        }
                    }
                    litaC_std__array__Array_add_cb_CCompilerOption_ce_(&((litaC_this->lita->compilerOptions)), litaC_ccOption);
                    #undef litaC_len
                    
                    
                }
                
            } else {
                if(litaC_intern__InternedString_equals(&((litaC_note->type->name)), &(litaC_intern__INLINE))) {
                    {
                        litaC_cgen__CGen_emitStr(litaC_this, "LITAC_INLINE ");
                        
                        
                    }
                    
                } else {
                    if(litaC_intern__InternedString_equals(&((litaC_note->type->name)), &(litaC_intern__NOINLINE))) {
                        {
                            litaC_cgen__CGen_emitStr(litaC_this, "LITAC_NOINLINE ");
                            
                            
                        }
                        
                    } else {
                        if(litaC_intern__InternedString_equals(&((litaC_note->type->name)), &(litaC_intern__STATIC))) {
                            {
                                litaC_cgen__CGen_emitStr(litaC_this, "static ");
                                
                                
                            }
                            
                        } else {
                            if(litaC_intern__InternedString_equals(&((litaC_note->type->name)), &(litaC_intern__ATOMIC))) {
                                {
                                    litaC_cgen__CGen_emitStr(litaC_this, "_Atomic ");
                                    
                                    
                                }
                                
                            } else {
                                if(litaC_intern__InternedString_equals(&((litaC_note->type->name)), &(litaC_intern__REGISTER))) {
                                    {
                                        litaC_cgen__CGen_emitStr(litaC_this, "register ");
                                        
                                        
                                    }
                                    
                                } else {
                                    if(litaC_intern__InternedString_equals(&((litaC_note->type->name)), &(litaC_intern__THREADLOCAL))) {
                                        {
                                            litaC_cgen__CGen_emitStr(litaC_this, "LITAC_THREADLOCAL ");
                                            
                                            
                                        }
                                        
                                    } else {
                                        if(litaC_intern__InternedString_equals(&((litaC_note->type->name)), &(litaC_intern__EXPORT))) {
                                            {
                                                litaC_cgen__CGen_emitStr(litaC_this, "LITAC_EXPORT ");
                                                
                                                
                                            }
                                            
                                        } else {
                                            if(litaC_intern__InternedString_equals(&((litaC_note->type->name)), &(litaC_intern__PACKED))) {
                                                {
                                                    litaC_cgen__CGen_emitStr(litaC_this, "LITAC_PACKED ");
                                                    
                                                    
                                                }
                                                
                                            } else {
                                                if(litaC_intern__InternedString_equals(&((litaC_note->type->name)), &(litaC_intern__CC))) {
                                                    {
                                                        if(!(litaC_std__array__Array_empty_cb_CallArg_ce_(&((litaC_note->arguments))))) {
                                                            {
                                                                litaC_ast__CallArg litaC_attr = litaC_std__array__Array_get_cb_CallArg_ce_(&((litaC_note->arguments)), 0);
                                                                if(litaC_attr.argExpr) {
                                                                    {
                                                                        litaC_std__string_view__StringView litaC_value = litaC_attr.argExpr->operand.val.str;
                                                                        litaC_cgen__CGen_emitStrn(litaC_this, litaC_value.buffer, litaC_value.length);
                                                                        litaC_cgen__CGen_emitStrn(litaC_this, " ", 1);
                                                                        
                                                                        
                                                                    }
                                                                    
                                                                } 
                                                                
                                                                
                                                                
                                                            }
                                                            
                                                        } 
                                                        
                                                        
                                                        
                                                    }
                                                    
                                                } else {
                                                    if(litaC_intern__InternedString_equals(&((litaC_note->type->name)), &(litaC_intern__CFILE))) {
                                                        {
                                                            
#define litaC_BUFFER_SIZE (1024 * 10)
                                                            litaC_char litaC_filename[_MAX_PATH] =  {
                                                                0
                                                            };
                                                            litaC_std__string__String litaC_filenameStr = litaC_std__string__StringInit(litaC_filename, _MAX_PATH, 0);
                                                            litaC_char litaC_filedata[litaC_BUFFER_SIZE] =  {
                                                                0
                                                            };
                                                            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_CallArg_ce_(&((litaC_note->arguments)));litaC_i += 1) {
                                                                {
                                                                    litaC_ast__CallArg litaC_arg = litaC_std__array__Array_get_cb_CallArg_ce_(&((litaC_note->arguments)), litaC_i);
                                                                    if(!(litaC_arg.argExpr)) {
                                                                        {
                                                                            continue;
                                                                            
                                                                            
                                                                        }
                                                                        
                                                                    } 
                                                                    
                                                                    litaC_std__string_view__StringView litaC_value = litaC_arg.argExpr->operand.val.str;
                                                                    litaC_std__system__FilePath(litaC_note->stmt.node.startPos.filename, litaC_filename);
                                                                    litaC_std__string__String_adjust(&((litaC_filenameStr)));
                                                                    litaC_std__string__String_append(&((litaC_filenameStr)), "/%.*s", litaC_value.length, litaC_value.buffer);
                                                                    if(!(litaC_std__system__FileExists(litaC_std__string__String_cStr(litaC_filenameStr)))) {
                                                                        {
                                                                            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_note->stmt.node.startPos, "unable to locate file: '%.*s'", litaC_value.length, litaC_value.buffer);
                                                                            continue;
                                                                            
                                                                            
                                                                        }
                                                                        
                                                                    } 
                                                                    
                                                                    FILE* litaC_file = fopen(litaC_filename, "r");
                                                                    
                                                                    if(!(litaC_file)) {
                                                                        {
                                                                            litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_note->stmt.node.startPos, "unable to open file: '%s'", litaC_filename);
                                                                            if(litaC_file) {
                                                                                fclose(litaC_file);
                                                                                
                                                                            } 
                                                                            ;
                                                                            continue;
                                                                            
                                                                            
                                                                        }
                                                                        
                                                                    } 
                                                                    
                                                                    litaC_cgen__CGen_flush(litaC_this);
                                                                    litaC_cgen__CGen_emitStrn(litaC_this, "\n", 1);
                                                                    if(!(litaC_this->lita->options->disableLineSync)) {
                                                                        {
                                                                            litaC_cgen__CGen_emit(litaC_this, "#line %d \"%s\"\n", 0, litaC_filename);
                                                                            
                                                                            
                                                                        }
                                                                        
                                                                    } 
                                                                    
                                                                    litaC_i64 litaC_bytesRead = 0L;
                                                                    do {
                                                                        {
                                                                            litaC_bytesRead = fread(litaC_filedata, 1, litaC_BUFFER_SIZE, litaC_file);
                                                                            if(litaC_this->output) {
                                                                                {
                                                                                    litaC_std__io__File_writeBytes(litaC_this->output, litaC_filedata, litaC_bytesRead);
                                                                                    
                                                                                    
                                                                                }
                                                                                
                                                                            } 
                                                                            
                                                                            
                                                                            
                                                                        }
                                                                    }
                                                                    while(litaC_bytesRead > 0);
                                                                    litaC_cgen__CGen_emitStrn(litaC_this, "\n", 1);
                                                                    if(litaC_file) {
                                                                        fclose(litaC_file);
                                                                        
                                                                    } 
                                                                    ;
                                                                    
                                                                    
                                                                }
                                                            }
                                                            #undef litaC_BUFFER_SIZE
                                                            
                                                            
                                                        }
                                                        
                                                    } else {
                                                        if(litaC_intern__InternedString_equals(&((litaC_note->type->name)), &(litaC_intern__CINCLUDE))) {
                                                            {
                                                                
#define litaC_BUFFER_SIZE (1024 * 10)
                                                                litaC_char litaC_filename[_MAX_PATH] =  {
                                                                    0
                                                                };
                                                                litaC_std__string__String litaC_filenameStr = litaC_std__string__StringInit(litaC_filename, _MAX_PATH, 0);
                                                                litaC_char litaC_filedata[litaC_BUFFER_SIZE] =  {
                                                                    0
                                                                };
                                                                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_CallArg_ce_(&((litaC_note->arguments)));litaC_i += 1) {
                                                                    {
                                                                        litaC_ast__CallArg litaC_arg = litaC_std__array__Array_get_cb_CallArg_ce_(&((litaC_note->arguments)), litaC_i);
                                                                        if(!(litaC_arg.argExpr)) {
                                                                            {
                                                                                continue;
                                                                                
                                                                                
                                                                            }
                                                                            
                                                                        } 
                                                                        
                                                                        litaC_std__string_view__StringView litaC_value = litaC_arg.argExpr->operand.val.str;
                                                                        litaC_std__system__FilePath(litaC_note->stmt.node.startPos.filename, litaC_filename);
                                                                        litaC_std__string__String_adjust(&((litaC_filenameStr)));
                                                                        litaC_std__string__String_append(&((litaC_filenameStr)), "/%.*s", litaC_value.length, litaC_value.buffer);
                                                                        if(!(litaC_std__system__FileExists(litaC_std__string__String_cStr(litaC_filenameStr)))) {
                                                                            {
                                                                                litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_note->stmt.node.startPos, "unable to locate file: '%.*s'", litaC_value.length, litaC_value.buffer);
                                                                                continue;
                                                                                
                                                                                
                                                                            }
                                                                            
                                                                        } 
                                                                        
                                                                        if(!(litaC_this->lita->options->disableLineSync)) {
                                                                            {
                                                                                litaC_cgen__CGen_emit(litaC_this, "#line %d \"%s\"\n", 0, litaC_filename);
                                                                                
                                                                                
                                                                            }
                                                                            
                                                                        } 
                                                                        
                                                                        litaC_cgen__CGen_emit(litaC_this, "#include \"%s\"\n", litaC_filename);
                                                                        
                                                                        
                                                                    }
                                                                }
                                                                #undef litaC_BUFFER_SIZE
                                                                
                                                                
                                                            }
                                                            
                                                        } 
                                                        
                                                    } 
                                                    
                                                } 
                                                
                                            } 
                                            
                                        } 
                                        
                                    } 
                                    
                                } 
                                
                            } 
                            
                        } 
                        
                    } 
                    
                } 
                
            } 
            
        } 
        
    } 
    
    
}

litaC_void litaC_cgen__CGen_emitPostludeNote(litaC_cgen__CGen* litaC_this,litaC_ast__NoteStmt* litaC_note) {
    if(litaC_intern__InternedString_equals(&((litaC_note->type->name)), &(litaC_intern__PACKED))) {
        {
            litaC_cgen__CGen_emitStr(litaC_this, " LITAC_PACKED_POP ");
            
            
        }
        
    } 
    
    
}

litaC_void litaC_cgen__CGen_emitFieldName(litaC_cgen__CGen* litaC_this,litaC_ast__FieldStmt litaC_field) {
    assert(litaC_field.kind != litaC_ast__StmtKind_POISON_EXPR);
    litaC_ast__NoteStmt* litaC_alias = litaC_ast__Decl_getNote(&((litaC_field.varField->decl)), "alias");
    if(litaC_alias && litaC_std__array__Array_size_cb_CallArg_ce_(&((litaC_alias->arguments)))) {
        {
            litaC_ast__CallArg litaC_name = litaC_std__array__Array_get_cb_CallArg_ce_(&((litaC_alias->arguments)), 0);
            if(litaC_name.argExpr) {
                {
                    litaC_cgen__CGen_emitNameStr(litaC_this, litaC_name.argExpr->operand.val.str);
                    return;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_cgen__CGen_emitName(litaC_this, litaC_field.varField->decl.name);
    
}

litaC_void litaC_cgen__CGen_emitSymbol(litaC_cgen__CGen* litaC_this,litaC_symbols__Symbol* litaC_sym) {
    if(!(litaC_sym)) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(!((litaC_sym->flags & litaC_symbols__SymbolFlags_IS_USING))) {
        {
            litaC_cgen__CGen_emitStr(litaC_this, litaC_cgen__CGen_cName(litaC_this, litaC_sym));
            return;
            
            
            
        }
        
    } 
    
    litaC_symbols__Symbol* litaC_paramInfo = litaC_sym->usingParent;
    assert(litaC_paramInfo != NULL);
    litaC_types__TypeInfo* litaC_aggType = litaC_types__TypeInfo_getBaseType(litaC_paramInfo->type);
    litaC_cgen__CGen_emitStr(litaC_this, litaC_cgen__CGen_cName(litaC_this, litaC_paramInfo));
    litaC_types__FieldPath litaC_path =  {
        
    };
    litaC_bool litaC_isFound = litaC_types__TypeInfo_getFieldPath(litaC_aggType, litaC_sym->name, &(litaC_path));
    assert(litaC_isFound);
    litaC_types__TypeInfo* litaC_nextType = litaC_paramInfo->type;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_path.numOfFields;litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_path.fields[litaC_i];
            if(litaC_nextType->kind == litaC_types__TypeKind_PTR) {
                {
                    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "->", 2);
                    
                    
                }
                
            } else {
                {
                    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ".", 1);
                    
                    
                }
            } 
            
            litaC_cgen__CGen_emitStrn(litaC_this, litaC_field.varField->decl.name.str.buffer, litaC_field.varField->decl.name.str.length);
            litaC_nextType = litaC_field.typeInfo;
            
            
        }
    }
    
}

litaC_void litaC_cgen__CGen_emitTraitFuncCall(litaC_cgen__CGen* litaC_this,litaC_ast__FuncCallExpr* litaC_expr) {
    switch(litaC_expr->object->stmt.node.kind) {
        case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: {
            {
                litaC_ast__IdentifierExpr* litaC_idExpr = (litaC_ast__IdentifierExpr*)litaC_expr->object;
                litaC_cgen__CGen_emit(litaC_this, "/* something here */");
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GET_EXPR: {
            {
                litaC_ast__GetExpr* litaC_getExpr = (litaC_ast__GetExpr*)litaC_expr->object;
                litaC_types__TypeInfo* litaC_type = litaC_getExpr->object->operand.typeInfo;
                if(litaC_getExpr->object->stmt.node.kind == litaC_ast__StmtKind_IDENTIFIER_EXPR) {
                    {
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_getExpr->object->stmt)));
                        if(litaC_types__IsPtr(litaC_type)) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, "->", 2);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, ".", 1);
                                
                                
                            }
                        } 
                        
                        litaC_cgen__CGen_emitStr(litaC_this, "__vtable->");
                        assert(litaC_types__IsAggregateLike(litaC_type));
                        litaC_types__TypeInfo* litaC_aggInfo = litaC_types__AsAggregate(litaC_type);
                        litaC_ast__FieldStmt litaC_field = litaC_types__TypeInfo_getField(litaC_aggInfo, litaC_getExpr->field->type->name);
                        litaC_cgen__CGen_emitFieldName(litaC_this, litaC_field);
                        litaC_cgen__CGen_emitStrn(litaC_this, "(", 1);
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_getExpr->object->stmt)));
                        if(litaC_types__IsPtr(litaC_type)) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, "->", 2);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, ".", 1);
                                
                                
                            }
                        } 
                        
                        litaC_cgen__CGen_emitStrn(litaC_this, "__this", 6);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_char litaC_buffer[256] = {0};
                        const litaC_char* litaC_tmpName = litaC_cgen__CGen_allocTemp(litaC_this, litaC_type, litaC_buffer);
                        litaC_cgen__CGen_emit(litaC_this, "(%s = ", litaC_tmpName);
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_getExpr->object->stmt)));
                        litaC_cgen__CGen_emit(litaC_this, ", %s", litaC_tmpName);
                        if(litaC_types__IsPtr(litaC_type)) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, "->", 2);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, ".", 1);
                                
                                
                            }
                        } 
                        
                        litaC_cgen__CGen_emitStrn(litaC_this, "__vtable)->", 11);
                        assert(litaC_types__IsAggregateLike(litaC_type));
                        litaC_types__TypeInfo* litaC_aggInfo = litaC_types__AsAggregate(litaC_type);
                        litaC_ast__FieldStmt litaC_field = litaC_types__TypeInfo_getField(litaC_aggInfo, litaC_getExpr->field->type->name);
                        litaC_cgen__CGen_emitFieldName(litaC_this, litaC_field);
                        litaC_cgen__CGen_emit(litaC_this, "(%s", litaC_tmpName);
                        if(litaC_types__IsPtr(litaC_type)) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, "->", 2);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, ".", 1);
                                
                                
                            }
                        } 
                        
                        litaC_cgen__CGen_emitStrn(litaC_this, "__this", 6);
                        
                        
                    }
                } 
                
                if(litaC_std__array__Array_size_cb_CallArg_ce_(&((litaC_expr->arguments))) > 0) {
                    {
                        litaC_cgen__CGen_emitStrn(litaC_this, ", ", 2);
                        
                        
                    }
                    
                } 
                
                break;
                
                
            }
            
            
        }
        default: {
            {
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    
}

litaC_void litaC_cgen__CGen_emitStaticCompStmt(litaC_cgen__CGen* litaC_this,litaC_ast__CompStmt* litaC_s) {
    if(!(litaC_s->isStatic)) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_intern__InternedString_equals(&((litaC_s->type)), &((litaC_intern__STATIC_IF)))) {
        {
            litaC_cgen__CGen_emitStrn(litaC_this, "\n#if", 4);
            litaC_cgen__CGen_emit(litaC_this, " %.*s\n", litaC_s->expr.length, litaC_s->expr.buffer);
            
            
        }
        
    } else {
        if(litaC_intern__InternedString_equals(&((litaC_s->type)), &((litaC_intern__ELSEIF)))) {
            {
                litaC_cgen__CGen_emitStrn(litaC_this, "\n#elif", 6);
                litaC_cgen__CGen_emit(litaC_this, " %.*s\n", litaC_s->expr.length, litaC_s->expr.buffer);
                
                
            }
            
        } else {
            if(litaC_intern__InternedString_equals(&((litaC_s->type)), &((litaC_intern__ELSE)))) {
                {
                    litaC_cgen__CGen_emitStrn(litaC_this, "\n#else\n", 7);
                    
                    
                }
                
            } else {
                if(litaC_intern__InternedString_equals(&((litaC_s->type)), &((litaC_intern__END)))) {
                    {
                        litaC_cgen__CGen_emitStrn(litaC_this, "\n#endif\n", 8);
                        
                        
                    }
                    
                } 
                
            } 
            
        } 
        
    } 
    
    {
        litaC_cgen__CGen_pushScope(litaC_this, &((litaC_cgen__CGenScope) {
            
        }));
        
        litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_stmts = litaC_s->body;
        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Stmt_ce_(&((litaC_stmts)));litaC_i += 1) {
            {
                litaC_ast__Stmt* litaC_n = litaC_std__array__Array_get_cb__ptr_Stmt_ce_(&((litaC_stmts)), litaC_i);
                litaC_cgen__CGen_emitStmt(litaC_this, litaC_n);
                if(litaC_ast__IsExpr(&((litaC_n->node)))) {
                    {
                        litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_cgen__CGen_emitStrn(litaC_this, "\n", 1);
                        
                        
                    }
                } 
                
                
                
            }
        }
        litaC_cgen__CGen_popScope(litaC_this);
        
        
    }
    if(litaC_s->end) {
        {
            litaC_cgen__CGen_emitStaticCompStmt(litaC_this, litaC_s->end);
            
            
        }
        
    } 
    
    
}

litaC_void litaC_cgen__CGen_emitStmt(litaC_cgen__CGen* litaC_this,litaC_ast__Stmt* litaC_s) {
    if(!(litaC_s)) {
        return;
        
        
    } 
    
    litaC_cgen__CGen_emitLineInfo(litaC_this, litaC_s);
    switch(litaC_s->node.kind) {
        case litaC_ast__StmtKind_IMPORT_DECL: {
            {
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONST_DECL: 
        case litaC_ast__StmtKind_VAR_DECL: {
            {
                litaC_ast__VarDecl* litaC_decl = (litaC_ast__VarDecl*)litaC_s;
                litaC_cgen_decl__CGen_emitVarDecl(litaC_this, litaC_decl);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TRAIT_DECL: 
        case litaC_ast__StmtKind_UNION_DECL: 
        case litaC_ast__StmtKind_STRUCT_DECL: {
            {
                litaC_ast__AggregateDecl* litaC_decl = (litaC_ast__AggregateDecl*)litaC_s;
                litaC_cgen_decl__CGen_emitAggregateDecl(litaC_this, litaC_decl);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: {
            {
                litaC_ast__EnumDecl* litaC_decl = (litaC_ast__EnumDecl*)litaC_s;
                litaC_cgen_decl__CGen_emitEnumDecl(litaC_this, litaC_decl);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            {
                litaC_ast__FuncDecl* litaC_decl = (litaC_ast__FuncDecl*)litaC_s;
                litaC_cgen_decl__CGen_emitFuncDecl(litaC_this, litaC_decl);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            {
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAM_DECL: {
            {
                assert(litaC_false);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NATIVE_DECL: {
            {
                assert(litaC_false);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_DECL: {
            {
                assert(litaC_false);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BLOCK_STMT: {
            {
                litaC_ast__BlockStmt* litaC_stmt = (litaC_ast__BlockStmt*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "{", 1);
                {
                    litaC_cgen__CGen_pushScope(litaC_this, &((litaC_cgen__CGenScope) {
                        
                    }));
                    
                    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)));litaC_i += 1) {
                        {
                            litaC_ast__Stmt* litaC_n = litaC_std__array__Array_get_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)), litaC_i);
                            litaC_cgen__CGen_emitStmt(litaC_this, litaC_n);
                            if(litaC_ast__IsExpr(&((litaC_n->node)))) {
                                {
                                    litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                                    
                                    
                                }
                                
                            } else {
                                {
                                    litaC_cgen__CGen_emitStrn(litaC_this, "\n", 1);
                                    
                                    
                                }
                            } 
                            
                            
                            
                        }
                    }
                    litaC_cgen__CGen_popScope(litaC_this);
                    
                    
                }
                litaC_cgen__CGen_emitStrn(litaC_this, "\n}", 2);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BREAK_STMT: {
            {
                litaC_cgen__CGen_popLoopScope(litaC_this, litaC_true);
                litaC_cgen__CGen_emitStrn(litaC_this, "break;", 6);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_COMP_STMT: {
            {
                litaC_ast__CompStmt* litaC_stmt = (litaC_ast__CompStmt*)litaC_s;
                if(litaC_stmt->isStatic) {
                    {
                        litaC_cgen__CGen_emitStaticCompStmt(litaC_this, litaC_stmt);
                        return;
                        
                        
                        
                    }
                    
                } 
                
                litaC_ast__Stmt* litaC_result = litaC_stmt->evaluatedStmt;
                if(litaC_result) {
                    {
                        litaC_cgen__CGen_emitStmt(litaC_this, litaC_result);
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CONTINUE_STMT: {
            {
                litaC_cgen__CGen_popLoopScope(litaC_this, litaC_false);
                litaC_cgen__CGen_emitStrn(litaC_this, "continue;", 9);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DEFER_STMT: {
            {
                litaC_ast__DeferStmt* litaC_stmt = (litaC_ast__DeferStmt*)litaC_s;
                if(litaC_std__array__Array_empty_cb__ptr_Stmt_ce_(&((litaC_this->currentScope->defers)))) {
                    {
                        litaC_std__array__Array_init_cb__ptr_Stmt_ce_(&((litaC_this->currentScope->defers)), 16, litaC_this->lita->allocator);
                        
                        
                    }
                    
                } 
                
                litaC_std__array__Array_add_cb__ptr_Stmt_ce_(&((litaC_this->currentScope->defers)), litaC_stmt->deferedStmt);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_DO_WHILE_STMT: {
            {
                litaC_ast__DoWhileStmt* litaC_stmt = (litaC_ast__DoWhileStmt*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "do {", 4);
                {
                    litaC_cgen__CGen_pushScope(litaC_this, &((litaC_cgen__CGenScope) {
                        .isLoop = litaC_true
                    }));
                    
                    litaC_cgen__CGen_emitStmt(litaC_this, litaC_stmt->body);
                    if(litaC_ast__IsExpr(&((litaC_stmt->body->node)))) {
                        {
                            litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                            
                            
                        }
                        
                    } 
                    
                    litaC_cgen__CGen_popScope(litaC_this);
                    
                    
                }
                litaC_cgen__CGen_emitStrn(litaC_this, "}\nwhile(", 8);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_stmt->cond->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, ");", 2);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_EMPTY_STMT: {
            {
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ENUM_FIELD_ENTRY_DECL: {
            {
                assert(litaC_false);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FOR_STMT: {
            {
                litaC_ast__ForStmt* litaC_stmt = (litaC_ast__ForStmt*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "for(", 4);
                if(litaC_stmt->init) {
                    {
                        litaC_cgen__CGen_emitStmt(litaC_this, litaC_stmt->init);
                        if(litaC_ast__IsExpr(&((litaC_stmt->init->node)))) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } else {
                    {
                        litaC_cgen__CGen_emitStrn(litaC_this, ";", 1);
                        
                        
                    }
                } 
                
                if(litaC_stmt->cond) {
                    {
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_stmt->cond->stmt)));
                        
                        
                    }
                    
                } 
                
                litaC_cgen__CGen_emitStrn(litaC_this, ";", 1);
                if(litaC_stmt->post) {
                    {
                        litaC_cgen__CGen_emitStmt(litaC_this, litaC_stmt->post);
                        
                        
                    }
                    
                } 
                
                litaC_cgen__CGen_emitStrn(litaC_this, ") {", 3);
                if(litaC_stmt->body) {
                    {
                        litaC_cgen__CGen_pushScope(litaC_this, &((litaC_cgen__CGenScope) {
                            .isLoop = litaC_true
                        }));
                        
                        litaC_cgen__CGen_emitStmt(litaC_this, litaC_stmt->body);
                        if(litaC_ast__IsExpr(&((litaC_stmt->body->node)))) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                                
                                
                            }
                            
                        } 
                        
                        litaC_cgen__CGen_popScope(litaC_this);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_cgen__CGen_emitStrn(litaC_this, ";", 1);
                        
                        
                    }
                } 
                
                litaC_cgen__CGen_emitStrn(litaC_this, "}", 1);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_BODY_STMT: {
            {
                litaC_ast__FuncBodyStmt* litaC_stmt = (litaC_ast__FuncBodyStmt*)litaC_s;
                litaC_cgen__CGen_pushScope(litaC_this, &((litaC_cgen__CGenScope) {
                    
                }));
                
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)));litaC_i += 1) {
                    {
                        litaC_ast__Stmt* litaC_n = litaC_std__array__Array_get_cb__ptr_Stmt_ce_(&((litaC_stmt->stmts)), litaC_i);
                        litaC_cgen__CGen_emitStmt(litaC_this, litaC_n);
                        if(litaC_ast__IsExpr(&((litaC_n->node)))) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, "\n", 1);
                                
                                
                            }
                        } 
                        
                        
                        
                    }
                }
                litaC_cgen__CGen_popScope(litaC_this);
                return;
                
                litaC_cgen__CGen_popScope(litaC_this);
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GOTO_STMT: {
            {
                litaC_ast__GotoStmt* litaC_stmt = (litaC_ast__GotoStmt*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "goto ", 5);
                litaC_cgen__CGen_emitName(litaC_this, litaC_stmt->label);
                litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IF_STMT: {
            {
                litaC_ast__IfStmt* litaC_stmt = (litaC_ast__IfStmt*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "if(", 3);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_stmt->cond->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, ") {", 3);
                {
                    litaC_cgen__CGen_pushScope(litaC_this, &((litaC_cgen__CGenScope) {
                        
                    }));
                    
                    litaC_cgen__CGen_emitStmt(litaC_this, litaC_stmt->then);
                    if(litaC_ast__IsExpr(&((litaC_stmt->then->node)))) {
                        {
                            litaC_cgen__CGen_emitStrn(litaC_this, ";", 1);
                            
                            
                        }
                        
                    } 
                    
                    litaC_cgen__CGen_emitStrn(litaC_this, "\n", 1);
                    litaC_cgen__CGen_popScope(litaC_this);
                    
                    
                }
                litaC_cgen__CGen_emitStrn(litaC_this, "} ", 2);
                if(litaC_stmt->elseStmt) {
                    {
                        litaC_cgen__CGen_emitStrn(litaC_this, "else {", 6);
                        {
                            litaC_cgen__CGen_pushScope(litaC_this, &((litaC_cgen__CGenScope) {
                                
                            }));
                            
                            litaC_cgen__CGen_emitStmt(litaC_this, litaC_stmt->elseStmt);
                            if(litaC_ast__IsExpr(&((litaC_stmt->elseStmt->node)))) {
                                {
                                    litaC_cgen__CGen_emitStrn(litaC_this, ";", 1);
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_cgen__CGen_popScope(litaC_this);
                            
                            
                        }
                        litaC_cgen__CGen_emitStrn(litaC_this, "} ", 2);
                        
                        
                    }
                    
                } 
                
                litaC_cgen__CGen_emitStrn(litaC_this, "\n", 1);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_LABEL_STMT: {
            {
                litaC_ast__LabelStmt* litaC_stmt = (litaC_ast__LabelStmt*)litaC_s;
                litaC_cgen__CGen_emitName(litaC_this, litaC_stmt->label);
                litaC_cgen__CGen_emitStrn(litaC_this, ":;\n", 3);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_MODULE_STMT: {
            {
                assert(litaC_false);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NOTE_STMT: {
            {
                assert(litaC_false);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_PARAMETERS_STMT: {
            {
                assert(litaC_false);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_RETURN_STMT: {
            {
                litaC_ast__ReturnStmt* litaC_stmt = (litaC_ast__ReturnStmt*)litaC_s;
                if(litaC_stmt->expr && litaC_stmt->expr->operand.typeInfo != &(litaC_types__VOID_TYPE) && litaC_cgen__CGen_hasPendingDefers(litaC_this)) {
                    {
                        assert(litaC_this->currentFunc != NULL);
                        litaC_cgen__CGen_emit(litaC_this, "{%s = ", litaC_cgen__CGen_cTypeDecl(litaC_this, litaC_this->currentFunc->returnType, "___result", litaC_false));
                        if(!(litaC_cgen__CGen_emitTraitCast(litaC_this, litaC_stmt->expr))) {
                            {
                                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_stmt->expr->stmt)));
                                
                                
                            }
                            
                        } 
                        
                        litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                        litaC_cgen__CGen_emitDefers(litaC_this);
                        litaC_cgen__CGen_emitStr(litaC_this, "return ___result;\n}\n");
                        
                        
                    }
                    
                } else {
                    {
                        litaC_cgen__CGen_emitDefers(litaC_this);
                        litaC_cgen__CGen_emitStrn(litaC_this, "return", 6);
                        if(litaC_stmt->expr) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, " ", 1);
                                if(!(litaC_cgen__CGen_emitTraitCast(litaC_this, litaC_stmt->expr))) {
                                    {
                                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_stmt->expr->stmt)));
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                        
                        
                    }
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SWITCH_CASE_STMT: {
            {
                litaC_ast__SwitchCaseStmt* litaC_stmt = (litaC_ast__SwitchCaseStmt*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "case ", 5);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_stmt->cond->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, ": ", 2);
                litaC_cgen__CGen_emitStmt(litaC_this, litaC_stmt->body);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SWITCH_STMT: {
            {
                litaC_ast__SwitchStmt* litaC_stmt = (litaC_ast__SwitchStmt*)litaC_s;
                litaC_cgen__CGen_pushScope(litaC_this, &((litaC_cgen__CGenScope) {
                    .isSwitch = litaC_true
                }));
                
                litaC_cgen__CGen_emitStrn(litaC_this, "switch(", 7);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_stmt->cond->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, ") {", 3);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_SwitchCaseStmt_ce_(&((litaC_stmt->cases)));litaC_i += 1) {
                    {
                        if(litaC_i > 0) {
                            litaC_cgen__CGen_emitln(litaC_this);
                            
                        } 
                        
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_std__array__Array_get_cb__ptr_SwitchCaseStmt_ce_(&((litaC_stmt->cases)), litaC_i)->stmt)));
                        
                        
                    }
                }
                if(litaC_stmt->defaultStmt) {
                    {
                        litaC_cgen__CGen_emitStrn(litaC_this, "\ndefault: ", 10);
                        litaC_cgen__CGen_emitStmt(litaC_this, litaC_stmt->defaultStmt);
                        
                        
                    }
                    
                } 
                
                litaC_cgen__CGen_emitStrn(litaC_this, "}", 1);
                litaC_cgen__CGen_popScope(litaC_this);
                return;
                
                litaC_cgen__CGen_popScope(litaC_this);
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
            {
                litaC_ast__TraitFieldDecl* litaC_decl = (litaC_ast__TraitFieldDecl*)litaC_s;
                litaC_cgen__CGen_emitLineInfo(litaC_this, &((litaC_decl->decl.stmt)));
                litaC_cgen__CGen_emitNotes(litaC_this, &(litaC_decl->decl.attributes), litaC_true);
                litaC_char litaC_name[256] = {0};
                litaC_std__string__String litaC_nameStr = litaC_std__string__StringInit(litaC_name, litaC_symbols__MAX_SYMBOL_NAME, 0);
                litaC_std__string__String_setStrn(&((litaC_nameStr)), litaC_decl->decl.name.str.buffer, litaC_decl->decl.name.str.length);
                litaC_ast__NoteStmt* litaC_aliasNote = litaC_ast__Decl_getNote(&((litaC_decl->decl)), "alias");
                if(litaC_aliasNote && !(litaC_std__array__Array_empty_cb_CallArg_ce_(&((litaC_aliasNote->arguments))))) {
                    {
                        litaC_ast__CallArg litaC_aliasName = litaC_std__array__Array_get_cb_CallArg_ce_(&((litaC_aliasNote->arguments)), 0);
                        if(litaC_aliasName.argExpr) {
                            {
                                litaC_std__string_view__StringView litaC_value = litaC_aliasName.argExpr->operand.val.str;
                                litaC_std__string__String_clear(&((litaC_nameStr)));
                                litaC_std__string__String_setStrn(&((litaC_nameStr)), litaC_value.buffer, litaC_value.length);
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                litaC_cgen__CGen_emitStr(litaC_this, litaC_cgen__CGen_cTypeDecl(litaC_this, litaC_decl->type->typeInfo, litaC_std__string__String_cStrConst(litaC_nameStr), litaC_false));
                litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_VAR_FIELD_DECL: {
            {
                litaC_ast__VarFieldDecl* litaC_decl = (litaC_ast__VarFieldDecl*)litaC_s;
                litaC_cgen__CGen_emitLineInfo(litaC_this, &((litaC_decl->decl.stmt)));
                litaC_cgen__CGen_emitNotes(litaC_this, &(litaC_decl->decl.attributes), litaC_true);
                litaC_char litaC_name[256] = {0};
                litaC_std__string__String litaC_nameStr = litaC_std__string__StringInit(litaC_name, litaC_symbols__MAX_SYMBOL_NAME, 0);
                litaC_std__string__String_setStrn(&((litaC_nameStr)), litaC_decl->decl.name.str.buffer, litaC_decl->decl.name.str.length);
                litaC_ast__NoteStmt* litaC_aliasNote = litaC_ast__Decl_getNote(&((litaC_decl->decl)), "alias");
                if(litaC_aliasNote && !(litaC_std__array__Array_empty_cb_CallArg_ce_(&((litaC_aliasNote->arguments))))) {
                    {
                        litaC_ast__CallArg litaC_aliasName = litaC_std__array__Array_get_cb_CallArg_ce_(&((litaC_aliasNote->arguments)), 0);
                        if(litaC_aliasName.argExpr) {
                            {
                                litaC_std__string_view__StringView litaC_value = litaC_aliasName.argExpr->operand.val.str;
                                litaC_std__string__String_clear(&((litaC_nameStr)));
                                litaC_std__string__String_setStrn(&((litaC_nameStr)), litaC_value.buffer, litaC_value.length);
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                litaC_cgen__CGen_emitStr(litaC_this, litaC_cgen__CGen_cTypeDecl(litaC_this, litaC_decl->type->typeInfo, litaC_std__string__String_cStrConst(litaC_nameStr), litaC_false));
                litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_WHILE_STMT: {
            {
                litaC_ast__WhileStmt* litaC_stmt = (litaC_ast__WhileStmt*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "while(", 6);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_stmt->cond->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, ") {", 3);
                {
                    litaC_cgen__CGen_pushScope(litaC_this, &((litaC_cgen__CGenScope) {
                        .isLoop = litaC_true
                    }));
                    
                    litaC_cgen__CGen_emitStmt(litaC_this, litaC_stmt->body);
                    if(litaC_ast__IsExpr(&((litaC_stmt->body->node)))) {
                        {
                            litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
                            
                            
                        }
                        
                    } 
                    
                    litaC_cgen__CGen_popScope(litaC_this);
                    
                    
                }
                litaC_cgen__CGen_emitStrn(litaC_this, "}", 1);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR: {
            {
                litaC_ast__ArrayDesignationExpr* litaC_expr = (litaC_ast__ArrayDesignationExpr*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "[", 1);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->index->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, "] = ", 4);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->value->stmt)));
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_ARRAY_INIT_EXPR: {
            {
                litaC_ast__ArrayInitExpr* litaC_expr = (litaC_ast__ArrayInitExpr*)litaC_s;
                if(litaC_false && litaC_std__array__Array_empty_cb__ptr_Expr_ce_(&((litaC_expr->values)))) {
                    {
                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "{}", 2);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_bool litaC_requiresCast = litaC_false;
                        if(litaC_expr->expr.stmt.node.parent) {
                            {
                                litaC_requiresCast = litaC_expr->expr.stmt.node.parent->kind == litaC_ast__StmtKind_RETURN_STMT || litaC_expr->expr.stmt.node.parent->kind == litaC_ast__StmtKind_FUNC_CALL_EXPR;
                                
                                
                            }
                            
                        } 
                        
                        if(litaC_requiresCast || !(litaC_expr->expr.expectedType) || litaC_expr->expr.expectedType->kind == litaC_types__TypeKind_PTR) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, "(", 1);
                                litaC_cgen__CGen_emitStr(litaC_this, litaC_cgen__CGen_cType(litaC_this, litaC_expr->type->typeInfo, litaC_false, litaC_false));
                                litaC_cgen__CGen_emitStrn(litaC_this, ")", 1);
                                
                                
                            }
                            
                        } 
                        
                        litaC_cgen__CGen_emitStrn(litaC_this, " {", 2);
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Expr_ce_(&((litaC_expr->values)));litaC_i += 1) {
                            {
                                if(litaC_i > 0) {
                                    {
                                        litaC_cgen__CGen_emitStrn(litaC_this, ",\n", 2);
                                        
                                        
                                    }
                                    
                                } 
                                
                                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_std__array__Array_get_cb__ptr_Expr_ce_(&((litaC_expr->values)), litaC_i)->stmt)));
                                
                                
                            }
                        }
                        litaC_cgen__CGen_emitStrn(litaC_this, "}", 1);
                        
                        
                    }
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BINARY_EXPR: {
            {
                litaC_ast__BinaryExpr* litaC_expr = (litaC_ast__BinaryExpr*)litaC_s;
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->left->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, " ", 1);
                litaC_cgen__CGen_emitStr(litaC_this, litaC_lex__tokenText[litaC_expr->operator]);
                litaC_cgen__CGen_emitStrn(litaC_this, " ", 1);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->right->stmt)));
                break;
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_BOOLEAN_EXPR: {
            {
                litaC_ast__BooleanExpr* litaC_expr = (litaC_ast__BooleanExpr*)litaC_s;
                litaC_cgen__CGen_emitStr(litaC_this, litaC_this->lita->options->cPrefix);
                if(litaC_expr->boolean) {
                    {
                        litaC_cgen__CGen_emitStrn(litaC_this, "true", 4);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_cgen__CGen_emitStrn(litaC_this, "false", 5);
                        
                        
                    }
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CAST_EXPR: {
            {
                litaC_ast__CastExpr* litaC_expr = (litaC_ast__CastExpr*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "(", 1);
                litaC_cgen__CGen_emitStr(litaC_this, litaC_cgen__CGen_cType(litaC_this, litaC_expr->castTo->typeInfo, litaC_true, litaC_false));
                litaC_cgen__CGen_emitStrn(litaC_this, ")", 1);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->exprToCast->stmt)));
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_CHAR_EXPR: {
            {
                litaC_ast__CharExpr* litaC_expr = (litaC_ast__CharExpr*)litaC_s;
                litaC_i64 litaC_value = litaC_expr->character.value.intValue;
                if(litaC_value < 256 && litaC_value >= 0) {
                    {
                        const litaC_char* litaC_c = litaC_cgen__escapeStrings[litaC_value];
                        if(litaC_c != 0) {
                            {
                                litaC_std__string_buffer__StringBuffer_append(&((litaC_this->buf)), "'%s'", litaC_c);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_std__string_buffer__StringBuffer_append(&((litaC_this->buf)), "'%c'", (litaC_char)litaC_value);
                                
                                
                            }
                        } 
                        
                        
                        
                    }
                    
                } else {
                    {
                        litaC_std__string_buffer__StringBuffer_append(&((litaC_this->buf)), "%d", litaC_value);
                        
                        
                    }
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_FUNC_CALL_EXPR: {
            {
                litaC_ast__FuncCallExpr* litaC_expr = (litaC_ast__FuncCallExpr*)litaC_s;
                litaC_types__TypeInfo* litaC_objectType = litaC_expr->object->operand.typeInfo;
                litaC_bool litaC_isTrait = litaC_false;
                if(litaC_objectType->kind == litaC_types__TypeKind_FUNC_PTR) {
                    {
                        litaC_types__TypeInfo* litaC_funcPtr = litaC_objectType;
                        if(litaC_funcPtr->isTrait) {
                            {
                                litaC_isTrait = litaC_true;
                                litaC_cgen__CGen_emitTraitFuncCall(litaC_this, litaC_expr);
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_isTrait)) {
                    {
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->object->stmt)));
                        litaC_cgen__CGen_emitStrn(litaC_this, "(", 1);
                        
                        
                    }
                    
                } 
                
                litaC_lex__SrcPos litaC_startPos = litaC_expr->expr.stmt.node.startPos;
                litaC_i32 litaC_i = 0;
                for(;litaC_i < litaC_std__array__Array_size_cb_CallArg_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
                    {
                        if(litaC_i > 0) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, ", ", 2);
                                
                                
                            }
                            
                        } 
                        
                        litaC_ast__CallArg litaC_arg = litaC_std__array__Array_get_cb_CallArg_ce_(&((litaC_expr->arguments)), litaC_i);
                        if(!(litaC_arg.argExpr)) {
                            {
                                continue;
                                
                                
                            }
                            
                        } 
                        
                        if(!(litaC_cgen__CGen_emitTraitCast(litaC_this, litaC_arg.argExpr))) {
                            {
                                if(litaC_arg.isDefault) {
                                    {
                                        litaC_lex__SrcPos litaC_oldPos = litaC_arg.argExpr->stmt.node.startPos;
                                        
                                        litaC_arg.argExpr->stmt.node.startPos.filename = litaC_startPos.filename;
                                        litaC_arg.argExpr->stmt.node.startPos.lineNumber = litaC_startPos.lineNumber;
                                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_arg.argExpr->stmt)));
                                        litaC_arg.argExpr->stmt.node.startPos = litaC_oldPos;
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_arg.argExpr->stmt)));
                                        litaC_startPos = litaC_arg.argExpr->stmt.node.startPos;
                                        
                                        
                                    }
                                } 
                                
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                }
                if(litaC_objectType->kind == litaC_types__TypeKind_FUNC) {
                    {
                        litaC_types__TypeInfo* litaC_funcType = litaC_objectType;
                        for(;litaC_i < litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcType->funcDecl->params->params)));litaC_i += 1) {
                            {
                                litaC_ast__ParameterDecl* litaC_param = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcType->funcDecl->params->params)), litaC_i);
                                if(litaC_param->defaultExpr) {
                                    {
                                        if(litaC_i > 0) {
                                            {
                                                litaC_cgen__CGen_emitStrn(litaC_this, ", ", 2);
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_param->defaultExpr->stmt)));
                                        
                                        
                                    }
                                    
                                } 
                                
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                litaC_cgen__CGen_emitStrn(litaC_this, ")", 1);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: 
        case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: {
            {
                litaC_ast__IdentifierExpr* litaC_expr = (litaC_ast__IdentifierExpr*)litaC_s;
                litaC_types__TypeInfo* litaC_type = litaC_expr->type->typeInfo;
                litaC_symbols__Symbol* litaC_sym = ((litaC_type)) ? litaC_type->sym : litaC_expr->sym;
                if(!(litaC_sym)) {
                    {
                        litaC_cgen__CGen_emitStr(litaC_this, litaC_this->lita->options->cPrefix);
                        litaC_cgen__CGen_emitStrn(litaC_this, litaC_expr->type->name.buffer, litaC_expr->type->name.length);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_cgen__CGen_emitSymbol(litaC_this, litaC_sym);
                        
                        
                    }
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GET_EXPR: {
            {
                litaC_ast__GetExpr* litaC_expr = (litaC_ast__GetExpr*)litaC_s;
                if(litaC_expr->flags & litaC_ast__GetExprFlags_IS_METHOD_CALL) {
                    {
                        litaC_cgen__CGen_emitStr(litaC_this, litaC_cgen__CGen_cTypeName(litaC_this, litaC_expr->field->expr.operand.typeInfo));
                        return;
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__TypeInfo* litaC_objectType = litaC_expr->object->operand.typeInfo;
                if(litaC_expr->flags & litaC_ast__GetExprFlags_IS_ENUM) {
                    {
                        if(litaC_objectType->sym && litaC_objectType->sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN) {
                            {
                                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), litaC_expr->field->type->name.buffer, litaC_expr->field->type->name.length);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), litaC_cgen__CGen_cName(litaC_this, litaC_objectType->sym));
                                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "_", 1);
                                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), litaC_expr->field->type->name.buffer, litaC_expr->field->type->name.length);
                                
                                
                            }
                        } 
                        
                        return;
                        
                        
                        
                    }
                    
                } 
                
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->object->stmt)));
                if(!(litaC_types__IsAggregateLike(litaC_objectType))) {
                    {
                        if(litaC_objectType->kind == litaC_types__TypeKind_PTR) {
                            {
                                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "->", 2);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ".", 1);
                                
                                
                            }
                        } 
                        
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->field->expr.stmt)));
                        return;
                        
                        
                        
                    }
                    
                } 
                
                litaC_types__TypeInfo* litaC_baseInfo = litaC_types__TypeInfo_getBaseType(litaC_objectType);
                assert(litaC_baseInfo != NULL);
                assert(litaC_types__IsAggregate(litaC_baseInfo));
                litaC_types__TypeInfo* litaC_aggInfo = litaC_baseInfo;
                if(litaC_expr->flags & litaC_ast__GetExprFlags_IS_USING) {
                    {
                        litaC_types__FieldPath litaC_path =  {
                            
                        };
                        litaC_bool litaC_isFound = litaC_types__TypeInfo_getFieldPath(litaC_aggInfo, litaC_expr->field->type->name, &(litaC_path));
                        assert(litaC_isFound);
                        litaC_types__TypeInfo* litaC_nextType = litaC_objectType;
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_path.numOfFields;litaC_i += 1) {
                            {
                                litaC_ast__FieldStmt litaC_field = litaC_path.fields[litaC_i];
                                if(litaC_nextType->kind == litaC_types__TypeKind_PTR) {
                                    {
                                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "->", 2);
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ".", 1);
                                        
                                        
                                    }
                                } 
                                
                                litaC_cgen__CGen_emitFieldName(litaC_this, litaC_field);
                                litaC_nextType = litaC_field.typeInfo;
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } else {
                    {
                        if(litaC_objectType->kind == litaC_types__TypeKind_PTR) {
                            {
                                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "->", 2);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ".", 1);
                                
                                
                            }
                        } 
                        
                        litaC_ast__FieldStmt litaC_field = litaC_types__TypeInfo_getField(litaC_aggInfo, litaC_expr->field->type->name);
                        if(litaC_baseInfo->kind == litaC_types__TypeKind_TRAIT) {
                            {
                                litaC_cgen__CGen_emit(litaC_this, "__vtable->");
                                
                                
                            }
                            
                        } 
                        
                        litaC_cgen__CGen_emitFieldName(litaC_this, litaC_field);
                        
                        
                    }
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_GROUP_EXPR: {
            {
                litaC_ast__GroupExpr* litaC_expr = (litaC_ast__GroupExpr*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "(", 1);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->groupedExpr->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, ")", 1);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_INIT_ARG_EXPR: {
            {
                litaC_ast__InitArgExpr* litaC_expr = (litaC_ast__InitArgExpr*)litaC_s;
                if(litaC_expr->fieldName.token.type == litaC_lex__TokenType_IDENTIFIER) {
                    {
                        litaC_ast__Node* litaC_parentExpr = litaC_expr->expr.stmt.node.parent;
                        assert(litaC_parentExpr && litaC_parentExpr->kind == litaC_ast__StmtKind_INIT_EXPR);
                        litaC_types__TypeInfo* litaC_objectType = ((litaC_ast__InitExpr*)litaC_parentExpr)->type->typeInfo;
                        assert(litaC_objectType != NULL);
                        assert(litaC_types__IsAggregateLike(litaC_objectType));
                        litaC_types__TypeInfo* litaC_baseInfo = litaC_types__TypeInfo_getBaseType(litaC_objectType);
                        assert(litaC_baseInfo != NULL);
                        assert(litaC_baseInfo->kind == litaC_types__TypeKind_STRUCT || litaC_baseInfo->kind == litaC_types__TypeKind_UNION);
                        litaC_types__TypeInfo* litaC_aggInfo = litaC_baseInfo;
                        litaC_ast__FieldStmt litaC_field = litaC_types__TypeInfo_getField(litaC_aggInfo, litaC_expr->fieldName.str);
                        if(litaC_field.kind == litaC_ast__StmtKind_VAR_FIELD_DECL) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, ".", 1);
                                litaC_cgen__CGen_emitFieldName(litaC_this, litaC_field);
                                litaC_cgen__CGen_emitStrn(litaC_this, " = ", 3);
                                
                                
                            }
                            
                        } else {
                            if(litaC_field.kind == litaC_ast__StmtKind_STRUCT_FIELD_DECL || litaC_field.kind == litaC_ast__StmtKind_UNION_FIELD_DECL) {
                                {
                                    litaC_ast__AggregateDecl* litaC_decl = litaC_field.aggregateField;
                                    litaC_cgen__CGen_emitStrn(litaC_this, ".", 1);
                                    litaC_cgen__CGen_emitName(litaC_this, litaC_decl->decl.declaration.name);
                                    litaC_cgen__CGen_emitStrn(litaC_this, " = ", 3);
                                    
                                    
                                }
                                
                            } else {
                                if(litaC_field.kind == litaC_ast__StmtKind_ENUM_FIELD_DECL) {
                                    {
                                        litaC_ast__EnumDecl* litaC_decl = litaC_field.enumField;
                                        litaC_cgen__CGen_emitStrn(litaC_this, ".", 1);
                                        litaC_cgen__CGen_emitName(litaC_this, litaC_decl->decl.name);
                                        litaC_cgen__CGen_emitStrn(litaC_this, " = ", 3);
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        assert(litaC_false);
                                        
                                        
                                    }
                                } 
                                
                            } 
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                if(!(litaC_cgen__CGen_emitTraitCast(litaC_this, litaC_expr->value))) {
                    {
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->value->stmt)));
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_INIT_EXPR: {
            {
                litaC_ast__InitExpr* litaC_expr = (litaC_ast__InitExpr*)litaC_s;
                litaC_bool litaC_requiresCast = litaC_false;
                if(litaC_expr->expr.stmt.node.parent) {
                    {
                        litaC_requiresCast = litaC_expr->expr.stmt.node.parent->kind == litaC_ast__StmtKind_RETURN_STMT || litaC_expr->expr.stmt.node.parent->kind == litaC_ast__StmtKind_FUNC_CALL_EXPR;
                        
                        
                    }
                    
                } 
                
                if(litaC_requiresCast || !(litaC_expr->expr.expectedType) || litaC_expr->expr.expectedType->kind == litaC_types__TypeKind_PTR) {
                    {
                        litaC_cgen__CGen_emitStrn(litaC_this, "(", 1);
                        litaC_cgen__CGen_emitStr(litaC_this, litaC_cgen__CGen_cType(litaC_this, litaC_expr->type->typeInfo, litaC_false, litaC_false));
                        litaC_cgen__CGen_emitStrn(litaC_this, ")", 1);
                        
                        
                    }
                    
                } 
                
                litaC_cgen__CGen_emitStrn(litaC_this, " {", 2);
                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)));litaC_i += 1) {
                    {
                        if(litaC_i > 0) {
                            {
                                litaC_cgen__CGen_emitStrn(litaC_this, ",\n", 2);
                                
                                
                            }
                            
                        } 
                        
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_std__array__Array_get_cb__ptr_InitArgExpr_ce_(&((litaC_expr->arguments)), litaC_i)->expr.stmt)));
                        
                        
                    }
                }
                litaC_cgen__CGen_emitStrn(litaC_this, "}", 1);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NULL_EXPR: {
            {
                litaC_cgen__CGen_emitStrn(litaC_this, "NULL", 4);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_NUMBER_EXPR: {
            {
                litaC_ast__NumberExpr* litaC_expr = (litaC_ast__NumberExpr*)litaC_s;
                litaC_bool litaC_hasDecimal = litaC_false;
                litaC_bool litaC_isHex = litaC_false;
                litaC_bool litaC_isBin = litaC_false;
                litaC_usize litaC_length = litaC_expr->expr.stmt.node.startPos.end - litaC_expr->expr.stmt.node.startPos.start;
                const litaC_char* litaC_start = litaC_expr->expr.stmt.node.startPos.start;
                if(litaC_length > 2) {
                    {
                        litaC_char litaC_first = litaC_expr->expr.stmt.node.startPos.start[0];
                        litaC_i32 litaC_second = tolower(litaC_expr->expr.stmt.node.startPos.start[1]);
                        if(litaC_first == '0' && litaC_second == 'x') {
                            {
                                litaC_isHex = litaC_true;
                                
                                
                            }
                            
                        } else {
                            if(litaC_first == '0' && litaC_second == 'b') {
                                {
                                    litaC_isBin = litaC_true;
                                    
                                    
                                }
                                
                            } 
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
                for(;litaC_start != litaC_expr->expr.stmt.node.startPos.end;litaC_start += 1) {
                    {
                        litaC_char litaC_c = *(litaC_start);
                        if(litaC_c == '.') {
                            {
                                litaC_hasDecimal = litaC_true;
                                
                                
                            }
                            
                        } else {
                            if(litaC_c == '_') {
                                {
                                    continue;
                                    
                                    
                                }
                                
                            } else {
                                if(isalpha(litaC_c)) {
                                    {
                                        if(!(litaC_isHex) && !(litaC_isBin)) {
                                            {
                                                break;
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        if(litaC_isHex) {
                                            {
                                                litaC_c = tolower(litaC_c);
                                                if(litaC_c != 'a' && litaC_c != 'b' && litaC_c != 'c' && litaC_c != 'd' && litaC_c != 'e' && litaC_c != 'f' && litaC_c != 'x') {
                                                    {
                                                        break;
                                                        
                                                        
                                                    }
                                                    
                                                } 
                                                
                                                
                                                
                                            }
                                            
                                        } else {
                                            if(litaC_isBin) {
                                                {
                                                    litaC_c = tolower(litaC_c);
                                                    if(litaC_c != 'b') {
                                                        {
                                                            break;
                                                            
                                                            
                                                        }
                                                        
                                                    } 
                                                    
                                                    
                                                    
                                                }
                                                
                                            } else {
                                                {
                                                    break;
                                                    
                                                    
                                                }
                                            } 
                                            
                                        } 
                                        
                                        
                                        
                                    }
                                    
                                } 
                                
                            } 
                            
                        } 
                        
                        litaC_std__string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), *(litaC_start));
                        
                        
                    }
                }
                litaC_types__TypeInfo* litaC_type = litaC_expr->expr.operand.typeInfo;
                if(!(litaC_isHex) && !(litaC_isBin)) {
                    {
                        switch(litaC_type->kind) {
                            case litaC_types__TypeKind_F32: {
                                {
                                    if(!(litaC_hasDecimal)) {
                                        {
                                            litaC_cgen__CGen_emitStrn(litaC_this, ".", 1);
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    litaC_cgen__CGen_emitStrn(litaC_this, "f", 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_types__TypeKind_F64: {
                                {
                                    if(!(litaC_hasDecimal)) {
                                        {
                                            litaC_cgen__CGen_emitStrn(litaC_this, ".0", 2);
                                            
                                            
                                        }
                                        
                                    } 
                                    
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_types__TypeKind_U8: 
                            case litaC_types__TypeKind_U16: 
                            case litaC_types__TypeKind_U32: {
                                {
                                    litaC_cgen__CGen_emitStrn(litaC_this, "U", 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_types__TypeKind_U64: {
                                {
                                    litaC_cgen__CGen_emitStrn(litaC_this, "UL", 2);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            case litaC_types__TypeKind_I64: {
                                {
                                    litaC_cgen__CGen_emitStrn(litaC_this, "L", 1);
                                    break;
                                    
                                    
                                }
                                
                                
                            }
                            default: {
                                {
                                    
                                    
                                }
                                
                                
                            }
                        }
                        
                        
                    }
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_OFFSET_OF_EXPR: {
            {
                litaC_ast__OffsetOfExpr* litaC_expr = (litaC_ast__OffsetOfExpr*)litaC_s;
                litaC_cgen__CGen_emit(litaC_this, "offsetof(%s, %.*s)", litaC_cgen__CGen_cType(litaC_this, litaC_expr->type->typeInfo, litaC_false, litaC_false), litaC_expr->field.str.length, litaC_expr->field.str.buffer);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SET_EXPR: {
            {
                litaC_ast__SetExpr* litaC_expr = (litaC_ast__SetExpr*)litaC_s;
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->object->stmt)));
                litaC_types__TypeInfo* litaC_objectType = litaC_expr->object->operand.typeInfo;
                if(litaC_expr->flags & litaC_ast__GetExprFlags_IS_USING) {
                    {
                        litaC_types__TypeInfo* litaC_baseInfo = litaC_types__TypeInfo_getBaseType(litaC_objectType);
                        assert(litaC_baseInfo != NULL);
                        assert(litaC_baseInfo->kind == litaC_types__TypeKind_STRUCT || litaC_baseInfo->kind == litaC_types__TypeKind_UNION);
                        litaC_types__TypeInfo* litaC_aggInfo = litaC_baseInfo;
                        litaC_types__FieldPath litaC_path =  {
                            
                        };
                        litaC_bool litaC_isFound = litaC_types__TypeInfo_getFieldPath(litaC_aggInfo, litaC_expr->field->type->name, &(litaC_path));
                        assert(litaC_isFound);
                        litaC_types__TypeInfo* litaC_nextType = litaC_objectType;
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_path.numOfFields;litaC_i += 1) {
                            {
                                litaC_ast__FieldStmt litaC_field = litaC_path.fields[litaC_i];
                                if(litaC_nextType->kind == litaC_types__TypeKind_PTR) {
                                    {
                                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "->", 2);
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ".", 1);
                                        
                                        
                                    }
                                } 
                                
                                litaC_cgen__CGen_emitStrn(litaC_this, litaC_field.varField->decl.name.str.buffer, litaC_field.varField->decl.name.str.length);
                                litaC_nextType = litaC_field.typeInfo;
                                
                                
                            }
                        }
                        litaC_cgen__CGen_emit(litaC_this, " %s ", litaC_lex__tokenText[litaC_expr->operator]);
                        
                        
                    }
                    
                } else {
                    {
                        if(litaC_objectType->kind == litaC_types__TypeKind_PTR) {
                            {
                                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "->", 2);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ".", 1);
                                
                                
                            }
                        } 
                        
                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), litaC_expr->field->type->name.buffer, litaC_expr->field->type->name.length);
                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), " ", 1);
                        litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), litaC_lex__tokenText[litaC_expr->operator]);
                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), " ", 1);
                        
                        
                    }
                } 
                
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->value->stmt)));
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SIZE_OF_EXPR: {
            {
                litaC_ast__SizeOfExpr* litaC_expr = (litaC_ast__SizeOfExpr*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "sizeof(", 7);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->sizeOfExpr->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, ")", 1);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_STRING_EXPR: {
            {
                litaC_ast__StringExpr* litaC_expr = (litaC_ast__StringExpr*)litaC_s;
                if(litaC_expr->string.mod == litaC_lex__Mod_MULTISTR) {
                    {
                        litaC_std__string_view__StringView litaC_str = litaC_expr->string.value.str;
                        litaC_std__string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), '"');
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_str.length;) {
                            {
                                litaC_u8 litaC_byte = (litaC_u8)litaC_str.buffer[litaC_i];
                                if(litaC_byte < 128) {
                                    {
                                        litaC_char litaC_c = (litaC_char)litaC_byte;
                                        litaC_u32 litaC_n = (litaC_u32)litaC_str.buffer[litaC_i + 1];
                                        litaC_bool litaC_isSeq = (litaC_n == 'u' || litaC_n == 'U' || litaC_n != 'x');
                                        if(litaC_c == '\r') {
                                            {
                                                litaC_i += 1;
                                                continue;
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        const litaC_char* litaC_escaped = litaC_cgen__escapeStrings[(litaC_u32)litaC_c];
                                        if(litaC_escaped && !((litaC_c == '\\' && litaC_isSeq))) {
                                            {
                                                litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), litaC_escaped);
                                                litaC_i += 1;
                                                continue;
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        if(litaC_c == '\\') {
                                            {
                                                litaC_u32 litaC_n = (litaC_u32)litaC_str.buffer[litaC_i + 1];
                                                const litaC_char* litaC_escapedChar = litaC_cgen__escapeChars[litaC_n];
                                                if(litaC_escapedChar) {
                                                    {
                                                        const litaC_char* litaC_chars = litaC_cgen__escapeChars[litaC_n];
                                                        assert(litaC_chars);
                                                        litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), litaC_chars);
                                                        litaC_i += 2;
                                                        continue;
                                                        
                                                        
                                                    }
                                                    
                                                } else {
                                                    if(!(litaC_isSeq)) {
                                                        {
                                                            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "\\", 1);
                                                            
                                                            
                                                        }
                                                        
                                                    } 
                                                    
                                                } 
                                                
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        if(litaC_c == '"') {
                                            {
                                                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "\\", 1);
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        litaC_std__string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), litaC_c);
                                        litaC_i += 1;
                                        
                                        
                                    }
                                    
                                } else {
                                    {
                                        litaC_i32 litaC_result = 0;
                                        litaC_i32 litaC_len = (litaC_i32)litaC_std__unicode__utf8__Utf8Decode((const litaC_u8*)(&(litaC_str.buffer[litaC_i])), -(1), &(litaC_result));
                                        assert(litaC_len > 0);
                                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), &(litaC_str.buffer[litaC_i]), litaC_len);
                                        litaC_i += litaC_len;
                                        
                                        
                                    }
                                } 
                                
                                
                                
                            }
                        }
                        litaC_std__string_buffer__StringBuffer_appendChar(&((litaC_this->buf)), '"');
                        
                        
                    }
                    
                } else {
                    {
                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "\"", 1);
                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), litaC_expr->string.value.str.buffer, litaC_expr->string.value.str.length);
                        litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "\"", 1);
                        
                        
                    }
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR: {
            {
                litaC_ast__SubscriptGetExpr* litaC_expr = (litaC_ast__SubscriptGetExpr*)litaC_s;
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->object->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, "[", 1);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->index->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, "]", 1);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_SET_EXPR: {
            {
                litaC_ast__SubscriptSetExpr* litaC_expr = (litaC_ast__SubscriptSetExpr*)litaC_s;
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->object->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, "[", 1);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->index->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, "] ", 2);
                litaC_cgen__CGen_emitStr(litaC_this, litaC_lex__tokenText[litaC_expr->operator]);
                litaC_cgen__CGen_emitStrn(litaC_this, " ", 1);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->value->stmt)));
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TERNARY_EXPR: {
            {
                litaC_ast__TernaryExpr* litaC_expr = (litaC_ast__TernaryExpr*)litaC_s;
                litaC_cgen__CGen_emitStrn(litaC_this, "(", 1);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->cond->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, ") ? ", 4);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->then->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, " : ", 3);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->other->stmt)));
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR: {
            {
                litaC_ast__TypeIdentifierExpr* litaC_expr = (litaC_ast__TypeIdentifierExpr*)litaC_s;
                if(litaC_expr->type->typeInfo && !(litaC_expr->isBased)) {
                    {
                        litaC_cgen__CGen_emitStr(litaC_this, litaC_cgen__CGen_cType(litaC_this, litaC_expr->type->typeInfo, litaC_false, litaC_false));
                        
                        
                    }
                    
                } else {
                    {
                        if(litaC_expr->sym) {
                            {
                                litaC_cgen__CGen_emitSymbol(litaC_this, litaC_expr->sym);
                                
                                
                            }
                            
                        } else {
                            {
                                litaC_cgen__CGen_emitTypeSpec(litaC_this, litaC_expr->type);
                                
                                
                            }
                        } 
                        
                        
                        
                    }
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_TYPE_OF_EXPR: {
            {
                litaC_ast__TypeOfExpr* litaC_expr = (litaC_ast__TypeOfExpr*)litaC_s;
                if(litaC_expr->typeOfExpr) {
                    {
                        litaC_cgen__CGen_emit(litaC_this, "%lldLL", litaC_expr->typeOfExpr->operand.typeInfo->typeid);
                        
                        
                    }
                    
                } else {
                    if(litaC_expr->type) {
                        {
                            litaC_cgen__CGen_emit(litaC_this, "%lldLL", litaC_expr->type->typeInfo->typeid);
                            
                            
                        }
                        
                    } 
                    
                } 
                
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_UNARY_EXPR: {
            {
                litaC_ast__UnaryExpr* litaC_expr = (litaC_ast__UnaryExpr*)litaC_s;
                litaC_cgen__CGen_emitStr(litaC_this, litaC_lex__tokenText[litaC_expr->operator]);
                litaC_cgen__CGen_emitStrn(litaC_this, "(", 1);
                litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_expr->unaryExpr->stmt)));
                litaC_cgen__CGen_emitStrn(litaC_this, ")", 1);
                return;
                
                
                
            }
            
            
        }
        case litaC_ast__StmtKind_POISON_EXPR: {
            {
                assert(litaC_false);
                return;
                
                
                
            }
            
            
        }
        default: {
            {
                litaC_cgen__CGen_emit(litaC_this, "<%s Not Implemented>", litaC_ast__StmtKindAsStr(litaC_s->node.kind));
                assert(litaC_false);
                
                
            }
            
            
        }
    }
    
}

litaC_void litaC_dependency_graph__DependencyGraph_init(litaC_dependency_graph__DependencyGraph* litaC_this,litaC_lita__Lita* litaC_lita) {
    litaC_symbols__ProgramSymbols* litaC_symbols = &(litaC_lita->programSymbols);
    litaC_this->lita = litaC_lita;
    litaC_std__array__Array_init_cb__ptr_Symbol_ce_(&((litaC_this->sortedPrimitives)), litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_symbols->values))), litaC_lita->allocator);
    litaC_std__array__Array_init_cb__ptr_Symbol_ce_(&((litaC_this->sortedGlobals)), litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_symbols->values))), litaC_lita->allocator);
    litaC_std__array__Array_init_cb__ptr_Symbol_ce_(&((litaC_this->sortedAggregates)), litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_symbols->symbolTypes))), litaC_lita->allocator);
    litaC_std__array__Array_init_cb__ptr_Symbol_ce_(&((litaC_this->sortedFuncs)), litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_symbols->symbolFuncs))), litaC_lita->allocator);
    litaC_std__array__Array_init_cb__ptr_Symbol_ce_(&((litaC_this->sortedSymbols)), litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_symbols->values))) + litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_symbols->symbolTypes))) + litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_symbols->symbolFuncs))), litaC_lita->allocator);
    litaC_std__map__Map_init_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_this->dependencies)), litaC_dependency_graph__EmptyDependency, litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_symbols->symbolTypes))), litaC_std__map__PtrHashFn_cb__ptr_Symbol_ce_, litaC_std__map__PtrEqualFn_cb__ptr_Symbol_ce_, litaC_lita->allocator, 0);
    
}

litaC_void litaC_dependency_graph__DependencyGraph_markDependencies(litaC_dependency_graph__DependencyGraph* litaC_this,litaC_dependency_graph__Dependency* litaC_dependency) {
    assert(litaC_dependency != NULL);
    assert(litaC_dependency->sym != NULL);
    assert(litaC_dependency->state != litaC_dependency_graph__State_RESOLVED);
    litaC_symbols__Symbol* litaC_sym = litaC_dependency->sym;
    if(!(litaC_types__IsAggregate(litaC_sym->type))) {
        {
            litaC_dependency->state = litaC_dependency_graph__State_RESOLVED;
            return;
            
            
            
        }
        
    } 
    
    litaC_types__TypeInfo* litaC_aggInfo = litaC_sym->type;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_aggInfo->aggDecl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_aggInfo->aggDecl->fields)), litaC_i);
            assert(litaC_field.typeInfo != NULL);
            litaC_symbols__Symbol* litaC_dependentSym = NULL;
            if(litaC_types__IsAggregate(litaC_field.typeInfo)) {
                {
                    litaC_dependentSym = litaC_field.typeInfo->sym;
                    
                    
                }
                
            } else {
                if(litaC_field.typeInfo->kind == litaC_types__TypeKind_ARRAY) {
                    {
                        litaC_types__TypeInfo* litaC_arrayInfo = litaC_field.typeInfo;
                        litaC_types__TypeInfo* litaC_baseInfo = litaC_types__TypeInfo_getBaseType(litaC_arrayInfo);
                        if(litaC_types__IsAggregate(litaC_baseInfo)) {
                            {
                                litaC_dependentSym = litaC_baseInfo->sym;
                                
                                
                            }
                            
                        } 
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            if(litaC_dependentSym) {
                {
                    litaC_dependency_graph__Dependency* litaC_other = litaC_std__map__Map_getPtr_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_this->dependencies)), litaC_dependentSym);
                    assert(litaC_other != NULL);
                    litaC_std__array__Array_add_cb__ptr_Dependency_ce_(&((litaC_dependency->dependsOn)), litaC_other);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

litaC_void litaC_dependency_graph__DependencyGraph_buildGraph(litaC_dependency_graph__DependencyGraph* litaC_this,litaC_symbols__ProgramSymbols* litaC_program) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_program->values)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_program->values)), litaC_i);
            if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_CONSTANT && litaC_types__IsPrimitive(litaC_sym->type)) {
                {
                    litaC_std__array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->sortedPrimitives)), litaC_sym);
                    
                    
                }
                
            } else {
                {
                    litaC_std__array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->sortedGlobals)), litaC_sym);
                    
                    
                }
            } 
            
            
            
        }
    }
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_program->symbolFuncs)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_program->symbolFuncs)), litaC_i);
            if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_std__array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->sortedFuncs)), litaC_sym);
            
            
        }
    }
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Symbol_ce_(&((litaC_program->symbolTypes)));litaC_i += 1) {
        {
            litaC_symbols__Symbol* litaC_sym = litaC_std__array__Array_get_cb__ptr_Symbol_ce_(&((litaC_program->symbolTypes)), litaC_i);
            if(litaC_sym->flags & litaC_symbols__SymbolFlags_IS_GENERIC_TEMPLATE) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_dependency_graph__Dependency litaC_dep =  {
                .state = litaC_dependency_graph__State_PENDING,
                .sym = litaC_sym
            };
            litaC_std__array__Array_init_cb__ptr_Dependency_ce_(&((litaC_dep.dependsOn)), 64, litaC_this->lita->allocator);
            litaC_std__map__Map_put_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_this->dependencies)), litaC_sym, litaC_dep);
            
            
        }
    }
    for(litaC_std__map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_ litaC_it = litaC_std__map__Map_iter_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_this->dependencies)));litaC_std__map__MapIterator_hasNext_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_it)));) {
        {
            litaC_std__map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_ litaC_entry = litaC_std__map__MapIterator_next_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_it)));
            litaC_dependency_graph__Dependency* litaC_dep = litaC_entry.valuePtr;
            litaC_dependency_graph__DependencyGraph_markDependencies(litaC_this, litaC_dep);
            
            
        }
    }
    
}

litaC_dependency_graph__Dependency* litaC_dependency_graph__DependencyGraph_resolveDependency(litaC_dependency_graph__DependencyGraph* litaC_this,litaC_dependency_graph__Dependency* litaC_dependency) {
    if(litaC_dependency->state == litaC_dependency_graph__State_RESOLVED) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Dependency_ce_(&((litaC_dependency->dependsOn)));litaC_i += 1) {
        {
            litaC_dependency_graph__Dependency* litaC_dep = litaC_std__array__Array_get_cb__ptr_Dependency_ce_(&((litaC_dependency->dependsOn)), litaC_i);
            if(litaC_dep->state != litaC_dependency_graph__State_RESOLVED) {
                {
                    return litaC_dep;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_dependency->state = litaC_dependency_graph__State_RESOLVED;
    litaC_std__array__Array_add_cb__ptr_Symbol_ce_(&((litaC_this->sortedAggregates)), litaC_dependency->sym);
    return NULL;
    
    
}

litaC_void litaC_dependency_graph__DependencyGraph_sortAggregates(litaC_dependency_graph__DependencyGraph* litaC_this) {
    litaC_std__array__Array_cb__ptr_Dependency_ce_ litaC_pending =  {
        
    };
    litaC_std__array__Array_init_cb__ptr_Dependency_ce_(&((litaC_pending)), litaC_std__map__Map_size_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_this->dependencies))), litaC_this->lita->allocator);
    for(litaC_std__map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_ litaC_it = litaC_std__map__Map_iter_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_this->dependencies)));litaC_std__map__MapIterator_hasNext_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_it)));) {
        {
            litaC_std__map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_ litaC_entry = litaC_std__map__MapIterator_next_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_it)));
            litaC_dependency_graph__Dependency* litaC_dep = litaC_entry.valuePtr;
            if(litaC_dependency_graph__DependencyGraph_resolveDependency(litaC_this, litaC_dep) != NULL) {
                {
                    litaC_std__array__Array_add_cb__ptr_Dependency_ce_(&((litaC_pending)), litaC_dep);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_pending = litaC_dependency_graph__DependencyGraph_sortAggregatesDependencies(litaC_this, &((litaC_pending)));
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Dependency_ce_(&((litaC_pending)));litaC_i += 1) {
        {
            litaC_dependency_graph__Dependency* litaC_dep = litaC_std__array__Array_get_cb__ptr_Dependency_ce_(&((litaC_pending)), litaC_i);
            litaC_dependency_graph__Dependency* litaC_cause = litaC_dependency_graph__DependencyGraph_resolveDependency(litaC_this, litaC_dep);
            if(litaC_cause) {
                {
                    litaC_phase_result__PhaseResult_addError(&((litaC_this->lita->result)), litaC_dep->sym->decl->stmt.node.startPos, "could not resolve dependency order for '%.*s' because of cyclic dependency with '%.*s'", litaC_dep->sym->name.length, litaC_dep->sym->name.buffer, litaC_cause->sym->name.length, litaC_cause->sym->name.buffer);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    
}

litaC_std__array__Array_cb__ptr_Dependency_ce_ litaC_dependency_graph__DependencyGraph_sortAggregatesDependencies(litaC_dependency_graph__DependencyGraph* litaC_this,litaC_std__array__Array_cb__ptr_Dependency_ce_* litaC_deps) {
    litaC_std__array__Array_cb__ptr_Dependency_ce_ litaC_pending =  {
        
    };
    litaC_bool litaC_isInit = litaC_false;
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_Dependency_ce_(litaC_deps);litaC_i += 1) {
        {
            litaC_dependency_graph__Dependency* litaC_dep = litaC_std__array__Array_get_cb__ptr_Dependency_ce_(litaC_deps, litaC_i);
            if(litaC_dependency_graph__DependencyGraph_resolveDependency(litaC_this, litaC_dep) != NULL) {
                {
                    litaC_std__array__Array_cb__ptr_Dependency_ce_ litaC_result = litaC_dependency_graph__DependencyGraph_sortAggregatesDependencies(litaC_this, &((litaC_dep->dependsOn)));
                    if(!(litaC_std__array__Array_empty_cb__ptr_Dependency_ce_(&((litaC_result))))) {
                        {
                            if(!(litaC_isInit)) {
                                {
                                    litaC_std__array__Array_init_cb__ptr_Dependency_ce_(&((litaC_pending)), litaC_std__array__Array_size_cb__ptr_Dependency_ce_(litaC_deps), litaC_this->lita->allocator);
                                    litaC_isInit = litaC_true;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__array__Array_addAll_cb__ptr_Dependency_ce_(&((litaC_pending)), &((litaC_result)));
                    if(litaC_dependency_graph__DependencyGraph_resolveDependency(litaC_this, litaC_dep) != NULL) {
                        {
                            if(!(litaC_isInit)) {
                                {
                                    litaC_std__array__Array_init_cb__ptr_Dependency_ce_(&((litaC_pending)), litaC_std__array__Array_size_cb__ptr_Dependency_ce_(litaC_deps), litaC_this->lita->allocator);
                                    litaC_isInit = litaC_true;
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_std__array__Array_add_cb__ptr_Dependency_ce_(&((litaC_pending)), litaC_dep);
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_pending;
    
    
}

litaC_std__array__Array_cb__ptr_Symbol_ce_ litaC_dependency_graph__DependencyGraph_sort(litaC_dependency_graph__DependencyGraph* litaC_this) {
    litaC_dependency_graph__DependencyGraph_buildGraph(litaC_this, &((litaC_this->lita->programSymbols)));
    litaC_dependency_graph__DependencyGraph_sortAggregates(litaC_this);
    litaC_std__array__Array_clear_cb__ptr_Symbol_ce_(&((litaC_this->sortedSymbols)));
    litaC_std__array__Array_addAll_cb__ptr_Symbol_ce_(&((litaC_this->sortedSymbols)), &((litaC_this->sortedPrimitives)));
    litaC_std__array__Array_addAll_cb__ptr_Symbol_ce_(&((litaC_this->sortedSymbols)), &((litaC_this->sortedAggregates)));
    litaC_std__array__Array_addAll_cb__ptr_Symbol_ce_(&((litaC_this->sortedSymbols)), &((litaC_this->sortedGlobals)));
    litaC_std__array__Array_addAll_cb__ptr_Symbol_ce_(&((litaC_this->sortedSymbols)), &((litaC_this->sortedFuncs)));
    return litaC_this->sortedSymbols;
    
    
}

litaC_void litaC_cgen_decl__CGen_emitVarDecl(litaC_cgen__CGen* litaC_this,litaC_ast__VarDecl* litaC_decl) {
    assert(litaC_decl->decl.sym != NULL);
    if(litaC_decl->decl.sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_decl->decl.sym->flags |= litaC_symbols__SymbolFlags_IS_EMITTED;
    litaC_cgen__CGen_emitNotes(litaC_this, &((litaC_decl->decl.attributes)), litaC_true);
    litaC_cgen__CGen_emitLineInfo(litaC_this, &((litaC_decl->decl.stmt)));
    const litaC_char* litaC_name = litaC_cgen__CGen_cName(litaC_this, litaC_decl->decl.sym);
    if(litaC_decl->decl.sym->flags & litaC_symbols__SymbolFlags_IS_CONSTANT && litaC_ast__Expr_isConstExpr(litaC_decl->expr) && litaC_decl->expr->operand.isConst) {
        {
            assert(litaC_decl->expr != NULL);
            litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), "\n#define ");
            litaC_cgen__CGen_emitStr(litaC_this, litaC_name);
            litaC_this->inTextBlock = litaC_true;
            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), " (", 2);
            litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_decl->expr->stmt)));
            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ")", 1);
            litaC_this->inTextBlock = litaC_false;
            if(litaC_decl->decl.sym->flags & litaC_symbols__SymbolFlags_IS_LOCAL) {
                {
                    if(litaC_std__array__Array_empty_cb__ptr_const_char_ce_(&((litaC_this->currentScope->constDefs)))) {
                        {
                            litaC_std__array__Array_init_cb__ptr_const_char_ce_(&((litaC_this->currentScope->constDefs)), 16, litaC_this->lita->allocator);
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_this->currentScope->constDefs)), litaC_name);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } else {
        {
            litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), litaC_cgen__CGen_cTypeDecl(litaC_this, litaC_decl->decl.sym->type, litaC_name, litaC_false));
            if(litaC_decl->expr) {
                {
                    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), " = ", 3);
                    if(!(litaC_cgen__CGen_emitTraitCast(litaC_this, litaC_decl->expr))) {
                        {
                            litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_decl->expr->stmt)));
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } else {
                {
                    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), " = ", 3);
                    litaC_cgen_decl__CGen_emitDefaultInitValue(litaC_this, litaC_decl->decl.sym);
                    
                    
                }
            } 
            
            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ";", 1);
            
            
        }
    } 
    
    
}

litaC_void litaC_cgen_decl__CGen_emitDefaultInitValue(litaC_cgen__CGen* litaC_this,litaC_symbols__Symbol* litaC_sym) {
    assert(litaC_sym != NULL);
    if(litaC_types__IsPtr(litaC_sym->type)) {
        {
            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "NULL", 4);
            
            
        }
        
    } else {
        {
            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "{0}", 3);
            
            
        }
    } 
    
    
}

litaC_void litaC_cgen_decl__CGen_emitFuncDeclSignature(litaC_cgen__CGen* litaC_this,litaC_ast__FuncDecl* litaC_decl,const litaC_char* litaC_name) {
    assert(litaC_decl->decl.declaration.sym != NULL);
    if(litaC_decl->decl.declaration.sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_cgen__CGen_emitNotes(litaC_this, &((litaC_decl->decl.declaration.attributes)), litaC_true);
    litaC_cgen__CGen_emitLineInfo(litaC_this, &((litaC_decl->decl.declaration.stmt)));
    litaC_types__TypeInfo* litaC_funcInfo = litaC_decl->decl.declaration.sym->type;
    if(litaC_funcInfo->returnType->kind == litaC_types__TypeKind_FUNC_PTR) {
        {
            litaC_types__TypeInfo* litaC_funcPtrInfo = litaC_funcInfo->returnType;
            litaC_std__string_buffer__StringBuffer_append(&((litaC_this->buf)), "%s (*%s(", litaC_cgen__CGen_cType(litaC_this, litaC_funcPtrInfo->returnType, litaC_false, litaC_false), litaC_name);
            
            
        }
        
    } else {
        {
            litaC_std__string_buffer__StringBuffer_append(&((litaC_this->buf)), "%s %s(", litaC_cgen__CGen_cType(litaC_this, litaC_funcInfo->returnType, litaC_false, litaC_false), litaC_name);
            
            
        }
    } 
    
    litaC_bool litaC_decayArrays = litaC_true;
    litaC_i32 litaC_i = 0;
    litaC_std__string_buffer__StringBuffer litaC_tmp = litaC_std__string_buffer__StringBufferInit(256, litaC_this->lita->allocator);
    for(;litaC_i < litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)));litaC_i += 1) {
        {
            if(litaC_i > 0) {
                {
                    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ",", 1);
                    
                    
                }
                
            } 
            
            litaC_ast__ParameterDecl* litaC_param = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(&((litaC_funcInfo->funcDecl->params->params)), litaC_i);
            litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), litaC_cgen__CGen_cTypeDecl(litaC_this, litaC_param->decl.sym->type, litaC_cgen__CGen_prefix(litaC_this, litaC_param->decl.sym->name.view, &(litaC_tmp)), litaC_decayArrays));
            litaC_std__string_buffer__StringBuffer_clear(&((litaC_tmp)));
            
            
        }
    }
    if(litaC_funcInfo->funcDecl->flags & litaC_ast__FuncFlags_HAS_VARARGS) {
        {
            if(litaC_i > 0) {
                {
                    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ",", 1);
                    
                    
                }
                
            } 
            
            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "...", 3);
            
            
        }
        
    } 
    
    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ")", 1);
    if(litaC_funcInfo->returnType->kind == litaC_types__TypeKind_FUNC_PTR) {
        {
            litaC_types__TypeInfo* litaC_funcPtrInfo = litaC_funcInfo->returnType;
            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ")  (", 4);
            litaC_i32 litaC_j = 0;
            for(;litaC_j < litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(&((litaC_funcPtrInfo->paramDecls)));litaC_j += 1) {
                {
                    if(litaC_j > 0) {
                        {
                            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ",", 1);
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__string_buffer__StringBuffer_appendStr(&((litaC_this->buf)), litaC_cgen__CGen_cType(litaC_this, litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(&((litaC_funcPtrInfo->paramDecls)), litaC_j), litaC_false, litaC_false));
                    
                    
                }
            }
            if(litaC_funcPtrInfo->hasVarargs) {
                {
                    if(litaC_j > 0) {
                        {
                            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ",", 1);
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), "...", 3);
                    
                    
                }
                
            } 
            
            litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_this->buf)), ")", 1);
            
            
        }
        
    } 
    
    
}

litaC_void litaC_cgen_decl__CGen_emitFuncDecl(litaC_cgen__CGen* litaC_this,litaC_ast__FuncDecl* litaC_decl) {
    assert(litaC_decl != NULL);
    if(litaC_decl->decl.declaration.sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_decl->decl.declaration.sym->flags |= litaC_symbols__SymbolFlags_IS_EMITTED;
    const litaC_char* litaC_name = litaC_cgen__CGen_cName(litaC_this, litaC_decl->decl.declaration.sym);
    litaC_cgen_decl__CGen_emitFuncDeclSignature(litaC_this, litaC_decl, litaC_name);
    litaC_cgen__CGen_emitStrn(litaC_this, " {", 2);
    litaC_this->funcIndex = litaC_this->buf.length;
    if(litaC_decl->body) {
        {
            litaC_this->currentFunc = litaC_decl->decl.declaration.sym->type;
            litaC_cgen__CGen_emitStmt(litaC_this, litaC_decl->body);
            litaC_this->currentFunc = NULL;
            
            
        }
        
    } 
    
    litaC_cgen__CGen_emitStrn(litaC_this, "}\n", 2);
    
}

litaC_void litaC_cgen_decl__CGen_emitAggregateDecl(litaC_cgen__CGen* litaC_this,litaC_ast__AggregateDecl* litaC_decl) {
    assert(litaC_decl->decl.declaration.sym != NULL);
    if(litaC_decl->decl.declaration.sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_decl->flags & litaC_ast__AggregateFlags_IS_EMBEDDED && litaC_this->aggregateLevel < 1) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_decl->decl.declaration.sym->flags |= litaC_symbols__SymbolFlags_IS_EMITTED;
    litaC_this->aggregateLevel += 1;
    
    litaC_cgen__CGen_emitNotes(litaC_this, &((litaC_decl->decl.declaration.attributes)), litaC_true);
    litaC_cgen__CGen_emitLineInfo(litaC_this, &((litaC_decl->decl.declaration.stmt)));
    const litaC_char* litaC_name = litaC_cgen__CGen_cName(litaC_this, litaC_decl->decl.declaration.sym);
    if(litaC_decl->flags & litaC_ast__AggregateFlags_IS_ANONYMOUS) {
        {
            litaC_name = "";
            
            
        }
        
    } 
    
    litaC_cgen__CGen_emit(litaC_this, "%s %s {", (litaC_decl->decl.declaration.stmt.node.kind == litaC_ast__StmtKind_UNION_DECL) ? "union" : "struct", litaC_name);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_FieldStmt_ce_(&((litaC_decl->fields)));litaC_i += 1) {
        {
            litaC_ast__FieldStmt litaC_field = litaC_std__array__Array_get_cb_FieldStmt_ce_(&((litaC_decl->fields)), litaC_i);
            switch(litaC_field.kind) {
                case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
                    {
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_VAR_FIELD_DECL: {
                    {
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_field.varField->decl.stmt)));
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_UNION_FIELD_DECL: 
                case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
                    {
                        litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_field.aggregateField->decl.declaration.stmt)));
                        break;
                        
                        
                    }
                    
                    
                }
                case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
                    {
                        litaC_ast__Decl litaC_decl = litaC_field.enumField->decl;
                        litaC_cgen__CGen_emit(litaC_this, "enum %s %.*s;\n", litaC_cgen__CGen_cTypeName(litaC_this, litaC_decl.sym->type), litaC_decl.name.str.length, litaC_decl.name.str.buffer);
                        break;
                        
                        
                    }
                    
                    
                }
                default: {
                    {
                        
                        
                    }
                    
                    
                }
            }
            
            
        }
    }
    if(litaC_decl->decl.declaration.sym->flags & litaC_symbols__SymbolFlags_IS_TRAIT) {
        {
            litaC_module__Module* litaC_root = litaC_this->lita->programSymbols.root;
            assert(litaC_root != NULL);
            litaC_char litaC_vtableName[256] =  {
                
            };
            litaC_std__string__String litaC_vtableNameStr = litaC_std__string__StringInit(litaC_vtableName, litaC_symbols__MAX_SYMBOL_NAME, 0);
            litaC_std__string_view__StringView litaC_escapedName = litaC_cgen__CGen_escapeNameStr(litaC_this, litaC_decl->decl.declaration.sym->name);
            litaC_module__Module* litaC_module = litaC_root;
            litaC_i32 litaC_len = litaC_std__string__String_format(&((litaC_vtableNameStr)), "%s%.*s__%.*s", litaC_this->lita->options->cPrefix, litaC_module->id.name.length, litaC_module->id.name.buffer, litaC_escapedName.length, litaC_escapedName.buffer);
            litaC_cgen__CGen_emit(litaC_this, "%s__VirtualTable* __vtable;\n", litaC_std__string__String_cStr(litaC_vtableNameStr));
            litaC_cgen__CGen_emitStrn(litaC_this, "void* __this;", 13);
            
            
        }
        
    } else {
        if(litaC_std__array__Array_empty_cb_FieldStmt_ce_(&((litaC_decl->fields)))) {
            {
                litaC_cgen__CGen_emitStr(litaC_this, "int __dummy;");
                
                
            }
            
        } 
        
    } 
    
    litaC_cgen__CGen_emitStrn(litaC_this, "}", 1);
    if(litaC_this->aggregateLevel > 1) {
        {
            if(litaC_decl->decl.declaration.name.str.length) {
                {
                    litaC_cgen__CGen_emitStrn(litaC_this, " ", 1);
                    litaC_cgen__CGen_emitStrn(litaC_this, litaC_decl->decl.declaration.name.str.buffer, litaC_decl->decl.declaration.name.str.length);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_cgen__CGen_emitStrn(litaC_this, ";\n", 2);
    litaC_cgen__CGen_emitNotes(litaC_this, &((litaC_decl->decl.declaration.attributes)), litaC_false);
    litaC_this->aggregateLevel -= 1;
    
}

litaC_void litaC_cgen_decl__CGen_emitEnumDecl(litaC_cgen__CGen* litaC_this,litaC_ast__EnumDecl* litaC_decl) {
    assert(litaC_decl->decl.sym != NULL);
    if(litaC_decl->decl.sym->flags & litaC_symbols__SymbolFlags_IS_FOREIGN) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_decl->decl.sym->flags |= litaC_symbols__SymbolFlags_IS_EMITTED;
    litaC_cgen__CGen_emitNotes(litaC_this, &((litaC_decl->decl.attributes)), litaC_true);
    litaC_cgen__CGen_emitLineInfo(litaC_this, &((litaC_decl->decl.stmt)));
    const litaC_char* litaC_name = litaC_cgen__CGen_cName(litaC_this, litaC_decl->decl.sym);
    litaC_cgen__CGen_emit(litaC_this, "typedef enum %s {", litaC_name);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_decl->fields)));litaC_i += 1) {
        {
            if(litaC_i > 0) {
                {
                    litaC_cgen__CGen_emit(litaC_this, ",\n");
                    
                    
                }
                
            } 
            
            litaC_ast__EnumFieldEntryDecl* litaC_field = litaC_std__array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(&((litaC_decl->fields)), litaC_i);
            litaC_cgen__CGen_emit(litaC_this, "%s_%.*s", litaC_name, litaC_field->decl.name.str.length, litaC_field->decl.name.str.buffer);
            if(litaC_field->value) {
                {
                    litaC_cgen__CGen_emitStrn(litaC_this, " = ", 3);
                    litaC_cgen__CGen_emitStmt(litaC_this, &((litaC_field->value->stmt)));
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_cgen__CGen_emit(litaC_this, "} %s;\n", litaC_name);
    
}

litaC_void litaC_build__BuildFile_init(litaC_build__BuildFile* litaC_this,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_this->allocator = litaC_allocator;
    litaC_this->compileCmdTemplate = NULL;
    litaC_this->projectSrcDir = NULL;
    litaC_std__array__Array_init_cb__ptr_const_char_ce_(&((litaC_this->pkgPaths)), 32, litaC_allocator);
    litaC_std__array__Array_init_cb__ptr_const_char_ce_(&((litaC_this->includePaths)), 32, litaC_allocator);
    litaC_std__array__Array_init_cb__ptr_const_char_ce_(&((litaC_this->libraryPaths)), 32, litaC_allocator);
    litaC_std__array__Array_init_cb__ptr_const_char_ce_(&((litaC_this->staticLibs)), 32, litaC_allocator);
    
}

litaC_void litaC_build__BuildFile_free(litaC_build__BuildFile* litaC_this) {
    if(litaC_this->compileCmdTemplate) {
        {
            litaC_std__mem__Allocator_free(litaC_this->allocator, (litaC_void*)litaC_this->compileCmdTemplate);
            
            
        }
        
    } 
    
    if(litaC_this->projectSrcDir) {
        {
            litaC_std__mem__Allocator_free(litaC_this->allocator, (litaC_void*)litaC_this->projectSrcDir);
            
            
        }
        
    } 
    
    litaC_build__FreeArray(&((litaC_this->pkgPaths)), litaC_this->allocator);
    litaC_build__FreeArray(&((litaC_this->includePaths)), litaC_this->allocator);
    litaC_build__FreeArray(&((litaC_this->libraryPaths)), litaC_this->allocator);
    litaC_build__FreeArray(&((litaC_this->staticLibs)), litaC_this->allocator);
    
}

litaC_void litaC_build__FreeArray(litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_array,const litaC_std__mem__Allocator* litaC_allocator) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_const_char_ce_(litaC_array);litaC_i += 1) {
        {
            const litaC_char* litaC_v = litaC_std__array__Array_get_cb__ptr_const_char_ce_(litaC_array, litaC_i);
            litaC_std__mem__Allocator_free(litaC_allocator, (litaC_void*)litaC_v);
            
            
        }
    }
    litaC_std__array__Array_free_cb__ptr_const_char_ce_(litaC_array);
    
}

litaC_bool litaC_build__BuildFile_writeTo(litaC_build__BuildFile* litaC_this,litaC_std__io__File* litaC_file) {
    litaC_std__json__JsonNode* litaC_root = litaC_std__json__CreateJsonObject(litaC_this->allocator);
    litaC_std__json__JsonNode_putStr(litaC_root, "compile_template", litaC_this->compileCmdTemplate, -(1));
    litaC_std__json__JsonNode_putStr(litaC_root, "source_directory", litaC_this->projectSrcDir, -(1));
    litaC_std__json__JsonNode_put(litaC_root, "package_paths", litaC_build__CreateArray(&(litaC_this->pkgPaths), litaC_this->allocator));
    litaC_std__json__JsonNode_put(litaC_root, "include_paths", litaC_build__CreateArray(&(litaC_this->includePaths), litaC_this->allocator));
    litaC_std__json__JsonNode_put(litaC_root, "library_paths", litaC_build__CreateArray(&(litaC_this->libraryPaths), litaC_this->allocator));
    litaC_std__json__JsonNode_put(litaC_root, "static_libs", litaC_build__CreateArray(&(litaC_this->staticLibs), litaC_this->allocator));
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(1024, litaC_this->allocator);
    
    litaC_std__json__JsonNode_print(litaC_root, &((litaC_sb)));
    if(litaC_std__io__File_writeBytes(litaC_file, litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_sb.length) != litaC_std__io__FileStatus_Ok) {
        {
            {
                litaC_bool ___result = litaC_false;
                litaC_std__string_buffer__StringBuffer_free(&((litaC_sb)));
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    {
        litaC_bool ___result = litaC_true;
        litaC_std__string_buffer__StringBuffer_free(&((litaC_sb)));
        return ___result;
        
    }
    
    litaC_std__string_buffer__StringBuffer_free(&((litaC_sb)));
    
}

litaC_bool litaC_build__BuildFileFromFile(const litaC_char* litaC_filename,litaC_build__BuildFile* litaC_buildFile,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_std__json__JsonParser litaC_parser =  {
        
    };
    litaC_std__json__JsonParser_init(&((litaC_parser)), litaC_allocator);
    
    litaC_char* litaC_data = NULL;
    litaC_usize litaC_length = {0};
    if(litaC_std__io__ReadFile(litaC_filename, &(litaC_data), &(litaC_length), litaC_allocator) != litaC_std__io__FileStatus_Ok) {
        {
            {
                litaC_bool ___result = litaC_false;
                litaC_std__json__JsonParser_free(&((litaC_parser)));
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_std__json__JsonNode* litaC_node = litaC_std__json__JsonParser_parseJson(&((litaC_parser)), litaC_data);
    
    if(litaC_std__json__JsonParser_hasError(&((litaC_parser)))) {
        {
            {
                litaC_bool ___result = litaC_false;
                if(litaC_node) {
                    litaC_std__json__JsonNode_free(litaC_node);
                    
                } 
                ;
                litaC_std__json__JsonParser_free(&((litaC_parser)));
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    {
        litaC_bool ___result = litaC_build__BuildFileFromJson(litaC_node, litaC_buildFile, litaC_allocator);
        if(litaC_node) {
            litaC_std__json__JsonNode_free(litaC_node);
            
        } 
        ;
        litaC_std__json__JsonParser_free(&((litaC_parser)));
        return ___result;
        
    }
    
    if(litaC_node) {
        litaC_std__json__JsonNode_free(litaC_node);
        
    } 
    ;
    litaC_std__json__JsonParser_free(&((litaC_parser)));
    
}

litaC_bool litaC_build__BuildFileFromJson(litaC_std__json__JsonNode* litaC_json,litaC_build__BuildFile* litaC_buildFile,const litaC_std__mem__Allocator* litaC_allocator) {
    if(!(litaC_json)) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_buildFile->allocator = litaC_allocator;
    litaC_buildFile->compileCmdTemplate = litaC_std__string__StringClone(litaC_std__json__JsonNode_getStr(litaC_json, "compile_template", NULL), -(1), litaC_allocator);
    litaC_buildFile->projectSrcDir = litaC_std__string__StringClone(litaC_std__json__JsonNode_getStr(litaC_json, "source_directory", NULL), -(1), litaC_allocator);
    litaC_build__AddStrings(litaC_json, "package_paths", &(litaC_buildFile->pkgPaths), litaC_allocator);
    litaC_build__AddStrings(litaC_json, "include_paths", &(litaC_buildFile->includePaths), litaC_allocator);
    litaC_build__AddStrings(litaC_json, "library_paths", &(litaC_buildFile->libraryPaths), litaC_allocator);
    litaC_build__AddStrings(litaC_json, "static_libs", &(litaC_buildFile->staticLibs), litaC_allocator);
    return litaC_true;
    
    
}

litaC_void litaC_build__AddStrings(litaC_std__json__JsonNode* litaC_json,const litaC_char* litaC_key,litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_array,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_std__json__JsonNode* litaC_nodes = litaC_std__json__JsonNode_getArray(litaC_json, litaC_key);
    if(litaC_nodes) {
        {
            if(litaC_array->alloc == NULL) {
                {
                    litaC_std__array__Array_init_cb__ptr_const_char_ce_(litaC_array, litaC_std__json__JsonNode_size(litaC_nodes), litaC_allocator);
                    
                    
                }
                
            } 
            
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__json__JsonNode_size(litaC_nodes);litaC_i += 1) {
                {
                    litaC_std__json__JsonNode* litaC_node = litaC_std__json__JsonNode_at(litaC_nodes, litaC_i);
                    if(!(litaC_std__json__JsonNode_isString(litaC_node))) {
                        {
                            continue;
                            
                            
                        }
                        
                    } 
                    
                    litaC_std__array__Array_add_cb__ptr_const_char_ce_(litaC_array, litaC_std__string__StringClone(litaC_std__json__JsonNode_asString(litaC_node), -(1), litaC_allocator));
                    
                    
                }
            }
            
            
        }
        
    } 
    
    
}

litaC_std__json__JsonNode* litaC_build__CreateArray(litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_array,const litaC_std__mem__Allocator* litaC_allocator) {
    if(litaC_std__array__Array_empty_cb__ptr_const_char_ce_(litaC_array)) {
        {
            return litaC_std__json__JSON_NULL;
            
            
            
        }
        
    } 
    
    litaC_std__json__JsonNode* litaC_node = litaC_std__json__CreateJsonArray(litaC_allocator);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_const_char_ce_(litaC_array);litaC_i += 1) {
        {
            const litaC_char* litaC_value = litaC_std__array__Array_get_cb__ptr_const_char_ce_(litaC_array, litaC_i);
            litaC_std__json__JsonNode_add(litaC_node, litaC_std__json__CreateJsonStringNoDup(litaC_value, litaC_allocator));
            
            
        }
    }
    return litaC_node;
    
    
}

litaC_bool litaC_tcc__libtcc__IsLibtccAvailable() {
    
    #if LITA_X86 || LITA_X64
    return litaC_true;
    
    
    #else
    return litaC_false;
    
    
    #endif
    
    
}

litaC_void litaC_pkg_mgr__PackageManager_init(litaC_pkg_mgr__PackageManager* litaC_this,litaC_pkg_mgr__PackageOptions litaC_options,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_this->options = litaC_options;
    litaC_this->allocator = litaC_allocator;
    litaC_this->packages = litaC_std__map__StrMap_cb__ptr_PackageDef_ce_(NULL, 32, litaC_allocator);
    litaC_this->errors = litaC_std__string_buffer__StringBufferInit(128, litaC_allocator);
    litaC_this->warnings = litaC_std__string_buffer__StringBufferInit(128, litaC_allocator);
    
}

litaC_void litaC_pkg_mgr__PackageManager_free(litaC_pkg_mgr__PackageManager* litaC_this) {
    for(litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_PackageDef_ce_ litaC_it = litaC_std__map__Map_iter_cb__ptr_const_char_c__ptr_PackageDef_ce_(&((litaC_this->packages)));litaC_std__map__MapIterator_hasNext_cb__ptr_const_char_c__ptr_PackageDef_ce_(&((litaC_it)));) {
        {
            litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_PackageDef_ce_ litaC_n = litaC_std__map__MapIterator_next_cb__ptr_const_char_c__ptr_PackageDef_ce_(&((litaC_it)));
            if(litaC_n.value) {
                {
                    litaC_pkg_mgr__pkg__PackageDef_free(litaC_n.value);
                    litaC_std__mem__Allocator_free(litaC_this->allocator, litaC_n.value);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_std__map__Map_free_cb__ptr_const_char_c__ptr_PackageDef_ce_(&((litaC_this->packages)));
    litaC_std__string_buffer__StringBuffer_free(&((litaC_this->errors)));
    litaC_std__string_buffer__StringBuffer_free(&((litaC_this->warnings)));
    litaC_this->pkg = NULL;
    
}

litaC_void litaC_pkg_mgr__PackageManager_printMessages(litaC_pkg_mgr__PackageManager* litaC_this) {
    if(litaC_this->warnings.length > 0) {
        {
            printf("Warning: %s\n", litaC_std__string_buffer__StringBuffer_cStr(&((litaC_this->warnings))));
            
            
        }
        
    } 
    
    if(litaC_this->errors.length > 0) {
        {
            printf("Error: %s\n", litaC_std__string_buffer__StringBuffer_cStr(&((litaC_this->errors))));
            
            
        }
        
    } 
    
    
}


litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__PackageManager_initCommand(litaC_pkg_mgr__PackageManager* litaC_this,litaC_pkg_mgr__PackageInitOptions litaC_options) {
    
    {
        litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__pkg_init__PackageInit(litaC_this, litaC_options);
        litaC_pkg_mgr__PackageManager_printMessages(litaC_this);
        return ___result;
        
    }
    
    litaC_pkg_mgr__PackageManager_printMessages(litaC_this);
    
}


litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__PackageManager_buildCommand(litaC_pkg_mgr__PackageManager* litaC_this,litaC_pkg_mgr__PackageBuildOptions litaC_options) {
    
    litaC_pkg_mgr__PkgStatus litaC_status = litaC_pkg_mgr__PackageManager_readProjectPkg(litaC_this);
    if(litaC_status != litaC_pkg_mgr__PkgStatus_OK) {
        {
            {
                litaC_pkg_mgr__PkgStatus ___result = litaC_status;
                litaC_pkg_mgr__PackageManager_printMessages(litaC_this);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    {
        litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__pkg_build__PackageBuild(litaC_this, litaC_options);
        litaC_pkg_mgr__PackageManager_printMessages(litaC_this);
        return ___result;
        
    }
    
    litaC_pkg_mgr__PackageManager_printMessages(litaC_this);
    
}


litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__PackageManager_installCommand(litaC_pkg_mgr__PackageManager* litaC_this,litaC_pkg_mgr__PackageInstallOptions litaC_options) {
    
    litaC_pkg_mgr__PkgStatus litaC_status = litaC_pkg_mgr__PackageManager_readProjectPkg(litaC_this);
    if(litaC_status != litaC_pkg_mgr__PkgStatus_OK) {
        {
            {
                litaC_pkg_mgr__PkgStatus ___result = litaC_status;
                litaC_pkg_mgr__PackageManager_printMessages(litaC_this);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    printf("Found '%s/pkg.json' with %d package dependencies.\n", litaC_std__system__CurrentWorkingPath(), litaC_std__array__Array_size_cb_PackageId_ce_(&((litaC_this->pkg->dependencies))));
    if(!(litaC_std__array__Array_empty_cb_PackageId_ce_(&((litaC_this->pkg->dependencies))))) {
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_PackageId_ce_(&((litaC_this->pkg->dependencies)));litaC_i += 1) {
                {
                    printf("Installing '%s'\n", litaC_std__array__Array_get_cb_PackageId_ce_(&((litaC_this->pkg->dependencies)), litaC_i).id);
                    
                    
                }
            }
            
            
        }
        
    } 
    
    {
        litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__pkg_install__PackageInstall(litaC_this, litaC_options);
        litaC_pkg_mgr__PackageManager_printMessages(litaC_this);
        return ___result;
        
    }
    
    litaC_pkg_mgr__PackageManager_printMessages(litaC_this);
    
}


litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__PackageManager_createBuildFile(litaC_pkg_mgr__PackageManager* litaC_this,litaC_build__BuildFile* litaC_buildFile) {
    litaC_build__BuildFile_init(litaC_buildFile, litaC_this->allocator);
    litaC_char litaC_temp[_MAX_PATH] = {0};
    litaC_i32 litaC_len = (litaC_this->options.projectPath != NULL) ? strlen(litaC_this->options.projectPath) : 0;
    for(litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_PackageDef_ce_ litaC_it = litaC_std__map__Map_iter_cb__ptr_const_char_c__ptr_PackageDef_ce_(&((litaC_this->packages)));litaC_std__map__MapIterator_hasNext_cb__ptr_const_char_c__ptr_PackageDef_ce_(&((litaC_it)));) {
        {
            litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_PackageDef_ce_ litaC_entry = litaC_std__map__MapIterator_next_cb__ptr_const_char_c__ptr_PackageDef_ce_(&((litaC_it)));
            litaC_std__string_view__StringView litaC_fullPkgPath = litaC_std__string_view__StringViewInit(litaC_entry.value->path, -(1));
            if(litaC_std__string_view__StringView_startsWith(litaC_fullPkgPath, litaC_this->options.projectPath, litaC_len, 0)) {
                {
                    litaC_fullPkgPath = litaC_std__string_view__StringView_substring(litaC_fullPkgPath, litaC_len, -(1));
                    
                    
                }
                
            } 
            
            litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_buildFile->pkgPaths)), litaC_std__string__StringClone(litaC_fullPkgPath.buffer, litaC_fullPkgPath.length, litaC_this->allocator));
            
            
        }
    }
    return litaC_pkg_mgr__PkgStatus_OK;
    
    
}


litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__PackageManager_runCommand(litaC_pkg_mgr__PackageManager* litaC_this,const litaC_char* litaC_cmd) {
    
    litaC_pkg_mgr__PkgStatus litaC_status = litaC_pkg_mgr__PackageManager_readProjectPkg(litaC_this);
    if(litaC_status != litaC_pkg_mgr__PkgStatus_OK) {
        {
            {
                litaC_pkg_mgr__PkgStatus ___result = litaC_status;
                litaC_pkg_mgr__PackageManager_printMessages(litaC_this);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    {
        litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__pkg_run__PackageRun(litaC_this, litaC_cmd);
        litaC_pkg_mgr__PackageManager_printMessages(litaC_this);
        return ___result;
        
    }
    
    litaC_pkg_mgr__PackageManager_printMessages(litaC_this);
    
}

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__PackageManager_readProjectPkg(litaC_pkg_mgr__PackageManager* litaC_this) {
    litaC_char litaC_temp[_MAX_PATH] = {0};
    litaC_std__string__String litaC_pkgDef = litaC_std__string__StringInit(litaC_temp, _MAX_PATH, 0);
    litaC_std__string__String_format(&((litaC_pkgDef)), "%s/pkg.json", litaC_std__system__CurrentWorkingPath());
    if(!(litaC_std__system__FileExists(litaC_std__string__String_cStr(litaC_pkgDef)))) {
        {
            litaC_std__string_buffer__StringBuffer_append(&((litaC_this->errors)), "could not find '%s'\n", litaC_std__string__String_cStr(litaC_pkgDef));
            return litaC_pkg_mgr__PkgStatus_ERROR_NO_PROJECT_PKG_FOUND;
            
            
            
        }
        
    } 
    
    if(litaC_pkg_mgr__pkg__ParsePackageFile(litaC_this, litaC_std__string__String_cStr(litaC_pkgDef), &(litaC_this->pkg)) != litaC_pkg_mgr__PkgStatus_OK) {
        {
            litaC_std__string_buffer__StringBuffer_append(&((litaC_this->errors)), "could not parse pkg.json\n");
            return litaC_pkg_mgr__PkgStatus_ERROR_PARSING_PKG_JSON;
            
            
            
        }
        
    } 
    
    litaC_std__string__String litaC_pkgPath = litaC_std__string__StringInit(litaC_this->pkg->path, _MAX_PATH, 0);
    litaC_std__string__String_format(&((litaC_pkgPath)), "%s/src", litaC_std__system__CurrentWorkingPath());
    litaC_std__string__String_cStr(litaC_pkgPath);
    return litaC_pkg_mgr__PkgStatus_OK;
    
    
}

litaC_void litaC_pkg_mgr__pkg__PackageDef_free(litaC_pkg_mgr__pkg__PackageDef* litaC_this) {
    litaC_std__array__Array_free_cb_PackageId_ce_(&((litaC_this->dependencies)));
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_const_char_ce_(&((litaC_this->dynamicLibraries)));litaC_i += 1) {
        {
            const litaC_char* litaC_lib = litaC_std__array__Array_get_cb__ptr_const_char_ce_(&((litaC_this->dynamicLibraries)), litaC_i);
            litaC_std__mem__Allocator_free(litaC_this->dynamicLibraries.alloc, (litaC_void*)litaC_lib);
            
            
        }
    }
    litaC_std__array__Array_free_cb__ptr_const_char_ce_(&((litaC_this->dynamicLibraries)));
    litaC_std__json__JsonNode_free(litaC_this->json);
    
}

litaC_std__string_view__StringView litaC_pkg_mgr__pkg__PackageId_repo(litaC_pkg_mgr__pkg__PackageId* litaC_this) {
    return litaC_std__string_view__StringViewInit(litaC_this->id + litaC_this->repoOffset, litaC_this->repoLength);
    
    
}

litaC_std__string_view__StringView litaC_pkg_mgr__pkg__PackageId_name(litaC_pkg_mgr__pkg__PackageId* litaC_this) {
    return litaC_std__string_view__StringViewInit(litaC_this->id + litaC_this->nameOffset, litaC_this->nameLength);
    
    
}

litaC_std__string_view__StringView litaC_pkg_mgr__pkg__PackageId_version(litaC_pkg_mgr__pkg__PackageId* litaC_this) {
    return litaC_std__string_view__StringViewInit(litaC_this->id + litaC_this->versionOffset, litaC_this->versionLength);
    
    
}

litaC_bool litaC_pkg_mgr__pkg__PackageIdFromString(const litaC_char* litaC_id,litaC_pkg_mgr__pkg__PackageId* litaC_pkgId) {
    litaC_std__string_view__StringView litaC_view = litaC_std__string_view__StringViewInit(litaC_id, -(1));
    litaC_i32 litaC_nameIndex = litaC_std__string_view__StringView_indexOfAt(litaC_view, litaC_pkg_mgr__pkg__SEPARATOR, litaC_pkg_mgr__pkg__SEPARATOR_LENGTH, 0);
    if(litaC_nameIndex < 0) {
        {
            goto invalid;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_versionIndex = litaC_std__string_view__StringView_indexOfAt(litaC_view, litaC_pkg_mgr__pkg__SEPARATOR, litaC_pkg_mgr__pkg__SEPARATOR_LENGTH, litaC_nameIndex + 1);
    if(litaC_versionIndex < 0) {
        {
            goto invalid;
            
            
            
        }
        
    } 
    
    litaC_std__string__StringCopy(litaC_id, litaC_pkgId->id, _MAX_PATH);
    litaC_pkgId->repoOffset = 0;
    litaC_pkgId->repoLength = litaC_nameIndex;
    litaC_pkgId->nameOffset = litaC_nameIndex + 1;
    litaC_pkgId->nameLength = litaC_versionIndex - litaC_nameIndex - 1;
    litaC_pkgId->versionOffset = litaC_versionIndex + 1;
    litaC_pkgId->versionLength = litaC_view.length - litaC_versionIndex - 1;
    return litaC_true;
    
    invalid:;
    
    return litaC_false;
    
    
}

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg__ParsePackageFile(litaC_pkg_mgr__PackageManager* litaC_pm,const litaC_char* litaC_pkgFile,litaC_pkg_mgr__pkg__PackageDef** litaC_result) {
    litaC_std__json__JsonParser litaC_parser =  {
        
    };
    litaC_std__json__JsonParser_init(&((litaC_parser)), litaC_pm->allocator);
    
    litaC_char* litaC_data = NULL;
    litaC_usize litaC_length = {0};
    
    if(litaC_std__io__ReadFile(litaC_pkgFile, &(litaC_data), &(litaC_length), litaC_pm->allocator) != litaC_std__io__FileStatus_Ok) {
        {
            {
                litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_ERROR_READING_PKG_FILE;
                litaC_std__mem__Allocator_free(litaC_pm->allocator, litaC_data);
                litaC_std__json__JsonParser_free(&((litaC_parser)));
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_std__json__JsonNode* litaC_node = litaC_std__json__JsonParser_parseJson(&((litaC_parser)), litaC_data);
    if(litaC_std__json__JsonParser_hasError(&((litaC_parser)))) {
        {
            if(litaC_node) {
                {
                    litaC_std__json__JsonNode_free(litaC_node);
                    
                    
                }
                
            } 
            
            {
                litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_ERROR_PARSING_PKG_JSON;
                litaC_std__mem__Allocator_free(litaC_pm->allocator, litaC_data);
                litaC_std__json__JsonParser_free(&((litaC_parser)));
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_pkg_mgr__PkgStatus litaC_status = litaC_pkg_mgr__pkg__ParsePackage(litaC_pm, litaC_node, litaC_result);
    if(litaC_status != litaC_pkg_mgr__PkgStatus_OK) {
        {
            if(litaC_node) {
                {
                    litaC_std__json__JsonNode_free(litaC_node);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    {
        litaC_pkg_mgr__PkgStatus ___result = litaC_status;
        litaC_std__mem__Allocator_free(litaC_pm->allocator, litaC_data);
        litaC_std__json__JsonParser_free(&((litaC_parser)));
        return ___result;
        
    }
    
    litaC_std__mem__Allocator_free(litaC_pm->allocator, litaC_data);
    litaC_std__json__JsonParser_free(&((litaC_parser)));
    
}

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg__ParsePackage(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_std__json__JsonNode* litaC_json,litaC_pkg_mgr__pkg__PackageDef** litaC_result) {
    if(!(litaC_json)) {
        {
            return litaC_pkg_mgr__PkgStatus_ERROR_READING_PKG_FILE;
            
            
            
        }
        
    } 
    
    litaC_pkg_mgr__pkg__PackageId litaC_pkgId =  {
        
    };
    litaC_pkg_mgr__PkgStatus litaC_code = litaC_pkg_mgr__pkg__ParsePackageId(litaC_json, &(litaC_pkgId), litaC_pm->allocator);
    if(litaC_code != litaC_pkg_mgr__PkgStatus_OK) {
        {
            return litaC_code;
            
            
            
        }
        
    } 
    
    if(litaC_std__map__Map_contains_cb__ptr_const_char_c__ptr_PackageDef_ce_(&((litaC_pm->packages)), litaC_pkgId.id)) {
        {
            *(litaC_result) = litaC_std__map__Map_get_cb__ptr_const_char_c__ptr_PackageDef_ce_(&((litaC_pm->packages)), litaC_pkgId.id);
            return litaC_pkg_mgr__PkgStatus_OK;
            
            
            
        }
        
    } 
    
    litaC_pkg_mgr__pkg__PackageDef* litaC_pkg = litaC_std__mem__new_cb_PackageDef_ce_(litaC_pm->allocator);
    memset(litaC_pkg, 0, sizeof(litaC_pkg_mgr__pkg__PackageDef));
    litaC_pkg->id = litaC_pkgId;
    litaC_pkg->json = litaC_json;
    litaC_std__map__Map_put_cb__ptr_const_char_c__ptr_PackageDef_ce_(&((litaC_pm->packages)), litaC_pkgId.id, litaC_pkg);
    const litaC_char* litaC_type = litaC_std__json__JsonNode_getStr(litaC_json, "type", "source");
    litaC_std__json__JsonNode* litaC_deps = litaC_std__json__JsonNode_getArray(litaC_json, "dependencies");
    if(litaC_deps && litaC_std__json__JsonNode_size(litaC_deps) > 0) {
        {
            litaC_std__array__Array_init_cb_PackageId_ce_(&((litaC_pkg->dependencies)), litaC_std__json__JsonNode_size(litaC_deps), litaC_pm->allocator);
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__json__JsonNode_size(litaC_deps);litaC_i += 1) {
                {
                    litaC_std__json__JsonNode* litaC_depNode = litaC_std__json__JsonNode_at(litaC_deps, litaC_i);
                    litaC_std__array__Array_add_cb_PackageId_ce_(&((litaC_pkg->dependencies)), (litaC_pkg_mgr__pkg__PackageId) {
                        
                    });
                    litaC_pkg_mgr__pkg__PackageId* litaC_pkgId = litaC_std__array__Array_getPtr_cb_PackageId_ce_(&((litaC_pkg->dependencies)), litaC_i);
                    litaC_pkg_mgr__PkgStatus litaC_code = litaC_pkg_mgr__pkg__ParsePackageId(litaC_depNode, litaC_pkgId, litaC_pm->allocator);
                    if(litaC_code != litaC_pkg_mgr__PkgStatus_OK) {
                        {
                            return litaC_code;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } 
    
    litaC_std__json__JsonNode* litaC_dyLibs = litaC_std__json__JsonNode_getArray(litaC_json, "dynamic_libraries");
    if(litaC_dyLibs && litaC_std__json__JsonNode_size(litaC_dyLibs) > 0) {
        {
            litaC_std__array__Array_init_cb__ptr_const_char_ce_(&((litaC_pkg->dynamicLibraries)), litaC_std__json__JsonNode_size(litaC_dyLibs), litaC_pm->allocator);
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__json__JsonNode_size(litaC_dyLibs);litaC_i += 1) {
                {
                    litaC_std__json__JsonNode* litaC_dyLibNode = litaC_std__json__JsonNode_at(litaC_dyLibs, litaC_i);
                    if(litaC_dyLibNode && litaC_std__json__JsonNode_isString(litaC_dyLibNode)) {
                        {
                            litaC_std__string_buffer__StringBuffer litaC_path = litaC_std__string_buffer__StringBufferInit(_MAX_PATH, litaC_pm->allocator);
                            litaC_std__string_buffer__StringBuffer_append(&((litaC_path)), "%s", litaC_std__json__JsonNode_asString(litaC_dyLibNode));
                            litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_pkg->dynamicLibraries)), litaC_std__string_buffer__StringBuffer_cStr(&((litaC_path))));
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
            }
            
            
        }
        
    } 
    
    (*(litaC_result)) = litaC_pkg;
    return litaC_pkg_mgr__PkgStatus_OK;
    
    
}

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg__ParsePackageId(litaC_std__json__JsonNode* litaC_json,litaC_pkg_mgr__pkg__PackageId* litaC_pkgId,const litaC_std__mem__Allocator* litaC_allocator) {
    if(!(litaC_json)) {
        {
            return litaC_pkg_mgr__PkgStatus_ERROR_PARSING_PKG_JSON;
            
            
            
        }
        
    } 
    
    const litaC_char* litaC_repo = litaC_std__json__JsonNode_getStr(litaC_json, "repo", NULL);
    if(!(litaC_repo)) {
        return litaC_pkg_mgr__PkgStatus_ERROR_PARSING_PKG_JSON;
        
        
    } 
    
    const litaC_char* litaC_name = litaC_std__json__JsonNode_getStr(litaC_json, "name", NULL);
    if(!(litaC_name)) {
        return litaC_pkg_mgr__PkgStatus_ERROR_PARSING_PKG_JSON;
        
        
    } 
    
    const litaC_char* litaC_version = litaC_std__json__JsonNode_getStr(litaC_json, "version", NULL);
    if(!(litaC_version)) {
        return litaC_pkg_mgr__PkgStatus_ERROR_PARSING_PKG_JSON;
        
        
    } 
    
    litaC_i32 litaC_repoLen = strlen(litaC_repo);
    litaC_i32 litaC_nameLen = strlen(litaC_name);
    litaC_i32 litaC_versionLen = strlen(litaC_version);
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(litaC_repoLen + litaC_nameLen + litaC_versionLen + (litaC_pkg_mgr__pkg__SEPARATOR_LENGTH * 2) + 1, litaC_allocator);
    
    litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "%s%s%s%s%s", litaC_repo, litaC_pkg_mgr__pkg__SEPARATOR, litaC_name, litaC_pkg_mgr__pkg__SEPARATOR, litaC_version);
    litaC_char* litaC_id = litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb)));
    litaC_pkg_mgr__pkg__PackageIdFromString(litaC_std__string_buffer__StringBuffer_cStr(&((litaC_sb))), litaC_pkgId);
    {
        litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_OK;
        litaC_std__string_buffer__StringBuffer_free(&((litaC_sb)));
        return ___result;
        
    }
    
    litaC_std__string_buffer__StringBuffer_free(&((litaC_sb)));
    
}

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_install__PackageInstall(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_pkg_mgr__PackageInstallOptions litaC_options) {
    if(!(litaC_pm->pkg)) {
        {
            return litaC_pkg_mgr__PkgStatus_OK;
            
            
            
        }
        
    } 
    
    litaC_std__system__Mkdir(litaC_pm->options.pkgDir);
    if(!(litaC_std__system__FileExists(litaC_pm->options.pkgDir))) {
        {
            return litaC_pkg_mgr__PkgStatus_ERROR_CREATING_PKG_DIR;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_numOfPkgs = litaC_std__array__Array_size_cb_PackageId_ce_(&((litaC_pm->pkg->dependencies)));
    if(litaC_numOfPkgs < 1) {
        {
            return litaC_pkg_mgr__PkgStatus_OK;
            
            
            
        }
        
    } 
    
    if(litaC_options.fullSync) {
        {
            litaC_char litaC_temp[_MAX_PATH] = {0};
            litaC_std__string__String litaC_pkgPath = litaC_std__string__StringInit(litaC_temp, _MAX_PATH, 0);
            litaC_std__string__String_format(&((litaC_pkgPath)), "%s/%s", litaC_std__system__CurrentWorkingPath(), litaC_pm->options.pkgDir);
            litaC_pkg_mgr__PkgStatus litaC_status = litaC_pkg_mgr__pkg_install__cleanPackageDirectory(litaC_pm, litaC_std__string__String_cStr(litaC_pkgPath));
            if(litaC_status != litaC_pkg_mgr__PkgStatus_OK) {
                {
                    return litaC_status;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_std__array__Array_cb_PackageId_ce_ litaC_pkgsToInstall = litaC_std__array__ArrayInit_cb_PackageId_ce_(litaC_numOfPkgs, litaC_pm->allocator);
    
    litaC_pkg_mgr__PkgStatus litaC_findCode = litaC_pkg_mgr__pkg_install__findPackagesToInstall(litaC_pm, &(litaC_pkgsToInstall));
    if(litaC_findCode != litaC_pkg_mgr__PkgStatus_OK) {
        {
            {
                litaC_pkg_mgr__PkgStatus ___result = litaC_findCode;
                litaC_std__array__Array_free_cb_PackageId_ce_(&((litaC_pkgsToInstall)));
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_std__http__Http litaC_http =  {
        
    };
    litaC_std__http__Http_init(&((litaC_http)), &((litaC_options.httpOptions)), litaC_std__mem__defaultAllocator);
    
    litaC_char litaC_pkgPath[_MAX_PATH] = {0};
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb_PackageId_ce_(&((litaC_pkgsToInstall)));litaC_i += 1) {
        {
            litaC_pkg_mgr__pkg__PackageId litaC_pkgId = litaC_std__array__Array_get_cb_PackageId_ce_(&((litaC_pkgsToInstall)), litaC_i);
            litaC_pkg_mgr__PkgStatus litaC_status = litaC_pkg_mgr__pkg_install__makePackageDirectory(litaC_pm, &((litaC_pkgId)), litaC_pkgPath);
            if(litaC_status != litaC_pkg_mgr__PkgStatus_OK) {
                {
                    {
                        litaC_pkg_mgr__PkgStatus ___result = litaC_status;
                        litaC_std__http__Http_free(&((litaC_http)));
                        litaC_std__array__Array_free_cb_PackageId_ce_(&((litaC_pkgsToInstall)));
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            if(litaC_pkg_mgr__pkg_install__isPackageInstalled(litaC_pm, &((litaC_pkgId)), litaC_pkgPath)) {
                {
                    litaC_pkg_mgr__pkg__PackageDef* litaC_pkg = NULL;
                    litaC_pkg_mgr__PkgStatus litaC_status = litaC_pkg_mgr__pkg_install__readPackage(litaC_pm, &((litaC_pkgId)), litaC_pkgPath, &(litaC_pkg), &((litaC_pkgsToInstall)));
                    if(litaC_status != litaC_pkg_mgr__PkgStatus_OK) {
                        {
                            {
                                litaC_pkg_mgr__PkgStatus ___result = litaC_status;
                                litaC_std__http__Http_free(&((litaC_http)));
                                litaC_std__array__Array_free_cb_PackageId_ce_(&((litaC_pkgsToInstall)));
                                return ___result;
                                
                            }
                            
                            
                            
                        }
                        
                    } 
                    
                    continue;
                    
                    
                }
                
            } 
            
            litaC_status = litaC_pkg_mgr__pkg_install__cleanPackageDirectory(litaC_pm, litaC_pkgPath);
            if(litaC_status != litaC_pkg_mgr__PkgStatus_OK) {
                {
                    {
                        litaC_pkg_mgr__PkgStatus ___result = litaC_status;
                        litaC_std__http__Http_free(&((litaC_http)));
                        litaC_std__array__Array_free_cb_PackageId_ce_(&((litaC_pkgsToInstall)));
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            litaC_std__string__String litaC_pkgFile = litaC_std__string__StringInit(litaC_pkgPath, _MAX_PATH, -(1));
            litaC_std__string__String_appendStr(&((litaC_pkgFile)), "/pkg.zip");
            if(litaC_std__string_view__StringView_startsWith(litaC_pkg_mgr__pkg__PackageId_repo(&((litaC_pkgId))), "file://", -(1), 0)) {
                {
                    litaC_status = litaC_pkg_mgr__pkg_install__zipLocalPackage(litaC_pm, &((litaC_pkgId)), litaC_std__string__String_cStr(litaC_pkgFile));
                    
                    
                }
                
            } else {
                {
                    litaC_status = litaC_pkg_mgr__pkg_install__downloadPackage(litaC_pm, &(litaC_http), &((litaC_pkgId)), litaC_std__string__String_cStr(litaC_pkgFile));
                    
                    
                }
            } 
            
            if(litaC_status != litaC_pkg_mgr__PkgStatus_OK) {
                {
                    {
                        litaC_pkg_mgr__PkgStatus ___result = litaC_status;
                        litaC_std__http__Http_free(&((litaC_http)));
                        litaC_std__array__Array_free_cb_PackageId_ce_(&((litaC_pkgsToInstall)));
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            litaC_status = litaC_pkg_mgr__pkg_install__installPackage(litaC_pm, &((litaC_pkgId)), litaC_std__string__String_cStr(litaC_pkgFile), &((litaC_pkgsToInstall)));
            if(litaC_status != litaC_pkg_mgr__PkgStatus_OK) {
                {
                    {
                        litaC_pkg_mgr__PkgStatus ___result = litaC_status;
                        litaC_std__http__Http_free(&((litaC_http)));
                        litaC_std__array__Array_free_cb_PackageId_ce_(&((litaC_pkgsToInstall)));
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    {
        litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_OK;
        litaC_std__http__Http_free(&((litaC_http)));
        litaC_std__array__Array_free_cb_PackageId_ce_(&((litaC_pkgsToInstall)));
        return ___result;
        
    }
    
    litaC_std__http__Http_free(&((litaC_http)));
    litaC_std__array__Array_free_cb_PackageId_ce_(&((litaC_pkgsToInstall)));
    
}

litaC_bool litaC_pkg_mgr__pkg_install__isPackageInstalled(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_pkg_mgr__pkg__PackageId* litaC_pkgId,const litaC_char* litaC_pkgDir) {
    litaC_char litaC_temp[_MAX_PATH] = {0};
    litaC_std__string__String litaC_lockFile = litaC_std__string__StringInit(litaC_temp, _MAX_PATH, 0);
    litaC_std__string__String_format(&((litaC_lockFile)), "%s/%s", litaC_pkgDir, litaC_pkg_mgr__pkg_install__INSTALL_COMPLETED_FILE);
    if(litaC_std__system__FileExists(litaC_std__string__String_cStr(litaC_lockFile))) {
        {
            return litaC_true;
            
            
            
        }
        
    } 
    
    return litaC_false;
    
    
}

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_install__cleanPackageDirectory(litaC_pkg_mgr__PackageManager* litaC_pm,const litaC_char* litaC_pkgPath) {
    litaC_char litaC_temp[_MAX_PATH] = {0};
    litaC_std__string__String litaC_path = litaC_std__string__StringInit(litaC_temp, _MAX_PATH, 0);
    litaC_std__string__String_append(&((litaC_path)), "%s", litaC_pkgPath);
    return litaC_pkg_mgr__pkg_install__deleteDir(litaC_pm, &((litaC_path)));
    
    
}

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_install__deleteDir(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_std__string__String* litaC_path) {
    if(!(litaC_std__system__FileExists(litaC_std__string__String_cStr(*((litaC_path)))))) {
        {
            return litaC_pkg_mgr__PkgStatus_OK;
            
            
            
        }
        
    } 
    
    litaC_std__fs__FileHandle litaC_file = {0};
    if(!(litaC_std__fs__FileHandle_open(&((litaC_file)), litaC_std__string__String_cStr(*((litaC_path)))))) {
        {
            litaC_std__string_buffer__StringBuffer_append(&((litaC_pm->errors)), "unable to open: '%s'\n", litaC_std__string__String_cStr(*((litaC_path))));
            return litaC_pkg_mgr__PkgStatus_ERROR_CLEANING_PKG;
            
            
            
        }
        
    } 
    
    
    while(litaC_std__fs__FileHandle_next(&((litaC_file)))) {
        {
            litaC_i32 litaC_len = litaC_path->length;
            litaC_std__string__String_append(litaC_path, "/%s", litaC_std__fs__FileHandle_name(&((litaC_file))));
            
            if(litaC_std__fs__FileHandle_isDirectory(&((litaC_file)))) {
                {
                    if(litaC_pkg_mgr__pkg_install__deleteDir(litaC_pm, litaC_path) != litaC_pkg_mgr__PkgStatus_OK) {
                        {
                            litaC_std__string_buffer__StringBuffer_append(&((litaC_pm->errors)), "unable to delete directory: '%s'\n", litaC_std__string__String_cStr(*((litaC_path))));
                            {
                                litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_ERROR_CLEANING_PKG;
                                litaC_path->length = litaC_len;
                                litaC_std__fs__FileHandle_close(&((litaC_file)));
                                return ___result;
                                
                            }
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            if(!(litaC_std__system__FileDelete(litaC_std__string__String_cStr(*((litaC_path)))))) {
                {
                    litaC_std__string_buffer__StringBuffer_append(&((litaC_pm->errors)), "failed to delete: '%s'\n", litaC_std__string__String_cStr(*((litaC_path))));
                    {
                        litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_ERROR_CLEANING_PKG;
                        litaC_path->length = litaC_len;
                        litaC_std__fs__FileHandle_close(&((litaC_file)));
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            litaC_path->length = litaC_len;
            
            
        }
    }
    {
        litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_OK;
        litaC_std__fs__FileHandle_close(&((litaC_file)));
        return ___result;
        
    }
    
    litaC_std__fs__FileHandle_close(&((litaC_file)));
    
}

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_install__findPackagesToInstall(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_std__array__Array_cb_PackageId_ce_* litaC_pkgsToInstall) {
    if(litaC_pm->pkg) {
        {
            litaC_std__array__Array_addAll_cb_PackageId_ce_(litaC_pkgsToInstall, &((litaC_pm->pkg->dependencies)));
            
            
        }
        
    } 
    
    return litaC_pkg_mgr__PkgStatus_OK;
    
    
}

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_install__makePackageDirectory(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_pkg_mgr__pkg__PackageId* litaC_pkgId,litaC_char* litaC_output) {
    litaC_std__string__String litaC_pkgDirectory = litaC_std__string__StringInit(litaC_output, _MAX_PATH, 0);
    {
        litaC_std__string__String_format(&((litaC_pkgDirectory)), "%s/%s/", litaC_std__system__CurrentWorkingPath(), litaC_pm->options.pkgDir);
        litaC_std__system__Mkdir(litaC_std__string__String_cStr(litaC_pkgDirectory));
        
        
    }
    {
        litaC_std__string_view__StringView litaC_name = litaC_pkg_mgr__pkg__PackageId_name(litaC_pkgId);
        litaC_i32 litaC_len = litaC_pkgDirectory.length;
        litaC_std__string__String_append(&((litaC_pkgDirectory)), "%.*s/", litaC_name.length, litaC_name.buffer);
        litaC_char* litaC_sanitizedPath = litaC_std__string__String_cStr(litaC_pkgDirectory) + litaC_len;
        litaC_pkg_mgr__pkg_install__sanitizeFilename(litaC_sanitizedPath, litaC_sanitizedPath);
        litaC_std__system__Mkdir(litaC_std__string__String_cStr(litaC_pkgDirectory));
        
        
    }
    {
        litaC_std__string_view__StringView litaC_version = litaC_pkg_mgr__pkg__PackageId_version(litaC_pkgId);
        litaC_i32 litaC_len = litaC_pkgDirectory.length;
        litaC_std__string__String_append(&((litaC_pkgDirectory)), "%.*s", litaC_version.length, litaC_version.buffer);
        litaC_char* litaC_sanitizedPath = litaC_std__string__String_cStr(litaC_pkgDirectory) + litaC_len;
        litaC_pkg_mgr__pkg_install__sanitizeFilename(litaC_sanitizedPath, litaC_sanitizedPath);
        litaC_std__system__Mkdir(litaC_std__string__String_cStr(litaC_pkgDirectory));
        
        
    }
    litaC_char* litaC_path = litaC_std__string__String_cStr(litaC_pkgDirectory);
    litaC_std__system__Mkdir(litaC_path);
    if(!(litaC_std__system__FileExists(litaC_path))) {
        {
            return litaC_pkg_mgr__PkgStatus_ERROR_CREATING_PKG_DIR;
            
            
            
        }
        
    } 
    
    return litaC_pkg_mgr__PkgStatus_OK;
    
    
}

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_install__downloadPackage(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_std__http__Http* litaC_http,litaC_pkg_mgr__pkg__PackageId* litaC_pkgId,const litaC_char* litaC_pkgFile) {
    const litaC_char* litaC_uriTemplate = litaC_pkg_mgr__pkg_install__getRepoTemplate(litaC_pkgId);
    if(!(litaC_uriTemplate)) {
        {
            return litaC_pkg_mgr__PkgStatus_ERROR_INVALID_REPO;
            
            
            
        }
        
    } 
    
    litaC_char litaC_temp[_MAX_PATH] = {0};
    litaC_std__string__String litaC_uri = litaC_std__string__StringInit(litaC_temp, _MAX_PATH, 0);
    litaC_std__string_view__StringView litaC_repo = litaC_pkg_mgr__pkg__PackageId_repo(litaC_pkgId);
    litaC_std__string_view__StringView litaC_name = litaC_pkg_mgr__pkg__PackageId_name(litaC_pkgId);
    litaC_std__string_view__StringView litaC_version = litaC_pkg_mgr__pkg__PackageId_version(litaC_pkgId);
    litaC_std__string__String_format(&((litaC_uri)), litaC_uriTemplate, litaC_repo.length, litaC_repo.buffer, litaC_version.length, litaC_version.buffer);
    litaC_std__io__File litaC_file = {0};
    if(litaC_std__io__File_open(&((litaC_file)), litaC_pkgFile, litaC_std__io__FileOpenOp_WRITE_BINARY) != litaC_std__io__FileStatus_Ok) {
        {
            return litaC_pkg_mgr__PkgStatus_ERROR_UNABLE_TO_OPEN_FILE;
            
            
            
        }
        
    } 
    
    
    litaC_std__http__HttpResponse litaC_resp =  {
        .userdata = &(litaC_file),
        .bodyFn = litaC_pkg_mgr__pkg_install__httpCallback
    };
    litaC_std__http__Http_get(litaC_http, litaC_std__string__String_cStr(litaC_uri), &(litaC_resp));
    if(litaC_resp.statusCode < 200 || litaC_resp.statusCode > 299) {
        {
            litaC_std__string_buffer__StringBuffer_append(&((litaC_pm->errors)), "error returned http status code: %d for request '%s'\n", litaC_resp.statusCode, litaC_std__string__String_cStr(litaC_uri));
            {
                litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_ERROR_HTTP_STATUS;
                litaC_std__io__File_close(&((litaC_file)));
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    {
        litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_OK;
        litaC_std__io__File_close(&((litaC_file)));
        return ___result;
        
    }
    
    litaC_std__io__File_close(&((litaC_file)));
    
}

litaC_usize litaC_pkg_mgr__pkg_install__httpCallback(litaC_void* litaC_data,litaC_usize litaC_size,litaC_usize litaC_n,litaC_void* litaC_userdata) {
    litaC_std__io__File* litaC_file = (litaC_std__io__File*)litaC_userdata;
    if(!(litaC_file)) {
        {
            return 0;
            
            
            
        }
        
    } 
    
    if(litaC_std__io__File_writeBytes(litaC_file, (const litaC_char*)litaC_data, litaC_size * litaC_n) != litaC_std__io__FileStatus_Ok) {
        {
            return 0;
            
            
            
        }
        
    } 
    
    return litaC_size * litaC_n;
    
    
}

const litaC_char* litaC_pkg_mgr__pkg_install__getRepoTemplate(litaC_pkg_mgr__pkg__PackageId* litaC_pkgId) {
    if(!(litaC_pkgId)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_std__string_view__StringView litaC_repo = litaC_pkg_mgr__pkg__PackageId_repo(litaC_pkgId);
    if(litaC_std__string_view__StringView_startsWith(litaC_repo, "https://github.com", -(1), 0)) {
        {
            return "%.*s/archive/refs/tags/%.*s.zip";
            
            
            
        }
        
    } 
    
    return NULL;
    
    
}

litaC_char* litaC_pkg_mgr__pkg_install__sanitizeFilename(const litaC_char* litaC_filename,litaC_char* litaC_out) {
    if(!(litaC_filename)) {
        {
            goto end;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_len = strlen(litaC_filename);
    litaC_len = MIN(litaC_len, _MAX_PATH);
    litaC_i32 litaC_i = 0;
    for(;litaC_i < litaC_len;litaC_i += 1) {
        {
            litaC_char litaC_c = litaC_filename[litaC_i];
            if(!(isalnum(litaC_c)) && litaC_c != '/' && litaC_c != '.' && litaC_c != '-') {
                {
                    litaC_c = '_';
                    
                    
                }
                
            } 
            
            litaC_out[litaC_i] = litaC_c;
            
            
        }
    }
    end:;
    
    litaC_out[litaC_i] = '\0';
    return litaC_out;
    
    
}

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_install__installPackage(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_pkg_mgr__pkg__PackageId* litaC_pkgId,const litaC_char* litaC_pkgFile,litaC_std__array__Array_cb_PackageId_ce_* litaC_pkgsToInstall) {
    litaC_char litaC_pkgPath[_MAX_PATH] = {0};
    litaC_std__system__FilePath(litaC_pkgFile, litaC_pkgPath);
    {
        litaC_std__zip__ZipFile litaC_zip = {0};
        {
            
            
        }
        
        if(litaC_std__zip__ZipFile_open(&((litaC_zip)), litaC_pkgFile, litaC_std__zip__ZipOpen_READ, litaC_pm->allocator) != litaC_std__zip__ZipStatus_OK) {
            {
                {
                    litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_ERROR_UNABLE_TO_OPEN_PKG_FILE;
                    {
                        litaC_std__zip__ZipFile_close(&((litaC_zip)));
                        litaC_std__system__FileDelete(litaC_pkgFile);
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
        } 
        
        litaC_std__array__Array_cb__ptr_const_char_ce_ litaC_extractedFiles = litaC_std__array__ArrayInit_cb__ptr_const_char_ce_(64, litaC_pm->allocator);
        
        if(litaC_std__zip__ZipFile_unzip(&((litaC_zip)), litaC_pkgPath, &(litaC_extractedFiles), 0) != litaC_std__zip__ZipStatus_OK) {
            {
                {
                    litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_ERROR_UNABLE_TO_EXTRACT_PKG_FILE;
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_const_char_ce_(&((litaC_extractedFiles)));litaC_i += 1) {
                            {
                                const litaC_char* litaC_file = litaC_std__array__Array_get_cb__ptr_const_char_ce_(&((litaC_extractedFiles)), litaC_i);
                                litaC_std__mem__Allocator_free(litaC_pm->allocator, (litaC_void*)litaC_file);
                                
                                
                            }
                        }
                        litaC_std__array__Array_free_cb__ptr_const_char_ce_(&((litaC_extractedFiles)));
                        
                        
                    };
                    {
                        litaC_std__zip__ZipFile_close(&((litaC_zip)));
                        litaC_std__system__FileDelete(litaC_pkgFile);
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
        } 
        
        if(litaC_pkg_mgr__pkg_install__dealWithGithubBS(litaC_pkgPath, &(litaC_extractedFiles)) != litaC_pkg_mgr__PkgStatus_OK) {
            {
                {
                    litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_ERROR_UNABLE_TO_EXTRACT_PKG_FILE;
                    {
                        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_const_char_ce_(&((litaC_extractedFiles)));litaC_i += 1) {
                            {
                                const litaC_char* litaC_file = litaC_std__array__Array_get_cb__ptr_const_char_ce_(&((litaC_extractedFiles)), litaC_i);
                                litaC_std__mem__Allocator_free(litaC_pm->allocator, (litaC_void*)litaC_file);
                                
                                
                            }
                        }
                        litaC_std__array__Array_free_cb__ptr_const_char_ce_(&((litaC_extractedFiles)));
                        
                        
                    };
                    {
                        litaC_std__zip__ZipFile_close(&((litaC_zip)));
                        litaC_std__system__FileDelete(litaC_pkgFile);
                        
                        
                    };
                    return ___result;
                    
                }
                
                
                
            }
            
        } 
        
        {
            for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_const_char_ce_(&((litaC_extractedFiles)));litaC_i += 1) {
                {
                    const litaC_char* litaC_file = litaC_std__array__Array_get_cb__ptr_const_char_ce_(&((litaC_extractedFiles)), litaC_i);
                    litaC_std__mem__Allocator_free(litaC_pm->allocator, (litaC_void*)litaC_file);
                    
                    
                }
            }
            litaC_std__array__Array_free_cb__ptr_const_char_ce_(&((litaC_extractedFiles)));
            
            
        };
        {
            litaC_std__zip__ZipFile_close(&((litaC_zip)));
            litaC_std__system__FileDelete(litaC_pkgFile);
            
            
        };
        
        
    }
    litaC_pkg_mgr__pkg__PackageDef* litaC_pkg = NULL;
    litaC_pkg_mgr__PkgStatus litaC_status = litaC_pkg_mgr__pkg_install__readPackage(litaC_pm, litaC_pkgId, litaC_pkgPath, &(litaC_pkg), litaC_pkgsToInstall);
    if(litaC_status != litaC_pkg_mgr__PkgStatus_OK) {
        {
            return litaC_status;
            
            
            
        }
        
    } 
    
    {
        litaC_char litaC_temp1[_MAX_PATH] = {0};
        litaC_std__string__String litaC_libPath = litaC_std__string__StringInit(litaC_temp1, _MAX_PATH, 0);
        litaC_char litaC_temp2[_MAX_PATH] = {0};
        litaC_std__string__String litaC_destPath = litaC_std__string__StringInit(litaC_temp2, _MAX_PATH, 0);
        for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_const_char_ce_(&((litaC_pkg->dynamicLibraries)));litaC_i += 1) {
            {
                const litaC_char* litaC_lib = litaC_std__array__Array_get_cb__ptr_const_char_ce_(&((litaC_pkg->dynamicLibraries)), litaC_i);
                litaC_std__string__String_format(&((litaC_libPath)), "%s/pkg/bin/%s", litaC_pkgPath, litaC_lib);
                if(!(litaC_std__system__FileExists(litaC_std__string__String_cStr(litaC_libPath)))) {
                    {
                        litaC_std__string_buffer__StringBuffer_append(&((litaC_pm->warnings)), "missing dynamic library: '%s'\n", litaC_std__string__String_cStr(litaC_libPath));
                        continue;
                        
                        
                    }
                    
                } 
                
                litaC_std__string__String_format(&((litaC_destPath)), "%s/bin/%s", litaC_pm->options.projectPath, litaC_lib);
                if(!(litaC_std__system__FileMove(litaC_std__string__String_cStr(litaC_libPath), litaC_std__string__String_cStr(litaC_destPath)))) {
                    {
                        litaC_std__string_buffer__StringBuffer_append(&((litaC_pm->warnings)), "unable to move dynamic library '%s' to '%s'\n", litaC_std__string__String_cStr(litaC_libPath), litaC_std__string__String_cStr(litaC_destPath));
                        
                        
                    }
                    
                } 
                
                
                
            }
        }
        
        
    }
    {
        litaC_std__string__String litaC_pkgLck = litaC_std__string__StringInit(litaC_pkgPath, _MAX_PATH, -(1));
        litaC_std__string__String_append(&((litaC_pkgLck)), "/%s", litaC_pkg_mgr__pkg_install__INSTALL_COMPLETED_FILE);
        litaC_std__io__File litaC_lockFile =  {
            
        };
        litaC_std__io__File_open(&((litaC_lockFile)), litaC_std__string__String_cStr(litaC_pkgLck), litaC_std__io__FileOpenOp_WRITE);
        litaC_std__io__File_close(&((litaC_lockFile)));
        
        
    }
    return litaC_pkg_mgr__PkgStatus_OK;
    
    
}

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_install__readPackage(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_pkg_mgr__pkg__PackageId* litaC_pkgId,const litaC_char* litaC_pkgPath,litaC_pkg_mgr__pkg__PackageDef** litaC_resultPkg,litaC_std__array__Array_cb_PackageId_ce_* litaC_pkgsToInstall) {
    litaC_std__string_view__StringView litaC_name = litaC_pkg_mgr__pkg__PackageId_name(litaC_pkgId);
    litaC_std__string_view__StringView litaC_version = litaC_pkg_mgr__pkg__PackageId_version(litaC_pkgId);
    litaC_char litaC_temp[_MAX_PATH] = {0};
    litaC_std__string__String litaC_pkgDef = litaC_std__string__StringInit(litaC_temp, _MAX_PATH, 0);
    litaC_std__string__String_format(&((litaC_pkgDef)), "%s/pkg/pkg.json", litaC_pkgPath);
    if(!(litaC_std__system__FileExists(litaC_std__string__String_cStr(litaC_pkgDef)))) {
        {
            return litaC_pkg_mgr__PkgStatus_ERROR_UNABLE_TO_OPEN_PKG_FILE;
            
            
            
        }
        
    } 
    
    if(litaC_pkg_mgr__pkg__ParsePackageFile(litaC_pm, litaC_std__string__String_cStr(litaC_pkgDef), litaC_resultPkg) != litaC_pkg_mgr__PkgStatus_OK) {
        {
            return litaC_pkg_mgr__PkgStatus_ERROR_PARSING_PKG_JSON;
            
            
            
        }
        
    } 
    
    litaC_pkg_mgr__pkg__PackageDef* litaC_pkg = (*(litaC_resultPkg));
    litaC_std__string__String litaC_srcPath = litaC_std__string__StringInit(litaC_pkg->path, _MAX_PATH, 0);
    litaC_std__string__String_format(&((litaC_srcPath)), "%s/pkg/src", litaC_pkgPath);
    litaC_std__string__String_cStr(litaC_srcPath);
    if(!(litaC_std__array__Array_empty_cb_PackageId_ce_(&((litaC_pkg->dependencies))))) {
        {
            litaC_std__array__Array_addAll_cb_PackageId_ce_(litaC_pkgsToInstall, &((litaC_pkg->dependencies)));
            
            
        }
        
    } 
    
    return litaC_pkg_mgr__PkgStatus_OK;
    
    
}

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_install__dealWithGithubBS(const litaC_char* litaC_pkgPath,litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_extractedFiles) {
    if(litaC_std__array__Array_size_cb__ptr_const_char_ce_(litaC_extractedFiles) < 1) {
        {
            return litaC_pkg_mgr__PkgStatus_OK;
            
            
            
        }
        
    } 
    
    litaC_char litaC_temp1[_MAX_PATH] = {0};
    litaC_std__string__String litaC_srcPath = litaC_std__string__StringInit(litaC_temp1, _MAX_PATH, 0);
    litaC_char litaC_temp2[_MAX_PATH] = {0};
    litaC_std__string__String litaC_destPath = litaC_std__string__StringInit(litaC_temp2, _MAX_PATH, 0);
    const litaC_char* litaC_root = litaC_std__array__Array_get_cb__ptr_const_char_ce_(litaC_extractedFiles, 0);
    litaC_i32 litaC_rootLength = strlen(litaC_root);
    litaC_std__string__String_format(&((litaC_srcPath)), "%s/%s", litaC_pkgPath, litaC_root);
    litaC_std__string__String_format(&((litaC_destPath)), "%s/pkg", litaC_pkgPath);
    if(litaC_std__system__FileExists(litaC_std__string__String_cStr(litaC_destPath))) {
        {
            return litaC_pkg_mgr__PkgStatus_OK;
            
            
            
        }
        
    } 
    
    if(!(litaC_std__system__FileMove(litaC_std__string__String_cStr(litaC_srcPath), litaC_std__string__String_cStr(litaC_destPath)))) {
        {
            return litaC_pkg_mgr__PkgStatus_ERROR_UNABLE_TO_PROCESS_PKG_FILE;
            
            
            
        }
        
    } 
    
    return litaC_pkg_mgr__PkgStatus_OK;
    
    
}

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_install__zipLocalPackage(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_pkg_mgr__pkg__PackageId* litaC_pkgId,const litaC_char* litaC_pkgFile) {
    litaC_std__zip__ZipFile litaC_zip = {0};
    {
        
        
    }
    
    if(litaC_std__zip__ZipFile_open(&((litaC_zip)), litaC_pkgFile, litaC_std__zip__ZipOpen_WRITE, litaC_pm->allocator) != litaC_std__zip__ZipStatus_OK) {
        {
            {
                litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_ERROR_OPENING_LOCAL_FILE_PKG;
                litaC_std__zip__ZipFile_close(&((litaC_zip)));
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    
#define litaC_len (7)
    litaC_std__string_view__StringView litaC_basePath = litaC_std__string_view__StringView_substring(litaC_pkg_mgr__pkg__PackageId_repo(litaC_pkgId), 7, -(1));
    if(litaC_std__zip__ZipFile_zipDir(&((litaC_zip)), litaC_basePath.buffer, litaC_basePath.length, "pkg", litaC_std__zip__ZipCompressionLevel_DEFAULT_LEVEL) != litaC_std__zip__ZipStatus_OK) {
        {
            {
                litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_ERROR_WRITING_LOCAL_FILE_PKG;
                litaC_std__zip__ZipFile_close(&((litaC_zip)));
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    if(litaC_std__zip__ZipFile_finalize(&((litaC_zip))) != litaC_std__zip__ZipStatus_OK) {
        {
            {
                litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_ERROR_FINALIZING_LOCAL_FILE_PKG;
                litaC_std__zip__ZipFile_close(&((litaC_zip)));
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    {
        litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_OK;
        litaC_std__zip__ZipFile_close(&((litaC_zip)));
        return ___result;
        
    }
    
    litaC_std__zip__ZipFile_close(&((litaC_zip)));
    #undef litaC_len
    
}

litaC_void* litaC_std__zip__ZipFileAlloc(litaC_void* litaC_opaque,litaC_usize litaC_items,litaC_usize litaC_size) {
    const litaC_std__mem__Allocator* litaC_allocator = (const litaC_std__mem__Allocator*)litaC_opaque;
    if(!(litaC_allocator)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    return litaC_std__mem__Allocator_alloc(litaC_allocator, litaC_items * litaC_size);
    
    
}

litaC_void* litaC_std__zip__ZipFileReAlloc(litaC_void* litaC_opaque,litaC_void* litaC_address,litaC_usize litaC_old_items,litaC_usize litaC_old_size,litaC_usize litaC_items,litaC_usize litaC_size) {
    const litaC_std__mem__Allocator* litaC_allocator = (const litaC_std__mem__Allocator*)litaC_opaque;
    if(!(litaC_allocator)) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    return litaC_std__mem__Allocator_realloc(litaC_allocator, litaC_address, litaC_old_items * litaC_old_size, litaC_items * litaC_size);
    
    
}

litaC_void litaC_std__zip__ZipFileFree(litaC_void* litaC_opaque,litaC_void* litaC_address) {
    const litaC_std__mem__Allocator* litaC_allocator = (const litaC_std__mem__Allocator*)litaC_opaque;
    if(!(litaC_allocator)) {
        {
            return;
            
            
            
        }
        
    } 
    
    litaC_std__mem__Allocator_free(litaC_allocator, litaC_address);
    
}

litaC_std__zip__ZipStatus litaC_std__zip__ZipFile_open(litaC_std__zip__ZipFile* litaC_this,const litaC_char* litaC_filename,litaC_std__zip__ZipOpen litaC_type,const litaC_std__mem__Allocator* litaC_allocator) {
    memset(&(litaC_this->archive), 0, sizeof(mz_zip_archive));
    litaC_this->type = litaC_type;
    litaC_this->allocator = litaC_allocator;
    litaC_this->archive.m_pAlloc = litaC_std__zip__ZipFileAlloc;
    litaC_this->archive.m_pFree = litaC_std__zip__ZipFileFree;
    litaC_this->archive.m_pRealloc = litaC_std__zip__ZipFileReAlloc;
    litaC_this->archive.m_pAlloc_opaque = (litaC_void*)litaC_allocator;
    if(litaC_type == litaC_std__zip__ZipOpen_READ) {
        {
            litaC_bool litaC_status = mz_zip_reader_init_file(&(litaC_this->archive), litaC_filename, 0);
            if(!(litaC_status)) {
                {
                    return litaC_std__zip__ZipStatus_ERROR_UNABLE_TO_OPEN_FILE;
                    
                    
                    
                }
                
            } 
            
            
            
        }
        
    } else {
        {
            litaC_bool litaC_status = mz_zip_writer_init_file(&(litaC_this->archive), litaC_filename, 0);
            if(!(litaC_status)) {
                {
                    return litaC_std__zip__ZipStatus_ERROR_UNABLE_TO_OPEN_FILE;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    } 
    
    return litaC_std__zip__ZipStatus_OK;
    
    
}

litaC_std__zip__ZipStatus litaC_std__zip__ZipFile_close(litaC_std__zip__ZipFile* litaC_this) {
    if(litaC_this->type == litaC_std__zip__ZipOpen_WRITE) {
        {
            if(!(mz_zip_writer_end(&(litaC_this->archive)))) {
                {
                    return litaC_std__zip__ZipStatus_ERROR_CLOSING;
                    
                    
                    
                }
                
            } 
            
            return litaC_std__zip__ZipStatus_OK;
            
            
            
        }
        
    } 
    
    if(!(mz_zip_end(&(litaC_this->archive)))) {
        {
            return litaC_std__zip__ZipStatus_ERROR_CLOSING;
            
            
            
        }
        
    } 
    
    return litaC_std__zip__ZipStatus_OK;
    
    
}


litaC_std__zip__ZipStatus litaC_std__zip__ZipFile_finalize(litaC_std__zip__ZipFile* litaC_this) {
    if(!(mz_zip_writer_finalize_archive(&(litaC_this->archive)))) {
        {
            return litaC_std__zip__ZipStatus_ERROR_FINALIZING;
            
            
            
        }
        
    } 
    
    return litaC_std__zip__ZipStatus_OK;
    
    
}

litaC_bool litaC_std__zip__ZipFile_isValid(litaC_std__zip__ZipFile* litaC_this) {
    return mz_zip_validate_archive(&(litaC_this->archive), 0);
    
    
}

const litaC_char* litaC_std__zip__ZipFile_getLastError(litaC_std__zip__ZipFile* litaC_this) {
    return mz_zip_get_error_string(litaC_this->archive.m_last_error);
    
    
}

litaC_std__zip__ZipStatus litaC_std__zip__ZipFile_zipDir(litaC_std__zip__ZipFile* litaC_this,const litaC_char* litaC_pathToZip,litaC_i32 litaC_len,const litaC_char* litaC_baseName,litaC_std__zip__ZipCompressionLevel litaC_level) {
    litaC_std__string_view__StringView litaC_basePath = litaC_std__string_view__StringViewInit(litaC_pathToZip, litaC_len);
    litaC_char litaC_tempArch[_MAX_PATH] = {0};
    litaC_char litaC_tempPath[_MAX_PATH] = {0};
    litaC_std__string__String litaC_archiveName = litaC_std__string__StringInit(litaC_tempArch, _MAX_PATH, 0);
    litaC_std__string__String litaC_path = litaC_std__string__StringInit(litaC_tempPath, _MAX_PATH, 0);
    litaC_std__string__String_format(&((litaC_path)), "%.*s", litaC_basePath.length, litaC_basePath.buffer);
    return litaC_std__zip__ZipFile_zipFolder(litaC_this, litaC_baseName, &(litaC_basePath), &(litaC_archiveName), &(litaC_path), litaC_level);
    
    
}

litaC_std__zip__ZipStatus litaC_std__zip__ZipFile_zipFolder(litaC_std__zip__ZipFile* litaC_this,const litaC_char* litaC_baseName,litaC_std__string_view__StringView* litaC_basePath,litaC_std__string__String* litaC_archiveName,litaC_std__string__String* litaC_path,litaC_std__zip__ZipCompressionLevel litaC_level) {
    litaC_std__fs__FileHandle litaC_handle = {0};
    {
        
        
    }
    if(!(litaC_std__fs__FileHandle_openEx(&((litaC_handle)), litaC_path->buffer, litaC_path->length))) {
        {
            return litaC_std__zip__ZipStatus_ERROR_UNABLE_TO_OPEN_FILE;
            
            
            
        }
        
    } 
    
    
    while(litaC_std__fs__FileHandle_hasNext(&((litaC_handle)))) {
        {
            if(litaC_std__fs__FileHandle_isDirectory(&((litaC_handle)))) {
                {
                    litaC_i32 litaC_len = litaC_path->length;
                    litaC_std__string__String_append(litaC_path, "/%s", litaC_std__fs__FileHandle_name(&((litaC_handle))));
                    litaC_std__zip__ZipStatus litaC_status = litaC_std__zip__ZipFile_zipFolder(litaC_this, litaC_baseName, litaC_basePath, litaC_archiveName, litaC_path, litaC_level);
                    litaC_path->length = litaC_len;
                    if(litaC_status != litaC_std__zip__ZipStatus_OK) {
                        {
                            {
                                litaC_std__zip__ZipStatus ___result = litaC_status;
                                litaC_std__fs__FileHandle_close(&((litaC_handle)));
                                return ___result;
                                
                            }
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } else {
                {
                    litaC_std__string__String_format(litaC_archiveName, "%s%.*s/%s", litaC_baseName, litaC_path->length - litaC_basePath->length, litaC_path->buffer + litaC_basePath->length, litaC_std__fs__FileHandle_name(&((litaC_handle))));
                    litaC_i32 litaC_len = litaC_path->length;
                    litaC_std__string__String_append(litaC_path, "/%s", litaC_std__fs__FileHandle_name(&((litaC_handle))));
                    if(litaC_std__zip__ZipFile_addFile(litaC_this, litaC_std__string__String_cStr(*((litaC_archiveName))), litaC_std__string__String_cStr(*((litaC_path))), litaC_level) != litaC_std__zip__ZipStatus_OK) {
                        {
                            {
                                litaC_std__zip__ZipStatus ___result = litaC_std__zip__ZipStatus_ERROR_ADDING_FILE;
                                litaC_std__fs__FileHandle_close(&((litaC_handle)));
                                return ___result;
                                
                            }
                            
                            
                            
                        }
                        
                    } 
                    
                    litaC_path->length = litaC_len;
                    
                    
                }
            } 
            
            litaC_std__fs__FileHandle_next(&((litaC_handle)));
            
            
        }
    }
    {
        litaC_std__zip__ZipStatus ___result = litaC_std__zip__ZipStatus_OK;
        litaC_std__fs__FileHandle_close(&((litaC_handle)));
        return ___result;
        
    }
    
    litaC_std__fs__FileHandle_close(&((litaC_handle)));
    
}

litaC_std__zip__ZipStatus litaC_std__zip__ZipFile_addFile(litaC_std__zip__ZipFile* litaC_this,const litaC_char* litaC_archiveName,const litaC_char* litaC_filename,litaC_std__zip__ZipCompressionLevel litaC_level) {
    if(!(mz_zip_writer_add_file(&(litaC_this->archive), litaC_archiveName, litaC_filename, "", 0U, MZ_DEFAULT_COMPRESSION))) {
        {
            return litaC_std__zip__ZipStatus_ERROR_ADDING_FILE;
            
            
            
        }
        
    } 
    
    return litaC_std__zip__ZipStatus_OK;
    
    
}


litaC_std__zip__ZipStatus litaC_std__zip__ZipFile_unzip(litaC_std__zip__ZipFile* litaC_this,const litaC_char* litaC_dest,litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_extractedFiles,litaC_i32 litaC_flags) {
    litaC_i32 litaC_fileCount = mz_zip_reader_get_num_files(&(litaC_this->archive));
    if(litaC_fileCount == 0) {
        {
            return litaC_std__zip__ZipStatus_OK;
            
            
            
        }
        
    } 
    
    mz_zip_archive_file_stat litaC_fileStat = {0};
    if(!(mz_zip_reader_file_stat(&(litaC_this->archive), 0, &(litaC_fileStat)))) {
        {
            return litaC_std__zip__ZipStatus_ERROR_UNABLE_TO_STAT;
            
            
            
        }
        
    } 
    
    litaC_char litaC_temp[_MAX_PATH] = {0};
    litaC_char litaC_temp2[_MAX_PATH] = {0};
    litaC_std__string__String litaC_path = litaC_std__string__StringInit(litaC_temp, _MAX_PATH, 0);
    litaC_i32 litaC_baseLen = strlen(litaC_fileStat.m_filename);
    if((litaC_flags | litaC_std__zip__ZipFlags_INCLUDE_ZIPFILE_NAME_ON_UNZIP) > 0) {
        {
            litaC_baseLen = 0;
            
            
        }
        
    } 
    
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_fileCount;litaC_i += 1) {
        {
            if(!(mz_zip_reader_file_stat(&(litaC_this->archive), litaC_i, &(litaC_fileStat)))) {
                {
                    continue;
                    
                    
                }
                
            } 
            
            litaC_std__string__String litaC_filename = litaC_std__string__StringInit(litaC_fileStat.m_filename + litaC_baseLen, MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - litaC_baseLen, -(1));
            litaC_std__string__String_format(&((litaC_path)), "%s/%.*s", litaC_dest, litaC_filename.length, litaC_filename.buffer);
            litaC_char* litaC_cPath = litaC_std__string__String_cStr(litaC_path);
            litaC_std__system__Mkdirs(litaC_std__system__FileParent(litaC_cPath, litaC_temp2, NULL));
            if(mz_zip_reader_is_file_a_directory(&(litaC_this->archive), litaC_i)) {
                {
                    litaC_std__system__Mkdir(litaC_cPath);
                    if(!(litaC_std__system__FileExists(litaC_cPath))) {
                        {
                            return litaC_std__zip__ZipStatus_ERROR_UNABLE_CREATE_DIR;
                            
                            
                            
                        }
                        
                    } 
                    
                    
                    
                }
                
            } else {
                if(!(mz_zip_reader_extract_to_file(&(litaC_this->archive), litaC_i, litaC_cPath, 0))) {
                    {
                        return litaC_std__zip__ZipStatus_ERROR_UNABLE_WRITE_FILE;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            if(litaC_extractedFiles) {
                {
                    litaC_std__array__Array_add_cb__ptr_const_char_ce_(litaC_extractedFiles, litaC_std__string__StringClone(litaC_filename.buffer, litaC_filename.length, litaC_this->allocator));
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_std__zip__ZipStatus_OK;
    
    
}

litaC_bool litaC_std__fs__FileHandle_openEx(litaC_std__fs__FileHandle* litaC_this,const litaC_char* litaC_path,litaC_i32 litaC_len) {
    if(litaC_len > _MAX_PATH) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_char litaC_temp[_MAX_PATH] = {0};
    litaC_std__string__String litaC_str = litaC_std__string__StringInit(litaC_temp, _MAX_PATH, 0);
    litaC_std__string__String_format(&((litaC_str)), "%.*s", litaC_len, litaC_path);
    return litaC_std__fs__FileHandle_open(litaC_this, litaC_std__string__String_cStr(litaC_str));
    
    
}

litaC_bool litaC_std__fs__FileHandle_open(litaC_std__fs__FileHandle* litaC_this,const litaC_char* litaC_path) {
    if(tinydir_open(&(litaC_this->dir), litaC_path) == -(1)) {
        {
            litaC_std__fs__FileHandle_close(litaC_this);
            return litaC_false;
            
            
            
        }
        
    } 
    
    return litaC_true;
    
    
}

litaC_bool litaC_std__fs__FileHandle_isFile(litaC_std__fs__FileHandle* litaC_this) {
    return litaC_this->file.is_reg;
    
    
}

litaC_bool litaC_std__fs__FileHandle_isDirectory(litaC_std__fs__FileHandle* litaC_this) {
    return litaC_this->file.is_dir;
    
    
}

const litaC_char* litaC_std__fs__FileHandle_name(litaC_std__fs__FileHandle* litaC_this) {
    return litaC_this->file.name;
    
    
}

litaC_bool litaC_std__fs__FileHandle_hasNext(litaC_std__fs__FileHandle* litaC_this) {
    return litaC_this->dir.has_next;
    
    
}

litaC_bool litaC_std__fs__FileHandle_next(litaC_std__fs__FileHandle* litaC_this) {
    litaC_bool litaC_nextFileFound = litaC_false;
    while(litaC_this->dir.has_next && !(litaC_nextFileFound)) {
        {
            if(tinydir_readfile(&(litaC_this->dir), &(litaC_this->file)) == -(1)) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            litaC_nextFileFound = litaC_true;
            if(strncmp(litaC_this->file.name, "..", _MAX_PATH) == 0) {
                {
                    litaC_nextFileFound = litaC_false;
                    
                    
                }
                
            } 
            
            if(strncmp(litaC_this->file.name, ".", _MAX_PATH) == 0) {
                {
                    litaC_nextFileFound = litaC_false;
                    
                    
                }
                
            } 
            
            if(tinydir_next(&(litaC_this->dir)) == -(1)) {
                {
                    return litaC_false;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_nextFileFound;
    
    
}

litaC_bool litaC_std__fs__FileHandle_close(litaC_std__fs__FileHandle* litaC_this) {
    tinydir_close(&(litaC_this->dir));
    return litaC_true;
    
    
}

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_build__PackageBuild(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_pkg_mgr__PackageBuildOptions litaC_options) {
    if(!(litaC_pm->pkg)) {
        {
            return litaC_pkg_mgr__PkgStatus_ERROR_NO_PROJECT_PKG_FOUND;
            
            
            
        }
        
    } 
    
    if(!(litaC_pm->pkg->json)) {
        {
            return litaC_pkg_mgr__PkgStatus_ERROR_PARSING_PKG_JSON;
            
            
            
        }
        
    } 
    
    litaC_std__json__JsonNode* litaC_buildCommand = litaC_std__json__JsonNode_get(litaC_pm->pkg->json, "build_command");
    if(!(litaC_buildCommand)) {
        {
            return litaC_pkg_mgr__PkgStatus_ERROR_COMMAND_NOT_DEFINED;
            
            
            
        }
        
    } 
    
    litaC_lita__LitaOptions* litaC_litaOptions = litaC_std__mem__new_cb_LitaOptions_ce_(litaC_std__mem__defaultAllocator);
    memset(litaC_litaOptions, 0, sizeof(litaC_lita__LitaOptions));
    
    litaC_pkg_mgr__pkg_build__CommandArgs litaC_args =  {
        
    };
    litaC_pkg_mgr__PkgStatus litaC_result = litaC_pkg_mgr__pkg_build__PackageManager_buildCommandArgs(litaC_pm, litaC_buildCommand, litaC_options, &(litaC_args));
    if(litaC_result != litaC_pkg_mgr__PkgStatus_OK) {
        {
            {
                litaC_pkg_mgr__PkgStatus ___result = litaC_result;
                litaC_std__mem__Allocator_free(litaC_std__mem__defaultAllocator, litaC_litaOptions);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    if(litaC_args.n == 0) {
        {
            {
                litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_OK;
                litaC_std__mem__Allocator_free(litaC_std__mem__defaultAllocator, litaC_litaOptions);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    if(litaC_main__ParseArgs(litaC_args.n, litaC_args.args, litaC_litaOptions) != litaC_main__ParseStatus_OK) {
        {
            {
                litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_ERROR_PARSING_BUILD_OPTIONS;
                litaC_std__mem__Allocator_free(litaC_std__mem__defaultAllocator, litaC_litaOptions);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    litaC_main__RunLitac(litaC_litaOptions);
    {
        litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_OK;
        litaC_std__mem__Allocator_free(litaC_std__mem__defaultAllocator, litaC_litaOptions);
        return ___result;
        
    }
    
    litaC_std__mem__Allocator_free(litaC_std__mem__defaultAllocator, litaC_litaOptions);
    
}

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_build__PackageManager_buildCommandArgs(litaC_pkg_mgr__PackageManager* litaC_this,litaC_std__json__JsonNode* litaC_buildCommand,litaC_pkg_mgr__PackageBuildOptions litaC_options,litaC_pkg_mgr__pkg_build__CommandArgs* litaC_args) {
    litaC_std__json__JsonNode* litaC_buildSection = NULL;
    litaC_std__json__JsonNode* litaC_defaultTarget = litaC_std__json__JsonNode_get(litaC_buildCommand, "default");
    litaC_std__json__JsonNode* litaC_target = litaC_pkg_mgr__pkg_build__GetTarget(litaC_buildCommand, litaC_defaultTarget, litaC_options);
    if(litaC_target) {
        {
            litaC_std__json__JsonNode* litaC_defaultOS = litaC_std__json__JsonNode_get(litaC_target, "default");
            litaC_std__json__JsonNode* litaC_os = litaC_pkg_mgr__pkg_build__GetOS(litaC_target, litaC_defaultTarget);
            if(litaC_os) {
                {
                    litaC_std__json__JsonNode* litaC_arch = litaC_pkg_mgr__pkg_build__GetArch(litaC_os, litaC_defaultOS);
                    litaC_buildSection = litaC_arch;
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    litaC_std__array__Array_cb__ptr_const_char_ce_ litaC_programArgs = litaC_std__array__ArrayInit_cb__ptr_const_char_ce_(64, litaC_this->allocator);
    litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_programArgs)), "litac");
    if(litaC_buildSection) {
        {
            litaC_std__json__JsonNode* litaC_script = litaC_std__json__JsonNode_get(litaC_buildSection, "script");
            if(litaC_script) {
                {
                    litaC_args->n = 0;
                    return litaC_pkg_mgr__pkg_build__PackageManager_buildWithScript(litaC_this, litaC_script);
                    
                    
                    
                }
                
            } 
            
            litaC_std__string_buffer__StringBuffer litaC_buildCmd = litaC_std__string_buffer__StringBufferInit(1024, NULL);
            const litaC_char* litaC_cc = litaC_std__json__JsonNode_getStr(litaC_buildSection, "cc", "clang");
            litaC_std__json__JsonNode* litaC_ccOptions = litaC_std__json__JsonNode_get(litaC_buildSection, "cc_options");
            if(litaC_ccOptions) {
                {
                    litaC_std__string_buffer__StringBuffer_append(&((litaC_buildCmd)), "%s ", litaC_cc);
                    if(litaC_std__json__JsonNode_isString(litaC_ccOptions)) {
                        {
                            litaC_std__string_buffer__StringBuffer_append(&((litaC_buildCmd)), "%s ", litaC_std__json__JsonNode_asString(litaC_ccOptions));
                            
                            
                        }
                        
                    } else {
                        if(litaC_std__json__JsonNode_isArray(litaC_ccOptions)) {
                            {
                                litaC_bool litaC_isFirst = litaC_true;
                                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__json__JsonNode_size(litaC_ccOptions);litaC_i += 1) {
                                    {
                                        if(!(litaC_isFirst)) {
                                            {
                                                litaC_std__string_buffer__StringBuffer_appendStrn(&((litaC_buildCmd)), " ", 1);
                                                
                                                
                                            }
                                            
                                        } 
                                        
                                        litaC_isFirst = litaC_false;
                                        litaC_std__json__JsonNode* litaC_n = litaC_std__json__JsonNode_at(litaC_ccOptions, litaC_i);
                                        litaC_std__string_buffer__StringBuffer_append(&((litaC_buildCmd)), "%s", litaC_std__json__JsonNode_asString(litaC_n));
                                        
                                        
                                    }
                                }
                                
                                
                            }
                            
                        } 
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            litaC_std__json__JsonNode* litaC_litaOptions = litaC_std__json__JsonNode_get(litaC_buildSection, "lita_options");
            if(litaC_litaOptions) {
                {
                    if(litaC_std__json__JsonNode_isString(litaC_litaOptions)) {
                        {
                            litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_programArgs)), litaC_std__json__JsonNode_asString(litaC_litaOptions));
                            
                            
                        }
                        
                    } else {
                        if(litaC_std__json__JsonNode_isArray(litaC_litaOptions)) {
                            {
                                for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__json__JsonNode_size(litaC_litaOptions);litaC_i += 1) {
                                    {
                                        litaC_std__json__JsonNode* litaC_n = litaC_std__json__JsonNode_at(litaC_litaOptions, litaC_i);
                                        litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_programArgs)), litaC_std__json__JsonNode_asString(litaC_n));
                                        
                                        
                                    }
                                }
                                
                                
                            }
                            
                        } 
                        
                    } 
                    
                    
                    
                }
                
            } 
            
            if(!(litaC_std__string_buffer__StringBuffer_empty(&((litaC_buildCmd))))) {
                {
                    litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_programArgs)), "-buildCmd");
                    litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_programArgs)), litaC_std__string_buffer__StringBuffer_cStr(&((litaC_buildCmd))));
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    if(!(litaC_pkg_mgr__pkg_build__ContainsOption("-outputDir", &(litaC_programArgs)))) {
        {
            litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_programArgs)), "-outputDir");
            litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_programArgs)), "./bin/");
            
            
        }
        
    } 
    
    if(!(litaC_pkg_mgr__pkg_build__ContainsOption("-output", &(litaC_programArgs)))) {
        {
            litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_programArgs)), "-output");
            litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_programArgs)), litaC_std__json__JsonNode_getStr(litaC_this->pkg->json, "name", "a"));
            
            
        }
        
    } 
    
    if(!(litaC_pkg_mgr__pkg_build__ContainsOption("-srcDir", &(litaC_programArgs)))) {
        {
            litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_programArgs)), "-srcDir");
            litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_programArgs)), "./src/");
            
            
        }
        
    } 
    
    const char* litaC_mainFile = "./src/main.lita";
    {
        if(litaC_this->options.litaOptions->run) {
            {
                litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_programArgs)), "-run");
                
                
            }
            
        } 
        
        if(litaC_this->options.litaOptions->testsOnly) {
            {
                litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_programArgs)), "-testDir");
                litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_programArgs)), "./test/");
                if(litaC_this->options.litaOptions->testsRegex) {
                    {
                        litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_programArgs)), "-test");
                        litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_programArgs)), litaC_this->options.litaOptions->testsRegex);
                        
                        
                    }
                    
                } else {
                    {
                        litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_programArgs)), "-testFile");
                        
                        
                    }
                } 
                
                litaC_mainFile = "./test/main_test.lita";
                
                
            }
            
        } 
        
        
        
    }
    if(strlen(litaC_this->options.litaOptions->inputFile) > 0) {
        {
            litaC_mainFile = (const litaC_char*)litaC_this->options.litaOptions->inputFile;
            
            
        }
        
    } 
    
    litaC_std__array__Array_add_cb__ptr_const_char_ce_(&((litaC_programArgs)), litaC_mainFile);
    litaC_args->n = litaC_std__array__Array_size_cb__ptr_const_char_ce_(&((litaC_programArgs)));
    litaC_args->args = (litaC_char**)litaC_programArgs.elements;
    return litaC_pkg_mgr__PkgStatus_OK;
    
    
}

litaC_bool litaC_pkg_mgr__pkg_build__ContainsOption(const litaC_char* litaC_option,litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_programArgs) {
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_std__array__Array_size_cb__ptr_const_char_ce_(litaC_programArgs);litaC_i += 1) {
        {
            const litaC_char* litaC_arg = litaC_std__array__Array_get_cb__ptr_const_char_ce_(litaC_programArgs, litaC_i);
            if(strcmp(litaC_arg, litaC_option) == 0) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_build__PackageManager_buildWithScript(litaC_pkg_mgr__PackageManager* litaC_this,litaC_std__json__JsonNode* litaC_script) {
    litaC_std__system__Process litaC_process = litaC_std__system__SystemExec(litaC_std__json__JsonNode_asString(litaC_script));
    if(!(litaC_process.pipe)) {
        {
            return litaC_pkg_mgr__PkgStatus_ERROR_RUNNING_COMMAND;
            
            
            
        }
        
    } 
    
    
    
#define litaC_BUFFER_SIZE (16)
    litaC_char litaC_buffer[16] =  {
        0
    };
    litaC_i64 litaC_bytesRead = -(1L);
    while((litaC_bytesRead = litaC_std__system__Process_readOutput(&((litaC_process)), litaC_buffer, litaC_BUFFER_SIZE)) > 0) {
        {
            printf("%.*s", (litaC_i32)litaC_bytesRead, litaC_buffer);
            
            
        }
    }
    {
        litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_OK;
        litaC_std__system__Process_close(&((litaC_process)));
        return ___result;
        
    }
    
    litaC_std__system__Process_close(&((litaC_process)));
    #undef litaC_BUFFER_SIZE
    
}

litaC_std__json__JsonNode* litaC_pkg_mgr__pkg_build__GetTarget(litaC_std__json__JsonNode* litaC_buildCommand,litaC_std__json__JsonNode* litaC_defaultTarget,litaC_pkg_mgr__PackageBuildOptions litaC_options) {
    litaC_std__json__JsonNode* litaC_target = NULL;
    if(litaC_options.isRelease) {
        {
            litaC_target = litaC_std__json__JsonNode_get(litaC_buildCommand, "release");
            
            
        }
        
    } else {
        {
            litaC_target = litaC_std__json__JsonNode_get(litaC_buildCommand, "debug");
            
            
        }
    } 
    
    if(!(litaC_target)) {
        {
            litaC_target = litaC_defaultTarget;
            
            
        }
        
    } 
    
    return litaC_target;
    
    
}

litaC_std__json__JsonNode* litaC_pkg_mgr__pkg_build__GetOS(litaC_std__json__JsonNode* litaC_target,litaC_std__json__JsonNode* litaC_defaultTarget) {
    litaC_std__json__JsonNode* litaC_os = NULL;
    litaC_std__json__JsonNode* litaC_defaultOS = litaC_std__json__JsonNode_get(litaC_target, "default");
    
    #if defined(_WIN32) || defined(_WIN64)
    litaC_os = litaC_std__json__JsonNode_get(litaC_target, "windows");
    
    #elif defined(__linux__)
    litaC_os = litaC_std__json__JsonNode_get(litaC_target, "linux");
    
    #elif defined(__APPLE__) && defined(__MACH__)
    litaC_os = litaC_std__json__JsonNode_get(litaC_target, "mac");
    
    #endif
    
    if(!(litaC_os)) {
        {
            litaC_os = litaC_defaultOS;
            
            
        }
        
    } 
    
    if(!(litaC_os)) {
        {
            if(!(litaC_os) && litaC_defaultTarget) {
                {
                    litaC_os = litaC_pkg_mgr__pkg_build__GetOS(litaC_defaultTarget, NULL);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    return litaC_os;
    
    
}

litaC_std__json__JsonNode* litaC_pkg_mgr__pkg_build__GetArch(litaC_std__json__JsonNode* litaC_os,litaC_std__json__JsonNode* litaC_defaultOS) {
    litaC_std__json__JsonNode* litaC_arch = NULL;
    litaC_std__json__JsonNode* litaC_defaultArch = litaC_std__json__JsonNode_get(litaC_os, "default");
    
    #if defined(LITA_X86)
    litaC_arch = litaC_std__json__JsonNode_get(litaC_os, "x86");
    
    #elif defined(LITA_X64)
    litaC_arch = litaC_std__json__JsonNode_get(litaC_os, "x64");
    
    #elif defined(LITA_ARM32)
    litaC_arch = litaC_std__json__JsonNode_get(litaC_os, "arm32");
    
    #elif defined(LITA_ARM64)
    litaC_arch = litaC_std__json__JsonNode_get(litaC_os, "arm64");
    
    #endif
    
    if(!(litaC_arch)) {
        {
            litaC_arch = litaC_defaultArch;
            
            
        }
        
    } 
    
    if(!(litaC_arch)) {
        {
            if(litaC_defaultOS) {
                {
                    litaC_arch = litaC_pkg_mgr__pkg_build__GetArch(litaC_defaultOS, NULL);
                    
                    
                }
                
            } 
            
            
            
        }
        
    } 
    
    return litaC_arch;
    
    
}

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_run__PackageRun(litaC_pkg_mgr__PackageManager* litaC_pm,const litaC_char* litaC_cmd) {
    if(!(litaC_pm->pkg)) {
        {
            return litaC_pkg_mgr__PkgStatus_OK;
            
            
            
        }
        
    } 
    
    if(!(litaC_pm->pkg->json)) {
        {
            return litaC_pkg_mgr__PkgStatus_OK;
            
            
            
        }
        
    } 
    
    litaC_std__json__JsonNode* litaC_commands = litaC_std__json__JsonNode_get(litaC_pm->pkg->json, "commands");
    if(!(litaC_commands)) {
        {
            return litaC_pkg_mgr__PkgStatus_ERROR_COMMAND_NOT_DEFINED;
            
            
            
        }
        
    } 
    
    
#define litaC_BUFFER_SIZE (16)
    litaC_char litaC_buffer[16] =  {
        0
    };
    litaC_std__string__String litaC_bufferStr = litaC_std__string__StringInit(litaC_buffer, litaC_BUFFER_SIZE, 0);
    litaC_std__string__String_format(&((litaC_bufferStr)), "%s", litaC_std__system__OSAsStr(litaC_std__system__GetOS()));
    litaC_std__string__String_toLower(litaC_bufferStr);
    const litaC_char* litaC_cmdScript = NULL;
    if(litaC_std__json__JsonNode_contains(litaC_commands, litaC_cmd)) {
        {
            litaC_cmdScript = litaC_std__json__JsonNode_getStr(litaC_commands, litaC_cmd, NULL);
            
            
        }
        
    } 
    
    litaC_std__json__JsonNode* litaC_osCommands = litaC_std__json__JsonNode_get(litaC_commands, litaC_std__string__String_cStr(litaC_bufferStr));
    if(litaC_osCommands && litaC_std__json__JsonNode_contains(litaC_osCommands, litaC_cmd)) {
        {
            litaC_cmdScript = litaC_std__json__JsonNode_getStr(litaC_osCommands, litaC_cmd, NULL);
            
            
        }
        
    } 
    
    if(!(litaC_cmdScript)) {
        {
            return litaC_pkg_mgr__PkgStatus_ERROR_COMMAND_NOT_DEFINED;
            
            
            
        }
        
    } 
    
    litaC_std__system__Process litaC_process = litaC_std__system__SystemExec(litaC_cmdScript);
    if(!(litaC_process.pipe)) {
        {
            return litaC_pkg_mgr__PkgStatus_ERROR_RUNNING_COMMAND;
            
            
            
        }
        
    } 
    
    
    litaC_i64 litaC_bytesRead = -(1L);
    while((litaC_bytesRead = litaC_std__system__Process_readOutput(&((litaC_process)), litaC_buffer, litaC_BUFFER_SIZE)) > 0) {
        {
            printf("%.*s", (litaC_i32)litaC_bytesRead, litaC_buffer);
            
            
        }
    }
    {
        litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_OK;
        litaC_std__system__Process_close(&((litaC_process)));
        return ___result;
        
    }
    
    litaC_std__system__Process_close(&((litaC_process)));
    #undef litaC_BUFFER_SIZE
    
}

litaC_pkg_mgr__PkgStatus litaC_pkg_mgr__pkg_init__PackageInit(litaC_pkg_mgr__PackageManager* litaC_pm,litaC_pkg_mgr__PackageInitOptions litaC_options) {
    
#define litaC_MAX_BUFFER (1024)
    litaC_char litaC_buffer[1024] =  {
        
    };
    litaC_std__string__String litaC_path = litaC_std__string__StringInit(litaC_buffer, litaC_MAX_BUFFER, 0);
    litaC_std__string__String_format(&((litaC_path)), "%s/bin", litaC_pm->options.projectPath);
    litaC_std__system__Mkdir(litaC_std__string__String_cStr(litaC_path));
    litaC_std__string__String_format(&((litaC_path)), "%s/doc", litaC_pm->options.projectPath);
    litaC_std__system__Mkdir(litaC_std__string__String_cStr(litaC_path));
    litaC_std__string__String_format(&((litaC_path)), "%s/lib", litaC_pm->options.projectPath);
    litaC_std__system__Mkdir(litaC_std__string__String_cStr(litaC_path));
    litaC_std__string__String_format(&((litaC_path)), "%s/src", litaC_pm->options.projectPath);
    litaC_std__system__Mkdir(litaC_std__string__String_cStr(litaC_path));
    litaC_std__string__String_format(&((litaC_path)), "%s/test", litaC_pm->options.projectPath);
    litaC_std__system__Mkdir(litaC_std__string__String_cStr(litaC_path));
    litaC_std__string_buffer__StringBuffer litaC_sb = litaC_std__string_buffer__StringBufferInit(1024, NULL);
    
    {
        litaC_std__string_buffer__StringBuffer_append(&((litaC_sb)), "%s", "\nimport \"std/libc\"\n\nfunc main(len: i32, args: **char) : i32 {\n    printf(\"Hello World\\n\")\n    return 0\n}\n");
        litaC_std__string__String_format(&((litaC_path)), "%s/src/main.lita", litaC_pm->options.projectPath);
        if(!(litaC_std__system__FileExists(litaC_std__string__String_cStr(litaC_path)))) {
            {
                if(litaC_std__io__WriteFile(litaC_std__string__String_cStr(litaC_path), litaC_sb.buffer, litaC_sb.length) != litaC_std__io__FileStatus_Ok) {
                    {
                        {
                            litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_ERROR_INIT_PACKAGE;
                            litaC_std__string_buffer__StringBuffer_free(&((litaC_sb)));
                            return ___result;
                            
                        }
                        
                        
                        
                    }
                    
                } 
                
                
                
            }
            
        } 
        
        
        
    }
    {
        litaC_std__string_buffer__StringBuffer_append(litaC_std__string_buffer__StringBuffer_clear(&((litaC_sb))), "%s", "\nimport \"main\"\nimport \"std/assert\"\n\n@test(\"project_test\")\nfunc test() {\n    assert(true)\n}\n\n");
        litaC_std__string__String_format(&((litaC_path)), "%s/test/main_test.lita", litaC_pm->options.projectPath);
        if(!(litaC_std__system__FileExists(litaC_std__string__String_cStr(litaC_path)))) {
            {
                if(litaC_std__io__WriteFile(litaC_std__string__String_cStr(litaC_path), litaC_sb.buffer, litaC_sb.length) != litaC_std__io__FileStatus_Ok) {
                    {
                        {
                            litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_ERROR_INIT_PACKAGE;
                            litaC_std__string_buffer__StringBuffer_free(&((litaC_sb)));
                            return ___result;
                            
                        }
                        
                        
                        
                    }
                    
                } 
                
                
                
            }
            
        } 
        
        
        
    }
    {
        litaC_std__string_buffer__StringBuffer_append(litaC_std__string_buffer__StringBuffer_clear(&((litaC_sb))), "\n{\n    \"name\" : \"%s\",\n    \"version\" : \"%s\",\n    \"type\" : \"%s\",\n    \"repo\" : \"%s\",\n\n    \"build_command\" : {\n        \"default\" : {\n            \"default\" : {\n                \"cc\" : \"clang\",\n                \"cc_options\" : \"-std=c99 -fsanitize=undefined,address %%input%% -o %%output%% -D_CRT_SECURE_NO_WARNINGS\",\n                \"lita_options\" : \"\"\n            }\n        }\n    },\n\n    \"dependencies\": [],\n\n}\n", litaC_options.name, litaC_options.version, litaC_options.type, litaC_options.repo);
        litaC_std__string__String_format(&((litaC_path)), "%s/pkg.json", litaC_pm->options.projectPath);
        if(!(litaC_std__system__FileExists(litaC_std__string__String_cStr(litaC_path)))) {
            {
                if(litaC_std__io__WriteFile(litaC_std__string__String_cStr(litaC_path), litaC_sb.buffer, litaC_sb.length) != litaC_std__io__FileStatus_Ok) {
                    {
                        {
                            litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_ERROR_INIT_PACKAGE;
                            litaC_std__string_buffer__StringBuffer_free(&((litaC_sb)));
                            return ___result;
                            
                        }
                        
                        
                        
                    }
                    
                } 
                
                
                
            }
            
        } 
        
        
        
    }
    {
        litaC_pkg_mgr__PkgStatus ___result = litaC_pkg_mgr__PkgStatus_OK;
        litaC_std__string_buffer__StringBuffer_free(&((litaC_sb)));
        return ___result;
        
    }
    
    litaC_std__string_buffer__StringBuffer_free(&((litaC_sb)));
    #undef litaC_MAX_BUFFER
    
}

const litaC_char* litaC_pkg_mgr__PkgStatusAsStr(litaC_pkg_mgr__PkgStatus litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_pkg_mgr__PkgStatus_OK: {
            return "OK";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_NO_PROJECT_PKG_FOUND: {
            return "ERROR_NO_PROJECT_PKG_FOUND";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_COMMAND_NOT_DEFINED: {
            return "ERROR_COMMAND_NOT_DEFINED";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_RUNNING_COMMAND: {
            return "ERROR_RUNNING_COMMAND";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_CREATING_PKG_DIR: {
            return "ERROR_CREATING_PKG_DIR";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_CLEANING_PKG: {
            return "ERROR_CLEANING_PKG";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_UNABLE_TO_OPEN_FILE: {
            return "ERROR_UNABLE_TO_OPEN_FILE";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_UNABLE_TO_OPEN_PKG_FILE: {
            return "ERROR_UNABLE_TO_OPEN_PKG_FILE";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_UNABLE_TO_EXTRACT_PKG_FILE: {
            return "ERROR_UNABLE_TO_EXTRACT_PKG_FILE";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_UNABLE_TO_PROCESS_PKG_FILE: {
            return "ERROR_UNABLE_TO_PROCESS_PKG_FILE";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_OPENING_LOCAL_FILE_PKG: {
            return "ERROR_OPENING_LOCAL_FILE_PKG";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_READING_LOCAL_FILE_PKG: {
            return "ERROR_READING_LOCAL_FILE_PKG";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_WRITING_LOCAL_FILE_PKG: {
            return "ERROR_WRITING_LOCAL_FILE_PKG";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_FINALIZING_LOCAL_FILE_PKG: {
            return "ERROR_FINALIZING_LOCAL_FILE_PKG";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_PARSING_PKG_JSON: {
            return "ERROR_PARSING_PKG_JSON";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_READING_PKG_FILE: {
            return "ERROR_READING_PKG_FILE";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_HTTP_STATUS: {
            return "ERROR_HTTP_STATUS";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_INVALID_DIRECTORY: {
            return "ERROR_INVALID_DIRECTORY";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_INVALID_REPO: {
            return "ERROR_INVALID_REPO";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_INIT_PACKAGE: {
            return "ERROR_INIT_PACKAGE";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_PARSING_BUILD_OPTIONS: {
            return "ERROR_PARSING_BUILD_OPTIONS";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_INVALID_BUILD_TARGET: {
            return "ERROR_INVALID_BUILD_TARGET";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_INVALID_BUILD_OS: {
            return "ERROR_INVALID_BUILD_OS";
            
            
            
        }
        case litaC_pkg_mgr__PkgStatus_ERROR_INVALID_BUILD_ARCH: {
            return "ERROR_INVALID_BUILD_ARCH";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_lsp__protocol__SymbolInfoKindAsStr(litaC_lsp__protocol__SymbolInfoKind litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_lsp__protocol__SymbolInfoKind_File: {
            return "File";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Module: {
            return "Module";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Namespace: {
            return "Namespace";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Package: {
            return "Package";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Class: {
            return "Class";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Method: {
            return "Method";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Property: {
            return "Property";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Field: {
            return "Field";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Constructor: {
            return "Constructor";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Enum: {
            return "Enum";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Interface: {
            return "Interface";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Function: {
            return "Function";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Variable: {
            return "Variable";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Constant: {
            return "Constant";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_String: {
            return "String";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Number: {
            return "Number";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Boolean: {
            return "Boolean";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Array: {
            return "Array";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Object: {
            return "Object";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Key: {
            return "Key";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Null: {
            return "Null";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_EnumMember: {
            return "EnumMember";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Struct: {
            return "Struct";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Event: {
            return "Event";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_Operator: {
            return "Operator";
            
            
            
        }
        case litaC_lsp__protocol__SymbolInfoKind_TypeParameter: {
            return "TypeParameter";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_std__json__JsonTypeAsStr(litaC_std__json__JsonType litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_std__json__JsonType_NULL: {
            return "NULL";
            
            
            
        }
        case litaC_std__json__JsonType_BOOLEAN: {
            return "BOOLEAN";
            
            
            
        }
        case litaC_std__json__JsonType_INT_NUMBER: {
            return "INT_NUMBER";
            
            
            
        }
        case litaC_std__json__JsonType_FLOAT_NUMBER: {
            return "FLOAT_NUMBER";
            
            
            
        }
        case litaC_std__json__JsonType_STRING: {
            return "STRING";
            
            
            
        }
        case litaC_std__json__JsonType_OBJECT: {
            return "OBJECT";
            
            
            
        }
        case litaC_std__json__JsonType_ARRAY: {
            return "ARRAY";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_lita__TypeInfoOptionAsStr(litaC_lita__TypeInfoOption litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_lita__TypeInfoOption_NONE: {
            return "NONE";
            
            
            
        }
        case litaC_lita__TypeInfoOption_TAGGED: {
            return "TAGGED";
            
            
            
        }
        case litaC_lita__TypeInfoOption_ALL: {
            return "ALL";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_lita__MetricTypeAsStr(litaC_lita__MetricType litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_lita__MetricType_PARSING: {
            return "PARSING";
            
            
            
        }
        case litaC_lita__MetricType_TYPE_CHECKING: {
            return "TYPE_CHECKING";
            
            
            
        }
        case litaC_lita__MetricType_CGEN: {
            return "CGEN";
            
            
            
        }
        case litaC_lita__MetricType_CCOMPILE: {
            return "CCOMPILE";
            
            
            
        }
        case litaC_lita__MetricType_MAX_METRIC_TYPES: {
            return "MAX_METRIC_TYPES";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_symbols__SymbolStateAsStr(litaC_symbols__SymbolState litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_symbols__SymbolState_UNRESOLVED: {
            return "UNRESOLVED";
            
            
            
        }
        case litaC_symbols__SymbolState_RESOLVING: {
            return "RESOLVING";
            
            
            
        }
        case litaC_symbols__SymbolState_RESOLVED: {
            return "RESOLVED";
            
            
            
        }
        case litaC_symbols__SymbolState_ERROR: {
            return "ERROR";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_symbols__SymbolKindAsStr(litaC_symbols__SymbolKind litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_symbols__SymbolKind_TYPE: {
            return "TYPE";
            
            
            
        }
        case litaC_symbols__SymbolKind_VAR: {
            return "VAR";
            
            
            
        }
        case litaC_symbols__SymbolKind_FUNC: {
            return "FUNC";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_ast__TypeSpecKindAsStr(litaC_ast__TypeSpecKind litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_ast__TypeSpecKind_NONE: {
            return "NONE";
            
            
            
        }
        case litaC_ast__TypeSpecKind_ARRAY: {
            return "ARRAY";
            
            
            
        }
        case litaC_ast__TypeSpecKind_PTR: {
            return "PTR";
            
            
            
        }
        case litaC_ast__TypeSpecKind_CONST: {
            return "CONST";
            
            
            
        }
        case litaC_ast__TypeSpecKind_NAME: {
            return "NAME";
            
            
            
        }
        case litaC_ast__TypeSpecKind_FUNC_PTR: {
            return "FUNC_PTR";
            
            
            
        }
        case litaC_ast__TypeSpecKind_MAX_TYPESPEC_KINDS: {
            return "MAX_TYPESPEC_KINDS";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_ast__StmtKindAsStr(litaC_ast__StmtKind litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_ast__StmtKind_IMPORT_DECL: {
            return "IMPORT_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_CONST_DECL: {
            return "CONST_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_VAR_DECL: {
            return "VAR_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_STRUCT_DECL: {
            return "STRUCT_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_UNION_DECL: {
            return "UNION_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_TRAIT_DECL: {
            return "TRAIT_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_ENUM_DECL: {
            return "ENUM_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_FUNC_DECL: {
            return "FUNC_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_TYPEDEF_DECL: {
            return "TYPEDEF_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_NOTE_DECL: {
            return "NOTE_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_PARAM_DECL: {
            return "PARAM_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_NATIVE_DECL: {
            return "NATIVE_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_NOTES_DECL: {
            return "NOTES_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_VAR_FIELD_DECL: {
            return "VAR_FIELD_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_ENUM_FIELD_ENTRY_DECL: {
            return "ENUM_FIELD_ENTRY_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_ENUM_FIELD_DECL: {
            return "ENUM_FIELD_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_STRUCT_FIELD_DECL: {
            return "STRUCT_FIELD_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_UNION_FIELD_DECL: {
            return "UNION_FIELD_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_TRAIT_FIELD_DECL: {
            return "TRAIT_FIELD_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_POISON_DECL: {
            return "POISON_DECL";
            
            
            
        }
        case litaC_ast__StmtKind_BLOCK_STMT: {
            return "BLOCK_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_BREAK_STMT: {
            return "BREAK_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_COMP_STMT: {
            return "COMP_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_CONTINUE_STMT: {
            return "CONTINUE_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_DEFER_STMT: {
            return "DEFER_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_DO_WHILE_STMT: {
            return "DO_WHILE_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_EMPTY_STMT: {
            return "EMPTY_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_FOR_STMT: {
            return "FOR_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_FUNC_BODY_STMT: {
            return "FUNC_BODY_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_GOTO_STMT: {
            return "GOTO_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_IF_STMT: {
            return "IF_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_LABEL_STMT: {
            return "LABEL_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_MODULE_STMT: {
            return "MODULE_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_NOTE_STMT: {
            return "NOTE_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_PARAMETERS_STMT: {
            return "PARAMETERS_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_RETURN_STMT: {
            return "RETURN_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_SWITCH_CASE_STMT: {
            return "SWITCH_CASE_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_SWITCH_STMT: {
            return "SWITCH_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_WHILE_STMT: {
            return "WHILE_STMT";
            
            
            
        }
        case litaC_ast__StmtKind_ARRAY_DESIGNATION_EXPR: {
            return "ARRAY_DESIGNATION_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_ARRAY_INIT_EXPR: {
            return "ARRAY_INIT_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_BINARY_EXPR: {
            return "BINARY_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_BOOLEAN_EXPR: {
            return "BOOLEAN_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_CAST_EXPR: {
            return "CAST_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_CHAR_EXPR: {
            return "CHAR_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_FUNC_CALL_EXPR: {
            return "FUNC_CALL_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_FUNC_IDENTIFIER_EXPR: {
            return "FUNC_IDENTIFIER_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_GET_EXPR: {
            return "GET_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_GROUP_EXPR: {
            return "GROUP_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_IDENTIFIER_EXPR: {
            return "IDENTIFIER_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_INIT_EXPR: {
            return "INIT_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_INIT_ARG_EXPR: {
            return "INIT_ARG_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_NULL_EXPR: {
            return "NULL_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_NUMBER_EXPR: {
            return "NUMBER_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_OFFSET_OF_EXPR: {
            return "OFFSET_OF_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_SET_EXPR: {
            return "SET_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_SIZE_OF_EXPR: {
            return "SIZE_OF_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_STRING_EXPR: {
            return "STRING_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_GET_EXPR: {
            return "SUBSCRIPT_GET_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_SUBSCRIPT_SET_EXPR: {
            return "SUBSCRIPT_SET_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_TERNARY_EXPR: {
            return "TERNARY_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_TYPE_IDENTIFIER_EXPR: {
            return "TYPE_IDENTIFIER_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_TYPE_OF_EXPR: {
            return "TYPE_OF_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_UNARY_EXPR: {
            return "UNARY_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_POISON_EXPR: {
            return "POISON_EXPR";
            
            
            
        }
        case litaC_ast__StmtKind_MAX_STMT_KINDS: {
            return "MAX_STMT_KINDS";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_types__TypeKindAsStr(litaC_types__TypeKind litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_types__TypeKind_BOOL: {
            return "BOOL";
            
            
            
        }
        case litaC_types__TypeKind_CHAR: {
            return "CHAR";
            
            
            
        }
        case litaC_types__TypeKind_I8: {
            return "I8";
            
            
            
        }
        case litaC_types__TypeKind_U8: {
            return "U8";
            
            
            
        }
        case litaC_types__TypeKind_I16: {
            return "I16";
            
            
            
        }
        case litaC_types__TypeKind_U16: {
            return "U16";
            
            
            
        }
        case litaC_types__TypeKind_I32: {
            return "I32";
            
            
            
        }
        case litaC_types__TypeKind_U32: {
            return "U32";
            
            
            
        }
        case litaC_types__TypeKind_I64: {
            return "I64";
            
            
            
        }
        case litaC_types__TypeKind_U64: {
            return "U64";
            
            
            
        }
        case litaC_types__TypeKind_F32: {
            return "F32";
            
            
            
        }
        case litaC_types__TypeKind_F64: {
            return "F64";
            
            
            
        }
        case litaC_types__TypeKind_USIZE: {
            return "USIZE";
            
            
            
        }
        case litaC_types__TypeKind_NULL: {
            return "NULL";
            
            
            
        }
        case litaC_types__TypeKind_VOID: {
            return "VOID";
            
            
            
        }
        case litaC_types__TypeKind_STR: {
            return "STR";
            
            
            
        }
        case litaC_types__TypeKind_ARRAY: {
            return "ARRAY";
            
            
            
        }
        case litaC_types__TypeKind_PTR: {
            return "PTR";
            
            
            
        }
        case litaC_types__TypeKind_FUNC_PTR: {
            return "FUNC_PTR";
            
            
            
        }
        case litaC_types__TypeKind_STRUCT: {
            return "STRUCT";
            
            
            
        }
        case litaC_types__TypeKind_UNION: {
            return "UNION";
            
            
            
        }
        case litaC_types__TypeKind_TRAIT: {
            return "TRAIT";
            
            
            
        }
        case litaC_types__TypeKind_ENUM: {
            return "ENUM";
            
            
            
        }
        case litaC_types__TypeKind_FUNC: {
            return "FUNC";
            
            
            
        }
        case litaC_types__TypeKind_CONST: {
            return "CONST";
            
            
            
        }
        case litaC_types__TypeKind_GENERIC_PARAM: {
            return "GENERIC_PARAM";
            
            
            
        }
        case litaC_types__TypeKind_POISON: {
            return "POISON";
            
            
            
        }
        case litaC_types__TypeKind_MAX_TYPE_KINDS: {
            return "MAX_TYPE_KINDS";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_lex__TokenTypeAsStr(litaC_lex__TokenType litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_lex__TokenType_IMPORT: {
            return "IMPORT";
            
            
            
        }
        case litaC_lex__TokenType_STRUCT: {
            return "STRUCT";
            
            
            
        }
        case litaC_lex__TokenType_UNION: {
            return "UNION";
            
            
            
        }
        case litaC_lex__TokenType_TRAIT: {
            return "TRAIT";
            
            
            
        }
        case litaC_lex__TokenType_ENUM: {
            return "ENUM";
            
            
            
        }
        case litaC_lex__TokenType_FUNC: {
            return "FUNC";
            
            
            
        }
        case litaC_lex__TokenType_TYPEDEF: {
            return "TYPEDEF";
            
            
            
        }
        case litaC_lex__TokenType_NOTE: {
            return "NOTE";
            
            
            
        }
        case litaC_lex__TokenType_VAR: {
            return "VAR";
            
            
            
        }
        case litaC_lex__TokenType_CONST: {
            return "CONST";
            
            
            
        }
        case litaC_lex__TokenType_NULL: {
            return "NULL";
            
            
            
        }
        case litaC_lex__TokenType_VOID: {
            return "VOID";
            
            
            
        }
        case litaC_lex__TokenType_TRUE: {
            return "TRUE";
            
            
            
        }
        case litaC_lex__TokenType_FALSE: {
            return "FALSE";
            
            
            
        }
        case litaC_lex__TokenType_BOOL: {
            return "BOOL";
            
            
            
        }
        case litaC_lex__TokenType_CHAR: {
            return "CHAR";
            
            
            
        }
        case litaC_lex__TokenType_I8: {
            return "I8";
            
            
            
        }
        case litaC_lex__TokenType_U8: {
            return "U8";
            
            
            
        }
        case litaC_lex__TokenType_I16: {
            return "I16";
            
            
            
        }
        case litaC_lex__TokenType_U16: {
            return "U16";
            
            
            
        }
        case litaC_lex__TokenType_I32: {
            return "I32";
            
            
            
        }
        case litaC_lex__TokenType_U32: {
            return "U32";
            
            
            
        }
        case litaC_lex__TokenType_I64: {
            return "I64";
            
            
            
        }
        case litaC_lex__TokenType_U64: {
            return "U64";
            
            
            
        }
        case litaC_lex__TokenType_F32: {
            return "F32";
            
            
            
        }
        case litaC_lex__TokenType_F64: {
            return "F64";
            
            
            
        }
        case litaC_lex__TokenType_USIZE: {
            return "USIZE";
            
            
            
        }
        case litaC_lex__TokenType_FOR: {
            return "FOR";
            
            
            
        }
        case litaC_lex__TokenType_WHILE: {
            return "WHILE";
            
            
            
        }
        case litaC_lex__TokenType_DO: {
            return "DO";
            
            
            
        }
        case litaC_lex__TokenType_IF: {
            return "IF";
            
            
            
        }
        case litaC_lex__TokenType_ELSE: {
            return "ELSE";
            
            
            
        }
        case litaC_lex__TokenType_SWITCH: {
            return "SWITCH";
            
            
            
        }
        case litaC_lex__TokenType_CASE: {
            return "CASE";
            
            
            
        }
        case litaC_lex__TokenType_DEFAULT: {
            return "DEFAULT";
            
            
            
        }
        case litaC_lex__TokenType_DEFER: {
            return "DEFER";
            
            
            
        }
        case litaC_lex__TokenType_BREAK: {
            return "BREAK";
            
            
            
        }
        case litaC_lex__TokenType_CONTINUE: {
            return "CONTINUE";
            
            
            
        }
        case litaC_lex__TokenType_RETURN: {
            return "RETURN";
            
            
            
        }
        case litaC_lex__TokenType_GOTO: {
            return "GOTO";
            
            
            
        }
        case litaC_lex__TokenType_SIZEOF: {
            return "SIZEOF";
            
            
            
        }
        case litaC_lex__TokenType_TYPEOF: {
            return "TYPEOF";
            
            
            
        }
        case litaC_lex__TokenType_OFFSETOF: {
            return "OFFSETOF";
            
            
            
        }
        case litaC_lex__TokenType_AS: {
            return "AS";
            
            
            
        }
        case litaC_lex__TokenType_PUBLIC: {
            return "PUBLIC";
            
            
            
        }
        case litaC_lex__TokenType_INTERNAL: {
            return "INTERNAL";
            
            
            
        }
        case litaC_lex__TokenType_USING: {
            return "USING";
            
            
            
        }
        case litaC_lex__TokenType_PLUS: {
            return "PLUS";
            
            
            
        }
        case litaC_lex__TokenType_MINUS: {
            return "MINUS";
            
            
            
        }
        case litaC_lex__TokenType_STAR: {
            return "STAR";
            
            
            
        }
        case litaC_lex__TokenType_MOD: {
            return "MOD";
            
            
            
        }
        case litaC_lex__TokenType_SLASH: {
            return "SLASH";
            
            
            
        }
        case litaC_lex__TokenType_BACK_SLASH: {
            return "BACK_SLASH";
            
            
            
        }
        case litaC_lex__TokenType_DOLLAR: {
            return "DOLLAR";
            
            
            
        }
        case litaC_lex__TokenType_HASH: {
            return "HASH";
            
            
            
        }
        case litaC_lex__TokenType_DOT: {
            return "DOT";
            
            
            
        }
        case litaC_lex__TokenType_VAR_ARGS: {
            return "VAR_ARGS";
            
            
            
        }
        case litaC_lex__TokenType_AT: {
            return "AT";
            
            
            
        }
        case litaC_lex__TokenType_QUESTION_MARK: {
            return "QUESTION_MARK";
            
            
            
        }
        case litaC_lex__TokenType_COMMA: {
            return "COMMA";
            
            
            
        }
        case litaC_lex__TokenType_SEMICOLON: {
            return "SEMICOLON";
            
            
            
        }
        case litaC_lex__TokenType_COLON: {
            return "COLON";
            
            
            
        }
        case litaC_lex__TokenType_COLON_COLON: {
            return "COLON_COLON";
            
            
            
        }
        case litaC_lex__TokenType_DOUBLE_QUOTE: {
            return "DOUBLE_QUOTE";
            
            
            
        }
        case litaC_lex__TokenType_LESS_THAN: {
            return "LESS_THAN";
            
            
            
        }
        case litaC_lex__TokenType_LESS_EQUALS: {
            return "LESS_EQUALS";
            
            
            
        }
        case litaC_lex__TokenType_GREATER_THAN: {
            return "GREATER_THAN";
            
            
            
        }
        case litaC_lex__TokenType_GREATER_EQUALS: {
            return "GREATER_EQUALS";
            
            
            
        }
        case litaC_lex__TokenType_EQUALS_EQUALS: {
            return "EQUALS_EQUALS";
            
            
            
        }
        case litaC_lex__TokenType_EQUALS: {
            return "EQUALS";
            
            
            
        }
        case litaC_lex__TokenType_NOT_EQUALS: {
            return "NOT_EQUALS";
            
            
            
        }
        case litaC_lex__TokenType_PLUS_EQ: {
            return "PLUS_EQ";
            
            
            
        }
        case litaC_lex__TokenType_MINUS_EQ: {
            return "MINUS_EQ";
            
            
            
        }
        case litaC_lex__TokenType_DIV_EQ: {
            return "DIV_EQ";
            
            
            
        }
        case litaC_lex__TokenType_MUL_EQ: {
            return "MUL_EQ";
            
            
            
        }
        case litaC_lex__TokenType_MOD_EQ: {
            return "MOD_EQ";
            
            
            
        }
        case litaC_lex__TokenType_LSHIFT_EQ: {
            return "LSHIFT_EQ";
            
            
            
        }
        case litaC_lex__TokenType_RSHIFT_EQ: {
            return "RSHIFT_EQ";
            
            
            
        }
        case litaC_lex__TokenType_BNOT_EQ: {
            return "BNOT_EQ";
            
            
            
        }
        case litaC_lex__TokenType_XOR_EQ: {
            return "XOR_EQ";
            
            
            
        }
        case litaC_lex__TokenType_BAND_EQ: {
            return "BAND_EQ";
            
            
            
        }
        case litaC_lex__TokenType_BOR_EQ: {
            return "BOR_EQ";
            
            
            
        }
        case litaC_lex__TokenType_LSHIFT: {
            return "LSHIFT";
            
            
            
        }
        case litaC_lex__TokenType_RSHIFT: {
            return "RSHIFT";
            
            
            
        }
        case litaC_lex__TokenType_BNOT: {
            return "BNOT";
            
            
            
        }
        case litaC_lex__TokenType_XOR: {
            return "XOR";
            
            
            
        }
        case litaC_lex__TokenType_BAND: {
            return "BAND";
            
            
            
        }
        case litaC_lex__TokenType_BOR: {
            return "BOR";
            
            
            
        }
        case litaC_lex__TokenType_LEFT_PAREN: {
            return "LEFT_PAREN";
            
            
            
        }
        case litaC_lex__TokenType_RIGHT_PAREN: {
            return "RIGHT_PAREN";
            
            
            
        }
        case litaC_lex__TokenType_LEFT_BRACKET: {
            return "LEFT_BRACKET";
            
            
            
        }
        case litaC_lex__TokenType_RIGHT_BRACKET: {
            return "RIGHT_BRACKET";
            
            
            
        }
        case litaC_lex__TokenType_LEFT_BRACE: {
            return "LEFT_BRACE";
            
            
            
        }
        case litaC_lex__TokenType_RIGHT_BRACE: {
            return "RIGHT_BRACE";
            
            
            
        }
        case litaC_lex__TokenType_NOT: {
            return "NOT";
            
            
            
        }
        case litaC_lex__TokenType_OR: {
            return "OR";
            
            
            
        }
        case litaC_lex__TokenType_AND: {
            return "AND";
            
            
            
        }
        case litaC_lex__TokenType_STRING: {
            return "STRING";
            
            
            
        }
        case litaC_lex__TokenType_IDENTIFIER: {
            return "IDENTIFIER";
            
            
            
        }
        case litaC_lex__TokenType_INT_NUMBER: {
            return "INT_NUMBER";
            
            
            
        }
        case litaC_lex__TokenType_FLOAT_NUMBER: {
            return "FLOAT_NUMBER";
            
            
            
        }
        case litaC_lex__TokenType_ERROR: {
            return "ERROR";
            
            
            
        }
        case litaC_lex__TokenType_END_OF_FILE: {
            return "END_OF_FILE";
            
            
            
        }
        case litaC_lex__TokenType_MAX_TOKEN_TYPES: {
            return "MAX_TOKEN_TYPES";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

const litaC_char* litaC_std__io__FileStatusAsStr(litaC_std__io__FileStatus litaC_enumType) {
    switch(litaC_enumType) {
        case litaC_std__io__FileStatus_Ok: {
            return "Ok";
            
            
            
        }
        case litaC_std__io__FileStatus_FileNotFoundError: {
            return "FileNotFoundError";
            
            
            
        }
        case litaC_std__io__FileStatus_IOError: {
            return "IOError";
            
            
            
        }
        default: {
            return NULL;
            
            
            
        }
    }
    
}

litaC_lita__LitaOptions* litaC_std__mem__new_cb_LitaOptions_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_lita__LitaOptions* litaC_result = (litaC_lita__LitaOptions*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_lita__LitaOptions));
    return litaC_result;
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb_PhaseError_ce_(litaC_std__array__Array_cb_PhaseError_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_PhaseError_ce_(litaC_std__array__Array_cb_PhaseError_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_phase_result__PhaseError litaC_std__array__Array_get_cb_PhaseError_ce_(litaC_std__array__Array_cb_PhaseError_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_const_char_ce_(litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

const litaC_char* litaC_std__array__Array_get_cb__ptr_const_char_ce_(litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_std__array__Array_cb_Option_ce_ litaC_std__array__ArrayInit_cb_Option_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__array__Array_cb_Option_ce_ litaC_array =  {
        
    };
    litaC_std__array__Array_init_cb_Option_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_std__array__Array_init_cb_Option_ce_(litaC_std__array__Array_cb_Option_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_std__cmdline__Option) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_std__cmdline__Option*)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_std__array__Array_cb__ptr_const_char_ce_ litaC_std__array__ArrayInit_cb__ptr_const_char_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__array__Array_cb__ptr_const_char_ce_ litaC_array =  {
        
    };
    litaC_std__array__Array_init_cb__ptr_const_char_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_std__array__Array_init_cb__ptr_const_char_ce_(litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(const litaC_char*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (const litaC_char**)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_free_cb_Option_ce_(litaC_std__array__Array_cb_Option_ce_* litaC_a) {
    if(litaC_a && litaC_a->elements) {
        {
            litaC_std__mem__Allocator_free(litaC_a->alloc, (litaC_void*)litaC_a->elements);
            litaC_a->elements = NULL;
            litaC_a->length = 0;
            litaC_a->capacity = 0;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_std__array__Array_free_cb__ptr_const_char_ce_(litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_a) {
    if(litaC_a && litaC_a->elements) {
        {
            litaC_std__mem__Allocator_free(litaC_a->alloc, (litaC_void*)litaC_a->elements);
            litaC_a->elements = NULL;
            litaC_a->length = 0;
            litaC_a->capacity = 0;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_std__array__Array_add_cb_Option_ce_(litaC_std__array__Array_cb_Option_ce_* litaC_a,litaC_std__cmdline__Option litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_Option_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb_Option_ce_(litaC_std__array__Array_cb_Option_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_std__cmdline__Option) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_std__cmdline__Option) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_std__cmdline__Option*)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_Option_ce_(litaC_std__array__Array_cb_Option_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_void litaC_std__array__Array_add_cb__ptr_const_char_ce_(litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_a,const litaC_char* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_const_char_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb__ptr_const_char_ce_(litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(const litaC_char*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(const litaC_char*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (const litaC_char**)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_std__array__Array_cb__ptr_TypeInfo_ce_ litaC_std__array__ArrayInit_cb__ptr_TypeInfo_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__array__Array_cb__ptr_TypeInfo_ce_ litaC_array =  {
        
    };
    litaC_std__array__Array_init_cb__ptr_TypeInfo_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_std__array__Array_init_cb__ptr_TypeInfo_ce_(litaC_std__array__Array_cb__ptr_TypeInfo_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_types__TypeInfo*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_types__TypeInfo**)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_TypeInfo_ce_(litaC_std__array__Array_cb__ptr_TypeInfo_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_void litaC_std__array__Array_add_cb__ptr_TypeInfo_ce_(litaC_std__array__Array_cb__ptr_TypeInfo_ce_* litaC_a,litaC_types__TypeInfo* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_TypeInfo_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb__ptr_TypeInfo_ce_(litaC_std__array__Array_cb__ptr_TypeInfo_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_types__TypeInfo*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_types__TypeInfo*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_types__TypeInfo**)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_types__TypeInfo* litaC_std__array__Array_get_cb__ptr_TypeInfo_ce_(litaC_std__array__Array_cb__ptr_TypeInfo_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb_GenericParam_ce_(litaC_std__array__Array_cb_GenericParam_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_GenericParam_ce_(litaC_std__array__Array_cb_GenericParam_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__GenericParam litaC_std__array__Array_get_cb_GenericParam_ce_(litaC_std__array__Array_cb_GenericParam_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__ParameterDecl* litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb_FieldStmt_ce_(litaC_std__array__Array_cb_FieldStmt_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_void litaC_std__array__Array_init_cb__ptr_TypeSpec_ce_(litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__TypeSpec*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__TypeSpec**)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_add_cb__ptr_TypeSpec_ce_(litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_a,litaC_ast__TypeSpec* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_TypeSpec_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb__ptr_TypeSpec_ce_(litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__TypeSpec*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__TypeSpec*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__TypeSpec**)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_std__array__Array_cb_GenericParam_ce_ litaC_std__array__ArrayInit_cb_GenericParam_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__array__Array_cb_GenericParam_ce_ litaC_array =  {
        
    };
    litaC_std__array__Array_init_cb_GenericParam_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_std__array__Array_init_cb_GenericParam_ce_(litaC_std__array__Array_cb_GenericParam_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__GenericParam) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__GenericParam*)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_addAll_cb_GenericParam_ce_(litaC_std__array__Array_cb_GenericParam_ce_* litaC_a,litaC_std__array__Array_cb_GenericParam_ce_* litaC_other) {
    if(!(litaC_other) || litaC_other->length == 0) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_a->length + litaC_other->length > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_GenericParam_ce_(litaC_a, litaC_other->length);
            
            
        }
        
    } 
    
    memcpy((litaC_void*)(&(litaC_a->elements[litaC_a->length])), (const litaC_void*)(&(litaC_other->elements[0])), litaC_other->length * sizeof(litaC_ast__GenericParam));
    litaC_a->length += litaC_other->length;
    
}

litaC_void litaC_std__array__ArrayGrow_cb_GenericParam_ce_(litaC_std__array__Array_cb_GenericParam_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__GenericParam) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__GenericParam) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__GenericParam*)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__EnumFieldEntryDecl* litaC_std__array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_FieldStmt_ce_(litaC_std__array__Array_cb_FieldStmt_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__FieldStmt litaC_std__array__Array_get_cb_FieldStmt_ce_(litaC_std__array__Array_cb_FieldStmt_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb__ptr_ParameterDecl_ce_(litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_ast__ParameterDecl* litaC_std__array__Array_first_cb__ptr_ParameterDecl_ce_(litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_a) {
    assert(litaC_a->length != 0);
    return litaC_a->elements[0];
    
    
}

litaC_void litaC_std__bucket_list__BucketList_init_cb_TypeSpec_ce_(litaC_std__bucket_list__BucketList_cb_TypeSpec_ce_* litaC_this,litaC_i32 litaC_bucketSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_this->allocator = litaC_alloc;
    litaC_this->length = 0;
    litaC_this->bucketSize = litaC_bucketSize;
    litaC_this->buckets = litaC_std__bucket_list__BucketList_allocBucket_cb_TypeSpec_ce_(litaC_this);
    litaC_this->top = litaC_this->buckets;
    
}

litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_* litaC_std__bucket_list__BucketList_allocBucket_cb_TypeSpec_ce_(litaC_std__bucket_list__BucketList_cb_TypeSpec_ce_* litaC_this) {
    litaC_void* litaC_mem = litaC_std__mem__Allocator_alloc(litaC_this->allocator, sizeof(litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_) + (sizeof(litaC_ast__TypeSpec) * litaC_this->bucketSize));
    litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_* litaC_bucket = (litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_*)litaC_mem;
    litaC_bucket->length = 0;
    litaC_bucket->next = NULL;
    litaC_bucket->elements = (litaC_ast__TypeSpec*)(litaC_mem + sizeof(litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_));
    return litaC_bucket;
    
    
}

litaC_void litaC_std__bucket_list__BucketList_free_cb_TypeSpec_ce_(litaC_std__bucket_list__BucketList_cb_TypeSpec_ce_* litaC_this) {
    litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_* litaC_current = litaC_this->buckets;
    litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_* litaC_next = NULL;
    while(litaC_current != NULL) {
        {
            litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_* litaC_bucket = litaC_current;
            litaC_current = litaC_current->next;
            litaC_bucket->next = NULL;
            litaC_std__mem__Allocator_free(litaC_this->allocator, litaC_bucket);
            
            
        }
    }
    
}

litaC_void litaC_std__bucket_list__BucketList_clear_cb_TypeSpec_ce_(litaC_std__bucket_list__BucketList_cb_TypeSpec_ce_* litaC_this) {
    litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_* litaC_current = litaC_this->buckets;
    litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_* litaC_next = NULL;
    while(litaC_current != NULL) {
        {
            litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_* litaC_bucket = litaC_current;
            litaC_current = litaC_current->next;
            litaC_bucket->length = 0;
            
            
        }
    }
    litaC_this->length = 0;
    litaC_this->top = litaC_this->buckets;
    
}

litaC_void litaC_std__bucket_list__BucketList_add_cb_TypeSpec_ce_(litaC_std__bucket_list__BucketList_cb_TypeSpec_ce_* litaC_this,litaC_ast__TypeSpec litaC_element) {
    if(litaC_this->top->length + 1 > litaC_this->bucketSize) {
        {
            if(!(litaC_this->top->next)) {
                {
                    litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_* litaC_next = litaC_std__bucket_list__BucketList_allocBucket_cb_TypeSpec_ce_(litaC_this);
                    litaC_this->top->next = litaC_next;
                    litaC_this->top = litaC_next;
                    
                    
                }
                
            } else {
                {
                    litaC_this->top = litaC_this->top->next;
                    
                    
                }
            } 
            
            
            
        }
        
    } 
    
    {
        litaC_this->top->elements[litaC_this->top->length] = litaC_element;
        
        
    }
    litaC_this->top->length += 1;
    litaC_this->length += 1;
    
}

litaC_ast__TypeSpec* litaC_std__bucket_list__BucketList_lastPtr_cb_TypeSpec_ce_(litaC_std__bucket_list__BucketList_cb_TypeSpec_ce_* litaC_this) {
    assert(litaC_this->length != 0);
    litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_* litaC_bucket = litaC_this->top;
    if(litaC_this->top->length == 0) {
        {
            litaC_i32 litaC_iterations = 0;
            litaC_bucket = litaC_std__bucket_list__BucketList_getBucketAt_cb_TypeSpec_ce_(litaC_this, litaC_this->length - 1, &(litaC_iterations));
            litaC_this->top = litaC_bucket;
            
            
        }
        
    } 
    
    return &(litaC_bucket->elements[litaC_bucket->length - 1]);
    
    
}

litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_* litaC_std__bucket_list__BucketList_getBucketAt_cb_TypeSpec_ce_(litaC_std__bucket_list__BucketList_cb_TypeSpec_ce_* litaC_this,litaC_usize litaC_index,litaC_i32* litaC_iterations) {
    if(litaC_index < litaC_this->bucketSize) {
        {
            *(litaC_iterations) = 0;
            return litaC_this->buckets;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_bucketIndex = 0;
    litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_* litaC_current = litaC_this->buckets;
    litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_* litaC_next = NULL;
    while(litaC_current != NULL) {
        {
            litaC_std__bucket_list__Bucket_cb_TypeSpec_ce_* litaC_bucket = litaC_current;
            litaC_current = litaC_current->next;
            if((litaC_bucketIndex + litaC_bucket->length) > litaC_index) {
                {
                    return litaC_bucket;
                    
                    
                    
                }
                
            } 
            
            *(litaC_iterations) += 1;
            litaC_bucketIndex += litaC_bucket->length;
            
            
        }
    }
    return litaC_this->top;
    
    
}

litaC_ast__ImportDecl* litaC_std__mem__new_cb_ImportDecl_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__ImportDecl* litaC_result = (litaC_ast__ImportDecl*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__ImportDecl));
    return litaC_result;
    
    
}

litaC_ast__VarDecl* litaC_std__mem__new_cb_VarDecl_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__VarDecl* litaC_result = (litaC_ast__VarDecl*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__VarDecl));
    return litaC_result;
    
    
}

litaC_ast__FuncDecl* litaC_std__mem__new_cb_FuncDecl_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__FuncDecl* litaC_result = (litaC_ast__FuncDecl*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__FuncDecl));
    return litaC_result;
    
    
}

litaC_ast__ParametersStmt* litaC_ast__Node_becomeParentOf_cb_ParametersStmt_ce_(litaC_ast__Node* litaC_n,litaC_ast__ParametersStmt* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__Stmt* litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(litaC_ast__Node* litaC_n,litaC_ast__Stmt* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__AggregateDecl* litaC_std__mem__new_cb_AggregateDecl_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__AggregateDecl* litaC_result = (litaC_ast__AggregateDecl*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__AggregateDecl));
    return litaC_result;
    
    
}

litaC_ast__EnumDecl* litaC_ast__Node_becomeParentOf_cb_EnumDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__EnumDecl* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->decl.stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__AggregateDecl* litaC_ast__Node_becomeParentOf_cb_AggregateDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__AggregateDecl* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->decl.declaration.stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__TraitFieldDecl* litaC_ast__Node_becomeParentOf_cb_TraitFieldDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__TraitFieldDecl* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->decl.stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__VarFieldDecl* litaC_ast__Node_becomeParentOf_cb_VarFieldDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__VarFieldDecl* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->decl.stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__Expr* litaC_ast__Node_becomeParentOf_cb_Expr_ce_(litaC_ast__Node* litaC_n,litaC_ast__Expr* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__EnumDecl* litaC_std__mem__new_cb_EnumDecl_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__EnumDecl* litaC_result = (litaC_ast__EnumDecl*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__EnumDecl));
    return litaC_result;
    
    
}

litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_EnumFieldEntryDecl_ce_(litaC_ast__Node* litaC_n,litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_children) {
    litaC_i32 litaC_size = litaC_std__array__Array_size_cb__ptr_EnumFieldEntryDecl_ce_(litaC_children);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_size;litaC_i += 1) {
        {
            litaC_ast__EnumFieldEntryDecl* litaC_child = litaC_std__array__Array_get_cb__ptr_EnumFieldEntryDecl_ce_(litaC_children, litaC_i);
            if(litaC_child) {
                {
                    litaC_ast__Node_becomeParentOf_cb_EnumFieldEntryDecl_ce_(litaC_n, litaC_child);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_children;
    
    
}

litaC_ast__EnumFieldEntryDecl* litaC_ast__Node_becomeParentOf_cb_EnumFieldEntryDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__EnumFieldEntryDecl* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->decl.stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__TypedefDecl* litaC_std__mem__new_cb_TypedefDecl_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__TypedefDecl* litaC_result = (litaC_ast__TypedefDecl*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__TypedefDecl));
    return litaC_result;
    
    
}

litaC_ast__ParameterDecl* litaC_std__mem__new_cb_ParameterDecl_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__ParameterDecl* litaC_result = (litaC_ast__ParameterDecl*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__ParameterDecl));
    return litaC_result;
    
    
}

litaC_ast__NotesDecl* litaC_std__mem__new_cb_NotesDecl_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__NotesDecl* litaC_result = (litaC_ast__NotesDecl*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__NotesDecl));
    return litaC_result;
    
    
}

litaC_ast__NativeDecl* litaC_std__mem__new_cb_NativeDecl_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__NativeDecl* litaC_result = (litaC_ast__NativeDecl*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__NativeDecl));
    return litaC_result;
    
    
}

litaC_ast__PoisonDecl* litaC_std__mem__new_cb_PoisonDecl_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__PoisonDecl* litaC_result = (litaC_ast__PoisonDecl*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__PoisonDecl));
    return litaC_result;
    
    
}

litaC_ast__TernaryExpr* litaC_std__mem__new_cb_TernaryExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__TernaryExpr* litaC_result = (litaC_ast__TernaryExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__TernaryExpr));
    return litaC_result;
    
    
}

litaC_ast__BinaryExpr* litaC_std__mem__new_cb_BinaryExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__BinaryExpr* litaC_result = (litaC_ast__BinaryExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__BinaryExpr));
    return litaC_result;
    
    
}

litaC_ast__UnaryExpr* litaC_std__mem__new_cb_UnaryExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__UnaryExpr* litaC_result = (litaC_ast__UnaryExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__UnaryExpr));
    return litaC_result;
    
    
}

litaC_ast__InitExpr* litaC_std__mem__new_cb_InitExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__InitExpr* litaC_result = (litaC_ast__InitExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__InitExpr));
    return litaC_result;
    
    
}

litaC_std__array__Array_cb__ptr_InitArgExpr_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_InitArgExpr_ce_(litaC_ast__Node* litaC_n,litaC_std__array__Array_cb__ptr_InitArgExpr_ce_* litaC_children) {
    litaC_i32 litaC_size = litaC_std__array__Array_size_cb__ptr_InitArgExpr_ce_(litaC_children);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_size;litaC_i += 1) {
        {
            litaC_ast__InitArgExpr* litaC_child = litaC_std__array__Array_get_cb__ptr_InitArgExpr_ce_(litaC_children, litaC_i);
            if(litaC_child) {
                {
                    litaC_ast__Node_becomeParentOf_cb_InitArgExpr_ce_(litaC_n, litaC_child);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_children;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_InitArgExpr_ce_(litaC_std__array__Array_cb__ptr_InitArgExpr_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__InitArgExpr* litaC_std__array__Array_get_cb__ptr_InitArgExpr_ce_(litaC_std__array__Array_cb__ptr_InitArgExpr_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_ast__InitArgExpr* litaC_ast__Node_becomeParentOf_cb_InitArgExpr_ce_(litaC_ast__Node* litaC_n,litaC_ast__InitArgExpr* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->expr.stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__FuncCallExpr* litaC_std__mem__new_cb_FuncCallExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__FuncCallExpr* litaC_result = (litaC_ast__FuncCallExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__FuncCallExpr));
    return litaC_result;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__CallArg litaC_std__array__Array_get_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_ast__SubscriptGetExpr* litaC_std__mem__new_cb_SubscriptGetExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__SubscriptGetExpr* litaC_result = (litaC_ast__SubscriptGetExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__SubscriptGetExpr));
    return litaC_result;
    
    
}

litaC_ast__SubscriptSetExpr* litaC_std__mem__new_cb_SubscriptSetExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__SubscriptSetExpr* litaC_result = (litaC_ast__SubscriptSetExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__SubscriptSetExpr));
    return litaC_result;
    
    
}

litaC_ast__GetExpr* litaC_std__mem__new_cb_GetExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__GetExpr* litaC_result = (litaC_ast__GetExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__GetExpr));
    return litaC_result;
    
    
}

litaC_ast__IdentifierExpr* litaC_ast__Node_becomeParentOf_cb_IdentifierExpr_ce_(litaC_ast__Node* litaC_n,litaC_ast__IdentifierExpr* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->expr.stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__SetExpr* litaC_std__mem__new_cb_SetExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__SetExpr* litaC_result = (litaC_ast__SetExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__SetExpr));
    return litaC_result;
    
    
}

litaC_ast__IdentifierExpr* litaC_std__mem__new_cb_IdentifierExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__IdentifierExpr* litaC_result = (litaC_ast__IdentifierExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__IdentifierExpr));
    return litaC_result;
    
    
}

litaC_ast__TypeIdentifierExpr* litaC_std__mem__new_cb_TypeIdentifierExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__TypeIdentifierExpr* litaC_result = (litaC_ast__TypeIdentifierExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__TypeIdentifierExpr));
    return litaC_result;
    
    
}

litaC_ast__CastExpr* litaC_std__mem__new_cb_CastExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__CastExpr* litaC_result = (litaC_ast__CastExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__CastExpr));
    return litaC_result;
    
    
}

litaC_ast__ArrayDesignationExpr* litaC_std__mem__new_cb_ArrayDesignationExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__ArrayDesignationExpr* litaC_result = (litaC_ast__ArrayDesignationExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__ArrayDesignationExpr));
    return litaC_result;
    
    
}

litaC_ast__InitArgExpr* litaC_std__mem__new_cb_InitArgExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__InitArgExpr* litaC_result = (litaC_ast__InitArgExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__InitArgExpr));
    return litaC_result;
    
    
}

litaC_ast__BooleanExpr* litaC_std__mem__new_cb_BooleanExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__BooleanExpr* litaC_result = (litaC_ast__BooleanExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__BooleanExpr));
    return litaC_result;
    
    
}

litaC_ast__NullExpr* litaC_std__mem__new_cb_NullExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__NullExpr* litaC_result = (litaC_ast__NullExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__NullExpr));
    return litaC_result;
    
    
}

litaC_ast__NumberExpr* litaC_std__mem__new_cb_NumberExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__NumberExpr* litaC_result = (litaC_ast__NumberExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__NumberExpr));
    return litaC_result;
    
    
}

litaC_ast__StringExpr* litaC_std__mem__new_cb_StringExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__StringExpr* litaC_result = (litaC_ast__StringExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__StringExpr));
    return litaC_result;
    
    
}

litaC_ast__CharExpr* litaC_std__mem__new_cb_CharExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__CharExpr* litaC_result = (litaC_ast__CharExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__CharExpr));
    return litaC_result;
    
    
}

litaC_ast__GroupExpr* litaC_std__mem__new_cb_GroupExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__GroupExpr* litaC_result = (litaC_ast__GroupExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__GroupExpr));
    return litaC_result;
    
    
}

litaC_ast__ArrayInitExpr* litaC_std__mem__new_cb_ArrayInitExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__ArrayInitExpr* litaC_result = (litaC_ast__ArrayInitExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__ArrayInitExpr));
    return litaC_result;
    
    
}

litaC_std__array__Array_cb__ptr_Expr_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_Expr_ce_(litaC_ast__Node* litaC_n,litaC_std__array__Array_cb__ptr_Expr_ce_* litaC_children) {
    litaC_i32 litaC_size = litaC_std__array__Array_size_cb__ptr_Expr_ce_(litaC_children);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_size;litaC_i += 1) {
        {
            litaC_ast__Expr* litaC_child = litaC_std__array__Array_get_cb__ptr_Expr_ce_(litaC_children, litaC_i);
            if(litaC_child) {
                {
                    litaC_ast__Node_becomeParentOf_cb_Expr_ce_(litaC_n, litaC_child);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_children;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_Expr_ce_(litaC_std__array__Array_cb__ptr_Expr_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__Expr* litaC_std__array__Array_get_cb__ptr_Expr_ce_(litaC_std__array__Array_cb__ptr_Expr_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb__ptr_Expr_ce_(litaC_std__array__Array_cb__ptr_Expr_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_ast__SizeOfExpr* litaC_std__mem__new_cb_SizeOfExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__SizeOfExpr* litaC_result = (litaC_ast__SizeOfExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__SizeOfExpr));
    return litaC_result;
    
    
}

litaC_ast__TypeOfExpr* litaC_std__mem__new_cb_TypeOfExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__TypeOfExpr* litaC_result = (litaC_ast__TypeOfExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__TypeOfExpr));
    return litaC_result;
    
    
}

litaC_ast__OffsetOfExpr* litaC_std__mem__new_cb_OffsetOfExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__OffsetOfExpr* litaC_result = (litaC_ast__OffsetOfExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__OffsetOfExpr));
    return litaC_result;
    
    
}

litaC_ast__PoisonExpr* litaC_std__mem__new_cb_PoisonExpr_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__PoisonExpr* litaC_result = (litaC_ast__PoisonExpr*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__PoisonExpr));
    return litaC_result;
    
    
}

litaC_ast__ModuleStmt* litaC_std__mem__new_cb_ModuleStmt_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__ModuleStmt* litaC_result = (litaC_ast__ModuleStmt*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__ModuleStmt));
    return litaC_result;
    
    
}

litaC_ast__CompStmt* litaC_std__mem__new_cb_CompStmt_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__CompStmt* litaC_result = (litaC_ast__CompStmt*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__CompStmt));
    return litaC_result;
    
    
}

litaC_ast__BlockStmt* litaC_std__mem__new_cb_BlockStmt_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__BlockStmt* litaC_result = (litaC_ast__BlockStmt*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__BlockStmt));
    return litaC_result;
    
    
}

litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_Stmt_ce_(litaC_ast__Node* litaC_n,litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_children) {
    litaC_i32 litaC_size = litaC_std__array__Array_size_cb__ptr_Stmt_ce_(litaC_children);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_size;litaC_i += 1) {
        {
            litaC_ast__Stmt* litaC_child = litaC_std__array__Array_get_cb__ptr_Stmt_ce_(litaC_children, litaC_i);
            if(litaC_child) {
                {
                    litaC_ast__Node_becomeParentOf_cb_Stmt_ce_(litaC_n, litaC_child);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_children;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_Stmt_ce_(litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__Stmt* litaC_std__array__Array_get_cb__ptr_Stmt_ce_(litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_ast__IfStmt* litaC_std__mem__new_cb_IfStmt_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__IfStmt* litaC_result = (litaC_ast__IfStmt*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__IfStmt));
    return litaC_result;
    
    
}

litaC_ast__WhileStmt* litaC_std__mem__new_cb_WhileStmt_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__WhileStmt* litaC_result = (litaC_ast__WhileStmt*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__WhileStmt));
    return litaC_result;
    
    
}

litaC_ast__DoWhileStmt* litaC_std__mem__new_cb_DoWhileStmt_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__DoWhileStmt* litaC_result = (litaC_ast__DoWhileStmt*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__DoWhileStmt));
    return litaC_result;
    
    
}

litaC_ast__ForStmt* litaC_std__mem__new_cb_ForStmt_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__ForStmt* litaC_result = (litaC_ast__ForStmt*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__ForStmt));
    return litaC_result;
    
    
}

litaC_ast__SwitchCaseStmt* litaC_std__mem__new_cb_SwitchCaseStmt_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__SwitchCaseStmt* litaC_result = (litaC_ast__SwitchCaseStmt*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__SwitchCaseStmt));
    return litaC_result;
    
    
}

litaC_ast__SwitchStmt* litaC_std__mem__new_cb_SwitchStmt_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__SwitchStmt* litaC_result = (litaC_ast__SwitchStmt*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__SwitchStmt));
    return litaC_result;
    
    
}

litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_SwitchCaseStmt_ce_(litaC_ast__Node* litaC_n,litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_children) {
    litaC_i32 litaC_size = litaC_std__array__Array_size_cb__ptr_SwitchCaseStmt_ce_(litaC_children);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_size;litaC_i += 1) {
        {
            litaC_ast__SwitchCaseStmt* litaC_child = litaC_std__array__Array_get_cb__ptr_SwitchCaseStmt_ce_(litaC_children, litaC_i);
            if(litaC_child) {
                {
                    litaC_ast__Node_becomeParentOf_cb_SwitchCaseStmt_ce_(litaC_n, litaC_child);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_children;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_SwitchCaseStmt_ce_(litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__SwitchCaseStmt* litaC_std__array__Array_get_cb__ptr_SwitchCaseStmt_ce_(litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_ast__SwitchCaseStmt* litaC_ast__Node_becomeParentOf_cb_SwitchCaseStmt_ce_(litaC_ast__Node* litaC_n,litaC_ast__SwitchCaseStmt* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__BreakStmt* litaC_std__mem__new_cb_BreakStmt_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__BreakStmt* litaC_result = (litaC_ast__BreakStmt*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__BreakStmt));
    return litaC_result;
    
    
}

litaC_ast__ContinueStmt* litaC_std__mem__new_cb_ContinueStmt_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__ContinueStmt* litaC_result = (litaC_ast__ContinueStmt*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__ContinueStmt));
    return litaC_result;
    
    
}

litaC_ast__ReturnStmt* litaC_std__mem__new_cb_ReturnStmt_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__ReturnStmt* litaC_result = (litaC_ast__ReturnStmt*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__ReturnStmt));
    return litaC_result;
    
    
}

litaC_ast__DeferStmt* litaC_std__mem__new_cb_DeferStmt_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__DeferStmt* litaC_result = (litaC_ast__DeferStmt*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__DeferStmt));
    return litaC_result;
    
    
}

litaC_ast__GotoStmt* litaC_std__mem__new_cb_GotoStmt_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__GotoStmt* litaC_result = (litaC_ast__GotoStmt*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__GotoStmt));
    return litaC_result;
    
    
}

litaC_ast__LabelStmt* litaC_std__mem__new_cb_LabelStmt_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__LabelStmt* litaC_result = (litaC_ast__LabelStmt*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__LabelStmt));
    return litaC_result;
    
    
}

litaC_ast__NoteStmt* litaC_std__mem__new_cb_NoteStmt_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__NoteStmt* litaC_result = (litaC_ast__NoteStmt*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__NoteStmt));
    return litaC_result;
    
    
}

litaC_ast__EmptyStmt* litaC_std__mem__new_cb_EmptyStmt_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__EmptyStmt* litaC_result = (litaC_ast__EmptyStmt*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__EmptyStmt));
    return litaC_result;
    
    
}

litaC_ast__ParametersStmt* litaC_std__mem__new_cb_ParametersStmt_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__ParametersStmt* litaC_result = (litaC_ast__ParametersStmt*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__ParametersStmt));
    return litaC_result;
    
    
}

litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_ast__Node_becomeParentOfChildren_cb__ptr_ParameterDecl_ce_(litaC_ast__Node* litaC_n,litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_children) {
    litaC_i32 litaC_size = litaC_std__array__Array_size_cb__ptr_ParameterDecl_ce_(litaC_children);
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_size;litaC_i += 1) {
        {
            litaC_ast__ParameterDecl* litaC_child = litaC_std__array__Array_get_cb__ptr_ParameterDecl_ce_(litaC_children, litaC_i);
            if(litaC_child) {
                {
                    litaC_ast__Node_becomeParentOf_cb_ParameterDecl_ce_(litaC_n, litaC_child);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    return litaC_children;
    
    
}

litaC_ast__ParameterDecl* litaC_ast__Node_becomeParentOf_cb_ParameterDecl_ce_(litaC_ast__Node* litaC_n,litaC_ast__ParameterDecl* litaC_child) {
    if(!(litaC_child)) {
        return NULL;
        
        
    } 
    
    litaC_child->decl.stmt.node.parent = (litaC_ast__Node*)litaC_n;
    return litaC_child;
    
    
}

litaC_ast__VarFieldDecl* litaC_std__mem__new_cb_VarFieldDecl_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__VarFieldDecl* litaC_result = (litaC_ast__VarFieldDecl*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__VarFieldDecl));
    return litaC_result;
    
    
}

litaC_ast__TraitFieldDecl* litaC_std__mem__new_cb_TraitFieldDecl_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__TraitFieldDecl* litaC_result = (litaC_ast__TraitFieldDecl*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__TraitFieldDecl));
    return litaC_result;
    
    
}

litaC_ast__EnumFieldEntryDecl* litaC_std__mem__new_cb_EnumFieldEntryDecl_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_ast__EnumFieldEntryDecl* litaC_result = (litaC_ast__EnumFieldEntryDecl*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_ast__EnumFieldEntryDecl));
    return litaC_result;
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb__ptr_NoteStmt_ce_(litaC_std__array__Array_cb__ptr_NoteStmt_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_NoteStmt_ce_(litaC_std__array__Array_cb__ptr_NoteStmt_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__NoteStmt* litaC_std__array__Array_get_cb__ptr_NoteStmt_ce_(litaC_std__array__Array_cb__ptr_NoteStmt_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_ast__CallArg* litaC_std__array__Array_getPtr_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return &(litaC_a->elements[litaC_index]);
    
    
}

litaC_symbols__Scope* litaC_std__mem__new_cb_Scope_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_symbols__Scope* litaC_result = (litaC_symbols__Scope*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_symbols__Scope));
    return litaC_result;
    
    
}

litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_ litaC_intern__InternMap_cb__ptr_Symbol_ce_(litaC_symbols__Symbol* litaC_emptyValue,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_ litaC_map =  {
        
    };
    litaC_std__map__Map_init_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_map)), litaC_emptyValue, litaC_initialSize, litaC_intern__InternHashFn, litaC_intern__InternEqualFn, litaC_allocator, litaC_intern__EMPTY_STR);
    return litaC_map;
    
    
}

litaC_void litaC_std__map__Map_init_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_m,litaC_symbols__Symbol* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_intern__InternedString),litaC_bool (*litaC_equalFn)(litaC_intern__InternedString,litaC_intern__InternedString),const litaC_std__mem__Allocator* litaC_alloc,litaC_intern__InternedString litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_std__mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_std__map__nextPowerOf2(litaC_initialSize);
    litaC_std__map__MapGrow_cb_InternedString_c__ptr_Symbol_ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_std__map__MapGrow_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (litaC_std__map__Key_cb_InternedString_ce_*)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_std__map__Key_cb_InternedString_ce_)),
        .values = (litaC_symbols__Symbol**)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_symbols__Symbol*)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i].key, litaC_m->emptyKey))) {
                {
                    litaC_std__map__Map_put_cb_InternedString_c__ptr_Symbol_ce_(&((litaC_newMap)), litaC_m->keys[litaC_i].key, litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_std__map__Map_free_cb_InternedString_c__ptr_Symbol_ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_std__map__Map_put_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_m,litaC_intern__InternedString litaC_key,litaC_symbols__Symbol* litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_std__map__MapGrow_cb_InternedString_c__ptr_Symbol_ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb_InternedString_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i].key = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_std__map__Map_free_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_symbols__Symbol* litaC_std__map__Map_get_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_m,litaC_intern__InternedString litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb_InternedString_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    return litaC_m->values[litaC_i];
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

litaC_bool litaC_std__map__Map_contains_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_m,litaC_intern__InternedString litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb_InternedString_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_symbols__Symbol* litaC_std__map__Map_remove_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_m,litaC_intern__InternedString litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb_InternedString_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    litaC_symbols__Symbol* litaC_v = litaC_m->values[litaC_i];
                    litaC_m->keys[litaC_i].key = litaC_m->emptyKey;
                    litaC_m->keys[litaC_i].state = litaC_std__map__KeyState_TOMBSTONE;
                    litaC_m->length -= 1;
                    return litaC_v;
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

litaC_symbols__Symbol* litaC_std__mem__new_cb_Symbol_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_symbols__Symbol* litaC_result = (litaC_symbols__Symbol*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_symbols__Symbol));
    return litaC_result;
    
    
}

litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_ litaC_std__map__Map_iter_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_Symbol_ce_* litaC_m) {
    return (litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_) {
        .m = litaC_m,
        .it = 0,
        .prevIt = 0,
        .count = 0
    };
    
    
}

litaC_bool litaC_std__map__MapIterator_hasNext_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_* litaC_iter) {
    return litaC_iter->count < litaC_iter->m->length;
    
    
}

litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_ litaC_std__map__MapIterator_next_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_* litaC_iter) {
    litaC_i32 litaC_i = litaC_iter->it;
    assert(litaC_i < litaC_iter->m->capacity);
    
    for(;litaC_i < litaC_iter->m->capacity;litaC_i += 1) {
        {
            litaC_bool litaC_hasValue = !(litaC_iter->m->equalFn(litaC_iter->m->keys[litaC_i].key, litaC_iter->m->emptyKey));
            if(litaC_hasValue) {
                {
                    litaC_iter->count += 1;
                    litaC_iter->prevIt = litaC_i;
                    {
                        litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_ ___result = (litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_) {
                            .key = litaC_iter->m->keys[litaC_i].key,
                            .value = litaC_iter->m->values[litaC_i],
                            .valuePtr = &(litaC_iter->m->values[litaC_i])
                        };
                        litaC_iter->it = litaC_i + 1;
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    {
        litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_ ___result = (litaC_std__map__MapEntry_cb_InternedString_c__ptr_Symbol_ce_) {
            
        };
        litaC_iter->it = litaC_i + 1;
        return ___result;
        
    }
    
    litaC_iter->it = litaC_i + 1;
    
}

litaC_void litaC_std__map__MapIterator_remove_cb_InternedString_c__ptr_Symbol_ce_(litaC_std__map__MapIterator_cb_InternedString_c__ptr_Symbol_ce_* litaC_iter) {
    litaC_i32 litaC_i = litaC_iter->prevIt;
    assert(litaC_i > -(1) && litaC_i < litaC_iter->m->capacity);
    litaC_iter->m->keys[litaC_i].state = litaC_std__map__KeyState_TOMBSTONE;
    litaC_iter->m->keys[litaC_i].key = litaC_iter->m->emptyKey;
    litaC_iter->m->values[litaC_i] = litaC_iter->m->emptyValue;
    litaC_iter->m->length -= 1;
    litaC_iter->count -= 1;
    
}

litaC_std__map__MapIterator_cb__ptr_const_char_c_ModuleImport_ce_ litaC_std__map__Map_iter_cb__ptr_const_char_c_ModuleImport_ce_(litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_* litaC_m) {
    return (litaC_std__map__MapIterator_cb__ptr_const_char_c_ModuleImport_ce_) {
        .m = litaC_m,
        .it = 0,
        .prevIt = 0,
        .count = 0
    };
    
    
}

litaC_bool litaC_std__map__MapIterator_hasNext_cb__ptr_const_char_c_ModuleImport_ce_(litaC_std__map__MapIterator_cb__ptr_const_char_c_ModuleImport_ce_* litaC_iter) {
    return litaC_iter->count < litaC_iter->m->length;
    
    
}

litaC_std__map__MapEntry_cb__ptr_const_char_c_ModuleImport_ce_ litaC_std__map__MapIterator_next_cb__ptr_const_char_c_ModuleImport_ce_(litaC_std__map__MapIterator_cb__ptr_const_char_c_ModuleImport_ce_* litaC_iter) {
    litaC_i32 litaC_i = litaC_iter->it;
    assert(litaC_i < litaC_iter->m->capacity);
    
    for(;litaC_i < litaC_iter->m->capacity;litaC_i += 1) {
        {
            litaC_bool litaC_hasValue = !(litaC_iter->m->equalFn(litaC_iter->m->keys[litaC_i].key, litaC_iter->m->emptyKey));
            if(litaC_hasValue) {
                {
                    litaC_iter->count += 1;
                    litaC_iter->prevIt = litaC_i;
                    {
                        litaC_std__map__MapEntry_cb__ptr_const_char_c_ModuleImport_ce_ ___result = (litaC_std__map__MapEntry_cb__ptr_const_char_c_ModuleImport_ce_) {
                            .key = litaC_iter->m->keys[litaC_i].key,
                            .value = litaC_iter->m->values[litaC_i],
                            .valuePtr = &(litaC_iter->m->values[litaC_i])
                        };
                        litaC_iter->it = litaC_i + 1;
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    {
        litaC_std__map__MapEntry_cb__ptr_const_char_c_ModuleImport_ce_ ___result = (litaC_std__map__MapEntry_cb__ptr_const_char_c_ModuleImport_ce_) {
            
        };
        litaC_iter->it = litaC_i + 1;
        return ___result;
        
    }
    
    litaC_iter->it = litaC_i + 1;
    
}

litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_ litaC_std__map__StrMap_cb_ModuleImport_ce_(litaC_module__ModuleImport litaC_emptyValue,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_ litaC_m =  {
        
    };
    litaC_std__map__Map_init_cb__ptr_const_char_c_ModuleImport_ce_(&((litaC_m)), litaC_emptyValue, litaC_initialSize, litaC_std__map__StrHashFn, litaC_std__map__StrEqualFn, litaC_alloc, 0);
    return litaC_m;
    
    
}

litaC_void litaC_std__map__Map_init_cb__ptr_const_char_c_ModuleImport_ce_(litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_* litaC_m,litaC_module__ModuleImport litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(const litaC_char*),litaC_bool (*litaC_equalFn)(const litaC_char*,const litaC_char*),const litaC_std__mem__Allocator* litaC_alloc,const litaC_char* litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_std__mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_std__map__nextPowerOf2(litaC_initialSize);
    litaC_std__map__MapGrow_cb__ptr_const_char_c_ModuleImport_ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_std__map__MapGrow_cb__ptr_const_char_c_ModuleImport_ce_(litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (litaC_std__map__Key_cb__ptr_const_char_ce_*)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_std__map__Key_cb__ptr_const_char_ce_)),
        .values = (litaC_module__ModuleImport*)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_module__ModuleImport)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i].key, litaC_m->emptyKey))) {
                {
                    litaC_std__map__Map_put_cb__ptr_const_char_c_ModuleImport_ce_(&((litaC_newMap)), litaC_m->keys[litaC_i].key, litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_std__map__Map_free_cb__ptr_const_char_c_ModuleImport_ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_std__map__Map_put_cb__ptr_const_char_c_ModuleImport_ce_(litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_* litaC_m,const litaC_char* litaC_key,litaC_module__ModuleImport litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_std__map__MapGrow_cb__ptr_const_char_c_ModuleImport_ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb__ptr_const_char_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i].key = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_std__map__Map_free_cb__ptr_const_char_c_ModuleImport_ce_(litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_module__Module* litaC_std__mem__new_cb_Module_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_module__Module* litaC_result = (litaC_module__Module*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_module__Module));
    return litaC_result;
    
    
}

litaC_module__ModuleImport litaC_std__map__Map_get_cb__ptr_const_char_c_ModuleImport_ce_(litaC_std__map__Map_cb__ptr_const_char_c_ModuleImport_ce_* litaC_m,const litaC_char* litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb__ptr_const_char_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    return litaC_m->values[litaC_i];
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

litaC_void litaC_std__array__Array_init_cb_PhaseError_ce_(litaC_std__array__Array_cb_PhaseError_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_phase_result__PhaseError) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_phase_result__PhaseError*)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_add_cb_PhaseError_ce_(litaC_std__array__Array_cb_PhaseError_ce_* litaC_a,litaC_phase_result__PhaseError litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_PhaseError_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb_PhaseError_ce_(litaC_std__array__Array_cb_PhaseError_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_phase_result__PhaseError) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_phase_result__PhaseError) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_phase_result__PhaseError*)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

LITAC_INLINE 
litaC_void litaC_std__array__Array_clear_cb_PhaseError_ce_(litaC_std__array__Array_cb_PhaseError_ce_* litaC_a) {
    litaC_a->length = 0;
    
}

litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_ litaC_std__map__StrMap_cb__ptr_Module_ce_(litaC_module__Module* litaC_emptyValue,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_ litaC_m =  {
        
    };
    litaC_std__map__Map_init_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_m)), litaC_emptyValue, litaC_initialSize, litaC_std__map__StrHashFn, litaC_std__map__StrEqualFn, litaC_alloc, 0);
    return litaC_m;
    
    
}

litaC_void litaC_std__map__Map_init_cb__ptr_const_char_c__ptr_Module_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m,litaC_module__Module* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(const litaC_char*),litaC_bool (*litaC_equalFn)(const litaC_char*,const litaC_char*),const litaC_std__mem__Allocator* litaC_alloc,const litaC_char* litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_std__mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_std__map__nextPowerOf2(litaC_initialSize);
    litaC_std__map__MapGrow_cb__ptr_const_char_c__ptr_Module_ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_std__map__MapGrow_cb__ptr_const_char_c__ptr_Module_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (litaC_std__map__Key_cb__ptr_const_char_ce_*)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_std__map__Key_cb__ptr_const_char_ce_)),
        .values = (litaC_module__Module**)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_module__Module*)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i].key, litaC_m->emptyKey))) {
                {
                    litaC_std__map__Map_put_cb__ptr_const_char_c__ptr_Module_ce_(&((litaC_newMap)), litaC_m->keys[litaC_i].key, litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_std__map__Map_free_cb__ptr_const_char_c__ptr_Module_ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_std__map__Map_put_cb__ptr_const_char_c__ptr_Module_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m,const litaC_char* litaC_key,litaC_module__Module* litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_std__map__MapGrow_cb__ptr_const_char_c__ptr_Module_ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb__ptr_const_char_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i].key = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_std__map__Map_free_cb__ptr_const_char_c__ptr_Module_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_std__array__Array_init_cb_CCompilerOption_ce_(litaC_std__array__Array_cb_CCompilerOption_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_lita__CCompilerOption) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_lita__CCompilerOption*)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_module__Module* litaC_std__map__Map_get_cb__ptr_const_char_c__ptr_Module_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m,const litaC_char* litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb__ptr_const_char_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    return litaC_m->values[litaC_i];
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

litaC_void litaC_std__array__Array_insertAt_cb__ptr_ImportDecl_ce_(litaC_std__array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__ImportDecl* litaC_element) {
    assert(litaC_index >= 0 && litaC_index <= litaC_a->length);
    if(litaC_index == litaC_a->length) {
        {
            litaC_std__array__Array_add_cb__ptr_ImportDecl_ce_(litaC_a, litaC_element);
            return;
            
            
            
        }
        
    } 
    
    litaC_a->length += 1;
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_ImportDecl_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    memmove((litaC_void*)(&(litaC_a->elements[litaC_index + 1])), (const litaC_void*)(&(litaC_a->elements[litaC_index])), (litaC_a->length - litaC_index) * sizeof(litaC_ast__ImportDecl*));
    litaC_std__array__Array_set_cb__ptr_ImportDecl_ce_(litaC_a, litaC_index, litaC_element);
    
}

litaC_void litaC_std__array__Array_add_cb__ptr_ImportDecl_ce_(litaC_std__array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_ast__ImportDecl* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_ImportDecl_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb__ptr_ImportDecl_ce_(litaC_std__array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__ImportDecl*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__ImportDecl*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__ImportDecl**)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_void litaC_std__array__Array_set_cb__ptr_ImportDecl_ce_(litaC_std__array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__ImportDecl* litaC_element) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    {
        litaC_a->elements[litaC_index] = litaC_element;
        
        
    }
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_Symbol_ce_(litaC_std__array__Array_cb__ptr_Symbol_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_symbols__Symbol* litaC_std__array__Array_get_cb__ptr_Symbol_ce_(litaC_std__array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_symbols__Symbol* litaC_std__array__Array_removeAt_cb__ptr_Symbol_ce_(litaC_std__array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    litaC_symbols__Symbol* litaC_r = litaC_a->elements[litaC_index];
    if(litaC_index < litaC_a->length - 1) {
        {
            memmove((litaC_void*)(&(litaC_a->elements[litaC_index])), (const litaC_void*)(&(litaC_a->elements[litaC_index + 1])), ((litaC_a->length - 1) - litaC_index) * sizeof(litaC_symbols__Symbol*));
            
            
        }
        
    } 
    
    litaC_a->length -= 1;
    return litaC_r;
    
    
}

litaC_void litaC_std__array__Array_add_cb__ptr_Symbol_ce_(litaC_std__array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_symbols__Symbol* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_Symbol_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb__ptr_Symbol_ce_(litaC_std__array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_symbols__Symbol*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_symbols__Symbol*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_symbols__Symbol**)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb_CCompilerOption_ce_(litaC_std__array__Array_cb_CCompilerOption_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_CCompilerOption_ce_(litaC_std__array__Array_cb_CCompilerOption_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_lita__CCompilerOption* litaC_std__array__Array_getPtr_cb_CCompilerOption_ce_(litaC_std__array__Array_cb_CCompilerOption_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return &(litaC_a->elements[litaC_index]);
    
    
}

litaC_lsp__document__Document* litaC_std__map__Map_get_cb__ptr_const_char_c__ptr_Document_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_* litaC_m,const litaC_char* litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb__ptr_const_char_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    return litaC_m->values[litaC_i];
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_ImportDecl_ce_(litaC_std__array__Array_cb__ptr_ImportDecl_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__ImportDecl* litaC_std__array__Array_get_cb__ptr_ImportDecl_ce_(litaC_std__array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_void* litaC_std__mem__GenericMalloc_cb_BucketAllocator_ce_(const litaC_std__mem__Allocator* litaC_alloc,litaC_usize litaC_size) {
    litaC_std__mem__bucket_allocator__BucketAllocator* litaC_this = (litaC_std__mem__bucket_allocator__BucketAllocator*)litaC_alloc;
    return litaC_std__mem__bucket_allocator__BucketAllocator_malloc(litaC_this, litaC_size);
    
    
}

litaC_void* litaC_std__mem__GenericCalloc_cb_BucketAllocator_ce_(const litaC_std__mem__Allocator* litaC_alloc,litaC_usize litaC_num,litaC_usize litaC_size) {
    litaC_std__mem__bucket_allocator__BucketAllocator* litaC_this = (litaC_std__mem__bucket_allocator__BucketAllocator*)litaC_alloc;
    litaC_void* litaC_result = litaC_std__mem__bucket_allocator__BucketAllocator_malloc(litaC_this, litaC_size * litaC_num);
    if(litaC_result) {
        {
            memset(litaC_result, 0, litaC_size * litaC_num);
            
            
        }
        
    } 
    
    return litaC_result;
    
    
}

litaC_void* litaC_std__mem__GenericRealloc_cb_BucketAllocator_ce_(const litaC_std__mem__Allocator* litaC_alloc,litaC_void* litaC_ptr,litaC_usize litaC_oldSize,litaC_usize litaC_size) {
    if(litaC_ptr == NULL) {
        {
            return litaC_std__mem__GenericMalloc_cb_BucketAllocator_ce_(litaC_alloc, litaC_size);
            
            
            
        }
        
    } 
    
    litaC_std__mem__bucket_allocator__BucketAllocator* litaC_this = (litaC_std__mem__bucket_allocator__BucketAllocator*)litaC_alloc;
    litaC_void* litaC_result = litaC_std__mem__bucket_allocator__BucketAllocator_malloc(litaC_this, litaC_size);
    if(litaC_result) {
        {
            litaC_usize litaC_len = MIN(litaC_oldSize, litaC_size);
            memcpy(litaC_result, litaC_ptr, litaC_len);
            
            
        }
        
    } 
    
    return litaC_result;
    
    
}

litaC_void litaC_std__array__Array_init_cb_CheckerContext_ce_(litaC_std__array__Array_cb_CheckerContext_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_preprocessor__CheckerContext) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_preprocessor__CheckerContext*)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_init_cb_ScriptDecl_ce_(litaC_std__array__Array_cb_ScriptDecl_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_preprocessor__ScriptDecl) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_preprocessor__ScriptDecl*)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_add_cb_CheckerContext_ce_(litaC_std__array__Array_cb_CheckerContext_ce_* litaC_a,litaC_preprocessor__CheckerContext litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_CheckerContext_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb_CheckerContext_ce_(litaC_std__array__Array_cb_CheckerContext_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_preprocessor__CheckerContext) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_preprocessor__CheckerContext) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_preprocessor__CheckerContext*)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_void litaC_std__array__Array_add_cb__ptr_NoteStmt_ce_(litaC_std__array__Array_cb__ptr_NoteStmt_ce_* litaC_a,litaC_ast__NoteStmt* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_NoteStmt_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb__ptr_NoteStmt_ce_(litaC_std__array__Array_cb__ptr_NoteStmt_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__NoteStmt*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__NoteStmt*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__NoteStmt**)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_void litaC_std__array__Array_addAll_cb__ptr_NoteStmt_ce_(litaC_std__array__Array_cb__ptr_NoteStmt_ce_* litaC_a,litaC_std__array__Array_cb__ptr_NoteStmt_ce_* litaC_other) {
    if(!(litaC_other) || litaC_other->length == 0) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_a->length + litaC_other->length > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_NoteStmt_ce_(litaC_a, litaC_other->length);
            
            
        }
        
    } 
    
    memcpy((litaC_void*)(&(litaC_a->elements[litaC_a->length])), (const litaC_void*)(&(litaC_other->elements[0])), litaC_other->length * sizeof(litaC_ast__NoteStmt*));
    litaC_a->length += litaC_other->length;
    
}

litaC_void litaC_std__array__Array_add_cb__ptr_Decl_ce_(litaC_std__array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_ast__Decl* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_Decl_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb__ptr_Decl_ce_(litaC_std__array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__Decl*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__Decl*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__Decl**)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_CheckerContext_ce_(litaC_std__array__Array_cb_CheckerContext_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_preprocessor__CheckerContext litaC_std__array__Array_get_cb_CheckerContext_ce_(litaC_std__array__Array_cb_CheckerContext_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb_ScriptDecl_ce_(litaC_std__array__Array_cb_ScriptDecl_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_preprocessor__ScriptDecl litaC_std__array__Array_pop_cb_ScriptDecl_ce_(litaC_std__array__Array_cb_ScriptDecl_ce_* litaC_a) {
    assert(litaC_a->length != 0);
    litaC_preprocessor__ScriptDecl litaC_r = litaC_a->elements[litaC_a->length - 1];
    litaC_a->length -= 1;
    return litaC_r;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_Decl_ce_(litaC_std__array__Array_cb__ptr_Decl_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_void litaC_std__array__Array_addAll_cb__ptr_Decl_ce_(litaC_std__array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_std__array__Array_cb__ptr_Decl_ce_* litaC_other) {
    if(!(litaC_other) || litaC_other->length == 0) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_a->length + litaC_other->length > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_Decl_ce_(litaC_a, litaC_other->length);
            
            
        }
        
    } 
    
    memcpy((litaC_void*)(&(litaC_a->elements[litaC_a->length])), (const litaC_void*)(&(litaC_other->elements[0])), litaC_other->length * sizeof(litaC_ast__Decl*));
    litaC_a->length += litaC_other->length;
    
}

litaC_ast__Decl* litaC_std__array__Array_get_cb__ptr_Decl_ce_(litaC_std__array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_void litaC_std__array__Array_addAll_cb__ptr_ImportDecl_ce_(litaC_std__array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_std__array__Array_cb__ptr_ImportDecl_ce_* litaC_other) {
    if(!(litaC_other) || litaC_other->length == 0) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_a->length + litaC_other->length > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_ImportDecl_ce_(litaC_a, litaC_other->length);
            
            
        }
        
    } 
    
    memcpy((litaC_void*)(&(litaC_a->elements[litaC_a->length])), (const litaC_void*)(&(litaC_other->elements[0])), litaC_other->length * sizeof(litaC_ast__ImportDecl*));
    litaC_a->length += litaC_other->length;
    
}

LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb__ptr_TypeSpec_ce_(litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_TypeSpec_ce_(litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_ast__TypeSpec* litaC_std__array__Array_get_cb__ptr_TypeSpec_ce_(litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_void litaC_std__array__Array_add_cb_GenericParam_ce_(litaC_std__array__Array_cb_GenericParam_ce_* litaC_a,litaC_ast__GenericParam litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_GenericParam_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_std__array__Array_cb_CallArg_ce_ litaC_std__array__ArrayInit_cb_CallArg_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__array__Array_cb_CallArg_ce_ litaC_array =  {
        
    };
    litaC_std__array__Array_init_cb_CallArg_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_std__array__Array_init_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__CallArg) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__CallArg*)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_add_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a,litaC_ast__CallArg litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_CallArg_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__CallArg) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__CallArg) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__CallArg*)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_std__array__Array_cb__ptr_Expr_ce_ litaC_std__array__ArrayInit_cb__ptr_Expr_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__array__Array_cb__ptr_Expr_ce_ litaC_array =  {
        
    };
    litaC_std__array__Array_init_cb__ptr_Expr_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_std__array__Array_init_cb__ptr_Expr_ce_(litaC_std__array__Array_cb__ptr_Expr_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__Expr*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__Expr**)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_add_cb__ptr_Expr_ce_(litaC_std__array__Array_cb__ptr_Expr_ce_* litaC_a,litaC_ast__Expr* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_Expr_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb__ptr_Expr_ce_(litaC_std__array__Array_cb__ptr_Expr_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__Expr*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__Expr*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__Expr**)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb__ptr_Stmt_ce_(litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_std__array__ArrayInit_cb__ptr_Stmt_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__array__Array_cb__ptr_Stmt_ce_ litaC_array =  {
        
    };
    litaC_std__array__Array_init_cb__ptr_Stmt_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_std__array__Array_init_cb__ptr_Stmt_ce_(litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__Stmt*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__Stmt**)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_add_cb__ptr_Stmt_ce_(litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_ast__Stmt* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_Stmt_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb__ptr_Stmt_ce_(litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__Stmt*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__Stmt*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__Stmt**)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb__ptr_InitArgExpr_ce_(litaC_std__array__Array_cb__ptr_InitArgExpr_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_void litaC_std__array__Array_init_cb__ptr_InitArgExpr_ce_(litaC_std__array__Array_cb__ptr_InitArgExpr_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__InitArgExpr*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__InitArgExpr**)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_add_cb__ptr_InitArgExpr_ce_(litaC_std__array__Array_cb__ptr_InitArgExpr_ce_* litaC_a,litaC_ast__InitArgExpr* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_InitArgExpr_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb__ptr_InitArgExpr_ce_(litaC_std__array__Array_cb__ptr_InitArgExpr_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__InitArgExpr*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__InitArgExpr*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__InitArgExpr**)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_void litaC_std__array__Array_init_cb__ptr_ParameterDecl_ce_(litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__ParameterDecl*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__ParameterDecl**)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_add_cb__ptr_ParameterDecl_ce_(litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_ast__ParameterDecl* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_ParameterDecl_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb__ptr_ParameterDecl_ce_(litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__ParameterDecl*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__ParameterDecl*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__ParameterDecl**)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb__ptr_SwitchCaseStmt_ce_(litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_void litaC_std__array__Array_init_cb__ptr_SwitchCaseStmt_ce_(litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__SwitchCaseStmt*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__SwitchCaseStmt**)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_add_cb__ptr_SwitchCaseStmt_ce_(litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a,litaC_ast__SwitchCaseStmt* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_SwitchCaseStmt_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb__ptr_SwitchCaseStmt_ce_(litaC_std__array__Array_cb__ptr_SwitchCaseStmt_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__SwitchCaseStmt*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__SwitchCaseStmt*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__SwitchCaseStmt**)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_std__array__Array_cb_GenericParam_ce_ litaC_std__array__Array_copy_cb_GenericParam_ce_(litaC_std__array__Array_cb_GenericParam_ce_* litaC_a,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_std__array__Array_cb_GenericParam_ce_ litaC_copy = litaC_std__array__ArrayInit_cb_GenericParam_ce_(litaC_a->length, (litaC_allocator) ? litaC_allocator : litaC_a->alloc);
    memcpy(litaC_copy.elements, litaC_a->elements, litaC_a->length * sizeof(litaC_ast__GenericParam));
    litaC_copy.length = litaC_a->length;
    return litaC_copy;
    
    
}

litaC_std__array__Array_cb_FieldStmt_ce_ litaC_std__array__ArrayInit_cb_FieldStmt_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__array__Array_cb_FieldStmt_ce_ litaC_array =  {
        
    };
    litaC_std__array__Array_init_cb_FieldStmt_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_std__array__Array_init_cb_FieldStmt_ce_(litaC_std__array__Array_cb_FieldStmt_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__FieldStmt) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__FieldStmt*)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_add_cb_FieldStmt_ce_(litaC_std__array__Array_cb_FieldStmt_ce_* litaC_a,litaC_ast__FieldStmt litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_FieldStmt_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb_FieldStmt_ce_(litaC_std__array__Array_cb_FieldStmt_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__FieldStmt) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__FieldStmt) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__FieldStmt*)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_void litaC_std__array__Array_insertAt_cb__ptr_Stmt_ce_(litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__Stmt* litaC_element) {
    assert(litaC_index >= 0 && litaC_index <= litaC_a->length);
    if(litaC_index == litaC_a->length) {
        {
            litaC_std__array__Array_add_cb__ptr_Stmt_ce_(litaC_a, litaC_element);
            return;
            
            
            
        }
        
    } 
    
    litaC_a->length += 1;
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_Stmt_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    memmove((litaC_void*)(&(litaC_a->elements[litaC_index + 1])), (const litaC_void*)(&(litaC_a->elements[litaC_index])), (litaC_a->length - litaC_index) * sizeof(litaC_ast__Stmt*));
    litaC_std__array__Array_set_cb__ptr_Stmt_ce_(litaC_a, litaC_index, litaC_element);
    
}

litaC_void litaC_std__array__Array_set_cb__ptr_Stmt_ce_(litaC_std__array__Array_cb__ptr_Stmt_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__Stmt* litaC_element) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    {
        litaC_a->elements[litaC_index] = litaC_element;
        
        
    }
    
}

litaC_void litaC_std__array__Array_init_cb__ptr_Module_ce_(litaC_std__array__Array_cb__ptr_Module_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_module__Module*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_module__Module**)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_init_cb__ptr_Symbol_ce_(litaC_std__array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_symbols__Symbol*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_symbols__Symbol**)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_init_cb_Array_cb_GenericParam_ce__ce_(litaC_std__array__Array_cb_Array_cb_GenericParam_ce__ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_std__array__Array_cb_GenericParam_ce_) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_std__array__Array_cb_GenericParam_ce_*)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_u32 litaC_std__map__PtrHashFn_cb_i64_ce_(litaC_i64 litaC_a) {
    litaC_u32 litaC_hash = (litaC_u32)(((litaC_usize)litaC_a) % 4294967291U);
    return litaC_hash;
    
    
}

litaC_bool litaC_std__map__PtrEqualFn_cb_i64_ce_(litaC_i64 litaC_a,litaC_i64 litaC_b) {
    return litaC_a == litaC_b;
    
    
}

litaC_void litaC_std__map__Map_init_cb_i64_c_Array_cb_i64_ce__ce_(litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m,litaC_std__array__Array_cb_i64_ce_ litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_i64),litaC_bool (*litaC_equalFn)(litaC_i64,litaC_i64),const litaC_std__mem__Allocator* litaC_alloc,litaC_i64 litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_std__mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_std__map__nextPowerOf2(litaC_initialSize);
    litaC_std__map__MapGrow_cb_i64_c_Array_cb_i64_ce__ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_std__map__MapGrow_cb_i64_c_Array_cb_i64_ce__ce_(litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (litaC_std__map__Key_cb_i64_ce_*)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_std__map__Key_cb_i64_ce_)),
        .values = (litaC_std__array__Array_cb_i64_ce_*)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_std__array__Array_cb_i64_ce_)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i].key, litaC_m->emptyKey))) {
                {
                    litaC_std__map__Map_put_cb_i64_c_Array_cb_i64_ce__ce_(&((litaC_newMap)), litaC_m->keys[litaC_i].key, litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_std__map__Map_free_cb_i64_c_Array_cb_i64_ce__ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_std__map__Map_put_cb_i64_c_Array_cb_i64_ce__ce_(litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m,litaC_i64 litaC_key,litaC_std__array__Array_cb_i64_ce_ litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_std__map__MapGrow_cb_i64_c_Array_cb_i64_ce__ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb_i64_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i].key = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_std__map__Map_free_cb_i64_c_Array_cb_i64_ce__ce_(litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_ast__Decl* litaC_std__array__Array_removeAt_cb__ptr_Decl_ce_(litaC_std__array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    litaC_ast__Decl* litaC_r = litaC_a->elements[litaC_index];
    if(litaC_index < litaC_a->length - 1) {
        {
            memmove((litaC_void*)(&(litaC_a->elements[litaC_index])), (const litaC_void*)(&(litaC_a->elements[litaC_index + 1])), ((litaC_a->length - 1) - litaC_index) * sizeof(litaC_ast__Decl*));
            
            
        }
        
    } 
    
    litaC_a->length -= 1;
    return litaC_r;
    
    
}

litaC_void litaC_std__array__Array_push_cb__ptr_Module_ce_(litaC_std__array__Array_cb__ptr_Module_ce_* litaC_a,litaC_module__Module* litaC_element) {
    litaC_std__array__Array_add_cb__ptr_Module_ce_(litaC_a, litaC_element);
    
}

litaC_void litaC_std__array__Array_add_cb__ptr_Module_ce_(litaC_std__array__Array_cb__ptr_Module_ce_* litaC_a,litaC_module__Module* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_Module_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb__ptr_Module_ce_(litaC_std__array__Array_cb__ptr_Module_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_module__Module*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_module__Module*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_module__Module**)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_Module_ce_(litaC_std__array__Array_cb__ptr_Module_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_module__Module* litaC_std__array__Array_pop_cb__ptr_Module_ce_(litaC_std__array__Array_cb__ptr_Module_ce_* litaC_a) {
    assert(litaC_a->length != 0);
    litaC_module__Module* litaC_r = litaC_a->elements[litaC_a->length - 1];
    litaC_a->length -= 1;
    return litaC_r;
    
    
}

litaC_module__Module* litaC_std__array__Array_last_cb__ptr_Module_ce_(litaC_std__array__Array_cb__ptr_Module_ce_* litaC_a) {
    assert(litaC_a->length != 0);
    return litaC_a->elements[litaC_a->length - 1];
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_Array_cb_GenericParam_ce__ce_(litaC_std__array__Array_cb_Array_cb_GenericParam_ce__ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_void litaC_std__array__Array_add_cb_Array_cb_GenericParam_ce__ce_(litaC_std__array__Array_cb_Array_cb_GenericParam_ce__ce_* litaC_a,litaC_std__array__Array_cb_GenericParam_ce_ litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_Array_cb_GenericParam_ce__ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb_Array_cb_GenericParam_ce__ce_(litaC_std__array__Array_cb_Array_cb_GenericParam_ce__ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_std__array__Array_cb_GenericParam_ce_) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_std__array__Array_cb_GenericParam_ce_) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_std__array__Array_cb_GenericParam_ce_*)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_std__array__Array_cb_GenericParam_ce_ litaC_std__array__Array_pop_cb_Array_cb_GenericParam_ce__ce_(litaC_std__array__Array_cb_Array_cb_GenericParam_ce__ce_* litaC_a) {
    assert(litaC_a->length != 0);
    litaC_std__array__Array_cb_GenericParam_ce_ litaC_r = litaC_a->elements[litaC_a->length - 1];
    litaC_a->length -= 1;
    return litaC_r;
    
    
}

litaC_bool litaC_std__map__Map_contains_cb_i64_c_Array_cb_i64_ce__ce_(litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m,litaC_i64 litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb_i64_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_std__array__Array_cb_i64_ce_* litaC_std__map__Map_getPtr_cb_i64_c_Array_cb_i64_ce__ce_(litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m,litaC_i64 litaC_key) {
    if(litaC_m->length == 0) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb_i64_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    return &(litaC_m->values[litaC_i]);
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && !(litaC_k.key)) {
                    {
                        return NULL;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return NULL;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_i64_ce_(litaC_std__array__Array_cb_i64_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_i64 litaC_std__array__Array_get_cb_i64_ce_(litaC_std__array__Array_cb_i64_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_std__array__Array_cb_i64_ce_ litaC_std__array__ArrayInit_cb_i64_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__array__Array_cb_i64_ce_ litaC_array =  {
        
    };
    litaC_std__array__Array_init_cb_i64_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_std__array__Array_init_cb_i64_ce_(litaC_std__array__Array_cb_i64_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_i64) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_i64*)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_add_cb_i64_ce_(litaC_std__array__Array_cb_i64_ce_* litaC_a,litaC_i64 litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_i64_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb_i64_ce_(litaC_std__array__Array_cb_i64_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_i64) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_i64) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_i64*)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_types__TypeInfo* litaC_std__array__Array_last_cb__ptr_TypeInfo_ce_(litaC_std__array__Array_cb__ptr_TypeInfo_ce_* litaC_a) {
    assert(litaC_a->length != 0);
    return litaC_a->elements[litaC_a->length - 1];
    
    
}

litaC_void litaC_std__bucket_list__BucketList_init_cb_TypeInfo_ce_(litaC_std__bucket_list__BucketList_cb_TypeInfo_ce_* litaC_this,litaC_i32 litaC_bucketSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_this->allocator = litaC_alloc;
    litaC_this->length = 0;
    litaC_this->bucketSize = litaC_bucketSize;
    litaC_this->buckets = litaC_std__bucket_list__BucketList_allocBucket_cb_TypeInfo_ce_(litaC_this);
    litaC_this->top = litaC_this->buckets;
    
}

litaC_std__bucket_list__Bucket_cb_TypeInfo_ce_* litaC_std__bucket_list__BucketList_allocBucket_cb_TypeInfo_ce_(litaC_std__bucket_list__BucketList_cb_TypeInfo_ce_* litaC_this) {
    litaC_void* litaC_mem = litaC_std__mem__Allocator_alloc(litaC_this->allocator, sizeof(litaC_std__bucket_list__Bucket_cb_TypeInfo_ce_) + (sizeof(litaC_types__TypeInfo) * litaC_this->bucketSize));
    litaC_std__bucket_list__Bucket_cb_TypeInfo_ce_* litaC_bucket = (litaC_std__bucket_list__Bucket_cb_TypeInfo_ce_*)litaC_mem;
    litaC_bucket->length = 0;
    litaC_bucket->next = NULL;
    litaC_bucket->elements = (litaC_types__TypeInfo*)(litaC_mem + sizeof(litaC_std__bucket_list__Bucket_cb_TypeInfo_ce_));
    return litaC_bucket;
    
    
}

litaC_void litaC_std__map__Map_init_cb_i64_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_i64_c__ptr_TypeInfo_ce_* litaC_m,litaC_types__TypeInfo* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_i64),litaC_bool (*litaC_equalFn)(litaC_i64,litaC_i64),const litaC_std__mem__Allocator* litaC_alloc,litaC_i64 litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_std__mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_std__map__nextPowerOf2(litaC_initialSize);
    litaC_std__map__MapGrow_cb_i64_c__ptr_TypeInfo_ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_std__map__MapGrow_cb_i64_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_i64_c__ptr_TypeInfo_ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_std__map__Map_cb_i64_c__ptr_TypeInfo_ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (litaC_std__map__Key_cb_i64_ce_*)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_std__map__Key_cb_i64_ce_)),
        .values = (litaC_types__TypeInfo**)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_types__TypeInfo*)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i].key, litaC_m->emptyKey))) {
                {
                    litaC_std__map__Map_put_cb_i64_c__ptr_TypeInfo_ce_(&((litaC_newMap)), litaC_m->keys[litaC_i].key, litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_std__map__Map_free_cb_i64_c__ptr_TypeInfo_ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_std__map__Map_put_cb_i64_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_i64_c__ptr_TypeInfo_ce_* litaC_m,litaC_i64 litaC_key,litaC_types__TypeInfo* litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_std__map__MapGrow_cb_i64_c__ptr_TypeInfo_ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb_i64_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i].key = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_std__map__Map_free_cb_i64_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_i64_c__ptr_TypeInfo_ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_std__map__Map_init_cb_ArrayEntry_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_ArrayEntry_c__ptr_TypeInfo_ce_* litaC_m,litaC_types__TypeInfo* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_types_new__ArrayEntry),litaC_bool (*litaC_equalFn)(litaC_types_new__ArrayEntry,litaC_types_new__ArrayEntry),const litaC_std__mem__Allocator* litaC_alloc,litaC_types_new__ArrayEntry litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_std__mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_std__map__nextPowerOf2(litaC_initialSize);
    litaC_std__map__MapGrow_cb_ArrayEntry_c__ptr_TypeInfo_ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_std__map__MapGrow_cb_ArrayEntry_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_ArrayEntry_c__ptr_TypeInfo_ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_std__map__Map_cb_ArrayEntry_c__ptr_TypeInfo_ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (litaC_std__map__Key_cb_ArrayEntry_ce_*)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_std__map__Key_cb_ArrayEntry_ce_)),
        .values = (litaC_types__TypeInfo**)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_types__TypeInfo*)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i].key, litaC_m->emptyKey))) {
                {
                    litaC_std__map__Map_put_cb_ArrayEntry_c__ptr_TypeInfo_ce_(&((litaC_newMap)), litaC_m->keys[litaC_i].key, litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_std__map__Map_free_cb_ArrayEntry_c__ptr_TypeInfo_ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_std__map__Map_put_cb_ArrayEntry_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_ArrayEntry_c__ptr_TypeInfo_ce_* litaC_m,litaC_types_new__ArrayEntry litaC_key,litaC_types__TypeInfo* litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_std__map__MapGrow_cb_ArrayEntry_c__ptr_TypeInfo_ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb_ArrayEntry_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i].key = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_std__map__Map_free_cb_ArrayEntry_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_ArrayEntry_c__ptr_TypeInfo_ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_std__map__Map_cb_InternedString_c__ptr_TypeInfo_ce_ litaC_intern__InternMap_cb__ptr_TypeInfo_ce_(litaC_types__TypeInfo* litaC_emptyValue,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_allocator) {
    litaC_std__map__Map_cb_InternedString_c__ptr_TypeInfo_ce_ litaC_map =  {
        
    };
    litaC_std__map__Map_init_cb_InternedString_c__ptr_TypeInfo_ce_(&((litaC_map)), litaC_emptyValue, litaC_initialSize, litaC_intern__InternHashFn, litaC_intern__InternEqualFn, litaC_allocator, litaC_intern__EMPTY_STR);
    return litaC_map;
    
    
}

litaC_void litaC_std__map__Map_init_cb_InternedString_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_TypeInfo_ce_* litaC_m,litaC_types__TypeInfo* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_intern__InternedString),litaC_bool (*litaC_equalFn)(litaC_intern__InternedString,litaC_intern__InternedString),const litaC_std__mem__Allocator* litaC_alloc,litaC_intern__InternedString litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_std__mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_std__map__nextPowerOf2(litaC_initialSize);
    litaC_std__map__MapGrow_cb_InternedString_c__ptr_TypeInfo_ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_std__map__MapGrow_cb_InternedString_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_TypeInfo_ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_std__map__Map_cb_InternedString_c__ptr_TypeInfo_ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (litaC_std__map__Key_cb_InternedString_ce_*)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_std__map__Key_cb_InternedString_ce_)),
        .values = (litaC_types__TypeInfo**)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_types__TypeInfo*)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i].key, litaC_m->emptyKey))) {
                {
                    litaC_std__map__Map_put_cb_InternedString_c__ptr_TypeInfo_ce_(&((litaC_newMap)), litaC_m->keys[litaC_i].key, litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_std__map__Map_free_cb_InternedString_c__ptr_TypeInfo_ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_std__map__Map_put_cb_InternedString_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_TypeInfo_ce_* litaC_m,litaC_intern__InternedString litaC_key,litaC_types__TypeInfo* litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_std__map__MapGrow_cb_InternedString_c__ptr_TypeInfo_ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb_InternedString_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i].key = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_std__map__Map_free_cb_InternedString_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_TypeInfo_ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_std__bucket_list__BucketList_add_cb_TypeInfo_ce_(litaC_std__bucket_list__BucketList_cb_TypeInfo_ce_* litaC_this,litaC_types__TypeInfo litaC_element) {
    if(litaC_this->top->length + 1 > litaC_this->bucketSize) {
        {
            if(!(litaC_this->top->next)) {
                {
                    litaC_std__bucket_list__Bucket_cb_TypeInfo_ce_* litaC_next = litaC_std__bucket_list__BucketList_allocBucket_cb_TypeInfo_ce_(litaC_this);
                    litaC_this->top->next = litaC_next;
                    litaC_this->top = litaC_next;
                    
                    
                }
                
            } else {
                {
                    litaC_this->top = litaC_this->top->next;
                    
                    
                }
            } 
            
            
            
        }
        
    } 
    
    {
        litaC_this->top->elements[litaC_this->top->length] = litaC_element;
        
        
    }
    litaC_this->top->length += 1;
    litaC_this->length += 1;
    
}

litaC_types__TypeInfo* litaC_std__bucket_list__BucketList_lastPtr_cb_TypeInfo_ce_(litaC_std__bucket_list__BucketList_cb_TypeInfo_ce_* litaC_this) {
    assert(litaC_this->length != 0);
    litaC_std__bucket_list__Bucket_cb_TypeInfo_ce_* litaC_bucket = litaC_this->top;
    if(litaC_this->top->length == 0) {
        {
            litaC_i32 litaC_iterations = 0;
            litaC_bucket = litaC_std__bucket_list__BucketList_getBucketAt_cb_TypeInfo_ce_(litaC_this, litaC_this->length - 1, &(litaC_iterations));
            litaC_this->top = litaC_bucket;
            
            
        }
        
    } 
    
    return &(litaC_bucket->elements[litaC_bucket->length - 1]);
    
    
}

litaC_std__bucket_list__Bucket_cb_TypeInfo_ce_* litaC_std__bucket_list__BucketList_getBucketAt_cb_TypeInfo_ce_(litaC_std__bucket_list__BucketList_cb_TypeInfo_ce_* litaC_this,litaC_usize litaC_index,litaC_i32* litaC_iterations) {
    if(litaC_index < litaC_this->bucketSize) {
        {
            *(litaC_iterations) = 0;
            return litaC_this->buckets;
            
            
            
        }
        
    } 
    
    litaC_i32 litaC_bucketIndex = 0;
    litaC_std__bucket_list__Bucket_cb_TypeInfo_ce_* litaC_current = litaC_this->buckets;
    litaC_std__bucket_list__Bucket_cb_TypeInfo_ce_* litaC_next = NULL;
    while(litaC_current != NULL) {
        {
            litaC_std__bucket_list__Bucket_cb_TypeInfo_ce_* litaC_bucket = litaC_current;
            litaC_current = litaC_current->next;
            if((litaC_bucketIndex + litaC_bucket->length) > litaC_index) {
                {
                    return litaC_bucket;
                    
                    
                    
                }
                
            } 
            
            *(litaC_iterations) += 1;
            litaC_bucketIndex += litaC_bucket->length;
            
            
        }
    }
    return litaC_this->top;
    
    
}

litaC_types__TypeInfo* litaC_std__map__Map_get_cb_InternedString_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_InternedString_c__ptr_TypeInfo_ce_* litaC_m,litaC_intern__InternedString litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb_InternedString_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    return litaC_m->values[litaC_i];
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

litaC_types__TypeInfo* litaC_std__map__Map_get_cb_ArrayEntry_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_ArrayEntry_c__ptr_TypeInfo_ce_* litaC_m,litaC_types_new__ArrayEntry litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb_ArrayEntry_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    return litaC_m->values[litaC_i];
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

litaC_types__TypeInfo* litaC_std__map__Map_get_cb_i64_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_i64_c__ptr_TypeInfo_ce_* litaC_m,litaC_i64 litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb_i64_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    return litaC_m->values[litaC_i];
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

litaC_ast__GenericParam litaC_std__array__Array_removeAt_cb_GenericParam_ce_(litaC_std__array__Array_cb_GenericParam_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    litaC_ast__GenericParam litaC_r = litaC_a->elements[litaC_index];
    if(litaC_index < litaC_a->length - 1) {
        {
            memmove((litaC_void*)(&(litaC_a->elements[litaC_index])), (const litaC_void*)(&(litaC_a->elements[litaC_index + 1])), ((litaC_a->length - 1) - litaC_index) * sizeof(litaC_ast__GenericParam));
            
            
        }
        
    } 
    
    litaC_a->length -= 1;
    return litaC_r;
    
    
}

litaC_void litaC_std__array__Array_set_cb__ptr_TypeSpec_ce_(litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__TypeSpec* litaC_element) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    {
        litaC_a->elements[litaC_index] = litaC_element;
        
        
    }
    
}

litaC_std__map__MapIterator_cb_ArrayEntry_c__ptr_TypeInfo_ce_ litaC_std__map__Map_iter_cb_ArrayEntry_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_ArrayEntry_c__ptr_TypeInfo_ce_* litaC_m) {
    return (litaC_std__map__MapIterator_cb_ArrayEntry_c__ptr_TypeInfo_ce_) {
        .m = litaC_m,
        .it = 0,
        .prevIt = 0,
        .count = 0
    };
    
    
}

litaC_bool litaC_std__map__MapIterator_hasNext_cb_ArrayEntry_c__ptr_TypeInfo_ce_(litaC_std__map__MapIterator_cb_ArrayEntry_c__ptr_TypeInfo_ce_* litaC_iter) {
    return litaC_iter->count < litaC_iter->m->length;
    
    
}

litaC_std__map__MapEntry_cb_ArrayEntry_c__ptr_TypeInfo_ce_ litaC_std__map__MapIterator_next_cb_ArrayEntry_c__ptr_TypeInfo_ce_(litaC_std__map__MapIterator_cb_ArrayEntry_c__ptr_TypeInfo_ce_* litaC_iter) {
    litaC_i32 litaC_i = litaC_iter->it;
    assert(litaC_i < litaC_iter->m->capacity);
    
    for(;litaC_i < litaC_iter->m->capacity;litaC_i += 1) {
        {
            litaC_bool litaC_hasValue = !(litaC_iter->m->equalFn(litaC_iter->m->keys[litaC_i].key, litaC_iter->m->emptyKey));
            if(litaC_hasValue) {
                {
                    litaC_iter->count += 1;
                    litaC_iter->prevIt = litaC_i;
                    {
                        litaC_std__map__MapEntry_cb_ArrayEntry_c__ptr_TypeInfo_ce_ ___result = (litaC_std__map__MapEntry_cb_ArrayEntry_c__ptr_TypeInfo_ce_) {
                            .key = litaC_iter->m->keys[litaC_i].key,
                            .value = litaC_iter->m->values[litaC_i],
                            .valuePtr = &(litaC_iter->m->values[litaC_i])
                        };
                        litaC_iter->it = litaC_i + 1;
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    {
        litaC_std__map__MapEntry_cb_ArrayEntry_c__ptr_TypeInfo_ce_ ___result = (litaC_std__map__MapEntry_cb_ArrayEntry_c__ptr_TypeInfo_ce_) {
            
        };
        litaC_iter->it = litaC_i + 1;
        return ___result;
        
    }
    
    litaC_iter->it = litaC_i + 1;
    
}

litaC_std__map__MapIterator_cb_i64_c__ptr_TypeInfo_ce_ litaC_std__map__Map_iter_cb_i64_c__ptr_TypeInfo_ce_(litaC_std__map__Map_cb_i64_c__ptr_TypeInfo_ce_* litaC_m) {
    return (litaC_std__map__MapIterator_cb_i64_c__ptr_TypeInfo_ce_) {
        .m = litaC_m,
        .it = 0,
        .prevIt = 0,
        .count = 0
    };
    
    
}

litaC_bool litaC_std__map__MapIterator_hasNext_cb_i64_c__ptr_TypeInfo_ce_(litaC_std__map__MapIterator_cb_i64_c__ptr_TypeInfo_ce_* litaC_iter) {
    return litaC_iter->count < litaC_iter->m->length;
    
    
}

litaC_std__map__MapEntry_cb_i64_c__ptr_TypeInfo_ce_ litaC_std__map__MapIterator_next_cb_i64_c__ptr_TypeInfo_ce_(litaC_std__map__MapIterator_cb_i64_c__ptr_TypeInfo_ce_* litaC_iter) {
    litaC_i32 litaC_i = litaC_iter->it;
    assert(litaC_i < litaC_iter->m->capacity);
    
    for(;litaC_i < litaC_iter->m->capacity;litaC_i += 1) {
        {
            litaC_bool litaC_hasValue = !(litaC_iter->m->equalFn(litaC_iter->m->keys[litaC_i].key, litaC_iter->m->emptyKey));
            if(litaC_hasValue) {
                {
                    litaC_iter->count += 1;
                    litaC_iter->prevIt = litaC_i;
                    {
                        litaC_std__map__MapEntry_cb_i64_c__ptr_TypeInfo_ce_ ___result = (litaC_std__map__MapEntry_cb_i64_c__ptr_TypeInfo_ce_) {
                            .key = litaC_iter->m->keys[litaC_i].key,
                            .value = litaC_iter->m->values[litaC_i],
                            .valuePtr = &(litaC_iter->m->values[litaC_i])
                        };
                        litaC_iter->it = litaC_i + 1;
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    {
        litaC_std__map__MapEntry_cb_i64_c__ptr_TypeInfo_ce_ ___result = (litaC_std__map__MapEntry_cb_i64_c__ptr_TypeInfo_ce_) {
            
        };
        litaC_iter->it = litaC_i + 1;
        return ___result;
        
    }
    
    litaC_iter->it = litaC_i + 1;
    
}

litaC_types__TypeInfo* litaC_std__array__Array_pop_cb__ptr_TypeInfo_ce_(litaC_std__array__Array_cb__ptr_TypeInfo_ce_* litaC_a) {
    assert(litaC_a->length != 0);
    litaC_types__TypeInfo* litaC_r = litaC_a->elements[litaC_a->length - 1];
    litaC_a->length -= 1;
    return litaC_r;
    
    
}

litaC_void litaC_std__array__Array_insertAt_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__CallArg litaC_element) {
    assert(litaC_index >= 0 && litaC_index <= litaC_a->length);
    if(litaC_index == litaC_a->length) {
        {
            litaC_std__array__Array_add_cb_CallArg_ce_(litaC_a, litaC_element);
            return;
            
            
            
        }
        
    } 
    
    litaC_a->length += 1;
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_CallArg_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    memmove((litaC_void*)(&(litaC_a->elements[litaC_index + 1])), (const litaC_void*)(&(litaC_a->elements[litaC_index])), (litaC_a->length - litaC_index) * sizeof(litaC_ast__CallArg));
    litaC_std__array__Array_set_cb_CallArg_ce_(litaC_a, litaC_index, litaC_element);
    
}

litaC_void litaC_std__array__Array_set_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__CallArg litaC_element) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    {
        litaC_a->elements[litaC_index] = litaC_element;
        
        
    }
    
}

litaC_void litaC_std__array__Array_addAll_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a,litaC_std__array__Array_cb_CallArg_ce_* litaC_other) {
    if(!(litaC_other) || litaC_other->length == 0) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_a->length + litaC_other->length > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_CallArg_ce_(litaC_a, litaC_other->length);
            
            
        }
        
    } 
    
    memcpy((litaC_void*)(&(litaC_a->elements[litaC_a->length])), (const litaC_void*)(&(litaC_other->elements[0])), litaC_other->length * sizeof(litaC_ast__CallArg));
    litaC_a->length += litaC_other->length;
    
}

litaC_void litaC_std__array__Array_sort_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_a,litaC_i32 (*litaC_sorter)(litaC_ast__CallArg,litaC_ast__CallArg)) {
    litaC_std__array__QuickSort_cb_CallArg_ce_(litaC_a, litaC_sorter);
    
}

litaC_void litaC_std__array__QuickSort_cb_CallArg_ce_(litaC_std__array__Array_cb_CallArg_ce_* litaC_array,litaC_i32 (*litaC_comp)(litaC_ast__CallArg,litaC_ast__CallArg)) {
    litaC_i32 litaC_beg[300] =  {
        
    };
    litaC_i32 litaC_end[300] =  {
        
    };
    litaC_i32 litaC_i = 0;
    litaC_i32 litaC_L = 0;
    litaC_i32 litaC_R = 0;
    litaC_i32 litaC_swap = 0;
    litaC_ast__CallArg litaC_piv = {0};
    litaC_beg[0] = 0;
    litaC_end[0] = litaC_array->length;
    while(litaC_i >= 0) {
        {
            litaC_L = litaC_beg[litaC_i];
            litaC_R = litaC_end[litaC_i] - 1;
            if(litaC_L < litaC_R) {
                {
                    litaC_piv = litaC_array->elements[litaC_L];
                    while(litaC_L < litaC_R) {
                        {
                            while(litaC_L < litaC_R && litaC_comp(litaC_array->elements[litaC_R], litaC_piv) >= 0) {
                                {
                                    litaC_R -= 1;
                                    
                                    
                                }
                            }
                            if(litaC_L < litaC_R) {
                                {
                                    litaC_array->elements[litaC_L] = litaC_array->elements[litaC_R];
                                    litaC_L += 1;
                                    
                                    
                                }
                                
                            } 
                            
                            while(litaC_L < litaC_R && litaC_comp(litaC_array->elements[litaC_L], litaC_piv) <= 0) {
                                {
                                    litaC_L += 1;
                                    
                                    
                                }
                            }
                            if(litaC_L < litaC_R) {
                                {
                                    litaC_array->elements[litaC_R] = litaC_array->elements[litaC_L];
                                    litaC_R -= 1;
                                    
                                    
                                }
                                
                            } 
                            
                            litaC_array->elements[litaC_L] = litaC_piv;
                            litaC_beg[litaC_i + 1] = litaC_L + 1;
                            litaC_end[litaC_i + 1] = litaC_end[litaC_i];
                            litaC_end[litaC_i + 0] = litaC_L;
                            litaC_i += 1;
                            if(litaC_end[litaC_i] - litaC_beg[litaC_i] > litaC_end[litaC_i - 1] - litaC_beg[litaC_i - 1]) {
                                {
                                    litaC_swap = litaC_beg[litaC_i];
                                    litaC_beg[litaC_i] = litaC_beg[litaC_i - 1];
                                    litaC_beg[litaC_i - 1] = litaC_swap;
                                    litaC_swap = litaC_end[litaC_i];
                                    litaC_end[litaC_i] = litaC_end[litaC_i - 1];
                                    litaC_end[litaC_i - 1] = litaC_swap;
                                    
                                    
                                }
                                
                            } 
                            
                            
                            
                        }
                    }
                    
                    
                }
                
            } else {
                {
                    litaC_i -= 1;
                    
                    
                }
            } 
            
            
            
        }
    }
    
}

litaC_void litaC_std__array__Array_init_cb_Reference_ce_(litaC_std__array__Array_cb_Reference_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_lsp__references__Reference) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_lsp__references__Reference*)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_init_cb_FieldReference_ce_(litaC_std__array__Array_cb_FieldReference_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_lsp__references__FieldReference) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_lsp__references__FieldReference*)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_u32 litaC_std__map__PtrHashFn_cb_usize_ce_(litaC_usize litaC_a) {
    litaC_u32 litaC_hash = (litaC_u32)(((litaC_usize)litaC_a) % 4294967291U);
    return litaC_hash;
    
    
}

litaC_bool litaC_std__map__PtrEqualFn_cb_usize_ce_(litaC_usize litaC_a,litaC_usize litaC_b) {
    return litaC_a == litaC_b;
    
    
}

litaC_void litaC_std__map__Map_init_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_std__array__Array_cb_SrcPos_ce_ litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_usize),litaC_bool (*litaC_equalFn)(litaC_usize,litaC_usize),const litaC_std__mem__Allocator* litaC_alloc,litaC_usize litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_std__mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_std__map__nextPowerOf2(litaC_initialSize);
    litaC_std__map__MapGrow_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_std__map__MapGrow_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (litaC_std__map__Key_cb_usize_ce_*)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_std__map__Key_cb_usize_ce_)),
        .values = (litaC_std__array__Array_cb_SrcPos_ce_*)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_std__array__Array_cb_SrcPos_ce_)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i].key, litaC_m->emptyKey))) {
                {
                    litaC_std__map__Map_put_cb_usize_c_Array_cb_SrcPos_ce__ce_(&((litaC_newMap)), litaC_m->keys[litaC_i].key, litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_std__map__Map_free_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_std__map__Map_put_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_usize litaC_key,litaC_std__array__Array_cb_SrcPos_ce_ litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_std__map__MapGrow_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb_usize_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i].key = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_std__map__Map_free_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_bool litaC_std__map__Map_contains_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_usize litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb_usize_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_std__array__Array_cb_SrcPos_ce_ litaC_std__array__ArrayInit_cb_SrcPos_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__array__Array_cb_SrcPos_ce_ litaC_array =  {
        
    };
    litaC_std__array__Array_init_cb_SrcPos_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_std__array__Array_init_cb_SrcPos_ce_(litaC_std__array__Array_cb_SrcPos_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_lex__SrcPos) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_lex__SrcPos*)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_std__array__Array_cb_SrcPos_ce_* litaC_std__map__Map_getPtr_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_usize litaC_key) {
    if(litaC_m->length == 0) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb_usize_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    return &(litaC_m->values[litaC_i]);
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && !(litaC_k.key)) {
                    {
                        return NULL;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return NULL;
    
    
}

litaC_void litaC_std__array__Array_add_cb_SrcPos_ce_(litaC_std__array__Array_cb_SrcPos_ce_* litaC_a,litaC_lex__SrcPos litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_SrcPos_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb_SrcPos_ce_(litaC_std__array__Array_cb_SrcPos_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_lex__SrcPos) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_lex__SrcPos) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_lex__SrcPos*)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_void litaC_std__array__Array_add_cb_Reference_ce_(litaC_std__array__Array_cb_Reference_ce_* litaC_a,litaC_lsp__references__Reference litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_Reference_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb_Reference_ce_(litaC_std__array__Array_cb_Reference_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_lsp__references__Reference) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_lsp__references__Reference) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_lsp__references__Reference*)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_void litaC_std__array__Array_add_cb_FieldReference_ce_(litaC_std__array__Array_cb_FieldReference_ce_* litaC_a,litaC_lsp__references__FieldReference litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_FieldReference_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb_FieldReference_ce_(litaC_std__array__Array_cb_FieldReference_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_lsp__references__FieldReference) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_lsp__references__FieldReference) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_lsp__references__FieldReference*)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_std__array__Array_cb_SrcPos_ce_ litaC_std__map__Map_get_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m,litaC_usize litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb_usize_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    return litaC_m->values[litaC_i];
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

litaC_std__map__MapIterator_cb_usize_c_Array_cb_SrcPos_ce__ce_ litaC_std__map__Map_iter_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__Map_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_m) {
    return (litaC_std__map__MapIterator_cb_usize_c_Array_cb_SrcPos_ce__ce_) {
        .m = litaC_m,
        .it = 0,
        .prevIt = 0,
        .count = 0
    };
    
    
}

litaC_bool litaC_std__map__MapIterator_hasNext_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__MapIterator_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_iter) {
    return litaC_iter->count < litaC_iter->m->length;
    
    
}

litaC_std__map__MapEntry_cb_usize_c_Array_cb_SrcPos_ce__ce_ litaC_std__map__MapIterator_next_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__MapIterator_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_iter) {
    litaC_i32 litaC_i = litaC_iter->it;
    assert(litaC_i < litaC_iter->m->capacity);
    
    for(;litaC_i < litaC_iter->m->capacity;litaC_i += 1) {
        {
            litaC_bool litaC_hasValue = !(litaC_iter->m->equalFn(litaC_iter->m->keys[litaC_i].key, litaC_iter->m->emptyKey));
            if(litaC_hasValue) {
                {
                    litaC_iter->count += 1;
                    litaC_iter->prevIt = litaC_i;
                    {
                        litaC_std__map__MapEntry_cb_usize_c_Array_cb_SrcPos_ce__ce_ ___result = (litaC_std__map__MapEntry_cb_usize_c_Array_cb_SrcPos_ce__ce_) {
                            .key = litaC_iter->m->keys[litaC_i].key,
                            .value = litaC_iter->m->values[litaC_i],
                            .valuePtr = &(litaC_iter->m->values[litaC_i])
                        };
                        litaC_iter->it = litaC_i + 1;
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    {
        litaC_std__map__MapEntry_cb_usize_c_Array_cb_SrcPos_ce__ce_ ___result = (litaC_std__map__MapEntry_cb_usize_c_Array_cb_SrcPos_ce__ce_) {
            
        };
        litaC_iter->it = litaC_i + 1;
        return ___result;
        
    }
    
    litaC_iter->it = litaC_i + 1;
    
}

litaC_void litaC_std__map__MapIterator_remove_cb_usize_c_Array_cb_SrcPos_ce__ce_(litaC_std__map__MapIterator_cb_usize_c_Array_cb_SrcPos_ce__ce_* litaC_iter) {
    litaC_i32 litaC_i = litaC_iter->prevIt;
    assert(litaC_i > -(1) && litaC_i < litaC_iter->m->capacity);
    litaC_iter->m->keys[litaC_i].state = litaC_std__map__KeyState_TOMBSTONE;
    litaC_iter->m->keys[litaC_i].key = litaC_iter->m->emptyKey;
    litaC_iter->m->values[litaC_i] = litaC_iter->m->emptyValue;
    litaC_iter->m->length -= 1;
    litaC_iter->count -= 1;
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_Reference_ce_(litaC_std__array__Array_cb_Reference_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_lsp__references__Reference* litaC_std__array__Array_getPtr_cb_Reference_ce_(litaC_std__array__Array_cb_Reference_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return &(litaC_a->elements[litaC_index]);
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_FieldReference_ce_(litaC_std__array__Array_cb_FieldReference_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_lsp__references__FieldReference* litaC_std__array__Array_getPtr_cb_FieldReference_ce_(litaC_std__array__Array_cb_FieldReference_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return &(litaC_a->elements[litaC_index]);
    
    
}

litaC_std__json__JsonNode* litaC_std__mem__new_cb_JsonNode_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_std__json__JsonNode* litaC_result = (litaC_std__json__JsonNode*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_std__json__JsonNode));
    return litaC_result;
    
    
}

litaC_std__array__Array_cb__ptr_JsonNode_ce_* litaC_std__mem__new_cb_Array_cb__ptr_JsonNode_ce__ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_std__array__Array_cb__ptr_JsonNode_ce_* litaC_result = (litaC_std__array__Array_cb__ptr_JsonNode_ce_*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_std__array__Array_cb__ptr_JsonNode_ce_));
    return litaC_result;
    
    
}

litaC_void litaC_std__array__Array_init_cb__ptr_JsonNode_ce_(litaC_std__array__Array_cb__ptr_JsonNode_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_std__json__JsonNode*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_std__json__JsonNode**)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_std__json__JsonObject* litaC_std__mem__new_cb_JsonObject_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_std__json__JsonObject* litaC_result = (litaC_std__json__JsonObject*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_std__json__JsonObject));
    return litaC_result;
    
    
}

litaC_void litaC_std__map__Map_init_cb__ptr_const_char_c_i32_ce_(litaC_std__map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m,litaC_i32 litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(const litaC_char*),litaC_bool (*litaC_equalFn)(const litaC_char*,const litaC_char*),const litaC_std__mem__Allocator* litaC_alloc,const litaC_char* litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_std__mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_std__map__nextPowerOf2(litaC_initialSize);
    litaC_std__map__MapGrow_cb__ptr_const_char_c_i32_ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_std__map__MapGrow_cb__ptr_const_char_c_i32_ce_(litaC_std__map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_std__map__Map_cb__ptr_const_char_c_i32_ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (litaC_std__map__Key_cb__ptr_const_char_ce_*)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_std__map__Key_cb__ptr_const_char_ce_)),
        .values = (litaC_i32*)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_i32)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i].key, litaC_m->emptyKey))) {
                {
                    litaC_std__map__Map_put_cb__ptr_const_char_c_i32_ce_(&((litaC_newMap)), litaC_m->keys[litaC_i].key, litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_std__map__Map_free_cb__ptr_const_char_c_i32_ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_std__map__Map_put_cb__ptr_const_char_c_i32_ce_(litaC_std__map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m,const litaC_char* litaC_key,litaC_i32 litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_std__map__MapGrow_cb__ptr_const_char_c_i32_ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb__ptr_const_char_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i].key = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_std__map__Map_free_cb__ptr_const_char_c_i32_ce_(litaC_std__map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_std__array__Array_init_cb_JsonEntry_ce_(litaC_std__array__Array_cb_JsonEntry_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_std__json__JsonEntry) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_std__json__JsonEntry*)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_add_cb_JsonEntry_ce_(litaC_std__array__Array_cb_JsonEntry_ce_* litaC_a,litaC_std__json__JsonEntry litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_JsonEntry_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb_JsonEntry_ce_(litaC_std__array__Array_cb_JsonEntry_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_std__json__JsonEntry) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_std__json__JsonEntry) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_std__json__JsonEntry*)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_JsonEntry_ce_(litaC_std__array__Array_cb_JsonEntry_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_bool litaC_std__map__Map_contains_cb__ptr_const_char_c_i32_ce_(litaC_std__map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m,const litaC_char* litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb__ptr_const_char_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_i32 litaC_std__map__Map_get_cb__ptr_const_char_c_i32_ce_(litaC_std__map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m,const litaC_char* litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb__ptr_const_char_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    return litaC_m->values[litaC_i];
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

litaC_std__json__JsonEntry litaC_std__array__Array_get_cb_JsonEntry_ce_(litaC_std__array__Array_cb_JsonEntry_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_void litaC_std__array__Array_add_cb__ptr_JsonNode_ce_(litaC_std__array__Array_cb__ptr_JsonNode_ce_* litaC_a,litaC_std__json__JsonNode* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_JsonNode_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb__ptr_JsonNode_ce_(litaC_std__array__Array_cb__ptr_JsonNode_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_std__json__JsonNode*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_std__json__JsonNode*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_std__json__JsonNode**)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_std__json__JsonNode* litaC_std__array__Array_get_cb__ptr_JsonNode_ce_(litaC_std__array__Array_cb__ptr_JsonNode_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_JsonNode_ce_(litaC_std__array__Array_cb__ptr_JsonNode_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__map__Map_size_cb__ptr_const_char_c_i32_ce_(litaC_std__map__Map_cb__ptr_const_char_c_i32_ce_* litaC_m) {
    return litaC_m->length;
    
    
}

litaC_void litaC_std__array__Array_free_cb__ptr_JsonNode_ce_(litaC_std__array__Array_cb__ptr_JsonNode_ce_* litaC_a) {
    if(litaC_a && litaC_a->elements) {
        {
            litaC_std__mem__Allocator_free(litaC_a->alloc, (litaC_void*)litaC_a->elements);
            litaC_a->elements = NULL;
            litaC_a->length = 0;
            litaC_a->capacity = 0;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_std__array__Array_free_cb_JsonEntry_ce_(litaC_std__array__Array_cb_JsonEntry_ce_* litaC_a) {
    if(litaC_a && litaC_a->elements) {
        {
            litaC_std__mem__Allocator_free(litaC_a->alloc, (litaC_void*)litaC_a->elements);
            litaC_a->elements = NULL;
            litaC_a->length = 0;
            litaC_a->capacity = 0;
            
            
        }
        
    } 
    
    
}

litaC_void litaC_std__array__Array_init_cb_Token_ce_(litaC_std__array__Array_cb_Token_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_lex__Token) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_lex__Token*)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_add_cb_Token_ce_(litaC_std__array__Array_cb_Token_ce_* litaC_a,litaC_lex__Token litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_Token_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb_Token_ce_(litaC_std__array__Array_cb_Token_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_lex__Token) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_lex__Token) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_lex__Token*)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb_Token_ce_(litaC_std__array__Array_cb_Token_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_void litaC_std__array__Array_init_cb__ptr_ImportDecl_ce_(litaC_std__array__Array_cb__ptr_ImportDecl_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__ImportDecl*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__ImportDecl**)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_init_cb__ptr_NoteStmt_ce_(litaC_std__array__Array_cb__ptr_NoteStmt_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__NoteStmt*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__NoteStmt**)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_init_cb__ptr_Decl_ce_(litaC_std__array__Array_cb__ptr_Decl_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__Decl*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__Decl**)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_ast__Decl* litaC_std__array__Array_last_cb__ptr_Decl_ce_(litaC_std__array__Array_cb__ptr_Decl_ce_* litaC_a) {
    assert(litaC_a->length != 0);
    return litaC_a->elements[litaC_a->length - 1];
    
    
}

litaC_void litaC_std__array__Array_insertAt_cb__ptr_ParameterDecl_ce_(litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__ParameterDecl* litaC_element) {
    assert(litaC_index >= 0 && litaC_index <= litaC_a->length);
    if(litaC_index == litaC_a->length) {
        {
            litaC_std__array__Array_add_cb__ptr_ParameterDecl_ce_(litaC_a, litaC_element);
            return;
            
            
            
        }
        
    } 
    
    litaC_a->length += 1;
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_ParameterDecl_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    memmove((litaC_void*)(&(litaC_a->elements[litaC_index + 1])), (const litaC_void*)(&(litaC_a->elements[litaC_index])), (litaC_a->length - litaC_index) * sizeof(litaC_ast__ParameterDecl*));
    litaC_std__array__Array_set_cb__ptr_ParameterDecl_ce_(litaC_a, litaC_index, litaC_element);
    
}

litaC_void litaC_std__array__Array_set_cb__ptr_ParameterDecl_ce_(litaC_std__array__Array_cb__ptr_ParameterDecl_ce_* litaC_a,litaC_i32 litaC_index,litaC_ast__ParameterDecl* litaC_element) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    {
        litaC_a->elements[litaC_index] = litaC_element;
        
        
    }
    
}

litaC_void litaC_std__array__Array_init_cb__ptr_EnumFieldEntryDecl_ce_(litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_ast__EnumFieldEntryDecl*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_ast__EnumFieldEntryDecl**)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_add_cb__ptr_EnumFieldEntryDecl_ce_(litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_a,litaC_ast__EnumFieldEntryDecl* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_EnumFieldEntryDecl_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb__ptr_EnumFieldEntryDecl_ce_(litaC_std__array__Array_cb__ptr_EnumFieldEntryDecl_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_ast__EnumFieldEntryDecl*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_ast__EnumFieldEntryDecl*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_ast__EnumFieldEntryDecl**)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_void litaC_std__array__Array_free_cb__ptr_TypeSpec_ce_(litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_a) {
    if(litaC_a && litaC_a->elements) {
        {
            litaC_std__mem__Allocator_free(litaC_a->alloc, (litaC_void*)litaC_a->elements);
            litaC_a->elements = NULL;
            litaC_a->length = 0;
            litaC_a->capacity = 0;
            
            
        }
        
    } 
    
    
}

LITAC_INLINE 
litaC_void litaC_std__array__Array_clear_cb__ptr_TypeSpec_ce_(litaC_std__array__Array_cb__ptr_TypeSpec_ce_* litaC_a) {
    litaC_a->length = 0;
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_Token_ce_(litaC_std__array__Array_cb_Token_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_ litaC_std__map__StrMap_cb__ptr_Document_ce_(litaC_lsp__document__Document* litaC_emptyValue,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_ litaC_m =  {
        
    };
    litaC_std__map__Map_init_cb__ptr_const_char_c__ptr_Document_ce_(&((litaC_m)), litaC_emptyValue, litaC_initialSize, litaC_std__map__StrHashFn, litaC_std__map__StrEqualFn, litaC_alloc, 0);
    return litaC_m;
    
    
}

litaC_void litaC_std__map__Map_init_cb__ptr_const_char_c__ptr_Document_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_* litaC_m,litaC_lsp__document__Document* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(const litaC_char*),litaC_bool (*litaC_equalFn)(const litaC_char*,const litaC_char*),const litaC_std__mem__Allocator* litaC_alloc,const litaC_char* litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_std__mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_std__map__nextPowerOf2(litaC_initialSize);
    litaC_std__map__MapGrow_cb__ptr_const_char_c__ptr_Document_ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_std__map__MapGrow_cb__ptr_const_char_c__ptr_Document_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (litaC_std__map__Key_cb__ptr_const_char_ce_*)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_std__map__Key_cb__ptr_const_char_ce_)),
        .values = (litaC_lsp__document__Document**)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_lsp__document__Document*)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i].key, litaC_m->emptyKey))) {
                {
                    litaC_std__map__Map_put_cb__ptr_const_char_c__ptr_Document_ce_(&((litaC_newMap)), litaC_m->keys[litaC_i].key, litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_std__map__Map_free_cb__ptr_const_char_c__ptr_Document_ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_std__map__Map_put_cb__ptr_const_char_c__ptr_Document_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_* litaC_m,const litaC_char* litaC_key,litaC_lsp__document__Document* litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_std__map__MapGrow_cb__ptr_const_char_c__ptr_Document_ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb__ptr_const_char_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i].key = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_std__map__Map_free_cb__ptr_const_char_c__ptr_Document_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_bool litaC_std__map__Map_contains_cb__ptr_const_char_c__ptr_Document_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_* litaC_m,const litaC_char* litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb__ptr_const_char_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_lsp__document__Document* litaC_std__mem__new_cb_Document_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_lsp__document__Document* litaC_result = (litaC_lsp__document__Document*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_lsp__document__Document));
    return litaC_result;
    
    
}

litaC_void litaC_std__array__Array_init_cb_u32_ce_(litaC_std__array__Array_cb_u32_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_u32) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_u32*)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_lsp__document__Document* litaC_std__map__Map_remove_cb__ptr_const_char_c__ptr_Document_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Document_ce_* litaC_m,const litaC_char* litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb__ptr_const_char_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    litaC_lsp__document__Document* litaC_v = litaC_m->values[litaC_i];
                    litaC_m->keys[litaC_i].key = litaC_m->emptyKey;
                    litaC_m->keys[litaC_i].state = litaC_std__map__KeyState_TOMBSTONE;
                    litaC_m->length -= 1;
                    return litaC_v;
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_TextDocumentChangeEvent_ce_(litaC_std__array__Array_cb_TextDocumentChangeEvent_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_lsp__protocol__TextDocumentChangeEvent* litaC_std__array__Array_getPtr_cb_TextDocumentChangeEvent_ce_(litaC_std__array__Array_cb_TextDocumentChangeEvent_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return &(litaC_a->elements[litaC_index]);
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb_SrcPos_ce_(litaC_std__array__Array_cb_SrcPos_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_SrcPos_ce_(litaC_std__array__Array_cb_SrcPos_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_lex__SrcPos* litaC_std__array__Array_getPtr_cb_SrcPos_ce_(litaC_std__array__Array_cb_SrcPos_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return &(litaC_a->elements[litaC_index]);
    
    
}

litaC_lsp__protocol__TextDocumentDidChange* litaC_std__mem__new_cb_TextDocumentDidChange_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_lsp__protocol__TextDocumentDidChange* litaC_result = (litaC_lsp__protocol__TextDocumentDidChange*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_lsp__protocol__TextDocumentDidChange));
    return litaC_result;
    
    
}

litaC_void litaC_std__array__Array_init_cb_TextDocumentChangeEvent_ce_(litaC_std__array__Array_cb_TextDocumentChangeEvent_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_lsp__protocol__TextDocumentChangeEvent) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_lsp__protocol__TextDocumentChangeEvent*)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_add_cb_TextDocumentChangeEvent_ce_(litaC_std__array__Array_cb_TextDocumentChangeEvent_ce_* litaC_a,litaC_lsp__protocol__TextDocumentChangeEvent litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_TextDocumentChangeEvent_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb_TextDocumentChangeEvent_ce_(litaC_std__array__Array_cb_TextDocumentChangeEvent_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_lsp__protocol__TextDocumentChangeEvent) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_lsp__protocol__TextDocumentChangeEvent) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_lsp__protocol__TextDocumentChangeEvent*)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_ast__GenericParam* litaC_std__array__Array_getPtr_cb_GenericParam_ce_(litaC_std__array__Array_cb_GenericParam_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return &(litaC_a->elements[litaC_index]);
    
    
}

litaC_ast__FieldStmt* litaC_std__array__Array_getPtr_cb_FieldStmt_ce_(litaC_std__array__Array_cb_FieldStmt_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return &(litaC_a->elements[litaC_index]);
    
    
}

LITAC_INLINE 
litaC_void litaC_std__array__Array_clear_cb_u32_ce_(litaC_std__array__Array_cb_u32_ce_* litaC_a) {
    litaC_a->length = 0;
    
}

litaC_void litaC_std__array__Array_add_cb_u32_ce_(litaC_std__array__Array_cb_u32_ce_* litaC_a,litaC_u32 litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_u32_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb_u32_ce_(litaC_std__array__Array_cb_u32_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_u32) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_u32) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_u32*)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_u32 litaC_std__array__Array_get_cb_u32_ce_(litaC_std__array__Array_cb_u32_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb__ptr_TypeInfo_ce_(litaC_std__array__Array_cb__ptr_TypeInfo_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_void litaC_std__array__Array_add_cb_ScriptDecl_ce_(litaC_std__array__Array_cb_ScriptDecl_ce_* litaC_a,litaC_preprocessor__ScriptDecl litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_ScriptDecl_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb_ScriptDecl_ce_(litaC_std__array__Array_cb_ScriptDecl_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_preprocessor__ScriptDecl) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_preprocessor__ScriptDecl) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_preprocessor__ScriptDecl*)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_ litaC_std__map__Map_iter_cb__ptr_const_char_c__ptr_Module_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_Module_ce_* litaC_m) {
    return (litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_) {
        .m = litaC_m,
        .it = 0,
        .prevIt = 0,
        .count = 0
    };
    
    
}

litaC_bool litaC_std__map__MapIterator_hasNext_cb__ptr_const_char_c__ptr_Module_ce_(litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_* litaC_iter) {
    return litaC_iter->count < litaC_iter->m->length;
    
    
}

litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_Module_ce_ litaC_std__map__MapIterator_next_cb__ptr_const_char_c__ptr_Module_ce_(litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_Module_ce_* litaC_iter) {
    litaC_i32 litaC_i = litaC_iter->it;
    assert(litaC_i < litaC_iter->m->capacity);
    
    for(;litaC_i < litaC_iter->m->capacity;litaC_i += 1) {
        {
            litaC_bool litaC_hasValue = !(litaC_iter->m->equalFn(litaC_iter->m->keys[litaC_i].key, litaC_iter->m->emptyKey));
            if(litaC_hasValue) {
                {
                    litaC_iter->count += 1;
                    litaC_iter->prevIt = litaC_i;
                    {
                        litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_Module_ce_ ___result = (litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_Module_ce_) {
                            .key = litaC_iter->m->keys[litaC_i].key,
                            .value = litaC_iter->m->values[litaC_i],
                            .valuePtr = &(litaC_iter->m->values[litaC_i])
                        };
                        litaC_iter->it = litaC_i + 1;
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    {
        litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_Module_ce_ ___result = (litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_Module_ce_) {
            
        };
        litaC_iter->it = litaC_i + 1;
        return ___result;
        
    }
    
    litaC_iter->it = litaC_i + 1;
    
}

litaC_std__map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_ litaC_std__map__Map_iter_cb_i64_c_Array_cb_i64_ce__ce_(litaC_std__map__Map_cb_i64_c_Array_cb_i64_ce__ce_* litaC_m) {
    return (litaC_std__map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_) {
        .m = litaC_m,
        .it = 0,
        .prevIt = 0,
        .count = 0
    };
    
    
}

litaC_bool litaC_std__map__MapIterator_hasNext_cb_i64_c_Array_cb_i64_ce__ce_(litaC_std__map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_* litaC_iter) {
    return litaC_iter->count < litaC_iter->m->length;
    
    
}

litaC_std__map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_ litaC_std__map__MapIterator_next_cb_i64_c_Array_cb_i64_ce__ce_(litaC_std__map__MapIterator_cb_i64_c_Array_cb_i64_ce__ce_* litaC_iter) {
    litaC_i32 litaC_i = litaC_iter->it;
    assert(litaC_i < litaC_iter->m->capacity);
    
    for(;litaC_i < litaC_iter->m->capacity;litaC_i += 1) {
        {
            litaC_bool litaC_hasValue = !(litaC_iter->m->equalFn(litaC_iter->m->keys[litaC_i].key, litaC_iter->m->emptyKey));
            if(litaC_hasValue) {
                {
                    litaC_iter->count += 1;
                    litaC_iter->prevIt = litaC_i;
                    {
                        litaC_std__map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_ ___result = (litaC_std__map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_) {
                            .key = litaC_iter->m->keys[litaC_i].key,
                            .value = litaC_iter->m->values[litaC_i],
                            .valuePtr = &(litaC_iter->m->values[litaC_i])
                        };
                        litaC_iter->it = litaC_i + 1;
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    {
        litaC_std__map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_ ___result = (litaC_std__map__MapEntry_cb_i64_c_Array_cb_i64_ce__ce_) {
            
        };
        litaC_iter->it = litaC_i + 1;
        return ___result;
        
    }
    
    litaC_iter->it = litaC_i + 1;
    
}

litaC_void litaC_std__array__Array_add_cb_CCompilerOption_ce_(litaC_std__array__Array_cb_CCompilerOption_ce_* litaC_a,litaC_lita__CCompilerOption litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_CCompilerOption_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb_CCompilerOption_ce_(litaC_std__array__Array_cb_CCompilerOption_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_lita__CCompilerOption) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_lita__CCompilerOption) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_lita__CCompilerOption*)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_u32 litaC_std__map__PtrHashFn_cb__ptr_Symbol_ce_(litaC_symbols__Symbol* litaC_a) {
    litaC_u32 litaC_hash = (litaC_u32)(((litaC_usize)litaC_a) % 4294967291U);
    return litaC_hash;
    
    
}

litaC_bool litaC_std__map__PtrEqualFn_cb__ptr_Symbol_ce_(litaC_symbols__Symbol* litaC_a,litaC_symbols__Symbol* litaC_b) {
    return litaC_a == litaC_b;
    
    
}

litaC_void litaC_std__map__Map_init_cb__ptr_Symbol_c_Dependency_ce_(litaC_std__map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m,litaC_dependency_graph__Dependency litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(litaC_symbols__Symbol*),litaC_bool (*litaC_equalFn)(litaC_symbols__Symbol*,litaC_symbols__Symbol*),const litaC_std__mem__Allocator* litaC_alloc,litaC_symbols__Symbol* litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_std__mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_std__map__nextPowerOf2(litaC_initialSize);
    litaC_std__map__MapGrow_cb__ptr_Symbol_c_Dependency_ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_std__map__MapGrow_cb__ptr_Symbol_c_Dependency_ce_(litaC_std__map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_std__map__Map_cb__ptr_Symbol_c_Dependency_ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (litaC_std__map__Key_cb__ptr_Symbol_ce_*)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_std__map__Key_cb__ptr_Symbol_ce_)),
        .values = (litaC_dependency_graph__Dependency*)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_dependency_graph__Dependency)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i].key, litaC_m->emptyKey))) {
                {
                    litaC_std__map__Map_put_cb__ptr_Symbol_c_Dependency_ce_(&((litaC_newMap)), litaC_m->keys[litaC_i].key, litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_std__map__Map_free_cb__ptr_Symbol_c_Dependency_ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_std__map__Map_put_cb__ptr_Symbol_c_Dependency_ce_(litaC_std__map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m,litaC_symbols__Symbol* litaC_key,litaC_dependency_graph__Dependency litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_std__map__MapGrow_cb__ptr_Symbol_c_Dependency_ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb__ptr_Symbol_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i].key = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_std__map__Map_free_cb__ptr_Symbol_c_Dependency_ce_(litaC_std__map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_dependency_graph__Dependency* litaC_std__map__Map_getPtr_cb__ptr_Symbol_c_Dependency_ce_(litaC_std__map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m,litaC_symbols__Symbol* litaC_key) {
    if(litaC_m->length == 0) {
        {
            return NULL;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb__ptr_Symbol_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    return &(litaC_m->values[litaC_i]);
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && !(litaC_k.key)) {
                    {
                        return NULL;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return NULL;
    
    
}

litaC_void litaC_std__array__Array_add_cb__ptr_Dependency_ce_(litaC_std__array__Array_cb__ptr_Dependency_ce_* litaC_a,litaC_dependency_graph__Dependency* litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_Dependency_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb__ptr_Dependency_ce_(litaC_std__array__Array_cb__ptr_Dependency_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_dependency_graph__Dependency*) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_dependency_graph__Dependency*) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_dependency_graph__Dependency**)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_void litaC_std__array__Array_init_cb__ptr_Dependency_ce_(litaC_std__array__Array_cb__ptr_Dependency_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_dependency_graph__Dependency*) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_dependency_graph__Dependency**)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_std__map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_ litaC_std__map__Map_iter_cb__ptr_Symbol_c_Dependency_ce_(litaC_std__map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m) {
    return (litaC_std__map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_) {
        .m = litaC_m,
        .it = 0,
        .prevIt = 0,
        .count = 0
    };
    
    
}

litaC_bool litaC_std__map__MapIterator_hasNext_cb__ptr_Symbol_c_Dependency_ce_(litaC_std__map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_* litaC_iter) {
    return litaC_iter->count < litaC_iter->m->length;
    
    
}

litaC_std__map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_ litaC_std__map__MapIterator_next_cb__ptr_Symbol_c_Dependency_ce_(litaC_std__map__MapIterator_cb__ptr_Symbol_c_Dependency_ce_* litaC_iter) {
    litaC_i32 litaC_i = litaC_iter->it;
    assert(litaC_i < litaC_iter->m->capacity);
    
    for(;litaC_i < litaC_iter->m->capacity;litaC_i += 1) {
        {
            litaC_bool litaC_hasValue = !(litaC_iter->m->equalFn(litaC_iter->m->keys[litaC_i].key, litaC_iter->m->emptyKey));
            if(litaC_hasValue) {
                {
                    litaC_iter->count += 1;
                    litaC_iter->prevIt = litaC_i;
                    {
                        litaC_std__map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_ ___result = (litaC_std__map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_) {
                            .key = litaC_iter->m->keys[litaC_i].key,
                            .value = litaC_iter->m->values[litaC_i],
                            .valuePtr = &(litaC_iter->m->values[litaC_i])
                        };
                        litaC_iter->it = litaC_i + 1;
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    {
        litaC_std__map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_ ___result = (litaC_std__map__MapEntry_cb__ptr_Symbol_c_Dependency_ce_) {
            
        };
        litaC_iter->it = litaC_i + 1;
        return ___result;
        
    }
    
    litaC_iter->it = litaC_i + 1;
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb__ptr_Dependency_ce_(litaC_std__array__Array_cb__ptr_Dependency_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

litaC_dependency_graph__Dependency* litaC_std__array__Array_get_cb__ptr_Dependency_ce_(litaC_std__array__Array_cb__ptr_Dependency_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

LITAC_INLINE 
litaC_i32 litaC_std__map__Map_size_cb__ptr_Symbol_c_Dependency_ce_(litaC_std__map__Map_cb__ptr_Symbol_c_Dependency_ce_* litaC_m) {
    return litaC_m->length;
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb__ptr_Dependency_ce_(litaC_std__array__Array_cb__ptr_Dependency_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_void litaC_std__array__Array_addAll_cb__ptr_Dependency_ce_(litaC_std__array__Array_cb__ptr_Dependency_ce_* litaC_a,litaC_std__array__Array_cb__ptr_Dependency_ce_* litaC_other) {
    if(!(litaC_other) || litaC_other->length == 0) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_a->length + litaC_other->length > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_Dependency_ce_(litaC_a, litaC_other->length);
            
            
        }
        
    } 
    
    memcpy((litaC_void*)(&(litaC_a->elements[litaC_a->length])), (const litaC_void*)(&(litaC_other->elements[0])), litaC_other->length * sizeof(litaC_dependency_graph__Dependency*));
    litaC_a->length += litaC_other->length;
    
}

LITAC_INLINE 
litaC_void litaC_std__array__Array_clear_cb__ptr_Symbol_ce_(litaC_std__array__Array_cb__ptr_Symbol_ce_* litaC_a) {
    litaC_a->length = 0;
    
}

litaC_void litaC_std__array__Array_addAll_cb__ptr_Symbol_ce_(litaC_std__array__Array_cb__ptr_Symbol_ce_* litaC_a,litaC_std__array__Array_cb__ptr_Symbol_ce_* litaC_other) {
    if(!(litaC_other) || litaC_other->length == 0) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_a->length + litaC_other->length > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb__ptr_Symbol_ce_(litaC_a, litaC_other->length);
            
            
        }
        
    } 
    
    memcpy((litaC_void*)(&(litaC_a->elements[litaC_a->length])), (const litaC_void*)(&(litaC_other->elements[0])), litaC_other->length * sizeof(litaC_symbols__Symbol*));
    litaC_a->length += litaC_other->length;
    
}

LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb__ptr_const_char_ce_(litaC_std__array__Array_cb__ptr_const_char_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_ litaC_std__map__StrMap_cb__ptr_PackageDef_ce_(litaC_pkg_mgr__pkg__PackageDef* litaC_emptyValue,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_ litaC_m =  {
        
    };
    litaC_std__map__Map_init_cb__ptr_const_char_c__ptr_PackageDef_ce_(&((litaC_m)), litaC_emptyValue, litaC_initialSize, litaC_std__map__StrHashFn, litaC_std__map__StrEqualFn, litaC_alloc, 0);
    return litaC_m;
    
    
}

litaC_void litaC_std__map__Map_init_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_* litaC_m,litaC_pkg_mgr__pkg__PackageDef* litaC_emptyValue,litaC_i32 litaC_initialSize,litaC_u32 (*litaC_hashFn)(const litaC_char*),litaC_bool (*litaC_equalFn)(const litaC_char*,const litaC_char*),const litaC_std__mem__Allocator* litaC_alloc,const litaC_char* litaC_emptyKey) {
    if(!(litaC_alloc)) {
        {
            litaC_alloc = litaC_std__mem__defaultAllocator;
            
            
        }
        
    } 
    
    litaC_m->length = 0;
    litaC_m->capacity = 0;
    litaC_m->hashFn = litaC_hashFn;
    litaC_m->equalFn = litaC_equalFn;
    litaC_m->alloc = litaC_alloc;
    litaC_m->keys = 0;
    litaC_m->values = 0;
    litaC_m->emptyValue = litaC_emptyValue;
    litaC_m->emptyKey = litaC_emptyKey;
    litaC_initialSize = (litaC_i32)litaC_std__map__nextPowerOf2(litaC_initialSize);
    litaC_std__map__MapGrow_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_m, litaC_initialSize);
    
}

litaC_void litaC_std__map__MapGrow_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_* litaC_m,litaC_i32 litaC_newlength) {
    if(litaC_newlength < 16) {
        {
            litaC_newlength = 16;
            
            
        }
        
    } 
    
    litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_ litaC_newMap =  {
        .length = 0,
        .capacity = litaC_newlength,
        .keys = (litaC_std__map__Key_cb__ptr_const_char_ce_*)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_std__map__Key_cb__ptr_const_char_ce_)),
        .values = (litaC_pkg_mgr__pkg__PackageDef**)litaC_std__mem__Allocator_calloc(litaC_m->alloc, litaC_newlength, sizeof(litaC_pkg_mgr__pkg__PackageDef*)),
        .hashFn = litaC_m->hashFn,
        .equalFn = litaC_m->equalFn,
        .emptyValue = litaC_m->emptyValue,
        .emptyKey = litaC_m->emptyKey,
        .alloc = litaC_m->alloc
    };
    for(litaC_i32 litaC_i = 0;litaC_i < litaC_m->capacity;litaC_i += 1) {
        {
            if(!(litaC_m->equalFn(litaC_m->keys[litaC_i].key, litaC_m->emptyKey))) {
                {
                    litaC_std__map__Map_put_cb__ptr_const_char_c__ptr_PackageDef_ce_(&((litaC_newMap)), litaC_m->keys[litaC_i].key, litaC_m->values[litaC_i]);
                    
                    
                }
                
            } 
            
            
            
        }
    }
    litaC_std__map__Map_free_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_m);
    *(litaC_m) = litaC_newMap;
    
}

litaC_void litaC_std__map__Map_put_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_* litaC_m,const litaC_char* litaC_key,litaC_pkg_mgr__pkg__PackageDef* litaC_value) {
    if(2 * litaC_m->length >= litaC_m->capacity) {
        {
            litaC_std__map__MapGrow_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_m, 2 * litaC_m->capacity);
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb__ptr_const_char_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                {
                    litaC_m->length += 1;
                    litaC_m->keys[litaC_i].key = litaC_key;
                    litaC_m->values[litaC_i] = litaC_value;
                    return;
                    
                    
                    
                }
                
            } else {
                if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                    {
                        litaC_m->values[litaC_i] = litaC_value;
                        return;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    
}

litaC_void litaC_std__map__Map_free_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_* litaC_m) {
    if(litaC_m) {
        {
            litaC_m->capacity = 0;
            litaC_m->length = 0;
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->keys);
            litaC_std__mem__Allocator_free(litaC_m->alloc, (litaC_void*)litaC_m->values);
            litaC_m->keys = NULL;
            litaC_m->values = NULL;
            
            
        }
        
    } 
    
    
}

litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_PackageDef_ce_ litaC_std__map__Map_iter_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_* litaC_m) {
    return (litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_PackageDef_ce_) {
        .m = litaC_m,
        .it = 0,
        .prevIt = 0,
        .count = 0
    };
    
    
}

litaC_bool litaC_std__map__MapIterator_hasNext_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_PackageDef_ce_* litaC_iter) {
    return litaC_iter->count < litaC_iter->m->length;
    
    
}

litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_PackageDef_ce_ litaC_std__map__MapIterator_next_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_std__map__MapIterator_cb__ptr_const_char_c__ptr_PackageDef_ce_* litaC_iter) {
    litaC_i32 litaC_i = litaC_iter->it;
    assert(litaC_i < litaC_iter->m->capacity);
    
    for(;litaC_i < litaC_iter->m->capacity;litaC_i += 1) {
        {
            litaC_bool litaC_hasValue = !(litaC_iter->m->equalFn(litaC_iter->m->keys[litaC_i].key, litaC_iter->m->emptyKey));
            if(litaC_hasValue) {
                {
                    litaC_iter->count += 1;
                    litaC_iter->prevIt = litaC_i;
                    {
                        litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_PackageDef_ce_ ___result = (litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_PackageDef_ce_) {
                            .key = litaC_iter->m->keys[litaC_i].key,
                            .value = litaC_iter->m->values[litaC_i],
                            .valuePtr = &(litaC_iter->m->values[litaC_i])
                        };
                        litaC_iter->it = litaC_i + 1;
                        return ___result;
                        
                    }
                    
                    
                    
                }
                
            } 
            
            
            
        }
    }
    {
        litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_PackageDef_ce_ ___result = (litaC_std__map__MapEntry_cb__ptr_const_char_c__ptr_PackageDef_ce_) {
            
        };
        litaC_iter->it = litaC_i + 1;
        return ___result;
        
    }
    
    litaC_iter->it = litaC_i + 1;
    
}

LITAC_INLINE 
litaC_i32 litaC_std__array__Array_size_cb_PackageId_ce_(litaC_std__array__Array_cb_PackageId_ce_* litaC_a) {
    return litaC_a->length;
    
    
}

LITAC_INLINE 
litaC_bool litaC_std__array__Array_empty_cb_PackageId_ce_(litaC_std__array__Array_cb_PackageId_ce_* litaC_a) {
    return litaC_a->length == 0;
    
    
}

litaC_pkg_mgr__pkg__PackageId litaC_std__array__Array_get_cb_PackageId_ce_(litaC_std__array__Array_cb_PackageId_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return litaC_a->elements[litaC_index];
    
    
}

litaC_void litaC_std__array__Array_free_cb_PackageId_ce_(litaC_std__array__Array_cb_PackageId_ce_* litaC_a) {
    if(litaC_a && litaC_a->elements) {
        {
            litaC_std__mem__Allocator_free(litaC_a->alloc, (litaC_void*)litaC_a->elements);
            litaC_a->elements = NULL;
            litaC_a->length = 0;
            litaC_a->capacity = 0;
            
            
        }
        
    } 
    
    
}

litaC_bool litaC_std__map__Map_contains_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_* litaC_m,const litaC_char* litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_false;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb__ptr_const_char_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    return litaC_true;
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                    {
                        return litaC_false;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_false;
    
    
}

litaC_pkg_mgr__pkg__PackageDef* litaC_std__map__Map_get_cb__ptr_const_char_c__ptr_PackageDef_ce_(litaC_std__map__Map_cb__ptr_const_char_c__ptr_PackageDef_ce_* litaC_m,const litaC_char* litaC_key) {
    if(litaC_m->length == 0) {
        {
            return litaC_m->emptyValue;
            
            
            
        }
        
    } 
    
    litaC_u32 litaC_i = litaC_m->hashFn(litaC_key);
    for(;;) {
        {
            litaC_i &= litaC_m->capacity - 1;
            litaC_std__map__Key_cb__ptr_const_char_ce_ litaC_k = litaC_m->keys[litaC_i];
            if(litaC_m->equalFn(litaC_k.key, litaC_key)) {
                {
                    return litaC_m->values[litaC_i];
                    
                    
                    
                }
                
            } else {
                if(litaC_k.state != litaC_std__map__KeyState_TOMBSTONE && litaC_m->equalFn(litaC_k.key, litaC_m->emptyKey)) {
                    {
                        return litaC_m->emptyValue;
                        
                        
                        
                    }
                    
                } 
                
            } 
            
            litaC_i += 1;
            
            
        }
    }
    return litaC_m->emptyValue;
    
    
}

litaC_pkg_mgr__pkg__PackageDef* litaC_std__mem__new_cb_PackageDef_ce_(const litaC_std__mem__Allocator* litaC_a) {
    litaC_pkg_mgr__pkg__PackageDef* litaC_result = (litaC_pkg_mgr__pkg__PackageDef*)litaC_std__mem__Allocator_calloc(litaC_a, 1, sizeof(litaC_pkg_mgr__pkg__PackageDef));
    return litaC_result;
    
    
}

litaC_void litaC_std__array__Array_init_cb_PackageId_ce_(litaC_std__array__Array_cb_PackageId_ce_* litaC_a,litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_a->alloc = litaC_alloc;
    litaC_a->length = 0;
    litaC_a->capacity = litaC_initialSize;
    litaC_usize litaC_length = (sizeof(litaC_pkg_mgr__pkg__PackageId) * (litaC_u64)litaC_initialSize);
    if(litaC_initialSize > 0) {
        {
            litaC_a->elements = (litaC_pkg_mgr__pkg__PackageId*)litaC_std__mem__Allocator_alloc(litaC_alloc, litaC_length);
            
            
        }
        
    } else {
        {
            litaC_a->elements = NULL;
            
            
        }
    } 
    
    
}

litaC_void litaC_std__array__Array_add_cb_PackageId_ce_(litaC_std__array__Array_cb_PackageId_ce_* litaC_a,litaC_pkg_mgr__pkg__PackageId litaC_element) {
    if(litaC_a->length + 1 > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_PackageId_ce_(litaC_a, 1);
            
            
        }
        
    } 
    
    assert(litaC_a->length < litaC_a->capacity);
    assert(litaC_a->capacity > 0);
    assert(litaC_a->elements);
    {
        litaC_a->elements[litaC_a->length] = litaC_element;
        
        
    }
    litaC_a->length += 1;
    
}

litaC_void litaC_std__array__ArrayGrow_cb_PackageId_ce_(litaC_std__array__Array_cb_PackageId_ce_* litaC_a,litaC_i32 litaC_increment) {
    litaC_i32 litaC_doubleCurrent = litaC_a->capacity * 2;
    litaC_i32 litaC_minReq = litaC_a->length + litaC_increment;
    litaC_i32 litaC_n = litaC_minReq;
    if(litaC_doubleCurrent > litaC_minReq) {
        {
            litaC_n = litaC_doubleCurrent;
            
            
        }
        
    } 
    
    litaC_usize litaC_newlength = (sizeof(litaC_pkg_mgr__pkg__PackageId) * (litaC_usize)litaC_n);
    litaC_usize litaC_oldlength = (sizeof(litaC_pkg_mgr__pkg__PackageId) * (litaC_usize)litaC_a->capacity);
    litaC_a->elements = (litaC_pkg_mgr__pkg__PackageId*)litaC_std__mem__Allocator_realloc(litaC_a->alloc, (litaC_void*)litaC_a->elements, litaC_oldlength, litaC_newlength);
    assert(litaC_a->elements);
    litaC_a->capacity = litaC_n;
    
}

litaC_pkg_mgr__pkg__PackageId* litaC_std__array__Array_getPtr_cb_PackageId_ce_(litaC_std__array__Array_cb_PackageId_ce_* litaC_a,litaC_i32 litaC_index) {
    assert(litaC_index >= 0 && litaC_index < litaC_a->length);
    return &(litaC_a->elements[litaC_index]);
    
    
}

litaC_std__array__Array_cb_PackageId_ce_ litaC_std__array__ArrayInit_cb_PackageId_ce_(litaC_i32 litaC_initialSize,const litaC_std__mem__Allocator* litaC_alloc) {
    litaC_std__array__Array_cb_PackageId_ce_ litaC_array =  {
        
    };
    litaC_std__array__Array_init_cb_PackageId_ce_(&((litaC_array)), litaC_initialSize, litaC_alloc);
    return litaC_array;
    
    
}

litaC_void litaC_std__array__Array_addAll_cb_PackageId_ce_(litaC_std__array__Array_cb_PackageId_ce_* litaC_a,litaC_std__array__Array_cb_PackageId_ce_* litaC_other) {
    if(!(litaC_other) || litaC_other->length == 0) {
        {
            return;
            
            
            
        }
        
    } 
    
    if(litaC_a->length + litaC_other->length > litaC_a->capacity) {
        {
            litaC_std__array__ArrayGrow_cb_PackageId_ce_(litaC_a, litaC_other->length);
            
            
        }
        
    } 
    
    memcpy((litaC_void*)(&(litaC_a->elements[litaC_a->length])), (const litaC_void*)(&(litaC_other->elements[0])), litaC_other->length * sizeof(litaC_pkg_mgr__pkg__PackageId));
    litaC_a->length += litaC_other->length;
    
}


litaC_i32 main(litaC_i32 litaC_len,litaC_char** litaC_args) {
    litaC_std__system__SystemInit();
    litaC_lita__LitaOptions* litaC_options = litaC_std__mem__new_cb_LitaOptions_ce_(litaC_std__mem__defaultAllocator);
    memset(litaC_options, 0, sizeof(litaC_lita__LitaOptions));
    
    litaC_main__ParseStatus litaC_status = litaC_main__ParseArgs(litaC_len, litaC_args, litaC_options);
    if(litaC_status != litaC_main__ParseStatus_OK) {
        {
            {
                litaC_i32 ___result = (litaC_main__ParseStatus_TERMINATE == litaC_status) ? 0 : -(1);
                litaC_std__mem__Allocator_free(litaC_std__mem__defaultAllocator, litaC_options);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    if(litaC_options->pkgOptions.pkgCmd != litaC_lita__PkgCommand_PKG_NONE) {
        {
            {
                litaC_i32 ___result = litaC_main__HandlePkgCommand(litaC_options);
                litaC_std__mem__Allocator_free(litaC_std__mem__defaultAllocator, litaC_options);
                return ___result;
                
            }
            
            
            
        }
        
    } 
    
    {
        litaC_i32 ___result = litaC_main__RunLitac(litaC_options);
        litaC_std__mem__Allocator_free(litaC_std__mem__defaultAllocator, litaC_options);
        return ___result;
        
    }
    
    litaC_std__mem__Allocator_free(litaC_std__mem__defaultAllocator, litaC_options);
    
}